////////////////////////////////////////////////////////////////////////////////
// Выгрузка данных в файлы Excel и загрузка данных из файлов Excel.
//  
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

#Область Выгрузка

// Функция переводит цвет из формата 1С в формат Excel.
//
// Параметры:
//  Цвет1С - Цвет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьЦветExcel(Цвет1С) Экспорт
    
    Если Цвет1С.Вид = ВидЦвета.Абсолютный Тогда    
    	ЦветExcel = Цвет1С.Красный*(Pow(256,0)) + Цвет1С.Зеленый*(Pow(256,1)) + Цвет1С.Синий*(Pow(256,2));
    Иначе        
        ЦветExcel = 13499135;
    КонецЕсли;    
     
    Возврат ЦветExcel;
    
КонецФункции // ПолучитьЦветExcel()

// Осуществляет выгрузку шаблона формы ввода в Excel. 
// 
Процедура ФВБ_ВыгрузитьШаблонЭксель(ТабДокДанные, ДокСсылка, фДеревоВрем, КоличествоРазворачивать, ПутьКФайлу = Неопределено, Расширение = ".xlsx") Экспорт
	
	ТекстСостояния =  НСтр("ru = 'Выгрузка шаблона Excel...'");
	Состояние(ТекстСостояния);
	
	Отказ = Ложь;
	Excel = бит_ОбменДаннымиЭксельКлиентСервер.InitExcel(Истина, Отказ);	
	Если Отказ Тогда	
		Возврат; 	
	КонецЕсли; 
	
	XlEnums = бит_ОбменДаннымиЭксельКлиентСервер.InitExcelEnums();
	
	// Определим разделитель согласно региональным настройкам и подготовим форматы.
	Разделитель = Excel.International(XlEnums.XlApplicationInternational.xlDecimalSeparator);
	ФорматСумма = "# ##0"+Разделитель+"00";
	ФорматКоличество = "# ##0"+Разделитель+"000";
	
	Wb = Excel.Application.WorkBooks.Add(1);		
    
	// Вывод ячеек.
	КолСтрок   = ТабДокДанные.ВысотаТаблицы;
	КолКолонок = ТабДокДанные.ШиринаТаблицы;
	НомПервойСтроки = 3;
    
	// Лист для данных бюджета.
	ExcelSheet = Wb.Worksheets.Add(Wb.Worksheets(Wb.Worksheets.Count));
	ExcelSheet.Name =  НСтр("ru = 'Данные бюджета'");
	ExcelSheet.StandardWidth = 15;
	// Группировки внизу.
	ExcelSheet.Outline.SummaryRow = 0;
    
    // Общие свойства ячеек.
    ExcelSheet.Cells.NumberFormat = "@";
    ExcelSheet.Cells.Font.Size    = 8;
    ExcelSheet.Cells.WrapText     = True;
    ExcelSelect = ExcelSheet.Range(ExcelSheet.Cells(НомПервойСтроки+1, 1), ExcelSheet.Cells(НомПервойСтроки+КолСтрок, КолКолонок));//.Select;
    АвтоЦвет = Новый Цвет();
    СтандартныйЦвет = Новый Цвет(255,250,205);
    ExcelSelect.Interior.Color = ПолучитьЦветExcel(СтандартныйЦвет);
    
	// Информационная строка.
	ИнфСтр = Строка(ДокСсылка)+" "+ НСтр("ru = 'Выгружено:'")+" "+Формат(ТекущаяДата(),"ДФ=dd.MM.yyyy; ДЛФ=DT");
	ExcelSheet.Cells(2,1).Value = ИнфСтр;
    ExcelSheet.Cells(2,1).Font.Bold = True;
    	
	// Используем временное дерево для анализа группировок.
	ТекКоллекция = фДеревоВрем.ПолучитьЭлементы();
	ТекКоллекция.Очистить();
	УровниДерева = Новый Соответствие();
	
	Для нс = 1 По КолСтрок Цикл
		
		сим = нс+НомПервойСтроки;
		
		Для кол = 1 По КолКолонок Цикл
			
			// Ячейка табличного документа.
			Обл = ТабДокДанные.Область(нс, кол, нс, кол);
			Имя = Обл.Имя;			
			
			Если нс > 1 И кол = 1  Тогда
				// Заполняем данные об уровне выводимых строк в дерево для последующего анализа.
				Если ТипЗнч(Обл.Расшифровка) = Тип("Структура") И Обл.Расшифровка.Свойство("Уровень") Тогда
                    Если ТекКоллекция.Количество() = 0 Тогда
                        ТекущаяСтрока = ТекКоллекция.Добавить();
                        ТекущаяСтрока.Уровень = Обл.Расшифровка.Уровень;
                        ТекущаяСтрока.НомерСтроки = нс;
						УровниДерева.Вставить(ТекущаяСтрока.Уровень, ТекКоллекция); 
                    Иначе
                        Если Обл.Расшифровка.Уровень =  ТекущаяСтрока.Уровень Тогда
                            ТекущаяСтрока = ТекКоллекция.Добавить();
                            ТекущаяСтрока.Уровень = Обл.Расшифровка.Уровень;
                            ТекущаяСтрока.НомерСтроки = нс;
							УровниДерева.Вставить(ТекущаяСтрока.Уровень, ТекКоллекция); 
                        ИначеЕсли Обл.Расшифровка.Уровень > ТекущаяСтрока.Уровень Тогда
                            ТекКоллекция  = ТекущаяСтрока.ПолучитьЭлементы();
                            ТекущаяСтрока = ТекКоллекция.Добавить();
                            ТекущаяСтрока.Уровень = Обл.Расшифровка.Уровень;
                            ТекущаяСтрока.НомерСтроки = нс;
							УровниДерева.Вставить(ТекущаяСтрока.Уровень, ТекКоллекция); 
                        ИначеЕсли Обл.Расшифровка.Уровень < ТекущаяСтрока.Уровень Тогда	
                            ТекКоллекция = УровниДерева[Обл.Расшифровка.Уровень];
                            Если НЕ ТекКоллекция = Неопределено Тогда
                                ТекущаяСтрока = ТекКоллекция.Добавить();
                                ТекущаяСтрока.Уровень = Обл.Расшифровка.Уровень;
                                ТекущаяСтрока.НомерСтроки = нс;
                            КонецЕсли; 
                        КонецЕсли; 
					КонецЕсли; 
			    КонецЕсли; 
			КонецЕсли; // Анализируем иерархию.
			
			// Ячейка excel.
			Cell = ExcelSheet.Cells(сим,кол);
            Если нс = 1 Тогда				
				Cell.Font.Bold = True;				
			КонецЕсли; 
            Если Обл.ЦветФона <> АвтоЦвет И Обл.ЦветФона <> СтандартныйЦвет Тогда
                Cell.Interior.Color = ПолучитьЦветExcel(Обл.ЦветФона);
            КонецЕсли;            
			
			// Установка форматов и значений.
			ЭтоСумма      = ?(Лев(Имя,1)="С", Истина, Ложь);
			ЭтоКоличество = ?(Лев(Имя,1)="К", Истина, Ложь);
			Если Обл.СодержитЗначение Тогда				
				Зн = Обл.Значение;
				Если ЭтоСумма Тогда  					
					Cell.NumberFormat = ФорматСумма; 					
				КонецЕсли;   				
				Если ЭтоКоличество Тогда  					
					Cell.NumberFormat = ФорматКоличество;  					
				КонецЕсли; 				
			Иначе					
                Зн = Обл.Текст;				
            КонецЕсли;
            Если ЗначениеЗаполнено(Зн) Тогда
                Cell.Value = Зн;           
            КонецЕсли;
						
			
			Если бит_ОбщегоНазначенияКлиентСервер.ПроверитьИмяКласса(Обл.Расшифровка,"РасшифровкаЯчейкиФормыВвода") Тогда
				
				рас = Обл.Расшифровка;
				Если рас.Вид = "Значение" Тогда
					
					Если ПустаяСтрока(рас.Формула) Тогда			
						// Ручной ввод значений.
                        Cell.Locked = 0;
					КонецЕсли; 
					
				КонецЕсли;
				
				Если НЕ ПустаяСтрока(рас.Формула) Тогда
                    // Установка формул.
					СтрФормула = рас.Формула; 
                    
                    Если НЕ бит_ОбменДаннымиЭксельКлиентСервер.ФормулаСоответствуетТребованиям(СтрФормула) Тогда					
						// Заменяем имена на координаты ячеек.
                        ЗаменитьИменаЯчеекНаКоординаты(СтрФормула, ТабДокДанные, НомПервойСтроки);					
                    КонецЕсли;
                    
                    ПреобразоватьЛогическуюФормулу(СтрФормула, ТабДокДанные, НомПервойСтроки);                    
                    
                    // Удаление квадратных скобок.
					СтрФормула = СтрЗаменить(СтрФормула, "[","");
					СтрФормула = СтрЗаменить(СтрФормула, "]","");
                    
                    // Равно вперед.
					СтрФормула = "="+СокрЛП(СтрФормула);					 
					ИмяЯчейкиЭксель = "R"+сим+"C"+кол;
					
					Если бит_ОбменДаннымиЭксельКлиентСервер.ФормулаСоответствуетТребованиям(СтрФормула) Тогда
						Попытка
                            Cell.FormulaR1C1  = СтрФормула;
						Исключение
							ТекстСообщения = НСтр("ru = 'Не удалось установить формулу %1% для ячейки %2%. Описание ошибки: %3%.'");
							ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, СтрФормула, ИмяЯчейкиЭксель,ОписаниеОшибки());
							бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
						КонецПопытки;
					Иначе
					КонецЕсли; 
                КонецЕсли;
                
				Попытка 					
					Cell.Name = Имя;	
				Исключение 					
				КонецПопытки;
				
			КонецЕсли; 			
			
		КонецЦикла; // По колонкам.
		
	КонецЦикла; // По строкам. 
	
	// Фиксация шапки и левых колонок с измерениями.
	ФиксКолонка = КоличествоРазворачивать + 2;
	PosStart  = бит_ОбменДаннымиЭксельКлиентСервер.CellPosition(2 + НомПервойСтроки, ФиксКолонка);
	PosEnd    = бит_ОбменДаннымиЭксельКлиентСервер.CellPosition(2 + НомПервойСтроки, ФиксКолонка);			
	Selection = ExcelSheet.Range(ExcelSheet.Cells(PosStart.Row, PosStart.Column), ExcelSheet.Cells(PosEnd.Row, PosEnd.Column));
	Selection.Select();
	Excel.ActiveWindow.FreezePanes = True;
	
	// Установка сетки.
	posStart  = бит_ОбменДаннымиЭксельКлиентСервер.CellPosition(1 + НомПервойСтроки, 1);
	PosEnd    = бит_ОбменДаннымиЭксельКлиентСервер.CellPosition(КолСтрок + НомПервойСтроки, КолКолонок);
	бит_ОбменДаннымиЭксельКлиентСервер.SetBorderLines(ExcelSheet, XlEnums, posStart, PosEnd); 
	
	// Группировка строк.
	ГруппировкиИнфо = Новый Соответствие;
	ОбойтиДеревоВрем(фДеревоВрем, ГруппировкиИнфо);
	
	Для каждого КиЗ Из ГруппировкиИнфо Цикл
		ТекГруппировка = КиЗ.Значение;
		Если ТекГруппировка.Начало <> ТекГруппировка.Конец Тогда 		
			 бит_ОбменДаннымиЭксельКлиентСервер.GroupRows(Excel
                                                            , ТекГруппировка.Начало + 1 + НомПервойСтроки
                                                            , ТекГруппировка.Конец + НомПервойСтроки);		
		КонецЕсли; 
	КонецЦикла; 
	          
    Если ПутьКФайлу = Неопределено Тогда
        ExcelSheet.Protect();
        // Открыть файл для просмотра.
        Excel.Visible = Истина;        
    Иначе
        Cell = ExcelSheet.Cells(1, 1);
        Попытка 
            УИ_Док = "УИ_" + Строка(ДокСсылка.УникальныйИдентификатор());
            УИ_Док = СтрЗаменить(УИ_Док, "-", "_");
            Cell.Name = УИ_Док;	
        Исключение 					
        КонецПопытки;
        ExcelSheet.Protect();
        
        // Сохранить и закрыть файл.
        ДлинаРасширения = СтрДлина(Расширение);
        ПутьКФайлу = Лев(ПутьКФайлу, 217-ДлинаРасширения);
        Wb.Saveas(ПутьКФайлу + Расширение);    
        бит_ОбменДаннымиЭксельКлиентСервер.QuitExcel(Excel);    
    КонецЕсли;  	
	
    фДеревоВрем.ПолучитьЭлементы().Очистить();
	
КонецПроцедуры

#КонецОбласти

#Область Загрузка

// Функция опоставляет файлы Excel документам в базе
//
// Параметры:
//  МассивФайлов - Массив
//  
// Возвращаемое значение:
//   Соответствие
//
Функция СопоставитьФайлыДляЗагрузкиИдДок(МассивФайлов) Экспорт

	Результат = Новый Соответствие;
    
    Отказ = Ложь;
    
    // Открытие эксель  
    Эксель = бит_ОбменДаннымиЭксельКлиентСервер.InitExcel(Ложь, Отказ);		
    Если Отказ Тогда		
        Возврат Результат;		
    КонецЕсли;
        
    Для Каждого ИмяФайла Из МассивФайлов Цикл
        
        //ПутьКФайлу = ПутьКПапке + "\" + ИмяФайла;
                     
        ЭксельКнига = бит_ОбменДаннымиЭксельКлиентСервер.OpenExcelFile(Эксель, ИмяФайла, Отказ);		
        Если Отказ Тогда 		
            Возврат Результат; 		
        КонецЕсли;
        
        Лист = бит_ОбменДаннымиЭксельКлиентСервер.GetExcelSheet(ЭксельКнига, 1, Отказ); 		
        Если Отказ Тогда 		
            Возврат Результат;  		
        КонецЕсли;
        
        Попытка
            УИ_Док = Лист.Cells(1, 1).Name.Name;
            Если ЗначениеЗаполнено(УИ_Док) Тогда
                УИ_Док = СтрЗаменить(УИ_Док, "УИ_", "");
                УИ_Док = СтрЗаменить(УИ_Док, "_", "-");
                Результат.Вставить(ИмяФайла, УИ_Док);
            Иначе
                ТекстСообщения = Нстр("ru = 'Не удалось найти идентификатор документа в файле %1%.'");
                ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ИмяФайла);
                бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);  
            КонецЕсли;              
        Исключение
            ТекстСообщения = Нстр("ru = 'Не удалось найти идентификатор документа в файле %1%. Файл не предназначен для загрузки данных формы ввода бюджета через обработку. '");
            ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ИмяФайла);
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);          
        КонецПопытки;                
        
         // Закрытие Excel
        бит_ОбменДаннымиЭксельКлиентСервер.CloseExcelFile(ЭксельКнига, Ложь); 
    
    КонецЦикла;
    
    бит_ОбменДаннымиЭксельКлиентСервер.QuitExcel(Эксель);
   
	Возврат Результат;
	
КонецФункции // СопоставитьФайлыДляЗагрузкиИдДок()

// Выполняет загрузку данных по шаблону Excel.
// 
// Параметры:
//  ПутьКФайлу - Строка
//
Функция ФВБ_ЗагрузитьДанныеПоШаблону(ПутьКФайлу) Экспорт

    ДанныеЭксель = Неопределено;
    				
    ТекстСостояние = НСтр("ru = 'Загрузка данных...'");
    Состояние(ТекстСостояние);
                           
    Отказ = Ложь;		
    
    // Открытие эксель  
    Эксель = бит_ОбменДаннымиЭксельКлиентСервер.InitExcel(Ложь, Отказ);		
    Если Отказ Тогда		
        Возврат ДанныеЭксель;		
    КонецЕсли; 
    
    ЭксельКнига = бит_ОбменДаннымиЭксельКлиентСервер.OpenExcelFile(Эксель, ПутьКФайлу, Отказ);		
    Если Отказ Тогда 		
        Возврат ДанныеЭксель; 		
    КонецЕсли;
    
    Лист = бит_ОбменДаннымиЭксельКлиентСервер.GetExcelSheet(ЭксельКнига, 1, Отказ); 		
    Если Отказ Тогда 		
        Возврат ДанныеЭксель;  		
    КонецЕсли;
    
    //ОчиститьТаблицы();
    
    // Чтение данных по именам
    ДанныеЭксель = Новый Массив;
    Для каждого ИмяОбъект Из ЭксельКнига.Names Цикл
        
        ИмяЭксель = ИмяОбъект.Name;
        ЗнчСтр    = Лист.Range(ИмяЭксель).Value;

        Попытка 
            Зн = Число(ЗнчСтр);
        Исключение 
            Зн = 0;
        КонецПопытки;

        Если Зн <> 0 Тогда 
            эд = Новый Структура("Имя,Значение", ИмяЭксель, зн);
            ДанныеЭксель.Добавить(эд);    
        КонецЕсли; 
       
    КонецЦикла; 
    
    // Закрытие Excel
    бит_ОбменДаннымиЭксельКлиентСервер.CloseExcelFile(ЭксельКнига, Ложь);
    бит_ОбменДаннымиЭксельКлиентСервер.QuitExcel(Эксель);		
    
    ТекстСостояние = НСтр("ru = 'Преобразование данных...'");
    Состояние(ТекстСостояние);
		
    //// Преобразование данных 		
    //УстановитьЗагруженныеДанные(ДанныеЭксель);
       
    Возврат ДанныеЭксель;

КонецФункции // ЗагрузитьДанныеПоШаблону()

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция определяет максимальный номер строки, присутствующий в данной группировке.
// 
// Параметры:
//  ТекСтрока - СтрокаДерева.
// 
// Возвращаемое значение:
//  МаксНомер - Число.
// 
Функция НайтиМаксНомерГруппировки(ТекСтрока)
	
	МаксНомер = ТекСтрока.НомерСтроки;
	
	ТекКоллекция = ТекСтрока.ПолучитьЭлементы();
	КолЭлем = ТекКоллекция.Количество();
	Если КолЭлем > 0 Тогда
	
		ПоследняяСтрока = ТекКоллекция[КолЭлем-1];
		МаксНомер = НайтиМаксНомерГруппировки(ПоследняяСтрока);
	
	КонецЕсли; 
	
	Возврат МаксНомер;
	
КонецФункции // НайтиМаксНомерГруппировки()

// Процедура выполняет обход временного дерева, 
// для определения размера группировок. 
// 
// Параметры:
//  СтрокаВерх - СтрокаДерева.
//  ГруппировкиИнфо - Соответствие.
// 
Процедура ОбойтиДеревоВрем(СтрокаВерх, ГруппировкиИнфо)

    ТекКоллекция = СтрокаВерх.ПолучитьЭлементы();
	Если ТекКоллекция.Количество() > 0 И Не ТипЗнч(СтрокаВерх) = Тип("ДанныеФормыДерево") Тогда
	
		ТекГр = ГруппировкиИнфо[СтрокаВерх.НомерСтроки];
		Если ТекГр = Неопределено Тогда
		
			 ТекГр = Новый Структура("Начало, Конец", СтрокаВерх.НомерСтроки, СтрокаВерх.НомерСтроки);
			 ТекГр.Конец = НайтиМаксНомерГруппировки(СтрокаВерх);
			 
			 ГруппировкиИнфо.Вставить(СтрокаВерх.НомерСтроки, ТекГр);
		
		КонецЕсли; 
	
	КонецЕсли; 
	
	Для каждого ТекСтрока Из ТекКоллекция Цикл
		
		ОбойтиДеревоВрем(ТекСтрока, ГруппировкиИнфо);
	
	КонецЦикла; 
	
КонецПроцедуры // ОбойтиДеревоВрем()

// Процедура меняет имена ячеек на координаты. 
//
// Параметры:
//  СтрФормула      - Строка.
//  ТабДокДанные    - ТабличныйДокумент.
//  НомПервойСтроки - Число.
//
Процедура ЗаменитьИменаЯчеекНаКоординаты(СтрФормула, ТабДокДанные, НомПервойСтроки)

	МассивАрг = бит_СтрокиКлиентСервер.РазобратьФормулу(СтрФормула);
    МассивАрг = бит_РаботаСКоллекциямиКлиентСервер.УдалитьПовторяющиесяЭлементыМассива(МассивАрг);
    
    Для каждого ТекАрг Из МассивАрг Цикл
        
        ТекОбл = ТабДокДанные.Области.Найти(ТекАрг);
        Если бит_БюджетированиеКлиентСервер.ЭтоПрямоугольнаяОбласть(ТекОбл) Тогда
            
            // Номер строки
            ТекНомСтр = Формат(ТекОбл.Низ+НомПервойСтроки,"ЧГ=0");
            
            // Номер столбца
            ТекНомСтл = ТекОбл.Лево;
             
            // Область в Excel:
            ИмяОбл = "R" + ТекНомСтр + "C" + ТекНомСтл;
            
            СтрФормула = СтрЗаменить(СтрФормула, ТекАрг, ИмяОбл);
            
        КонецЕсли; 
        
    КонецЦикла; // По массиву аргументов

КонецПроцедуры // ЗаменитьИменаЯчеекНаКоординаты()

// Преобразует логическую формулу в строку, распознаваемую в Excel (BF-816).
//
// Параметры:
//  СтрФормула      - Строка.
//  ТабДокДанные    - ТабличныйДокумент.
//  НомПервойСтроки - Число.
//
Процедура ПреобразоватьЛогическуюФормулу(СтрФормула, ТабДокДанные, НомПервойСтроки)

    ИсхФормула = СтрФормула;
    
    Если Найти(СтрФормула, "?") = 0 
        И Найти(СтрФормула, "Цел") = 0 
        И Найти(СтрФормула, "Окр") = 0 
        И Найти(СтрФормула, "Sqrt") = 0 
        И Найти(СтрФормула, "%") = 0
        И Найти(СтрФормула, "Мин") = 0
        И Найти(СтрФормула, "Макс") = 0 Тогда
        
        // Не найдена логическая формула.
        Возврат;	
    
    КонецЕсли;
    
    //ЗаменитьИменаЯчеекНаКоординаты(СтрФормула, ТабДокДанные, НомПервойСтроки);
    
	Попытка       
        
        // Удаление пробелов
        СтрФормула = СтрЗаменить(СтрФормула, " ", "");
        
        // Условие ? = ЕСЛИ = IF
        СтрФормула = СтрЗаменить(СтрФормула, "?", "IF");
        
        // Цел = ЦЕЛОЕ = INT
        СтрФормула = СтрЗаменить(СтрФормула, "Цел", "INT");
        
        // Мин = МИН = MIN
        СтрФормула = СтрЗаменить(СтрФормула, "Мин", "MIN");
        
        // Макс = МАКС = MAX
        СтрФормула = СтрЗаменить(СтрФормула, "Макс", "MAX");        
                              
        // ОКРУГЛЕНИЕ
        // Окр([R2C4], 3, 1)=ОКРУГЛ(C2;3) = ROUND
        МассивРаздел = Новый Массив;
        МассивРаздел.Добавить("(");
        МассивРаздел.Добавить(")");
        Пока Найти(СтрФормула, "Окр") > 0 Цикл
            нПоз = Найти(СтрФормула, "Окр");
            ОтрСтр = Сред(СтрФормула, нПоз, СтрДлина(СтрФормула)-нПоз+1);
            масЧастей = бит_СтрокиКлиентСервер.РазложитьСтрокуВМассивПодстрок(ОтрСтр);
            Окрчисл = масЧастей[0];
            Окрточн = СтрЗаменить(масЧастей[1], ")", "");
            масЧастей = бит_СтрокиКлиентСервер.РазобратьСтрокуСМассивомРазделителей(ОтрСтр, МассивРаздел);
            стрОкрИсх  = "Окр(" + масЧастей[1] + ")";
            стрОкрЭкс  = СтрЗаменить(Окрчисл, "Окр", "ROUND") + "," + Окрточн + ")";
            СтрФормула = СтрЗаменить(СтрФормула, стрОкрИсх, стрОкрЭкс);
        КонецЦикла;
        
        // Sqrt = КОРЕНЬ = SQRT
        СтрФормула = СтрЗаменить(СтрФормула, "Sqrt","SQRT");
        
        // ОСТАТОК ОТ ДЕЛЕНИЯ
        // ([R2C4] % [R2C5]) = ОСТАТ(G2;G3) = MOD
        МассивРаздел = Новый Массив;
        МассивРаздел.Добавить("[");
        МассивРаздел.Добавить("]");
        Пока Найти(СтрФормула, "%") > 0 Цикл                        
            масЧастей = бит_СтрокиКлиентСервер.РазобратьСтрокуСМассивомРазделителей(СтрФормула, МассивРаздел);
            инд = масЧастей.Найти("%");
            стрДелИсх = "[" + масЧастей[инд-1] + "]" + масЧастей[инд] + "[" + масЧастей[инд+1] + "]";
            стрДелЭкс = "MOD(" + масЧастей[инд-1] + "," + масЧастей[инд+1] + ")";
            СтрФормула = СтрЗаменить(СтрФормула, стрДелИсх, стрДелЭкс);                    
        КонецЦикла;
        
    Исключение
        
        ТекстСообщения = НСтр("ru = 'Не удалось преобразовать формулу %1%.'");
        ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ИсхФормула);
        бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
        Возврат;

    КонецПопытки;
    
КонецПроцедуры // ПреобразоватьЛогическуюФормулу()

#КонецОбласти 
