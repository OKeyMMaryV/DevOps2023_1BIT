
#Область СлужебныйПрограммныйИнтерфейс

#Область ПодпискиНаСобытия

// Процедура обработчик подписки "бит_ПриЗаписиСтруктурнойЕдиницы" на событие  "ПриЗаписи".
// Выполняет синхронизацию структуры предприятия (Организациии, ПодразделенияОрганизаций) и ЦФО.
// 
// Параметры:
// 	Источник - СправочникОбъект.
// 	Отказ - Булево.
// 
Процедура бит_ПриЗаписиСтруктурнойЕдиницыПриЗаписи(Источник, Отказ) Экспорт
	
	Если Отказ Тогда
	
		Возврат;
	
	КонецЕсли; 
	
	Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_ЭтоЧужойПодчиненныйУзел") = Истина Тогда
		
	    // Функционал БФ может работать только в узлах, созданных с помощью ПО бит_Полный.
		Возврат;
	
	КонецЕсли; 				
	
	Если Источник.ОбменДанными.Загрузка Тогда
	
		Возврат;
	
	КонецЕсли; 
	
	Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_СинхронизироватьПодразделенияРеглЦФО") = Истина Тогда
	
		СинхронизироватьСтруктурнуюЕдинцуРеглЦФО(Источник);
	
	КонецЕсли; 
	
КонецПроцедуры

#КонецОбласти

#Область СинхронизацияСтруктурыПредприятияРеглИЦфо

// Функция выполняет первоначальную синхронизацию подразделений регл и ЦФО.
// 
Процедура ПервоначальнаяСинхронизацияПодразделенийРеглЦФО() Экспорт
	
	Если НЕ Метаданные.Справочники.Найти("ПодразделенияОрганизаций") = Неопределено Тогда
		
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
		               |	Организации.Ссылка
		               |ИЗ
		               |	Справочник.Организации КАК Организации
		               |;
		               |
		               |////////////////////////////////////////////////////////////////////////////////
		               |ВЫБРАТЬ
		               |	ПодразделенияОрганизаций.Ссылка КАК Ссылка
		               |ИЗ
		               |	Справочник.ПодразделенияОрганизаций КАК ПодразделенияОрганизаций
		               |
		               |УПОРЯДОЧИТЬ ПО
		               |	Ссылка ИЕРАРХИЯ
		               |АВТОУПОРЯДОЧИВАНИЕ";
					   
		МассивРезультатов = Запрос.ВыполнитьПакет();
		
		// Синхронизация организаций
		Выборка = МассивРезультатов[0].Выбрать();
		
		Пока Выборка.Следующий() Цикл
		
			СинхронизироватьСтруктурнуюЕдинцуРеглЦФО(Выборка.Ссылка);
		
		КонецЦикла; 
		
		// Синхронизация подразделений
		Выборка = МассивРезультатов[1].Выбрать();
		
		Пока Выборка.Следующий() Цикл
		
			СинхронизироватьСтруктурнуюЕдинцуРеглЦФО(Выборка.Ссылка);
		
		КонецЦикла; 
		
	КонецЕсли; 
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииРаботыСВалютамиСценария

// Возвращает курс валюты сценария на дату.
// 
// Параметры:
// 	Сценарий   - Сценарий - элемент справочника "СценарииПланирования".	
//  Валюта     - Валюта - элемент справочника "Валюты".
//  Дата       - Дата - на которую следует получить курс.
// 
// Возвращаемое значение: 
//  Структура, содержащая:
//   Курс      - курс валюты.
//   Кратность - кратность валюты.
// 
Функция ПолучитьКурсПоСценарию(Сценарий, Валюта, Дата) Экспорт
	
	СтруктураКурса = Новый Структура("Курс,Кратность",0,0);
	
	Если ЗначениеЗаполнено(Сценарий)
		И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Сценарий, "ИспользоватьКурсыСценария") Тогда
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Период",		Дата);
		Запрос.УстановитьПараметр("Сценарий",	Сценарий);
		Запрос.УстановитьПараметр("Валюта",		Валюта);
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	ЕСТЬNULL(бит_КурсыСценариевПланированияСрезПоследних.Курс, 0) КАК Курс,
		|	ЕСТЬNULL(бит_КурсыСценариевПланированияСрезПоследних.Кратность, 0) КАК Кратность
		|ИЗ
		|	РегистрСведений.бит_КурсыСценариевПланирования.СрезПоследних(
		|			&Период,
		|			Сценарий = &Сценарий
		|				И Валюта = &Валюта) КАК бит_КурсыСценариевПланированияСрезПоследних";
		Результат = Запрос.Выполнить();
		Выборка	  = Результат.Выбрать();
		Если Выборка.Следующий() Тогда
			ЗаполнитьЗначенияСвойств(СтруктураКурса, Выборка);
		КонецЕсли;
	Иначе
		СтруктураКурса = бит_КурсыВалют.ПолучитьКурсВалюты(Валюта, Дата);
	КонецЕсли;
	
	Возврат СтруктураКурса;
	
КонецФункции

// Проверяет наличие установленного курса и кратности сценария на 1 января 1980 года.
// В случае отсутствия устанавливает курс и кратность равными единице.
// 
// Параметры:
//  Сценарий - ссылка на элемент справочника СценарииПланирования.
// 	Валюта - СправочникСсылка.Валюты.
// 
Процедура ПроверитьКорректностьКурсаНа01_01_1980(Сценарий, Валюта) Экспорт

	ДатаКурса = Дата(1980, 1, 1);
	СтруктураКурса = ПолучитьКурсПоСценарию(Сценарий, Валюта, ДатаКурса);

	Если (СтруктураКурса.Курс = 0) 
		Или (СтруктураКурса.Кратность = 0) Тогда

		// Установим курс и кратность = 1 на 01.01.1980, чтобы не было ошибок при создании документов.

		РегистрКурсыСценария = РегистрыСведений.бит_КурсыСценариевПланирования.СоздатьМенеджерЗаписи();

		РегистрКурсыСценария.Период    = ДатаКурса;
		РегистрКурсыСценария.Сценарий  = Сценарий;
		РегистрКурсыСценария.Валюта	   = Валюта;
		РегистрКурсыСценария.Курс      = 1;
		РегистрКурсыСценария.Кратность = 1;
		
		РегистрКурсыСценария.Записать();

	КонецЕсли;

КонецПроцедуры

// Функция получает курсы валют сценария необходимые при пересчетах 
// для формирования движений по регистру бит_ОборотыПоБюджетам.
// 
// Параметры:
//   ТекущийДокумент - ДокументОбъект - текущий документ.
//   ДатаКурсов 	- Дата - дата.
//   ВидыКурсов 	- Структура - виды курсов.
// 
// Возвращаемое значение:
//   СтруктураКурсыВалют - Структура.
// 
Функция ПолучитьСтруктуруКурсовВалютСценария(ТекущийДокумент, ДатаКурсов, ВидыКурсов = Неопределено) Экспорт

	СтруктураКурсыВалют = Новый Структура;
	
	МетаданныеДокумента = ТекущийДокумент.Метаданные();
	
	Если бит_РаботаСМетаданными.ЕстьРеквизит("Сценарий", МетаданныеДокумента) Тогда
		Сценарий = ТекущийДокумент.Сценарий;
	Иначе
		Сценарий = Справочники[бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования()].ПустаяСсылка();
	КонецЕсли;
	
	// Курс документа
	Если ВидыКурсов = Неопределено ИЛИ ВидыКурсов.Свойство("Документ") Тогда
		
		Если бит_РаботаСМетаданными.ЕстьРеквизит("ВалютаДокумента", МетаданныеДокумента) 
			И бит_РаботаСМетаданными.ЕстьРеквизит("КурсДокумента", МетаданныеДокумента)
			И бит_РаботаСМетаданными.ЕстьРеквизит("КратностьДокумента", МетаданныеДокумента) Тогда
			
			СтрКурса = Новый Структура;
			СтрКурса.Вставить("Курс"     , ТекущийДокумент.КурсДокумента);
			СтрКурса.Вставить("Кратность", ТекущийДокумент.КратностьДокумента);
			СтрКурса.Вставить("Валюта"   , ТекущийДокумент.ВалютаДокумента);
			СтруктураКурсыВалют.Вставить("Документ", СтрКурса);
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	// Курс упр. учета
	Если ВидыКурсов = Неопределено ИЛИ ВидыКурсов.Свойство("Упр") Тогда	
		
		Валюта = Константы.бит_ВалютаУправленческогоУчета.Получить();
		
		СтрКурса = ПолучитьКурсПоСценарию(Сценарий, Валюта, ДатаКурсов);
		СтрКурса.Вставить("Валюта", Валюта);
		СтруктураКурсыВалют.Вставить("Упр", СтрКурса);
		
	КонецЕсли;
	
	// Курс сценария
	Если ВидыКурсов = Неопределено ИЛИ ВидыКурсов.Свойство("Сценарий") И Сценарий <> Неопределено Тогда
		
		Если бит_РаботаСМетаданными.ЕстьРеквизит("Сценарий", МетаданныеДокумента) Тогда 
			
			Валюта = ТекущийДокумент.Сценарий.Валюта;
			
			СтрКурса = ПолучитьКурсПоСценарию(Сценарий, Валюта, ДатаКурсов);
			СтрКурса.Вставить("Валюта", Валюта);
			СтруктураКурсыВалют.Вставить("Сценарий", СтрКурса);
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Валюта регламентированного учета
	Если ВидыКурсов = Неопределено ИЛИ ВидыКурсов.Свойство("Регл") Тогда
		
		СтрКурса = Новый Структура;
		СтрКурса.Вставить("Курс"	 , 1);
		СтрКурса.Вставить("Кратность", 1);
		СтрКурса.Вставить("Валюта"	 , Константы.ВалютаРегламентированногоУчета.Получить());
		СтруктураКурсыВалют.Вставить("Регл", СтрКурса);
	
	КонецЕсли;
	
    Возврат СтруктураКурсыВалют;
	
КонецФункции

#КонецОбласти

#Область РаботаСТабличнымиЧастямиДокументовБюджетирования

// Процедура заполняет норму в строке документов бюджетирования.
// 
// Параметры:
//  ТекущиеДанные - СтрокаТабличнойЧасти.
//  ВидПараметра - ПланВидовХарактеристик.бит_ВидыПроизвольныхПараметров.
//  Сценарий     - СправочникСсылка.СценарииПланирования.
//  СтрКурсаДок  - Структура.
//  ИменаПараметраНорм - Структура.
//  ЕдИзмСумм - ПеречислениеСсылка.бит_ЕдиницыИзмеренияСумм.
// 
Процедура ЗаполнитьНормуВСтроке(ТекущиеДанные, ВидПараметра, Сценарий, СтрКурсаДок, ИменаПараметраНорм, ЕдИзмСумм) Экспорт

	Если ТекущиеДанные.СтатьяОборотов.Учет_Количество И ТекущиеДанные.СтатьяОборотов.Учет_Сумма Тогда
		
	   МассивОтбор = Новый Массив;
	   Для каждого КиЗ Из ИменаПараметраНорм.БП Цикл
	   
	   	   эо = Новый Структура;
		   эо.Вставить("Имя"     ,КиЗ.Значение);
		   эо.Вставить("Значение", ТекущиеДанные[КиЗ.Ключ]);
		   
		   МассивОтбор.Добавить(эо);
	   
	   КонецЦикла; 
	   
	   Если МассивОтбор.Количество() = 0 Тогда
		   
		 // Если нет отбора, нет смысла получать норму.
	   	 Возврат;
	   
	   КонецЕсли; 	   
	   
	   ТекущиеДанные.Норма = РегистрыСведений.бит_ЗначенияПроизвольныхПараметровРегистратор.ПолучитьЗначениеНормы(ВидПараметра
	                                                                                                               , ТекущиеДанные.Период
																												   , Сценарий
																												   , МассивОтбор
																												   , СтрКурсаДок);	
																												   
	   РазмерностьНач      = 1;
	   РазмерностьКон      = бит_ОбщегоНазначения.ПолучитьРазмерностьЕдиницыИзмеренияСумм(ЕдИзмСумм);
	   ТекущиеДанные.Норма = бит_ОбщегоНазначенияКлиентСервер.ПересчитатьИзРазмерностиВРазмерность(ТекущиеДанные.Норма
																				                    ,РазмерностьНач
																				                    ,РазмерностьКон);																				   
																												   
	   бит_БюджетированиеКлиентСервер.РассчитатьПоНорме(ТекущиеДанные, Истина);
	
	КонецЕсли; 

КонецПроцедуры

// Процедура перезаполняет нормы в табличной части.
// 
// Параметры:
//  ВидПараметра - ПланВидовХарактеристикСсылка.бит_ВидыПроизвольныхПараметров.
//  Сценарий - СправочникСсылка.СценарииПланирования.
//  ТабЧасть - ТабличнаяЧасть.
//  СтрКурсаДок - Структура.
//  ИменаПараметровНорм - Структура.
//  ЕдИзмСумм - ПеречислениеСсылка.бит_ЕдиницыИзмеренияСумм.
// 
Процедура ПерезаполнитьНормыТабЧасти(ВидПараметра, Сценарий, ТабЧасть, СтрКурсаДок, ИменаПараметраНорм, ЕдИзмСумм) Экспорт
	
	Для каждого СтрокаТаблицы Из ТабЧасть Цикл
		
		Если СтрокаТаблицы.СтатьяОборотов.Учет_Сумма 
			 И СтрокаТаблицы.СтатьяОборотов.Учет_Количество Тогда
			
			  ЗаполнитьНормуВСтроке(СтрокаТаблицы, ВидПараметра, Сценарий, СтрКурсаДок, ИменаПараметраНорм, ЕдИзмСумм);
			
		КонецЕсли; 
		
	КонецЦикла; // ТабЧасть 
	
КонецПроцедуры

// Процедура проверяет использование аналитики в статье, устанавливает типы по-умолчанию. 
//
// Параметры:
//  ТекущиеДанные - СтрокаТабличнойЧасти.
//  НастройкиСтатьи - Структура.
//  НастройкиИзмерений - Структура.
//
Процедура УстановитьИспользованиеАналитики(ТекущиеДанные, НастройкиСтатьи, НастройкиИзмерений)  Экспорт
	
	Для каждого КлючИЗначение Из НастройкиИзмерений Цикл
		
		ИмяИзмерения     = КлючИЗначение.Ключ;
		СтрНастр         = Неопределено;
		
		НастройкиСтатьи.Измерения.Свойство(ИмяИзмерения, СтрНастр);
		Если ТипЗнч(СтрНастр) = Тип("Структура") Тогда
			
			Если ТипЗнч(СтрНастр.ТипПоУмолчанию) = Тип("ОписаниеТипов") Тогда
				
				ТекущиеДанные[ИмяИзмерения] = СтрНастр.ТипПоУмолчанию.ПривестиЗначение(ТекущиеДанные[ИмяИзмерения]);
				
			КонецЕсли; 
			
			Если НЕ СтрНастр.Учет Тогда
				
				ТекущиеДанные[ИмяИзмерения] = Неопределено;
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура обнуляет ресурсы бюджетирования в строке табличной части, 
// если по статье не ведется учет по ним. 
//
// Параметры:
//  ТекущиеДанные - СтрокаТабличнойЧасти.
//  НастройкиСтатьи - Структура.
//
Процедура УстановитьИспользованиеРесурсов(ТекущиеДанные, НастройкиСтатьи) Экспорт
	
	Если Не НастройкиСтатьи.Учет_Количество Тогда
		ТекущиеДанные.Количество = 0;
	КонецЕсли;
	
	Если Не НастройкиСтатьи.Учет_Сумма Тогда
		ТекущиеДанные.Сумма = 0;
	КонецЕсли;
	
КонецПроцедуры

// Процедура очищает аналитики бюджетирования, не используемые по статье оборотов,
// соответствующей строки переданной таблицы. 
//
// Параметры:
//  ТаблицаДанных - табличная часть / таблица значений с данными по аналитикам статьям оборотов.
//
Процедура ОчиститьНеИспользуемыеАналитикиСтатейОборотов(ТаблицаДанных) Экспорт
	
	ПараметрыУчета = ПараметрыУчета();
	ПоляУчета	= ПараметрыУчета.ПоляУчета;
	ТекстЗапроса= ПараметрыУчета.ТекстЗапроса;
	
	Запрос = Новый Запрос();
	СтатьиОборотов = ТаблицаДанных.ВыгрузитьКолонку("СтатьяОборотов");
	Запрос.УстановитьПараметр("СтатьиОборотов",	СтатьиОборотов);
	Запрос.Текст = ТекстЗапроса;
	
	Результат = Запрос.Выполнить();
	
	ТаблицаУчетаАналитик = Результат.Выгрузить();
	ТаблицаУчетаАналитик.Индексы.Добавить("СтатьяОборотов");
	
	Для каждого СтрТД Из ТаблицаДанных Цикл
		Если ЗначениеЗаполнено(СтрТД.СтатьяОборотов) Тогда
			ПравилаУчета = ТаблицаУчетаАналитик.Найти(СтрТД.СтатьяОборотов, "СтатьяОборотов");
		Иначе	
			ПравилаУчета = Неопределено;
		КонецЕсли; 
		Для Инд = 1 По 12 Цикл
			ИмяПоля = ПоляУчета["Аналитика_" + Строка(Инд)];
			Если ПравилаУчета = Неопределено Тогда
				СтрТД[ИмяПоля] = Неопределено;
			ИначеЕсли ПравилаУчета[ИмяПоля] = Ложь Тогда
				СтрТД[ИмяПоля] = Неопределено;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры
 
#КонецОбласти

#Область ФормированиеДереваВАктуализацииИФормыВвода

// Процедура выполняет расчеты в дереве данных в форме ввода бюджета.
// 
// Параметры:
//  ТабДокДанные - ТабличныйДокумент.
// 
Процедура ВыполнитьРасчеты(ТабДокДанные) Экспорт

	Для каждого Обл Из ТабДокДанные.Области Цикл
		Если Обл.Расшифровка.Вид = "Формула" 
			 ИЛИ Обл.Расшифровка.Вид = "Значение" Тогда
		
			бит_БюджетированиеКлиентСервер.ВычислитьФормулу(ТабДокДанные, Обл);
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

// Процедура устанавливает формат отрицательных чисел в скобках. 
// Используется при построении дерева с учетом коэффициентов.
// 
// Параметры:
//  Сч - ОбластьЯчеекТабличногоДокумента.
// 
Процедура УстановитьФорматОтрицательныхЧисел(Сч) Экспорт

	 СтрФормат = "ЧЦ=%1%; ЧДЦ=%2%; ЧО=0";
	 СтрФормат = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(СтрФормат
	                                                                         , Сч.ТипЗначения.КвалификаторыЧисла.Разрядность
																			 , Сч.ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти);
																			 
	 Сч.Формат = СтрФормат;																		 

КонецПроцедуры

// Функция формирует имя колонки по периоду. 
// 
// Параметры:
//  Префикс  - Строка.
//  ТекущийПериод  - Дата.
// 
// Возвращаемое значение:
//   Строка.   
// 
Функция СформироватьИмяКолонкиПериод(Префикс,ТекущийПериод) Экспорт

	 Возврат Префикс+"_"+Формат(ТекущийПериод,"ДФ=yyyyMMdd");

КонецФункции

// Возвращает шаблон параметров функции "бит_Бюджетирование.ОписаниеПериода".
// 
// Возвращаемое значение:
//  Параметры - структура с ключами:
//		* Период 			 - дата - начало периода
//		* Синоним 			 - строка - представление периода
//		* Имя	  			 - строка 
//		* ЭтоИтог 			 - булево
//		* ЭтоНарастающийИтог - булево
//		* КонецПериода 		 - дата
//		* Периодичность		 - ПеречислениСсылка.бит_ПериодичностьПланирования.	
//
Функция НовыеПараметрыОписаниеПериода() Экспорт

	Параметры = Новый Структура; 
	Параметры.Вставить("Период",			'0001-01-01');
	Параметры.Вставить("Синоним",			"");
	Параметры.Вставить("Имя",				"");
	Параметры.Вставить("ЭтоИтог",			Ложь);
	Параметры.Вставить("ЭтоНарастающийИтог",Ложь);
	Параметры.Вставить("КонецПериода",		Неопределено);
	Параметры.Вставить("Периодичность",		Неопределено);
			
	Возврат Параметры;
	
КонецФункции
 
// Конструктор структуры, описывающей колонку дерева.
// 
// Параметры:
//  Параметры - См. бит_Бюджетирование.НовыеПараметрыОписаниеПериода(). 
// 
// Возвращаемое значение:
//  РезСтр - Структура.ОписаниеКолонкиПериод.
// 
Функция ОписаниеПериода(Параметры) Экспорт
						 
	Период 			   = Параметры.Период;
	Синоним 		   = Параметры.Синоним;
	Имя 			   = Параметры.Имя;
	ЭтоИтог 		   = Параметры.ЭтоИтог;
	ЭтоНарастающийИтог = Параметры.ЭтоНарастающийИтог;
	КонецПериода 	   = Параметры.КонецПериода;
	Периодичность 	   = Параметры.Периодичность;					 
	
	ОписаниеПериода = Новый Структура; 
	ОписаниеПериода.Вставить("ИмяКласса", 		   "ОписаниеКолонкиПериод");
	ОписаниеПериода.Вставить("Период", 			   Период);
	ОписаниеПериода.Вставить("Синоним", 		   Синоним);
	ОписаниеПериода.Вставить("ЭтоИтог",			   ЭтоИтог);
	ОписаниеПериода.Вставить("ЭтоНарастающийИтог", ЭтоНарастающийИтог);
	ОписаниеПериода.Вставить("КонецПериода", 	   КонецПериода);
	ОписаниеПериода.Вставить("Периодичность", 	   Периодичность);
	ОписаниеПериода.Вставить("ЭтоВыходной", 	   Ложь);
	
	Префиксы = Новый Структура;					 
	Префиксы.Вставить("ИмяСумма",		  "СП");
	Префиксы.Вставить("ИмяСуммаФакт",	  "СФ");
	Префиксы.Вставить("ИмяКоличество",	  "КП");
	Префиксы.Вставить("ИмяКоличествоФакт","КФ");
	
	Для каждого КиЗ Из Префиксы Цикл
		Префикс = КиЗ.Значение;
		Если НЕ ЭтоИтог Тогда
			ТекИмя = ?(ПустаяСтрока(Имя), СформироватьИмяКолонкиПериод(Префикс, Период), Префикс+"_"+Имя);
		Иначе	
			ТекИмя = ?(ПустаяСтрока(Имя), СформироватьИмяКолонкиПериод(Префикс+"_Ит", Период),Префикс+"_"+Имя);			
		КонецЕсли; 
		ОписаниеПериода.Вставить(КиЗ.Ключ, ТекИмя);
	КонецЦикла; 
	
    Если ТипЗнч(КонецПериода) = Тип("Дата") Тогда
		ОписаниеПериода.КонецПериода = КонецПериода;
	Иначе	
		ОписаниеПериода.КонецПериода = КонецДня(Период);
	КонецЕсли; 							  

	Возврат ОписаниеПериода;
	
КонецФункции

// Конструктор структуры, описывающей параметры ячейки дерева.
// 
// Параметры:
//  Имя - Строка
//  Измерения - Структура
//	Период - Дата
//  Вид - Строка
//  Формула - Строка
//  Значение - Произвольный
// 
// Возвращаемое значение:
//  РезСтр - Структура.РасшифровкаЯчейкиФормыВвода.
// 
Функция РасшифровкаЯчейки(Имя,Измерения,Период,Вид,Формула="",Значение=Неопределено) Экспорт
	
	РезСтр = Новый Структура;
	РезСтр.Вставить("ИмяКласса", "РасшифровкаЯчейкиФормыВвода");
	РезСтр.Вставить("Имя"      , Имя);
	РезСтр.Вставить("Измерения", Измерения);
	РезСтр.Вставить("Период"       , Период);
	РезСтр.Вставить("Периодичность", Неопределено);
	РезСтр.Вставить("Значение" , Значение);
	РезСтр.Вставить("Вид"      , Вид);
	
	ИмяРесурса = "";
	Если ВРег(Лев(Имя,1)) = "С" Тогда
		ИмяРесурса = "Сумма";
	ИначеЕсли ВРег(Лев(Имя,1)) = "К" Тогда
		ИмяРесурса = "Количество";
	КонецЕсли; 
	РезСтр.Вставить("ИмяРесурса", ИмяРесурса);
	
	Если ВРег(Сред(Имя,2,1)) = "Ф" Тогда
		
		РезСтр.Вставить("ПланФакт","Ф");
		
	Иначе	
		
		РезСтр.Вставить("ПланФакт","П");
		
	КонецЕсли; 
	
	РезСтр.Вставить("Формула"  , Формула);
	РезСтр.Вставить("Аргументы", Новый Массив);
	
	Возврат РезСтр;
	
КонецФункции

// Определяет есть ли подчиненные строки с группами для данной строки дерева.
// 
Процедура ПроверитьНаличиеПодчиненныхЭлементов(СтрокаВерх, ИзмеренияРазворачивать, ЭтоНовыйЗапрос, флТолькоГруппы ) Экспорт
	
	Для каждого Имя Из ИзмеренияРазворачивать Цикл
		
		Если ЭтоНовыйЗапрос Тогда
			// Новый формат запроса может содержать несколько измерений.
			ТекЗначение = СтрокаВерх[Имя];
		Иначе	
			// Формат запроса редакции 2.8 содержал, только одно измерение с именем Ссылка.
			ТекЗначение = СтрокаВерх.Ссылка; 
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(ТекЗначение) И НЕ ТекЗначение.ЭтоГруппа Тогда
			
			флТолькоГруппы = Ложь;
			Возврат;
			
		КонецЕсли; 
		
	КонецЦикла;  // По именам измерений
	
	Для каждого СтрокаДерева Из СтрокаВерх.Строки Цикл
		
		ПроверитьНаличиеПодчиненныхЭлементов(СтрокаДерева, ИзмеренияРазворачивать, ЭтоНовыйЗапрос, флТолькоГруппы);
		
	КонецЦикла; 
	
КонецПроцедуры

// Формирует и устанавливает формулу для вычисления итогов по колонкам периодов.
// 
// Параметры:
//  Расшифровка - Структура
//  ИмяЯчейки - Строка
//  Аргументы - Массив.
// 
Функция УстановитьФормулуИтоговПоПериодам(Расшифровка,ТекОписание,Аргументы) Экспорт
	
	СтрФормула = "";
	Арг = Новый Массив;
	
	флЭтоОбщийИтог = Найти(ТекОписание.ИмяСумма, "Итог") > 0 ИЛИ Найти(ТекОписание.ИмяКоличество, "Итог") > 0;
	СтрНачПериода = Формат(ТекОписание.Период, "ДФ=yyyyMMdd");
	СтрКонПериода = Формат(ТекОписание.КонецПериода, "ДФ=yyyyMMdd");
	
	Для каждого ИмяАрг Из Аргументы Цикл
		
		СтрПериод = Сред(ИмяАрг,4,8);
		
		Если флЭтоОбщийИтог Тогда
			
			флДобавлять = Истина;
			
		ИначеЕсли ТекОписание.ЭтоНарастающийИтог Тогда
			
			флДобавлять = СтрПериод < СтрКонПериода;
			
		Иначе	
			// BF-1692 Изменение кода. Начало. 28.11.2017{{
			флДобавлять = СтрПериод >= СтрНачПериода И СтрПериод <= СтрКонПериода; 
			// Изменение кода. Конец. 28.11.2017}}
		КонецЕсли; 
		
		Если  флДобавлять Тогда
			
			СтрФормула = СтрФормула + ?(ПустаяСтрока(СтрФормула),""," + ")+"["+ИмяАрг+"]";
			Арг.Добавить(ИмяАрг);
			
		КонецЕсли; 
		
	КонецЦикла; // Аргументы 
	
	Расшифровка.Формула = СтрФормула;
	Расшифровка.Аргументы = Арг;
	
КонецФункции

// Формирует и устанавливает формулу, для вычисления итогов по группировке. 
// 
// Параметры:
//  ТабДок - ТабличныйДокумент.
//  ИменаЯчеекПодч - Соответствие
//  ИмяКолонки - Строка
//  НомСтроки - Число.
// 
Процедура УстановитьФормулуИтоговПоГруппе(ТабДок, ИменаЯчеекПодч, ИмяКолонки, ИдСтроки) Экспорт
	
	МассивИмен = ИменаЯчеекПодч[ИмяКолонки];
	Аргументы  = Новый Массив;
	
	СтрФормула = "";
	Если ТипЗнч(МассивИмен) = Тип("Массив") Тогда
		
		Для каждого ТекОписаниеЯчейки Из МассивИмен Цикл
			
			СтрЗнак = "+";			
			Если ТекОписаниеЯчейки.Коэф < 0  Тогда
				
				СтрЗнак = "-";			
				
			КонецЕсли; 
			// BF-2095 Изменение кода. Начало. 18.04.2018{{
			СтрФормула = СтрФормула+?(ПустаяСтрока(СтрФормула) И СтрЗнак <> "-",""," "+СтрЗнак+" ")
								   +?(ТекОписаниеЯчейки.Коэф=0,1,бит_ОбщегоНазначения.МодульЧисла(ТекОписаниеЯчейки.Коэф))
								   +"*["+ТекОписаниеЯчейки.Имя+"]";
			// Изменение кода. Конец. 18.04.2018}}
								   
			Аргументы.Добавить(ТекОписаниеЯчейки.Имя);
			
		КонецЦикла; 
		
	КонецЕсли; 
	
	Если НЕ ПустаяСтрока(СтрФормула) Тогда
		
		ТекИмяЯчейки = ИмяКолонки+"_"+ИдСтроки;		
		Обл = ТабДок.Область(ТекИмяЯчейки);
		Если ТипЗнч(Обл) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
			
			Обл.Расшифровка.Формула = СтрФормула;
			Обл.Расшифровка.Аргументы = Аргументы;						
			
		КонецЕсли; 
		
	КонецЕсли; 
	
КонецПроцедуры

// Функция создает структуру, используемую при проверке объединения ячеек в форме ввода.
// 
// Параметры:
//   ИзмеренияРазворачивать - Массив - Разворачивать.
// 
// Возвращаемое значение:
//  ДанныеВрем - Структура.
// 
Функция КонструкторСтруктурыПроверкиОбъединения(ИзмеренияРазворачивать) Экспорт
	
	ДанныеВрем = Новый Структура;
	Сч = 2;
	Для каждого Имя Из ИзмеренияРазворачивать Цикл
		
		ДанныеВрем.Вставить(Имя, Новый Структура("ТекЗначение, НомерСтроки, НомерКолонки",Неопределено, 0, Сч));
		
		Сч = Сч+1;
	КонецЦикла; 
	
	
	Возврат ДанныеВрем;
	
КонецФункции

// Процедура проверяет необходимость объединить ячейки со значениями измерений 
// и выполняет объединение при необходимости. 
// 
Процедура ПроверитьВыполнитьОбъединениеЯчеек(ТабДок
	                                          , ДанныеВрем
											  , Имя
											  , ТекЗначение
											  , ЕстьПодчиненные
											  , ПоследняяСтрокаУровня = Ложь) Экспорт
	
	ИзмерДанныеВрем = ДанныеВрем[Имя];
	Если ИзмерДанныеВрем.ТекЗначение <> ТекЗначение Тогда
		
		Если ИзмерДанныеВрем.НомерСтроки > 0 Тогда
			
			// Выполнить объединение
			Если ПоследняяСтрокаУровня Тогда
				ТекНомер = ТабДок.ВысотаТаблицы;
			Иначе	
				ТекНомер = ТабДок.ВысотаТаблицы-1;
			КонецЕсли; 
			Если (ТекНомер - ИзмерДанныеВрем.НомерСтроки) > 0  Тогда
				
				ТабДок.Область(ИзмерДанныеВрем.НомерСтроки, ИзмерДанныеВрем.НомерКолонки, ТекНомер, ИзмерДанныеВрем.НомерКолонки).Объединить(); 
				Если ИзмерДанныеВрем.НомерКолонки = 2 Тогда
					
					// Объединение кодификатора
					ТабДок.Область(ИзмерДанныеВрем.НомерСтроки, 1, ТекНомер, 1).Объединить(); 
					
				КонецЕсли; 
				
			КонецЕсли; 
			
		КонецЕсли; 
		ИзмерДанныеВрем.ТекЗначение =  ТекЗначение;
		ИзмерДанныеВрем.НомерСтроки =  ТабДок.ВысотаТаблицы;
		
	КонецЕсли; 
	
КонецПроцедуры

// Возвращает шаблон параметров функции "бит_Бюджетирование.ДоработатьЯчейку".
// 
// Возвращаемое значение:
//  Параметры - структура параметров функции.
//
// Пример:
//	ПараметрыДоработки = бит_Бюджетирование.НовыеПараметрыДоработкиЯчейки();
//	ПараметрыДоработки.ТД 			   = Новый ТабличныйДокумент;
//	ПараметрыДоработки.НомСтроки 	   = 0;
//	ПараметрыДоработки.НомСтолбца 	   = 0;
//	ПараметрыДоработки.Имя 			   = "";
//	ПараметрыДоработки.Измерения 	   = Неопределено;
//	ПараметрыДоработки.ОписаниеПериода = Неопределено;
//	ПараметрыДоработки.Вид 			   = Неопределено;
//	ПараметрыДоработки.Цвет 		   = Неопределено;
//	ПараметрыДоработки.Аргументы 	   = Неопределено;
//
Функция НовыеПараметрыДоработкиЯчейки() Экспорт

	Параметры = Новый Структура; 
	Параметры.Вставить("ТД",			  Новый ТабличныйДокумент);
	Параметры.Вставить("НомСтроки", 	  0);
	Параметры.Вставить("НомСтолбца", 	  0);
	Параметры.Вставить("Имя", 			  "");
	Параметры.Вставить("Измерения", 	  Неопределено);
	Параметры.Вставить("ОписаниеПериода", Неопределено);
	Параметры.Вставить("Вид", 			  Неопределено);
	Параметры.Вставить("Цвет", 			  Неопределено);
	Параметры.Вставить("Аргументы", 	  Неопределено);
		
	Возврат Параметры;

КонецФункции
 
// Процедура форматирует ячееку табличного документа перед выводом.
//
// Параметры:
//  Параметры - См. бит_Бюджетирование.НовыеПараметрыДоработкиЯчейки(). 
//
Процедура ДоработатьЯчейку(Параметры) Экспорт 
							
	ТД 				= Параметры.ТД;
	НомСтроки 		= Параметры.НомСтроки;
	НомСтолбца 		= Параметры.НомСтолбца;
	Имя 			= Параметры.Имя;
	Измерения 		= Параметры.Измерения;
	ОписаниеПериода = Параметры.ОписаниеПериода;
	Вид 			= Параметры.Вид;
	Цвет 			= Параметры.Цвет;
	Аргументы 		= Параметры.Аргументы;						
	
	яч = ТД.Область(НомСтроки,НомСтолбца,НомСтроки,НомСтолбца);
	яч.ИспользованиеРасшифровки = ИспользованиеРасшифровкиТабличногоДокумента.БезОбработки;
	яч.Имя = Имя;
	
	расш = РасшифровкаЯчейки(Имя, Измерения, ОписаниеПериода.Период, Вид);
	
	Если Вид = "Формула" И НЕ Аргументы = Неопределено Тогда
		УстановитьФормулуИтоговПоПериодам(расш, ОписаниеПериода, Аргументы); 
	КонецЕсли; 
	
	яч.Расшифровка = расш;
	Если НЕ Цвет = Неопределено Тогда
		яч.ЦветФона = Цвет;	
	КонецЕсли; 
	
КонецПроцедуры

#КонецОбласти

#Область ФиксацияБюджета

// Проверяет наличие зафиксированных данных бюджетных данных в таблице.
// 
// Параметры:
//   Сценарий - СправочникСсылка.СценарииПланирования
//   ТаблицаДанных - ТаблицаЗначений
//   Отказ - Булево
//   ВыводитьСообщения - Булево.
// 
Процедура ПроверитьФиксацию(Сценарий, ТаблицаДанных, Отказ, ВыводитьСообщения = Ложь) Экспорт
	
	 ТабВрем = ТаблицаДанных.Скопировать();
	 ТабВрем.Свернуть("Период, ЦФО");
	 
	 СписокЦФО = ТабВрем.ВыгрузитьКолонку("ЦФО");
	 
	 ИмяЦФО = бит_ОбщегоНазначения.ПолучитьИмяСправочникаЦФО();
	 ПустоеЦФО = Справочники[ИмяЦФО].ПустаяСсылка();
	 СписокЦФО.Добавить(ПустоеЦФО);
	
	 Запрос = Новый Запрос;
	 Запрос.УстановитьПараметр("Сценарий", Сценарий);
	 Запрос.УстановитьПараметр("СписокЦФО", СписокЦФО);
	 Запрос.УстановитьПараметр("ПустоеЦФО", ПустоеЦФО);
	 Запрос.УстановитьПараметр("ТабДанные", ТабВрем);
	 Запрос.Текст = "ВЫБРАТЬ
	                |	бит_ГраницыФиксацииБюджета.Сценарий,
	                |	бит_ГраницыФиксацииБюджета.ЦФО,
	                |	МАКСИМУМ(бит_ГраницыФиксацииБюджета.ДатаФиксации) КАК ДатаФиксации
	                |ПОМЕСТИТЬ ГраницыФиксации
	                |ИЗ
	                |	РегистрСведений.бит_ГраницыФиксацииБюджета КАК бит_ГраницыФиксацииБюджета
	                |ГДЕ
	                |	бит_ГраницыФиксацииБюджета.Сценарий = &Сценарий
	                |	И бит_ГраницыФиксацииБюджета.ЦФО В(&СписокЦФО)
	                |
	                |СГРУППИРОВАТЬ ПО
	                |	бит_ГраницыФиксацииБюджета.Сценарий,
	                |	бит_ГраницыФиксацииБюджета.ЦФО
	                |;
	                |
	                |////////////////////////////////////////////////////////////////////////////////
	                |ВЫБРАТЬ
	                |	НАЧАЛОПЕРИОДА(ТабДанные.Период, ДЕНЬ) КАК Период,
	                |	ТабДанные.ЦФО
	                |ПОМЕСТИТЬ ТабДанные
	                |ИЗ
	                |	&ТабДанные КАК ТабДанные
	                |;
	                |
	                |////////////////////////////////////////////////////////////////////////////////
	                |ВЫБРАТЬ ПЕРВЫЕ 1
	                |	ТабДанные.ЦФО,
	                |	ТабДанные.Период,
	                |	ГраницыФиксации.ДатаФиксации
	                |ИЗ
	                |	ТабДанные КАК ТабДанные
	                |		ЛЕВОЕ СОЕДИНЕНИЕ ГраницыФиксации КАК ГраницыФиксации
	                |		ПО ТабДанные.Период <= ГраницыФиксации.ДатаФиксации
	                |			И (ТабДанные.ЦФО = ГраницыФиксации.ЦФО
	                |				ИЛИ ГраницыФиксации.ЦФО = &ПустоеЦФО)
	                |ГДЕ
	                |	НЕ ГраницыФиксации.ДатаФиксации ЕСТЬ NULL";
					
	Результат = Запрос.Выполнить();
	
	Если НЕ Результат.Пустой() Тогда
		
		Отказ = Истина;
		
		Если ВыводитьСообщения Тогда 
			
			ТекстСообщения = НСтр("ru = 'Попытка изменения зафиксированных данных бюджета. Изменение отклонено.'");
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		КонецЕсли;
		
	КонецЕсли;	
	
КонецПроцедуры

// Проверяет наличие зафиксированных данных бюджетных данных в таблице.
// 
// Параметры:
//   ТекущаяФорма - УправляемаяФорма
//   ДокументСсылка - ДокументСсылка
//   ВыводитьСообщения - Булево.
// 
Процедура ПроверитьФиксациюВФорме(ТекущаяФорма, ДокументСсылка, ВыводитьСообщения = Ложь) Экспорт
	
	Отказ = Ложь;
	
	Набор = РегистрыНакопления.бит_ОборотыПоБюджетам.СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(ДокументСсылка);
	Набор.Прочитать();
	
	Если Набор.Количество() > 0 Тогда
		
		ТабДвижений = Набор.Выгрузить();
		ПерваяСтрока = ТабДвижений[0];
		
		ПроверитьФиксацию(ПерваяСтрока.Сценарий, ТабДвижений, Отказ, Ложь);
		
	КонецЕсли;
	
	Если Отказ Тогда
		
		ТекущаяФорма.ТолькоПросмотр = Истина;
		
		Если ВыводитьСообщения Тогда 
			
			ТекстСообщения = НСтр("ru = 'Документ содержит зафиксированные данных бюджета. Форма заблокирована.'");
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецЕсли;
		
	КонецЕсли;	
	
КонецПроцедуры

#КонецОбласти

#Область УстаревшийФункционал

Процедура ПроверитьЗаполнениеТабличнойЧастиБДДС(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, 
                                            Отказ, Заголовок)
//1С-ИжТиСи, Кондратьев, 03.2020, обновление. Функцию удалили, использований в типовых нет с 3.0.41.60/3.1.22.4. Возможно и раньше (
Экспорт

	МетаданныеОбъекта = ДокументОбъект.Метаданные();										
	ПредставлениеТабличнойЧасти = МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Представление();

	ТабличнаяЧасть      = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
	
	// Цикл по строкам табличной части.
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл

		СтруктураОбязательныхПолей.Удалить("Количество");
		СтруктураОбязательныхПолей.Удалить("Сумма");
		
		Если НЕ СтрокаТаблицы.СтатьяОборотов.ЭтоГруппа Тогда
			
			Если СтрокаТаблицы.СтатьяОборотов.Учет_Количество Тогда
				
				Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Количество",МетаданныеОбъекта,ИмяТабличнойЧасти) Тогда			
					СтруктураОбязательныхПолей.Вставить("Количество");
				КонецЕсли;
				
			КонецЕсли;
			
			Если СтрокаТаблицы.СтатьяОборотов.Учет_Сумма Тогда
				
				Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Сумма",МетаданныеОбъекта,ИмяТабличнойЧасти) Тогда
					СтруктураОбязательныхПолей.Вставить("Сумма");
				КонецЕсли;
				Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("СуммаСценарий",МетаданныеОбъекта,ИмяТабличнойЧасти) Тогда
					СтруктураОбязательныхПолей.Вставить("СуммаСценарий");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли; 
		
		СтрокаНачалаСообщенияОбОшибке = "В строке номер """+ СокрЛП(СтрокаТаблицы.НомерСтроки) +
		                               """ табличной части """ + ПредставлениеТабличнойЧасти + """: ";
			
		// Цикл по проверяемым полям
		Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если НЕ ЗначениеЗаполнено(Значение) Тогда 

				Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда // 
					ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
					СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";

				Иначе
					СтрокаСообщения = КлючЗначение.Значение;

				КонецЕсли;

				бит_ОбщегоНазначения.СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);

			КонецЕсли;

		КонецЦикла;
		
	КонецЦикла;
//1С-ИжТиСи, Кондратьев, 03.2020, обновление )

	// Устарело, удалить в 3.1.45.
	
КонецПроцедуры

Функция ПолучитьВидыОперацийДляРедактированияРасшифровкиПлатежа()
	
	// Устарело, удалить в 3.1.45.	
	Возврат Новый Массив;
	
КонецФункции

// Устарело, следует использовать бит_ОбщегоНазначенияКлиентСервер.НомерДекады(ТекущаяДата). 
// 
Функция НомерДекады(ТекущаяДата)
	
	// Устарело, удалить в 3.1.45.
	Возврат бит_ОбщегоНазначенияКлиентСервер.НомерДекады(ТекущаяДата);

КонецФункции

// Устарело, следует использовать бит_Бюджетирование.СвязанныеСтатьиОборотовИНоменклатурныеГруппы(Источник).
//
Функция ПолучитьСоответствиеСтатьиОборотовНомГруппы(Источник) Экспорт

	// Устарело, удалить в 3.1.45.
	Возврат СвязанныеСтатьиОборотовИНоменклатурныеГруппы(Источник);

КонецФункции

// Устарело, следует использовать бит_Бюджетирование.СвязанныеСтатьиОборотовИСтатьиРегл().
//
Функция ПолучитьСоответствиеСтатьиОборотовИСтатьиРегл(СтатьяОборотов, СтрокаТребуемыйТип = Неопределено) Экспорт

	// Устарело, удалить в 3.1.45.
	Возврат СвязанныеСтатьиОборотовИСтатьиРегл(СтатьяОборотов, СтрокаТребуемыйТип); 

КонецФункции

// Устарело, следует использовать бит_Бюджетирование.().
//
Функция ПолучитьСоответствиеДляЦФО_Подразделения(ЦФО_Подразделение) Экспорт
	
	// Устарело, удалить в 3.1.45.
	Возврат СвязанныеЦФОИПодразделения(ЦФО_Подразделение);
	
КонецФункции

#КонецОбласти 

// Функция позволяет получить имена измерений используемых в бюджетировании.
// 
// Параметры:
//  Режим  - Строка - "все","обязательные","произвольные","дополнительные".
//  СпособЗаполнения - Строка - "тип","имя","синоним".
//  ТипРезультата    - Строка - "Структура","Массив","СписокЗначений".
//  МассивИсключений - Массив - элементы, имена измерений, которые не должны попасть в результат.
// 
// Возвращаемое значение:
//   Структура - Ключ: ИмяИзмерения; Значение: Тип измерения; Строка.
// 
Функция ПолучитьИзмеренияБюджетирования(Режим, СпособЗаполнения, ТипРезультата = Неопределено, МассивИсключений = Неопределено) Экспорт
	
	// Определим тип возвращаемого результата
	РезультатМассив    = ВРег(ТипРезультата) = "МАССИВ";
	РезультатСписок    = ВРег(ТипРезультата) = "СПИСОКЗНАЧЕНИЙ";
	РезультатСтруктура = НЕ РезультатМассив И НЕ РезультатСписок;
	
	Если РезультатСтруктура Тогда
		Измерения = Новый Структура;
	КонецЕсли; 
	Если РезультатМассив Тогда
		Измерения = Новый Массив;
	КонецЕсли; 
	Если РезультатСписок Тогда
		Измерения = Новый СписокЗначений;
	КонецЕсли;  
	
	Если МассивИсключений = Неопределено Тогда	
		МассивИсключений = Новый Массив;	
	КонецЕсли; 
	
	МассивИсключений.Добавить("Валюта");
	
	// Обязательные измерения
	ОбязательныеИзмерения = Новый Массив;
	ОбязательныеИзмерения.Добавить("Сценарий");
	ОбязательныеИзмерения.Добавить("ЦФО");
	ОбязательныеИзмерения.Добавить("СтатьяОборотов");
	
	НастройкиИзмерений = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_НастройкиДополнительныхИзмерений");
	
	Для каждого Измерение Из Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам.Измерения Цикл
		
		// Проверим наличие исключений
		Если МассивИсключений.Найти(Измерение.Имя) <> Неопределено Тогда		
			Продолжить; 		
		КонецЕсли; 
		
		ТекущаяНастройка = НастройкиИзмерений[Измерение.Имя];
		
		Заполнять = Ложь;
		
		// Обязательные
		Если ВРег(Режим) = ВРег("обязательные") И ОбязательныеИзмерения.Найти(Измерение.Имя) <> Неопределено Тогда			
			Заполнять = Истина;   			
		КонецЕсли; 
		// Не обязательные 
		Если ВРег(Режим) = ВРег("произвольные") И ОбязательныеИзмерения.Найти(Измерение.Имя) = Неопределено  Тогда			
			Заполнять = Истина;  			
		КонецЕсли;   		
		// Произвольно назначаемые аналитики
		Если ВРег(Режим) = ВРег("дополнительные") И Найти(Измерение.Имя, "Аналитика") > 0 Тогда 			
			Заполнять = Истина;			
		КонецЕсли; 
		// Все
		Если ВРег(Режим) = ВРег("все") Тогда			
			Заполнять = Истина;			
		КонецЕсли; 
		
		Если Заполнять Тогда
			
			Если ВРег(СпособЗаполнения) = ВРег("тип") Тогда
			  	Значение = Измерение.Тип;
			ИначеЕсли ВРег(СпособЗаполнения) = ВРег("синоним") Тогда	
			  	Значение = Измерение.Синоним;
		    ИначеЕсли ВРег(СпособЗаполнения) = ВРег("имя") Тогда
				Если ТекущаяНастройка = Неопределено Тогда
					Значение = бит_РаботаСМетаданными.ПолучитьИмяОбъектаПоОписаниюТипов(Измерение.Тип);
				Иначе	
					Значение = бит_РаботаСМетаданными.ПолучитьИмяОбъектаПоОписаниюТипов(ТекущаяНастройка.Аналитика.ТипЗначения);
				КонецЕсли; 
		    КонецЕсли;
			
			Если РезультатСтруктура Тогда
				Измерения.Вставить(Измерение.Имя, Значение);
			КонецЕсли; 
			Если РезультатМассив Тогда
				Измерения.Добавить(Измерение.Имя);
			КонецЕсли; 
			Если РезультатСписок Тогда
				Измерения.Добавить(Значение, Измерение.Имя);
			КонецЕсли;  
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	Возврат Измерения;
	
КонецФункции
 
// Возвращает настройки измерений бюджетирования.
// 
// Параметры:
//  Исключения - Строка.
// 
// Возвращаемое значение:
//  Настройки - Соответствие.
// 
Функция НастройкиИзмеренийБюджетирования(Исключения = "") Экспорт

	Настройки = Новый Соответствие;
	
	Если ПустаяСтрока(Исключения) Тогда
		МассивИсключений = Новый Массив;
	Иначе	
		МассивИсключений = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(Исключения, ",");
	КонецЕсли; 
	МассивИсключений.Добавить("Валюта");
	
	НастройкиДоп = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_НастройкиДополнительныхИзмерений");
	
	Для каждого Измерение Из Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам.Измерения Цикл
		
		// Проверим наличие исключений
		Если МассивИсключений.Найти(Измерение.Имя) <> Неопределено Тогда
		
			 Продолжить;
		
		КонецЕсли; 
		
		Имя = Измерение.Имя;
		
		ТекНастройка = НастройкиДоп[Имя];
		
		Если ТекНастройка = Неопределено И Найти(Имя,"Аналитика_") = 0 Тогда
		
			 ТекНастройка = бит_МеханизмДопИзмерений.КонструкторСтруктураНастроек();
			 ТекНастройка.Синоним = Измерение.Синоним;
			 ТекНастройка.ТипЗначения = Измерение.Тип;
			 ТекНастройка.ЗначениеПоУмолчанию = Измерение.Тип.ПривестиЗначение();
		
		КонецЕсли; 
		
		Настройки.Вставить(Имя, ТекНастройка);
		
	КонецЦикла;	

	Возврат Настройки;
	
КонецФункции

// Функция формирует структуру параметров для получения курсов по периодам для документов бюджетирования.
// 
// Параметры:
//  Сценарий  - СправочникСсылка.СценарииПланирования.
//  ВалютаДокумента - СправочникСсылка.бит_Валюты.
// 
// Возвращаемое значение:
//   СтруктураПараметров   - Структура.
// 
Функция ЗаполнитьСтруктуруПараметровПолученияКурсовПоПериодам(Сценарий,ВалютаДокумента) Экспорт

	СтруктураПараметров = Новый Структура;
	Параметры = Новый Структура;
	Параметры.Вставить("Валюта",Константы.бит_ВалютаУправленческогоУчета.Получить());
	СтруктураПараметров.Вставить("Упр",Параметры);
	Параметры = Новый Структура;
	Параметры.Вставить("Валюта",Сценарий.Валюта);
	СтруктураПараметров.Вставить("Сценарий",Параметры);
	Параметры = Новый Структура;
	Параметры.Вставить("Валюта",ВалютаДокумента);
	СтруктураПараметров.Вставить("Документ",Параметры);
	

	Возврат СтруктураПараметров;

КонецФункции

// Процедура выполняет пересчеты из валюты документа в различные валюты, 
// необходимые для подготовки таблицы оборотов для проведения.
// 
// Параметры:
//  ТаблицаОборотов  - ТаблицаЗначений.
//  СтруктураКурсыВалют - Структура- значениями являются структуры с ключами "Валюта","Курс","Кратность".
// 
Процедура ВыполнитьПересчетыВТаблицеОборотов(ТаблицаОборотов,КурсыПоПериодам,СтруктураКурсыВалют, ДопРеквизит = Неопределено) Экспорт

	
	ИменаРеквизитов = Новый Массив;
	ИменаРеквизитов.Добавить("Сумма");
	
	Если ЗначениеЗаполнено(ДопРеквизит) Тогда
		ИменаРеквизитов.Добавить(ДопРеквизит);
	КонецЕсли;

	Для каждого СтрокаТаблицы Из ТаблицаОборотов Цикл
		
		ТекущиеКурсы = Новый Структура;
		
		ТекущиеКурсы.Вставить("Регл",СтруктураКурсыВалют.Регл);
		
		Если КурсыПоПериодам = Неопределено Тогда
			
				ТекущиеКурсы.Вставить("Упр"     ,СтруктураКурсыВалют.Упр);
				ТекущиеКурсы.Вставить("Сценарий",СтруктураКурсыВалют.Сценарий);
				ТекущиеКурсы.Вставить("Документ",СтруктураКурсыВалют.Документ);			
			
		Иначе	
			// Получаем курсы текущего периода
			КурсыПериода = КурсыПоПериодам[СтрокаТаблицы.Период];
			
			Если КурсыПериода = Неопределено Тогда
				
				ТекущиеКурсы.Вставить("Упр"     ,СтруктураКурсыВалют.Упр);
				ТекущиеКурсы.Вставить("Сценарий",СтруктураКурсыВалют.Сценарий);
				ТекущиеКурсы.Вставить("Документ",СтруктураКурсыВалют.Документ);
				
			Иначе
				
				ТекущиеКурсы.Вставить("Упр"     ,КурсыПериода.Упр);
				ТекущиеКурсы.Вставить("Сценарий",КурсыПериода.Сценарий);
				ТекущиеКурсы.Вставить("Документ",КурсыПериода.Документ);
				
			КонецЕсли; 
		КонецЕсли; 
		
		Если СтрокаТаблицы.ЭтоКоэффициент Тогда
			
			// Это безразмерный коэффициент - пересчеты по валютам не выполняются.
			Для каждого КиЗ Из ТекущиеКурсы Цикл
				
				 Постфикс = КиЗ.Ключ;
				 Если Постфикс = "Документ" Тогда
				 
				 	Продолжить;
				 
				 КонецЕсли; 
				 
				 Имя = "Сумма"+Постфикс;
				 СтрокаТаблицы[Имя] = СтрокаТаблицы.Сумма;
				 
			КонецЦикла; 
			
		Иначе
			
			бит_КурсыВалют.ВыполнитьПересчетыДляОбъекта(СтрокаТаблицы,ИменаРеквизитов,ТекущиеКурсы,СтруктураКурсыВалют.Документ);
			
		КонецЕсли; 
		
	КонецЦикла; // По строкам таблицы
	
КонецПроцедуры

// Процедура выполняет пересчет сумм в табличных частях документов бюджетирования при изменении валюты. 
// 
// Параметры:
//  ТабЧасть - ТабличнаяЧасть.
//  Сценарий - СправочникСсылка.СценарииПланирования.
//  КурсыДок - Структура.
//  ПоляПересчета - Массив.
// 
Процедура ПересчитатьТабЧастьПоВалюте(ТабЧасть, Сценарий, КурсыДок, ПоляПересчета, ИмяКолонкиСтатьяОборотов = "СтатьяОборотов") Экспорт
		
	флИспользоватьКурсыСценария = Сценарий.ИспользоватьКурсыСценария;
	
	Если флИспользоватьКурсыСценария Тогда
		
		// Пересчет с использованием курсов сценария.
		ТаблицаПериодов = ТабЧасть.Выгрузить();
		ТаблицаПериодов.Свернуть("Период");
		
		СтруктураПараметров = Новый Структура;
		Парам = Новый Структура;
		Парам.Вставить("Валюта",КурсыДок.Нач.Валюта);
		СтруктураПараметров.Вставить("Нач",Парам);
		Парам = Новый Структура;
		Парам.Вставить("Валюта",КурсыДок.Кон.Валюта);
		СтруктураПараметров.Вставить("Кон",Парам);
		
		// Получим курсы по периодам
		КурсыПоПериодам = бит_КурсыВалют.ПолучитьКурсыВалютПоПериодам(ТаблицаПериодов,Сценарий,СтруктураПараметров);
		
	КонецЕсли;	
	
	
	Для каждого СтрокаТаблицы Из ТабЧасть Цикл
		
		Если СтрокаТаблицы[ИмяКолонкиСтатьяОборотов].ЭтоКоэффициент Тогда
		
			 Продолжить;
		
		КонецЕсли; 
		
		Если флИспользоватьКурсыСценария Тогда
			
			ТекКурсы = КурсыПоПериодам[СтрокаТаблицы.Период];
			
		Иначе
			
			ТекКурсы = КурсыДок;
			
		КонецЕсли; 
		
		Если ТекКурсы = Неопределено Тогда
			
			Продолжить;
			
		КонецЕсли; 
		
		СтрКурсаНач = ТекКурсы.Нач;
		СтрКурсаКон = ТекКурсы.Кон;
		
		Для каждого Поле Из ПоляПересчета Цикл
			
			СтрокаТаблицы[Поле] = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(СтрокаТаблицы[Поле]
																							, СтрКурсаНач.Валюта
																							, СтрКурсаКон.Валюта
																							, СтрКурсаНач.Курс
																							, СтрКурсаКон.Курс
																							, СтрКурсаНач.Кратность
																							, СтрКурсаНач.Кратность);
			
		КонецЦикла; // ПоляПересчета 
		
	КонецЦикла; // Объект.БДДС
	
	
КонецПроцедуры
 
// Устарело, следует использовать бит_ОбщегоНазначенияКлиентСервер.СформироватьПредставлениеПериода(ТекущийПериод,Периодичность). 
Функция СформироватьПредставлениеПериода(ТекущийПериод,Периодичность) Экспорт

   Возврат бит_ОбщегоНазначенияКлиентСервер.СформироватьПредставлениеПериода(ТекущийПериод,Периодичность);
   
КонецФункции

// Устарело, следует использовать бит_ОбщегоНазначенияКлиентСервер.ПолучитьПериодПоСдвигу(ДатаНачала,Сдвиг,Периодичность,НеприводитьКНачалу).  
Функция ПолучитьПериодПоСдвигу(ДатаНачала,Сдвиг,Периодичность,НеприводитьКНачалу = Ложь) Экспорт
	
   Возврат бит_ОбщегоНазначенияКлиентСервер.ПолучитьПериодПоСдвигу(ДатаНачала,Сдвиг,Периодичность,НеприводитьКНачалу);
   
КонецФункции

// Устарело, следует использовать бит_ОбщегоНазначенияКлиентСервер.РазностьДат(ДатаНачала,ДатаОкончания,Периодичность). 
Функция РазностьДат(ДатаНачала,ДатаОкончания,Периодичность) Экспорт
	 	       	 	       	 
	Возврат бит_ОбщегоНазначенияКлиентСервер.РазностьДат(ДатаНачала,ДатаОкончания,Периодичность);
	
КонецФункции


// Устарело, следует использовать бит_ОбщегоНазначенияКлиентСервер.ПолучитьНачалоПериода(ДатаНачала,Периодичность). 
Функция ПолучитьНачалоПериода(ДатаНачала,Периодичность) Экспорт
	                	
   Возврат бит_ОбщегоНазначенияКлиентСервер.ПолучитьНачалоПериода(ДатаНачала,Периодичность);
   
КонецФункции

// Устарело, следует использовать бит_ОбщегоНазначенияКлиентСервер.ПолучитьКонецПериода(ДатаНачала,Периодичность).  
Функция ПолучитьКонецПериода(ДатаНачала,Периодичность) Экспорт
	
   Возврат бит_ОбщегоНазначенияКлиентСервер.ПолучитьКонецПериода(ДатаНачала,Периодичность);
   
КонецФункции

// Функция определяет текущий ИД по табличной части.
// 
// Параметры:
//  ТабличнаяЧасть  - ТабличнаяЧасть - табличная часть.
//  ИмяРеквизитаИД  - Строка - имя.
// 
// Возвращаемое значение:
//   ТекущийИД      - Число.
// 
Функция ОпределитьТекущийИД(ТабличнаяЧасть,ИмяРеквизитаИд) Экспорт
	
	ТекущийИД = 1;
	
	Если ТабличнаяЧасть.Количество()>0 Тогда
		
		ВремСписок = Новый СписокЗначений;
		ВремСписок.ЗагрузитьЗначения(ТабличнаяЧасть.ВыгрузитьКолонку("ИД"));
		ВремСписок.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
		ТекущийИД = ВремСписок[0].Значение+1;
	КонецЕсли; 

   Возврат ТекущийИД;
   
КонецФункции

// Извлекает настройки аналитик по массиву статей оборотов и упаковывает из в сответствие.
// 
// Параметры:
//  вхСтатьи - Массив, СправочникСсылка.бит_СтатьиОборотов
//  НастройкиСтатей - Соответствие- Ключ: СтатьяОборотов, Значение: Структура.НастройкиСтатейОборотов.
// 
Процедура ПолучитьНастройкиСтатейОборотов(вхСтатьи, НастройкиСтатей) Экспорт

	Если ТипЗнч(вхСтатьи) = Тип("СправочникСсылка.бит_СтатьиОборотов") Тогда		
		МассивСтатей = Новый Массив;
		МассивСтатей.Добавить(вхСтатьи);		
	Иначе		
		МассивСтатей = вхСтатьи;		
	КонецЕсли;
	
	ТекстПолей = "";
	Для каждого РеквизитУчет Из бит_РаботаСДиалогамиСервер.СформироватьМассивРеквизитовСтатей() Цикл
		
	 	ТекстПолей = ТекстПолей + "	бит_СтатьиОборотов.Учет_" + РеквизитУчет + "," + Символы.ПС;
		
	КонецЦикла;
	
	Для каждого РеквизитУчет Из бит_РаботаСДиалогамиСервер.СформироватьМассивРеквизитовСтатейИмяТипа() Цикл
		
		ТекстПолей = ТекстПолей + " бит_СтатьиОборотов.ИмяТипаПоУмолчанию_"+РеквизитУчет + "," + Символы.ПС
		
	КонецЦикла;
	
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("МассивСтатей", МассивСтатей);
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	бит_СтатьиОборотов.Ссылка КАК СтатьяОборотов,	
	|" + ТекстПолей + "
	|	ИСТИНА КАК Учет_ЦФО
	|ИЗ
	|	Справочник.бит_СтатьиОборотов КАК бит_СтатьиОборотов
	|ГДЕ
	|	НЕ бит_СтатьиОборотов.ЭтоГруппа
	|	И бит_СтатьиОборотов.Ссылка В(&МассивСтатей)
	|";
			   
	Результат = Запрос.Выполнить();
	ТабДанные = Результат.Выгрузить();
	 
	Для каждого СтрокаТаблицы Из ТабДанные Цикл
		 
		Настройка = Новый Структура;
		Настройка.Вставить("ИмяКласса", "НастройкаСтатьиОборотов");
	 	Для каждого Колонка Из ТабДанные.Колонки Цикл
		 
			Если Колонка.Имя = "СтатьяОборотов" Тогда
				Продолжить;
			КонецЕсли; 
			
			Если Найти(Колонка.Имя, "ИмяТипаПоУмолчанию_") > 0  Тогда
				
				ИмяТипа = СтрокаТаблицы[Колонка.Имя];
				Если ЗначениеЗаполнено(ИмяТипа) Тогда
					ИмяТипа = СтрЗаменить(ИмяТипа,".","Ссылка.");
					ТекТип = Новый ОписаниеТипов(ИмяТипа);					
				Иначе	
					ТекТип = Неопределено;
				КонецЕсли; 
				
				Настройка.Вставить(Колонка.Имя, ТекТип);
				
			Иначе	
				
				Настройка.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
				
			КонецЕсли; 
			  
		КонецЦикла; 
		 
		НастройкиСтатей.Вставить(СтрокаТаблицы.СтатьяОборотов, Настройка);
		 
	КонецЦикла;		   
	
КонецПроцедуры

// Функция получает настройки зависимых оборотов.
// 
// Параметры:
//  Сценарий - СправочникСсылка.СценарииПланирования - Сценарий.
//  ДатаЗапроса - Дата - дата для запроса.
// 
// Возвращаемое значение:
//  НастройкиЗависимыхОборотов - ТаблицаЗначений.
// 
Функция ПолучитьНастройкиЗависимыхОборотов(Сценарий, ДатаЗапроса) Экспорт

	ИмяСправочникаСценарии = бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования();	
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Дата", ДатаЗапроса);
	Запрос.УстановитьПараметр("Сценарий", Сценарий);
	Запрос.УстановитьПараметр("ПустойСценарий", Справочники[ИмяСправочникаСценарии].ПустаяСсылка());
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	*
	               |ИЗ
	               |	РегистрСведений.бит_ЗависимыеОбороты КАК бит_ЗависимыеОбороты
	               |ГДЕ
	               |	бит_ЗависимыеОбороты.Период <= &Дата
	               |	И (бит_ЗависимыеОбороты.Сценарий = &Сценарий
	               |			ИЛИ бит_ЗависимыеОбороты.Сценарий = &ПустойСценарий)";
				   
	Результат = Запрос.Выполнить();
	НастройкиЗависимыхОборотов = Результат.Выгрузить();
    НастройкиЗависимыхОборотов.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));
	
	Возврат НастройкиЗависимыхОборотов;
	
КонецФункции

// Функция получает максимальное значение периода из табличной части.
// 
// Параметры:
//    ТабЧасть - ТабличнаяЧасть
//    ИмяКолонки - Строка
// 
// Возвращаемое значение:
//  МаксПериод - Дата.
// 
Функция ПолучитьМаксПериод(ТабЧасть, ИмяКолонки = "Период") Экспорт

	МаксПериод = ТекущаяДата();
	МассивПериодов = ТабЧасть.ВыгрузитьКолонку(ИмяКолонки);
	СписокПериодов = Новый СписокЗначений;
	СписокПериодов.ЗагрузитьЗначения(МассивПериодов);
	СписокПериодов.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
	
	Если СписокПериодов.Количество() > 0 Тогда
	
		МаксПериод = СписокПериодов[0].Значение;
	
	КонецЕсли; 

	Возврат МаксПериод;
	
КонецФункции

// Возвращает шаблон параметров функции "бит_Бюджетирование.СформироватьЗависимыеОборотыПоСтроке".
// 
// Возвращаемое значение:
//  Параметры - структура параметров функции.
//
// Пример:
//	ПараметрыФормирования = бит_Бюджетирование.НовыеПараметрыФормированияЗависмыхОборотовПоСтроке();
//	ПараметрыФормирования.ДатаЗаполнения 			= '0001-01-01';
//	ПараметрыФормирования.ТекущийОбъект 			= Неопределено;
//	ПараметрыФормирования.СтрокаТабличнойЧасти		= Неопределено;
//	ПараметрыФормирования.ИмяТабличнойЧастиИсточник = "";
//	ПараметрыФормирования.ИмяТабличнойЧастиПриемник = "";
//	ПараметрыФормирования.ИзмеренияБюджетирования	= Неопределено;
//	ПараметрыФормирования.вхНастройкиЗависимых		= Неопределено;
//	ПараметрыФормирования.УровеньРекурсии 			= 0;
//	
Функция НовыеПараметрыФормированияЗависмыхОборотовПоСтроке() Экспорт

	Параметры = Новый Структура; 
	Параметры.Вставить("ДатаЗаполнения", 			'0001-01-01');
	Параметры.Вставить("ТекущийОбъект", 			Неопределено);
	Параметры.Вставить("СтрокаТабличнойЧасти",		Неопределено);
	Параметры.Вставить("ИмяТабличнойЧастиИсточник", "");
	Параметры.Вставить("ИмяТабличнойЧастиПриемник", "");
	Параметры.Вставить("ИзмеренияБюджетирования",	Неопределено);
	Параметры.Вставить("вхНастройкиЗависимых",		Неопределено);
	Параметры.Вставить("УровеньРекурсии", 			0);
	
	Возврат Параметры;

КонецФункции
 
// Процедура выполняе формирование зависимых оборотов по строке оборотов. Рекурсивный вызов.
// 
// Параметры:
//  ДатаЗаполнения  - Дата.
//  ТекущийОбъект   - ДокументОбъект.
//  СтрокаТабличнойЧасти - СтрокаТабличнойЧасти.
//  ИмяТабличнойЧастиИсточник - Строка.
//  ИмяТабличнойЧастиПриемник - Строка.
//  ИзмеренияБюджетирования   - Структура.
//  вхНастройкиЗависимых - ТаблицаЗначений.
//  УровеньРекурсии - Число.
// 
Процедура СформироватьЗависимыеОборотыПоСтроке(Параметры) Экспорт

	ДатаЗаполнения 			  = Параметры.ДатаЗаполнения;
	ТекущийОбъект 			  = Параметры.ТекущийОбъект;
	СтрокаТабличнойЧасти 	  = Параметры.СтрокаТабличнойЧасти;
	ИмяТабличнойЧастиИсточник = Параметры.ИмяТабличнойЧастиИсточник;
	ИмяТабличнойЧастиПриемник = Параметры.ИмяТабличнойЧастиПриемник;
	ИзмеренияБюджетирования   = Параметры.ИзмеренияБюджетирования;
	вхНастройкиЗависимых 	  = Параметры.вхНастройкиЗависимых;
	УровеньРекурсии 		  = Параметры.УровеньРекурсии;
   
	// Защита от зацикливания
	Если УровеньРекурсии>1000 Тогда
		ТекстСообщения = НСтр("ru = 'Превышен уровень рекурсии. Проверьте настройки зависимых оборотов на зацикливание.'"); 
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	    Возврат;
	КонецЕсли; 
	
	УровеньРекурсии = УровеньРекурсии+1;
	
	// Получим данные необходимые для выполнения процедуры.
	
	МетаданныеОбъекта = ТекущийОбъект.Метаданные();
	
	// Получаем имя справочника Сценарии бюджетирования в зависимости от текущего решения.
	ИмяСправочникаСценарии = бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования();
	
	Сценарий = Справочники[ИмяСправочникаСценарии].ПустаяСсылка();
	
	Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Сценарий",МетаданныеОбъекта,ИмяТабличнойЧастиИсточник) Тогда
		Сценарий = СтрокаТабличнойЧасти.Сценарий;
	ИначеЕсли бит_РаботаСМетаданными.ЕстьРеквизит("Сценарий",МетаданныеОбъекта) Тогда
		Сценарий = ТекущийОбъект.Сценарий;
	КонецЕсли; 
	
	Если Не ЗначениеЗаполнено(Сценарий) Тогда
		Возврат;
	КонецЕсли;

	флВестиПротокол = бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("КомментарийРасчета", МетаданныеОбъекта, ИмяТабличнойЧастиПриемник);
	
	// Получаем имена справочников в зависимости от текущего решения.
	ИмяСправочникаЦФО 	  = бит_ОбщегоНазначения.ПолучитьИмяСправочникаЦФО();
	ИмяСправочникаПроекты = бит_ОбщегоНазначения.ПолучитьИмяСправочникаПроекты();
	
	Периодичность = Сценарий.бит_Периодичность;
	
	ТаблицаПриемник = ТекущийОбъект[ИмяТабличнойЧастиПриемник];
	ПроверяемыеПоля = ПодготовитьПроверяемыеПоляЗавОборотов();
	
	// Получим структуру зависимых оборотов для данной строки таблицы оборотов.
	Если вхНастройкиЗависимых = Неопределено Тогда
		
		Результат = ВыполнитьЗапросДляФормированияЗависимыхОборотов(ДатаЗаполнения, Сценарий, ИзмеренияБюджетирования, СтрокаТабличнойЧасти);	
		Если Результат.Пустой() Тогда
			
			Возврат;
			
		КонецЕсли; 
		
		НастройкиЗависимыхОборотов = Результат.Выгрузить();
		НастройкиЗависимыхОборотов.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));
		Для каждого СтрокаНастройки Из НастройкиЗависимыхОборотов Цикл
		
			ВычислитьПриоритетСтрокиЗависимыхОборотов(СтрокаТабличнойЧасти, СтрокаНастройки, ПроверяемыеПоля);
		
		КонецЦикла; 
		
	Иначе	
		
		НастройкиЗависимыхОборотов = вхНастройкиЗависимых.СкопироватьКолонки();
		
		ТабВрем = вхНастройкиЗависимых.СкопироватьКолонки();
		
		// По статьи в настройке указаны практически всегда, поэтому в первую очередь отберем по статьям
		// по остальным полям будем фильтровать отдельно.
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("СтатьяОборотов", СтрокаТабличнойЧасти.СтатьяОборотов);
		
		МассивСтрокВрем = вхНастройкиЗависимых.НайтиСтроки(СтрОтбор);
		
		Для каждого СтрокаВрем Из МассивСтрокВрем Цикл
		
			 НоваяСтрока = ТабВрем.Добавить();
			 ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаВрем);
		
		КонецЦикла; 
		
		// Теоретически могут быть настройки на пустые статьи.
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("СтатьяОборотов", Справочники.бит_СтатьиОборотов.ПустаяСсылка());
		
		МассивСтрокВрем = вхНастройкиЗависимых.НайтиСтроки(СтрОтбор);
		
		Для каждого СтрокаВрем Из МассивСтрокВрем Цикл
		
			 НоваяСтрока = ТабВрем.Добавить();
			 ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаВрем);
		
		КонецЦикла; 
		
		// Выполним фильтрацию по остальным измерениям.
		Для каждого СтрокаВрем Из ТабВрем Цикл
			
			Если УсловиеНаПоляЗависимыхОборотов(СтрокаТабличнойЧасти, СтрокаВрем, ПроверяемыеПоля, ДатаЗаполнения) Тогда
				
				ВычислитьПриоритетСтрокиЗависимыхОборотов(СтрокаТабличнойЧасти, СтрокаВрем, ПроверяемыеПоля);
				НоваяСтрока = НастройкиЗависимыхОборотов.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаВрем);
				
			КонецЕсли; 
			
		КонецЦикла; 
		
		НастройкиЗависимыхОборотов.Сортировать("Период");
		
		// Выполним "срез последних" для полученной таблицы.
		ТабВрем = НастройкиЗависимыхОборотов.Скопировать();
		
		// Сверткой по измерениям выявим дубли
		КолонкиУдаления = Новый Массив;
		КолонкиУдаления.Добавить("Регистратор");				
		КолонкиУдаления.Добавить("Период");		
		КолонкиУдаления.Добавить("ПрофильРаспределения");
		КолонкиУдаления.Добавить("КоэффициентКоличество");
		КолонкиУдаления.Добавить("КоэффициентСумма");
		КолонкиУдаления.Добавить("РеквизитКоличество");
		КолонкиУдаления.Добавить("РеквизитСумма");
		КолонкиУдаления.Добавить("ФункцияКоличество");
		КолонкиУдаления.Добавить("ФункцияСумма");
		КолонкиУдаления.Добавить("ДатаОкончания");
		
		Для каждого ИмяКолонки Из КолонкиУдаления Цикл
			
			Если НЕ ТабВрем.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				
				ТабВрем.Колонки.Удалить(ИмяКолонки);
				
			КонецЕсли; 
			
		КонецЦикла; 
		
		СтрКолонкиГруппировки = "";
		Для каждого Колонка Из ТабВрем.Колонки Цикл
		
			СтрКолонкиГруппировки = СтрКолонкиГруппировки+ ?(ПустаяСтрока(СтрКолонкиГруппировки),"",",")+Колонка.Имя;
		
		КонецЦикла; 
		
		ТабВрем.Колонки.Добавить("КоличествоДублей", Новый ОписаниеТипов("Число"));
		ТабВрем.ЗаполнитьЗначения(1,"КоличествоДублей");
		ТабВрем.Свернуть(СтрКолонкиГруппировки, "КоличествоДублей");
		
		Для каждого СтрокаВрем Из ТабВрем Цикл
		
			Если СтрокаВрем.КоличествоДублей > 1 Тогда
				
				 // Найдем дублирующиеся строки в таблице НастройкиЗависимыхОборотов.
				 СтрОтбор = Новый Структура;
				 Для каждого Колонка Из ТабВрем.Колонки Цикл
					 
					Если Колонка.Имя = "КоличествоДублей" Тогда
					
						Продолжить;
					
					КонецЕсли;  
					 
				 	СтрОтбор.Вставить(Колонка.Имя, СтрокаВрем[Колонка.Имя]);
				 
				 КонецЦикла; 
				 
				 НайденныеСтроки = НастройкиЗависимыхОборотов.НайтиСтроки(СтрОтбор);
				 
				 КолСтрок = НайденныеСтроки.Количество();
				 Если КолСтрок > 0 Тогда
				 
				 	  Для Сч = 1 По КолСтрок Цикл
					  
						  Если Сч> 1 Тогда
						    // Т.к. таблица отсортирована по периоду по возрастанию - оставляем строку с самым большим индексом.
						    СчЙ = КолСтрок - Сч;
							НастройкиЗависимыхОборотов.Удалить(НайденныеСтроки[СчЙ]);
						  
						  КонецЕсли; 
						  
					  
					  КонецЦикла; 
				 
				 КонецЕсли; 
				 
			КонецЕсли; 
		
		КонецЦикла; // По временной таблице 
		
	КонецЕсли; 
	
		
	НастройкиЗависимыхОборотов.Сортировать("Приоритет УБЫВ");
	ТекущийПриоритет = 0;
	
	Если НастройкиЗависимыхОборотов.Количество() > 0 Тогда
	
		 ТекущийПриоритет = НастройкиЗависимыхОборотов[0].Приоритет;
	
	КонецЕсли; 
	
	// Заполним строки зависимых оборотов
	Для Каждого СтрокаНастройки Из НастройкиЗависимыхОборотов Цикл
		
		 // Применяем только строки наивысшего приоритета, например, если совпадает Статья и Проект, 
		 // то эта настройка имеет приоритет перед настройкой, когда совпадает только статья.
	     Если НЕ СтрокаНастройки.Приоритет = ТекущийПриоритет Тогда
		 
		 	   Продолжить;
		 
		 КонецЕсли; 
	
		 НоваяСтрока = ТаблицаПриемник.Добавить();
		 Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Сценарий",МетаданныеОбъекта,ИмяТабличнойЧастиПриемник) Тогда
			 
			 НоваяСтрока.Сценарий = Сценарий;
			 
		 КонецЕсли;  
		 НоваяСтрока.Период = СтрокаТабличнойЧасти.Период;
		 
		 Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Измерение",МетаданныеОбъекта,ИмяТабличнойЧастиПриемник) 
			 ИЛИ бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Измерение",МетаданныеОбъекта,ИмяТабличнойЧастиИсточник) Тогда
		 
		 	НоваяСтрока.Измерение = СтрокаТабличнойЧасти.Измерение;
		 
		 КонецЕсли; 
		 Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("ИД",МетаданныеОбъекта,ИмяТабличнойЧастиПриемник) 
			 ИЛИ бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("ИД",МетаданныеОбъекта,ИмяТабличнойЧастиИсточник) Тогда
		 
		 	НоваяСтрока.ИД = СтрокаТабличнойЧасти.ИД;
		 
		 КонецЕсли; 
		 Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("ИД_Родитель",МетаданныеОбъекта,ИмяТабличнойЧастиПриемник) 
			 ИЛИ бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("ИД",МетаданныеОбъекта,ИмяТабличнойЧастиИсточник) Тогда
		 
		 	НоваяСтрока.ИД_Родитель = СтрокаТабличнойЧасти.ИД;
		 
		 КонецЕсли; 
		 
         Если бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Расчетная",МетаданныеОбъекта,ИмяТабличнойЧастиПриемник) 
			 ИЛИ бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти("Расчетная",МетаданныеОбъекта,ИмяТабличнойЧастиИсточник) Тогда
		 
		 	НоваяСтрока.Расчетная = СтрокаТабличнойЧасти.Расчетная;
		 
		 КонецЕсли;		 
		 // Заполним измерения
		 ЗависимыеОборотыЗаполнитьИзмерения(ИзмеренияБюджетирования, СтрокаНастройки, СтрокаТабличнойЧасти, НоваяСтрока);
		 
		 // Заполним показатели
		ПарамРасчета = ЗависимыеОборотыВыполнитьРасчет(СтрокаНастройки, СтрокаТабличнойЧасти, НоваяСтрока, флВестиПротокол, Сценарий);
		Если флВестиПротокол Тогда
			НоваяСтрока.КомментарийРасчета = ЗависимыеОборотыКомментарийРасчета(ПарамРасчета);
		КонецЕсли; 
		 
		 Если ЗначениеЗаполнено(СтрокаНастройки.ПрофильРаспределения) Тогда
			 МассивСтрок = РаспределитьПоПрофилю(СтрокаНастройки.ПрофильРаспределения,ТаблицаПриемник,НоваяСтрока,Периодичность, флВестиПротокол);
			 Для каждого СозданнаяСтрока Из МассивСтрок Цикл
				 ПараметрыФормирования = бит_Бюджетирование.НовыеПараметрыФормированияЗависмыхОборотовПоСтроке();
				 ПараметрыФормирования.ДатаЗаполнения 			= ДатаЗаполнения;
				 ПараметрыФормирования.ТекущийОбъект 			= ТекущийОбъект;
				 ПараметрыФормирования.СтрокаТабличнойЧасти		= СозданнаяСтрока;
				 ПараметрыФормирования.ИмяТабличнойЧастиИсточник = ИмяТабличнойЧастиПриемник;
				 ПараметрыФормирования.ИмяТабличнойЧастиПриемник = ИмяТабличнойЧастиПриемник;
				 ПараметрыФормирования.ИзмеренияБюджетирования	= ИзмеренияБюджетирования;
				 ПараметрыФормирования.вхНастройкиЗависимых		= вхНастройкиЗависимых;
				 ПараметрыФормирования.УровеньРекурсии 			= УровеньРекурсии;
	
				 СформироватьЗависимыеОборотыПоСтроке(ПараметрыФормирования);
			 КонецЦикла; 
		 Иначе	
			 ПараметрыФормирования = бит_Бюджетирование.НовыеПараметрыФормированияЗависмыхОборотовПоСтроке();
			 ПараметрыФормирования.ДатаЗаполнения 			= ДатаЗаполнения;
			 ПараметрыФормирования.ТекущийОбъект 			= ТекущийОбъект;
			 ПараметрыФормирования.СтрокаТабличнойЧасти		= НоваяСтрока;
			 ПараметрыФормирования.ИмяТабличнойЧастиИсточник = ИмяТабличнойЧастиПриемник;
			 ПараметрыФормирования.ИмяТабличнойЧастиПриемник = ИмяТабличнойЧастиПриемник;
			 ПараметрыФормирования.ИзмеренияБюджетирования	= ИзмеренияБюджетирования;
			 ПараметрыФормирования.вхНастройкиЗависимых		= вхНастройкиЗависимых;
			 ПараметрыФормирования.УровеньРекурсии 			= УровеньРекурсии;
			 
			 СформироватьЗависимыеОборотыПоСтроке(ПараметрыФормирования);
		 КонецЕсли; 
	КонецЦикла; // По выборке структуры зависимых оборотов
	
КонецПроцедуры

// Процедура выполняе формирование зависимых оборотов по строке оборотов. 
// Сформированные зависимые обороты записываются в ТаблицуЗначений. Рекурсивный вызов.
// 
// Параметры:
//  ДатаЗаполнения  - Дата.
//  СтрокаТабличнойЧасти - СтрокаТаблицыЗначений.
//  ТаблицаПриемник - ТаблицаЗначений.
//  ИзмеренияБюджетирования   - Структура.
//  СтрПар - Структура.
//  УровеньРекурсии - Число.
// 
Процедура СформироватьЗависимыеОборотыВТаблицу(ДатаЗаполнения
											   ,СтрокаТабличнойЧасти
											   ,КолонкиИсточник
											   ,ТаблицаПриемник
											   ,ИзмеренияБюджетирования
											   ,СтрПар = Неопределено
											   ,УровеньРекурсии = 0) Экспорт

	// Защита от зацикливания
	Если УровеньРекурсии>1000 Тогда
		ТекстСообщения = НСтр("ru = 'Превышен уровень рекурсии. Проверьте настройки зависимых оборотов на зацикливание.'");
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения); 
		Возврат;
	КонецЕсли; 
	УровеньРекурсии = УровеньРекурсии+1;
	
	//BIT AMerkulov	02-01-2016 ++
	Если ТаблицаПриемник.Колонки.НАйти("НомерИсходный") = Неопределено Тогда
		ТаблицаПриемник.Колонки.Добавить("НомерИсходный");
	КонецЕсли;
	//BIT AMerkulov	02-01-2016 --	
	
	КолонкиПриемник = ТаблицаПриемник.Колонки;
	// Получаем имя справочника Сценарии бюджетирования в зависимости от текущего решения.
	ИмяСправочникаСценарии = бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования();
	
	Сценарий = Справочники[ИмяСправочникаСценарии].ПустаяСсылка();
	
	Если ТипЗнч(СтрПар) = Тип("Структура") И СтрПар.Свойство("Сценарий") Тогда
		
		Сценарий = СтрПар.Сценарий;
		
	Иначе	
		
		Если бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("Сценарий",КолонкиИсточник) Тогда
		
			Сценарий = СтрокаТабличнойЧасти.Сценарий;
		
		КонецЕсли; 
		
	КонецЕсли; 
	
	Если Не ЗначениеЗаполнено(Сценарий) Тогда
	
		Возврат;
	
	КонецЕсли;

	Периодичность = Сценарий.бит_Периодичность;
	
	// Получим структуру зависимых оборотов для данной строки таблицы оборотов.
	Результат = ВыполнитьЗапросДляФормированияЗависимыхОборотов(ДатаЗаполнения, Сценарий, ИзмеренияБюджетирования, СтрокаТабличнойЧасти);
	Если Результат.Пустой() Тогда
	
		Возврат;
	
	КонецЕсли; 
	
	НастройкиЗависимыхОборотов = Результат.Выгрузить();
	
	ПроверяемыеПоля = ПодготовитьПроверяемыеПоляЗавОборотов();	
	
	ТекущийПриоритет = 0;
	НастройкиЗависимыхОборотов.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));
	Для каждого СтрокаНастройки Из НастройкиЗависимыхОборотов Цикл
		
		ВычислитьПриоритетСтрокиЗависимыхОборотов(СтрокаТабличнойЧасти, СтрокаНастройки, ПроверяемыеПоля);
		
	КонецЦикла; 
	
	НастройкиЗависимыхОборотов.Сортировать("Приоритет УБЫВ");
	ТекущийПриоритет = 0;
	
	Если НастройкиЗависимыхОборотов.Количество() > 0 Тогда
	
		 ТекущийПриоритет = НастройкиЗависимыхОборотов[0].Приоритет;
	
	КонецЕсли; 
	
	
	// Заполним строки зависимых оборотов
	Для Каждого СтрокаНастройки Из НастройкиЗависимыхОборотов Цикл
		
		 // Применяем только строки наивысшего приоритета, например, если совпадает Статья и Проект, 
		 // то эта настройка имеет приоритет перед настройкой, когда совпадает только статья.		
	     Если НЕ СтрокаНастройки.Приоритет = ТекущийПриоритет Тогда
		 
		 	     Продолжить;
		 
		 КонецЕсли; 		
		
		 НоваяСтрока = ТаблицаПриемник.Добавить();
		 Если бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("Сценарий", КолонкиПриемник) Тогда
			 
			 НоваяСтрока.Сценарий = Сценарий;
			 
		 КонецЕсли;  
		 НоваяСтрока.Период = СтрокаТабличнойЧасти.Период;
		 НоваяСтрока.Валюта = СтрокаТабличнойЧасти.Валюта;
		 
		 //BIT AMerkulov	02-01-2016 ++
		 НоваяСтрока.НомерИсходный = СтрокаТабличнойЧасти.НомерСтроки;
		 //BIT AMerkulov	02-01-2016 --		 
		 
		 Если  бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("Измерение", КолонкиПриемник)
			  ИЛИ бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("Измерение", КолонкиИсточник) Тогда
		 
		 	НоваяСтрока.Измерение = СтрокаТабличнойЧасти.Измерение;
		 
		 КонецЕсли; 
		 Если  бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("ИД", КолонкиПриемник)
			  ИЛИ бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("ИД", КолонкиИсточник) Тогда
		 
		 	НоваяСтрока.ИД = СтрокаТабличнойЧасти.ИД;
		 
		 КонецЕсли; 
		 Если бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("ИД_Родитель", КолонкиПриемник) 
			   ИЛИ бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("ИД", КолонкиИсточник) Тогда
		 
		 	НоваяСтрока.ИД_Родитель = СтрокаТабличнойЧасти.ИД;
		 
		 КонецЕсли; 
		 
		 // Заполним измерения
		 ЗависимыеОборотыЗаполнитьИзмерения(ИзмеренияБюджетирования, СтрокаНастройки, СтрокаТабличнойЧасти, НоваяСтрока);
		 
		 Если бит_ОбщегоНазначенияКлиентСервер.ЕстьКолонка("ЭтоКоэффициент", КолонкиПриемник)  Тогда
		 
		 	НоваяСтрока.ЭтоКоэффициент = НоваяСтрока.СтатьяОборотов.ЭтоКоэффициент;
		 
		 КонецЕсли; 
		 
		 
		 // Заполним показатели
		 ЗависимыеОборотыВыполнитьРасчет(СтрокаНастройки, СтрокаТабличнойЧасти, НоваяСтрока);
		 
		 Если ЗначениеЗаполнено(СтрокаНастройки.ПрофильРаспределения) Тогда
		 	МассивСтрок = РаспределитьПоПрофилю(СтрокаНастройки.ПрофильРаспределения,ТаблицаПриемник,НоваяСтрока,Периодичность);
		 	Для каждого СозданнаяСтрока Из МассивСтрок Цикл
		    	 
		    	 СформироватьЗависимыеОборотыВТаблицу(ДатаЗаполнения
		    										  ,СозданнаяСтрока
													  ,КолонкиИсточник
		    										  ,ТаблицаПриемник
		    										  ,ИзмеренияБюджетирования
													  ,СтрПар
		    										  ,УровеньРекурсии);
		    	 
		 	КонецЦикла; 
		 Иначе	
		 	
		 	СформироватьЗависимыеОборотыВТаблицу(ДатаЗаполнения
		    									  ,НоваяСтрока
												  ,КолонкиИсточник
		    									  ,ТаблицаПриемник
		    									  ,ИзмеренияБюджетирования
												  ,СтрПар
		    									  ,УровеньРекурсии);
		 	
		 КонецЕсли; 
		 
	КонецЦикла; // По выборке структуры зависимых оборотов
	
КонецПроцедуры

// Процедура формирует зависимые обороты по набору записей регистра бит_ОборотыПоБюджетам.
// 
Процедура СформироватьЗависимыеОборотыПоНаборуЗаписей(ДокументОбъект, НаборОбороты) Экспорт

	ТаблицаИсточник = НаборОбороты.Выгрузить();
	Если ТаблицаИсточник.Количество() = 0 Тогда
	     Возврат;
	КонецЕсли; 
	
	ТаблицаПриемник = ТаблицаИсточник.СкопироватьКолонки();
	ТаблицаПриемник.Колонки.Добавить("ЭтоКоэффициент", Новый ОписаниеТипов("Булево"));
	
	ИзмеренияБюджетирования = ПолучитьИзмеренияБюджетирования("все","имя");
	
	// Формируем зависимые обороты в ТаблицуПриемник.
	Для каждого СтрокаТаблицы Из ТаблицаИсточник Цикл
	
		СформироватьЗависимыеОборотыВТаблицу(СтрокаТаблицы.Период
		                                                          ,СтрокаТаблицы
																  ,ТаблицаИсточник.Колонки
																  ,ТаблицаПриемник
																  ,ИзмеренияБюджетирования);
	
	КонецЦикла; 
	
	Если ТаблицаПриемник.Количество() > 0 Тогда
		
		// Из-за разнородности валют в наборе, барать валюту из первой строки не корректно.
		// Отсортируем таблицу по валютам.
		
		ВремТЗ = ТаблицаПриемник.Скопировать();
		ВремТЗ.Свернуть("Валюта");
		Валюты = ВремТЗ.ВыгрузитьКолонку("Валюта");
		
		Для каждого Валюта Из Валюты Цикл
			ТекТаблицаПриемник = ТаблицаПриемник.Скопировать(Новый Структура("Валюта", Валюта));
			
			// Выполним валютные пересчеты в ТаблицеПриемник.
			ПерваяСтрока    = ТекТаблицаПриемник[0];
			Сценарий        = ПерваяСтрока.Сценарий;
			ВалютаДокумента = ПерваяСтрока.Валюта;
			
			ДокМодель 			= Документы.бит_БюджетнаяОперация.СоздатьДокумент();
			ДокМодель.Сценарий  = Сценарий;
			ДокМодель.Дата      = ПерваяСтрока.Период;
			СтруктураКурсыВалют = ПолучитьСтруктуруКурсовВалютСценария(ДокМодель, 
												ПерваяСтрока.Период, Новый Структура("Регл, Упр, Сценарий"));
			
			СтрКурсаДок = бит_КурсыВалют.ПолучитьКурсВалюты(ВалютаДокумента, ПерваяСтрока.Период);		 
			СтруктураКурсыВалют.Вставить("Документ",СтрКурсаДок);
			
			КурсыПоПериодам = Неопределено;
			Если Сценарий.ИспользоватьКурсыСценария Тогда
				
				// Получим таблицу периодов
				ТаблицаПериодов = ТекТаблицаПриемник.Скопировать(, "Период");
				ТаблицаПериодов.Свернуть("Период");
				
				// Установим настройки для получения курсов по периодам.
				СтруктураПараметров = ЗаполнитьСтруктуруПараметровПолученияКурсовПоПериодам(Сценарий,ВалютаДокумента);
				
				// Получим курсы по периодам
				КурсыПоПериодам = бит_КурсыВалют.ПолучитьКурсыВалютПоПериодам(ТаблицаПериодов,Сценарий,СтруктураПараметров);
				
			КонецЕсли; 
			
			ВыполнитьПересчетыВТаблицеОборотов(ТекТаблицаПриемник,КурсыПоПериодам,СтруктураКурсыВалют);
			
			// Заполним полученные записи по зависимым оборотам в набор оборотов.
			Для каждого СтрокаТаблицы Из ТекТаблицаПриемник Цикл
				
				//BIT 17-02-2016 ++
				//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2020-10-26 (#ПроектИнтеграцияАксапта12)
				//Если  ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.ПоступлениеТоваровУслуг") ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") Тогда
				Если  ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.ПоступлениеТоваровУслуг") 
					ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты")
					ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты12") Тогда
				//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2020-10-26 (#ПроектИнтеграцияАксапта12)
					Если ДокументОбъект.Движения.битСтатьиОборотовПоЗависимымОборотам.выгрузить().НайтиСтроки(Новый СТруктура("НомерСтрокиИсходный",СтрокаТаблицы.НомерИсходный)).Количество() Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				//BIT 17-02-2016  --
				
				НоваяЗапись = НаборОбороты.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаТаблицы);
				
				//BIT AMerkulov	02-01-2016 ++
				// БИТ_YK_н 01/16
				//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2020-10-26 (#ПроектИнтеграцияАксапта12)
				//Если  ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.ПоступлениеТоваровУслуг") ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") И СтрокаТаблицы.СтатьяОборотов.ТипСтатьи = Перечисления.бит_ТипыСтатейОборотов.БДДС  Тогда
				Если  ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.ПоступлениеТоваровУслуг") 
					ИЛИ (ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") 
						ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты12"))
					И СтрокаТаблицы.СтатьяОборотов.ТипСтатьи = Перечисления.бит_ТипыСтатейОборотов.БДДС  Тогда
				//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2020-10-26 (#ПроектИнтеграцияАксапта12)
					// БИТ_YK_к
					СтрокаСвязи = ДокументОбъект.Движения.битСтатьиОборотовПоЗависимымОборотам.Добавить();
					СтрокаСвязи.ПоступлениеТоваровУслуг = ДокументОбъект.Ссылка;
					СтрокаСвязи.НомерСтрокиИсходный 	 = СтрокаТаблицы.НомерИсходный;
					СтрокаСвязи.СтатьяОборотовБДР 		 = НаборОбороты[СтрокаСвязи.НомерСтрокиИсходный-1].СтатьяОборотов;
					СтрокаСвязи.СтатьяОборотовБДДС 	 = СтрокаТаблицы.СтатьяОборотов;
					СтрокаСвязи.НомерСтрокиБДДС 		 = НаборОбороты.Количество();
				КонецЕсли;
				//BIT AMerkulov	02-01-2016 --
				
			КонецЦикла; 
		КонецЦикла;
		
		//BIT AMerkulov	02-01-2016 ++
		// БИТ_YK_н 01/16
		//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2020-10-26 (#ПроектИнтеграцияАксапта12)
		//Если  ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.ПоступлениеТоваровУслуг") ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") Тогда
		Если  ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.ПоступлениеТоваровУслуг") 
			ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") 
			ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты12") 
			Тогда
		//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2020-10-26 (#ПроектИнтеграцияАксапта12)
			// БИТ_YK_н 01/16
			ДокументОбъект.Движения.битСтатьиОборотовПоЗависимымОборотам.Записать();
		КонецЕсли;
		//BIT AMerkulov	02-01-2016 --
		
		НаборОбороты.УстановитьАктивность(НаборОбороты[0].Активность);
	КонецЕсли; 

КонецПроцедуры

// Функция выполняет распределение по профилю распределения.
// 
// Параметры:
//  ПрофильРаспределения  - СправочникСсылка.бит_ПрофилиРаспределения.
//  ТаблицаОбороты        - ТабличнаяЧасть,ТаблицаЗначений.
//  СтрокаИсточник        - СтрокаТабличнойЧасти,СтрокаТаблицыЗначений.
//  Периодичность         - ПеречислениеСсылка.бит_ПериодичностьПланирования.
// 	КомментироватьРасчет  - Булево.
// 
// Возвращаемое значение:
//   МассивСтрок   - Массив.
// 
Функция РаспределитьПоПрофилю(ПрофильРаспределения,ТаблицаОбороты,СтрокаИсточник,Периодичность, КомментироватьРасчет = Ложь) Экспорт

	МассивСтрок = Новый Массив;

	Если ПрофильРаспределения.Профиль.Количество()=0 Тогда
	
		МассивСтрок.Добавить(СтрокаИсточник);
		Возврат МассивСтрок;
	
	КонецЕсли;
	
	Итоги = Новый Структура("Сумма,Количество",0,0,0);
	
	Для каждого СтрокаПрофиля Из ПрофильРаспределения.Профиль Цикл
	
		НоваяСтрока = ТаблицаОбороты.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаИсточник);
		
		НоваяСтрока.Период = ПолучитьПериодПоСдвигу(СтрокаИсточник.Период,СтрокаПрофиля.НомерПериода,Периодичность);
		
		НоваяСтрока.Количество = СтрокаИсточник.Количество*СтрокаПрофиля.Процент/100;
		НоваяСтрока.Сумма      = СтрокаИсточник.Сумма*СтрокаПрофиля.Процент/100;
		
		Если КомментироватьРасчет Тогда
			НоваяСтрока.КомментарийРасчета = СтрЗаменить(НоваяСтрока.КомментарийРасчета, "%ПрофильРаспределения%", Строка(СтрокаПрофиля.Процент)+"%");
			НоваяСтрока.КомментарийРасчета = СтрЗаменить(НоваяСтрока.КомментарийРасчета, "%РезультатСумма%"		, Формат(НоваяСтрока.Сумма,"ЧЦ=15; ЧДЦ=2"));
			НоваяСтрока.КомментарийРасчета = СтрЗаменить(НоваяСтрока.КомментарийРасчета, "%РезультатКоличество%", Формат(НоваяСтрока.Количество,"ЧЦ=15; ЧДЦ=3"));
		КонецЕсли;
		
		МассивСтрок.Добавить(НоваяСтрока);
		
		// Соберем итоговые суммы
		Для каждого КлючИЗначение Из Итоги Цикл
		
			Итоги[КлючИЗначение.Ключ] = КлючИЗначение.Значение+НоваяСтрока[КлючИЗначение.Ключ];
		
		КонецЦикла; 
		
	КонецЦикла; 
	
	// Проверим распределение, при необходимости скорректируем суммы.
	Для каждого КлючИЗначение Из Итоги Цикл
		
		Разность = СтрокаИсточник[КлючИЗначение.Ключ] - КлючИЗначение.Значение;
		Если Разность<>0 Тогда
		
			НоваяСтрока[КлючИЗначение.Ключ] = НоваяСтрока[КлючИЗначение.Ключ]+Разность;
		
		КонецЕсли; 
		
	КонецЦикла; 
	
	ТаблицаОбороты.Удалить(СтрокаИсточник);
	
	Возврат МассивСтрок;
	
КонецФункции

// Функция распределения по настройкам, полученным из  обработки бит_РаспределениеБюджетныхДанныхПоПрофилю.
//
// Параметры:
//  НастройкиРаспределения - Структура.
//  ТаблицаОбороты         - ДанныеФормыКоллекция.
//  СтрокаИсточник         - ДанныеФормыЭлементКоллекции.
//  МассивРесурсов		   - Массив.
//
// Возвращаемое значение:
//  Массив.
//
Функция РаспределитьПоПрофилюАналитики(НастройкиРаспределения, ТаблицаОбороты, СтрокаИсточник, МассивРесурсов = Неопределено) Экспорт
	
	МассивСтрок = Новый Массив;
	
	Если НастройкиРаспределения.БазаРаспределения.Количество() = 0 Тогда  		
		Возврат МассивСтрок;  		
	КонецЕсли;
	
	Если МассивРесурсов = Неопределено Тогда
		МассивРесурсов = Новый Массив;	
		МассивРесурсов.Добавить("Сумма");
		МассивРесурсов.Добавить("Количество");
	КонецЕсли;
	
	Итоги = Новый Структура;
	Для каждого ИмяРесурса Из МассивРесурсов Цикл
	 	Итоги.Вставить(ИмяРесурса, 0);	
	КонецЦикла;
	
	Для каждого СтрокаПрофиля Из НастройкиРаспределения.БазаРаспределения Цикл
		
		НоваяСтрока = ТаблицаОбороты.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточник);
		
		Если НастройкиРаспределения.Вид = Перечисления.бит_ВидыПрофилейРаспределения.ПоАналитике Тогда
			НоваяСтрока[НастройкиРаспределения.ИмяКолонки] = СтрокаПрофиля.ЗначениеАналитики;
		Иначе	
			НоваяСтрока.Период = ПолучитьПериодПоСдвигу(СтрокаИсточник.Период,СтрокаПрофиля.НомерПериода,НастройкиРаспределения.Периодичность);
		КонецЕсли; 
		
		Для каждого ИмяРесурса Из МассивРесурсов Цикл
		 	НоваяСтрока[ИмяРесурса] = (СтрокаИсточник[ИмяРесурса] * СтрокаПрофиля.Процент) / 100;
		КонецЦикла;
		
		МассивСтрок.Добавить(НоваяСтрока);
		
		// Соберем итоговые суммы
		Для каждого КлючИЗначение Из Итоги Цикл			
			Итоги[КлючИЗначение.Ключ] = КлючИЗначение.Значение + НоваяСтрока[КлючИЗначение.Ключ]; 			
		КонецЦикла;            		
		
	КонецЦикла;  // по профилю распределения
	
	// Проверим распределение, при необходимости скорректируем суммы.
	Для каждого КлючИЗначение Из Итоги Цикл
		
		Разность = СтрокаИсточник[КлючИЗначение.Ключ] - КлючИЗначение.Значение;
		Если Разность <> 0 Тогда			
			НоваяСтрока[КлючИЗначение.Ключ] = НоваяСтрока[КлючИЗначение.Ключ] + Разность;			
		КонецЕсли; 
		
	КонецЦикла;		
	
	// Удаление исходной строки
	Если НастройкиРаспределения.УдалятьИсходныеДанные Тогда		
		ТаблицаОбороты.Удалить(СтрокаИсточник);	 		
	КонецЕсли; 
	
	Возврат МассивСтрок;
	
КонецФункции

// Функция возвращает массив объектов соответствующих значению 
// из регистра сведений "бит_ЦФО_Подразделения".
// 
// Параметры:
//  ЦФО_Подразделение - СправочникСсылка[бит_ЦФО/Организации/ПодразделенияОрганизаций].
// 
// Возвращаемое значение:
//  МассивОбъектов - Массив.
// 
Функция СвязанныеЦФОИПодразделения(ЦФО_Подразделение) Экспорт
	
	// Бывш. "ПолучитьСоответствиеДляЦФО_Подразделения".
	
    МассивОбъектов = Новый Массив;
	
    Если Не ЗначениеЗаполнено(ЦФО_Подразделение) Тогда
        Возврат МассивОбъектов;
    КонецЕсли;
	
	// Получаем имя типа ЦФО в зависимости от текущего решения.
	ИмяТипаЦФО = бит_ОбщегоНазначения.ПолучитьИмяТипаЦФО();
	
    // Получаем имена измерений:
    // 1) имя измерения для отбора. 
    // 2) имя измерения с объектами.
    Если ТипЗнч(ЦФО_Подразделение) = Тип(ИмяТипаЦФО) Тогда
        ИмяИзмеренияДляОтбора = "ЦФО";
        ИмяИзмеренияОбъектов  = "Подразделение";
    Иначе
        ИмяИзмеренияДляОтбора = "Подразделение";
        ИмяИзмеренияОбъектов  = "ЦФО";
    КонецЕсли;
    
    Запрос = Новый Запрос;
    Запрос.УстановитьПараметр("ЦФО_Подразделение", ЦФО_Подразделение);
    
    Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
        |    бит_ЦФО_Подразделения." + ИмяИзмеренияОбъектов + " КАК Объект
        |ИЗ
        |    РегистрСведений.бит_ЦФО_Подразделения КАК бит_ЦФО_Подразделения
        |ГДЕ
        |    бит_ЦФО_Подразделения." + ИмяИзмеренияДляОтбора + " = &ЦФО_Подразделение";
        
    РезультатЗапроса = Запрос.Выполнить();
    
    Если Не РезультатЗапроса.Пустой() Тогда
        
        ВыборкаЗапроса = РезультатЗапроса.Выбрать();
        Пока ВыборкаЗапроса.Следующий() Цикл
            МассивОбъектов.Добавить(ВыборкаЗапроса.Объект);
        КонецЦикла;
        
    КонецЕсли;
        
    Возврат МассивОбъектов;
    
КонецФункции

// Функция возвращает массив объектов соответствующих значению 
// из регистра сведений "бит_СтатьиОборотов_СтатьиРегл".
// 
// Параметры:
//  СтатьяОборотов - СправочникСсылка[бит_СтатьиОборотов/ПрочиеДоходыИРасходы/
//                                    СтатьиЗатрат/СтатьиДвиженияДенежныхСредств] - Статьи.
//  СтрокаТребуемыйТип - Строка - Строка требуемого типа.
// 
// Возвращаемое значение:
//  МассивОбъектов - Массив.
// 
Функция СвязанныеСтатьиОборотовИСтатьиРегл(СтатьяОборотов, СтрокаТребуемыйТип = Неопределено) Экспорт
	
	// Бывш. "ПолучитьСоответствиеСтатьиОборотовИСтатьиРегл".
    МассивОбъектов = Новый Массив;
    
    Если Не ЗначениеЗаполнено(СтатьяОборотов) Тогда
        Возврат МассивОбъектов;
    КонецЕсли;
    
    // Получаем имена измерений:
    // 1) имя измерения для отбора. 
    // 2) имя измерения с объектами.
    Если ТипЗнч(СтатьяОборотов) = Тип("СправочникСсылка.бит_СтатьиОборотов") Тогда
        ИмяИзмеренияДляОтбора = "СтатьяОборотов";
        ИмяИзмеренияОбъектов  = "СтатьяРегл";
    Иначе
        ИмяИзмеренияДляОтбора = "СтатьяРегл";
        ИмяИзмеренияОбъектов  = "СтатьяОборотов";
    КонецЕсли;
    
    Запрос = Новый Запрос;
    Запрос.УстановитьПараметр("СтатьяОборотов", СтатьяОборотов);
    
    Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
        |    бит_СтатьиОборотов_СтатьиРегл." + ИмяИзмеренияОбъектов + " КАК Объект
        |ИЗ
        |    РегистрСведений.бит_СтатьиОборотов_СтатьиРегл КАК бит_СтатьиОборотов_СтатьиРегл
        |ГДЕ
        |    бит_СтатьиОборотов_СтатьиРегл." + ИмяИзмеренияДляОтбора + " = &СтатьяОборотов";
        
    РезультатЗапроса = Запрос.Выполнить();
    
    Если Не РезультатЗапроса.Пустой() Тогда
        
        ВыборкаЗапроса = РезультатЗапроса.Выбрать();
		Пока ВыборкаЗапроса.Следующий() Цикл
			Если СтрокаТребуемыйТип = Неопределено 
				ИЛИ ТипЗнч(ВыборкаЗапроса.Объект) = Тип(СтрокаТребуемыйТип) Тогда
				 МассивОбъектов.Добавить(ВыборкаЗапроса.Объект);
			КонецЕсли;             
        КонецЦикла;
        
    КонецЕсли;
        
    Возврат МассивОбъектов;
    
КонецФункции

// Функция возвращает массив объектов соответствующих значению 
// из регистра сведений "бит_СтатьиОборотов_НоменклатурныеГруппы".
// 
// Параметры:
//  Источник - СправочникСсылка.бит_СтатьиОборотов или СправочникСсылка.НоменклатурныеГруппы.
// 
// Возвращаемое значение:
//  МассивОбъектов - Массив.
// 
Функция СвязанныеСтатьиОборотовИНоменклатурныеГруппы(Источник) Экспорт
	
	// Бывш. "ПолучитьСоответствиеСтатьиОборотовНомГруппы(Источник)".
	
    МассивОбъектов = Новый Массив;
    
    Если Не ЗначениеЗаполнено(Источник) Тогда
        Возврат МассивОбъектов;
    КонецЕсли;
    
    // Получаем имена измерений:
    // 1) имя измерения для отбора. 
    // 2) имя измерения с объектами.
    Если ТипЗнч(Источник) = Тип("СправочникСсылка.бит_СтатьиОборотов") Тогда
        ИмяИзмеренияДляОтбора = "СтатьяОборотов";
        ИмяИзмеренияОбъектов  = "НоменклатурнаяГруппа";
    Иначе
        ИмяИзмеренияДляОтбора = "НоменклатурнаяГруппа";
        ИмяИзмеренияОбъектов  = "СтатьяОборотов";
    КонецЕсли;
    
    Запрос = Новый Запрос;
    Запрос.УстановитьПараметр("Источник", Источник);
    
    Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
    |    бит_СтатьиОборотов_НомГруппы." + ИмяИзмеренияОбъектов + " КАК Объект
    |ИЗ
    |    РегистрСведений.бит_СтатьиОборотов_НоменклатурныеГруппы КАК бит_СтатьиОборотов_НомГруппы
    |ГДЕ
    |    бит_СтатьиОборотов_НомГруппы." + ИмяИзмеренияДляОтбора + " = &Источник
	|";
        
    РезультатЗапроса = Запрос.Выполнить();
    
    Если Не РезультатЗапроса.Пустой() Тогда
        
        ВыборкаЗапроса = РезультатЗапроса.Выбрать();
        Пока ВыборкаЗапроса.Следующий() Цикл
            МассивОбъектов.Добавить(ВыборкаЗапроса.Объект);
        КонецЦикла;
        
    КонецЕсли;
        
    Возврат МассивОбъектов;
    
КонецФункции

// Процедура проверяет на уникальность соспоставленные значения
// объектам в наборе записей регистра сведений (соспоставленное значение может быть сопоставлено одному объекту).
// 
// Параметры:
//  НаборЗаписейРегистра - НаборЗаписейРегистраСведений.
//  СтруктураИзмерений   - Структура, (Ключи: ИмяРегистра, ИмяИзмерения_Объект, ИмяИзмерения_Значения).
// 
//  Отказ - Булево, флаг отказа записи набора записей.
// 
Процедура ПроверитьУникальностьСопоставленныхЗначений_ОбъектамВНабореЗаписей(НаборЗаписейРегистра, СтруктураИзмерений, Отказ) Экспорт
    
    // Если набор записей не пуст, тогда
    Если НаборЗаписейРегистра.Количество() <> 0 Тогда
        
        ТаблицаДляПроверки = НаборЗаписейРегистра.Выгрузить();
        
        // Получаем значения для проверки.
        ИмяРегистраДляПроверки = СтруктураИзмерений["ИмяРегистра"];
        ИмяИзмерения_Объект    = СтруктураИзмерений["ИмяИзмерения_Объект"];
        ИмяИзмерения_Значения  = СтруктураИзмерений["ИмяИзмерения_Значения"];
        
        Запрос = Новый Запрос;
        Запрос.УстановитьПараметр("ТаблицаДляПроверки", НаборЗаписейРегистра.Выгрузить());
        
        Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
            |    ТаблицаДляПроверки." + ИмяИзмерения_Значения + " КАК Значение
            |ПОМЕСТИТЬ ТаблицаДляПроверки
            |ИЗ
            |    &ТаблицаДляПроверки КАК ТаблицаДляПроверки
            |;
            |
            |////////////////////////////////////////////////////////////////////////////////
            |ВЫБРАТЬ
            |    РегистрДляПроверки." + ИмяИзмерения_Объект + " КАК Объект,
            |    РегистрДляПроверки." + ИмяИзмерения_Значения + " КАК Значение
            |ИЗ
            |    РегистрСведений." + ИмяРегистраДляПроверки + " КАК РегистрДляПроверки
            |ГДЕ
            |    РегистрДляПроверки." + ИмяИзмерения_Значения + " В
            |            (ВЫБРАТЬ
            |                ТаблицаДляПроверки.Значение
            |            ИЗ
            |                ТаблицаДляПроверки КАК ТаблицаДляПроверки)
            |;
            |
            |////////////////////////////////////////////////////////////////////////////////
            |УНИЧТОЖИТЬ ТаблицаДляПроверки";
        
        РезультатЗапроса = Запрос.Выполнить();
        Если Не РезультатЗапроса.Пустой() Тогда
            ВыборкаЗапроса = РезультатЗапроса.Выбрать();
            Пока ВыборкаЗапроса.Следующий()Цикл
                
                ТекОбъект   = ВыборкаЗапроса.Объект;
                ТекЗначение = ВыборкаЗапроса.Значение;
                
                СинонимОбъекта  = ТекОбъект.Метаданные().Синоним;
                СинонимЗначения = ТекЗначение.Метаданные().Синоним;
                ТекстСообщения  = СтрШаблон(НСтр("ru = 'Значение ""%1"": элемент <%2> уже сопоставлено объекту ""%3"": элемент <%4>.'"),
									СинонимЗначения, ТекЗначение, СинонимОбъекта, ТекОбъект);
				ОбщегоНазначения.СообщитьПользователю(ТекстСообщения, , , ,Отказ); 					
            КонецЦикла;
        КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Процедура проверяет на уникальность массив соспоставленных значений
// объектам в наборе записей регистра сведений (соспоставленное значение может быть сопоставлено одному объекту).
// 
// Параметры:
//  НаборЗаписейРегистра - НаборЗаписейРегистраСведений.
//  СтруктураИзмерений   - Структура, (Ключи: ИмяРегистра, ИмяИзмерения_Объект, ИмяИзмерения_Значения).
// 
//  Отказ - Булево, флаг отказа записи набора записей.
// 
Процедура ПроверитьУникальностьСопоставленногоМассиваЗначений_ОбъектамВНабореЗаписей(НаборЗаписейРегистра, СтруктураИзмерений, Отказ) Экспорт
    
    // Если набор записей не пуст, тогда
    Если НаборЗаписейРегистра.Количество() <> 0 Тогда
        
        ТаблицаДляПроверки = НаборЗаписейРегистра.Выгрузить();
        
        // Получаем значения для проверки.
        ИмяРегистраДляПроверки = СтруктураИзмерений["ИмяРегистра"];
        ИмяИзмерения_Объект    = СтруктураИзмерений["ИмяИзмерения_Объект"];
        ИмяИзмерения_Значения  = СтруктураИзмерений["ИмяИзмерения_Значения"];
		
		Если ТипЗнч(ИмяИзмерения_Значения) = Тип("Массив") Тогда
			МассивПолей = ИмяИзмерения_Значения;
		Иначе
			МассивПолей = Новый Массив;
			МассивПолей.Добавить(ИмяИзмерения_Значения);
		КонецЕсли;
		
		ТекстПоляТаб = "";
		ТекстПоляРег = "";
		ТекстУсловияНач = "";
		ТекстУсловияКон = "";
		НомПоля = 0;
		Для Каждого ТекПоле Из ИмяИзмерения_Значения Цикл
			
			НомПоля = НомПоля + 1;
			
			ТекстПоляТаб = ТекстПоляТаб + ?(ПустаяСтрока(ТекстПоляТаб), "", ","+Символы.ПС);
			ТекстПоляТаб = ТекстПоляТаб + "    ТаблицаДляПроверки." + ТекПоле + " КАК Значение"+НомПоля;
			
			ТекстПоляРег = ТекстПоляРег + ?(ПустаяСтрока(ТекстПоляРег), "", ","+Символы.ПС);
			ТекстПоляРег = ТекстПоляРег + "    РегистрДляПроверки." + ТекПоле + " КАК Значение"+НомПоля;
			
			ТекстУсловияНач = ТекстУсловияНач + ?(ПустаяСтрока(ТекстУсловияНач), "", ", ");
			ТекстУсловияНач = ТекстУсловияНач + "РегистрДляПроверки."+ТекПоле;
			
			ТекстУсловияКон = ТекстУсловияКон + ?(ПустаяСтрока(ТекстУсловияКон), "", ", ");
			ТекстУсловияКон = ТекстУсловияКон + "ТаблицаДляПроверки.Значение"+НомПоля;
			
		КонецЦикла;
		
        Запрос = Новый Запрос;
        Запрос.УстановитьПараметр("ТаблицаДляПроверки", НаборЗаписейРегистра.Выгрузить());
        
        Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
            |    "+ТекстПоляТаб+"
            |ПОМЕСТИТЬ ТаблицаДляПроверки
            |ИЗ
            |    &ТаблицаДляПроверки КАК ТаблицаДляПроверки
            |;
            |
            |////////////////////////////////////////////////////////////////////////////////
            |ВЫБРАТЬ
            |    РегистрДляПроверки." + ИмяИзмерения_Объект + " КАК Объект,
            |    "+ТекстПоляРег+"
            |ИЗ
            |    РегистрСведений." + ИмяРегистраДляПроверки + " КАК РегистрДляПроверки
            |ГДЕ
            |    ("+ТекстУсловияНач+") В 
            |            (ВЫБРАТЬ
            |                "+ТекстУсловияКон+"
            |            ИЗ
            |                ТаблицаДляПроверки КАК ТаблицаДляПроверки)
            |;
            |
            |////////////////////////////////////////////////////////////////////////////////
            |УНИЧТОЖИТЬ ТаблицаДляПроверки";
        
        РезультатЗапроса = Запрос.Выполнить();
        Если Не РезультатЗапроса.Пустой() Тогда
            
            Отказ = Истина;
            
            ВыборкаЗапроса = РезультатЗапроса.Выбрать();
            Пока ВыборкаЗапроса.Следующий()Цикл
				
				ТекОбъект   = ВыборкаЗапроса.Объект;
				СинонимОбъекта  = ТекОбъект.Метаданные().Синоним;
				
				Структура = Новый Соответствие;
				
				ТекстСообщенияНач = НСтр("ru='Набор значений:'") + " ";
				ТекстСообщения = "";
				
				Для Ном = 1 По НомПоля Цикл 
					ТекЗначение = ВыборкаЗапроса["Значение"+Ном];
					СинонимТекЗначения = ТекЗначение.Метаданные().Синоним;
					
					ТекстСообщения = ТекстСообщения + ?(ПустаяСтрока(ТекстСообщения), "", " и ");
					ТекстСообщения = ТекстСообщения + СтрШаблон(НСтр("ru='значение ""%1"" - <%2>'"), СинонимТекЗначения, ТекЗначение);
				КонецЦикла;
				
				ТекстСообщения = ТекстСообщенияНач + ТекстСообщения + " "
							   + СтрШаблон(НСтр("ru='уже сопоставлено объекту ""%1"": элемент <%2>.'"), СинонимОбъекта, ТекОбъект);
				ОбщегоНазначения.СообщитьПользователю(ТекстСообщения); 
            КонецЦикла;
        КонецЕсли;
    КонецЕсли;

КонецПроцедуры

// Функция проверяет наличие механизма балансового учета для бюджетирования.
// 
// Параметры:
//  СообщатьОбОтсутствии - Булево, сообщать пользователю об отсутствии
//                         механизма балансового учета, по умолчанию Ложь.
// 
// Возвращаемое значение:
//   ЕстьМеханизм - Булево.
// 
Функция ЕстьМеханизмБалансовогоУчета(СообщатьОбОтсутствии = Ложь) Экспорт
	
	// Получим доступность функционала ПРОФ.
	ФункционалПРОФДоступен =  бит_ЛицензированиеБФCервер.СборкаДоступна("ПРОФ");
	
	ЕстьМеханизм = ?(ФункционалПРОФДоступен, Истина, Ложь);

    Если СообщатьОбОтсутствии 
        И Не ЕстьМеханизм Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Механизм балансового учета в данной версии не доступен.'")); 
    КонецЕсли;
    
	Возврат ЕстьМеханизм;
    
КонецФункции

// Процедура формирует проводки по регистру бухгалтерии бюджетирование.
// 
// Параметры:
//  ТаблицаДанные              - ТаблицаЗначений - Таблица по которой формируются движения 
// 												   по регистру бит_ОборотыПоБюджетам.
//  НаборЗаписейБюджетирование - РегистрБухгалтерииНаборЗаписей.бит_Бюджетирование.
//  ОчищатьНаборЗаписей		   - Булево (По умолчанию = Истина).
//  ДатаСторно                 - Дата (По умолчанию = Неопределено).
// 
Процедура СформироватьПроводкиБюджетирования(ТаблицаДанные, НаборЗаписейБюджетирование, ОчищатьНаборЗаписей = Истина, ДатаСторно = Неопределено) Экспорт
	
	бит_БюджетированиеБалансовыйУчет.СформироватьПроводкиБюджетирования(ТаблицаДанные
                                                    , НаборЗаписейБюджетирование
                                                    , ОчищатьНаборЗаписей
                                                    , ДатаСторно);
	
КонецПроцедуры

// Функция получает периодичность сценария. Если значение периодичности не удалось 
// определить возвращается периодичность МЕСЯЦ.
// 
// Параметры:
//  Сценарий  - СправочникСсылка.СценарииПланирования.
// 
// Возвращаемое значение:
//   Периодичность   - СправочникСсылка.бит_ПериодичностьПланирования.
// 
Функция ПолучитьПериодичностьСценария(Сценарий) Экспорт
	
	Периодичность = Сценарий.бит_Периодичность;
	Если НЕ ЗначениеЗаполнено(Периодичность) Тогда
		Периодичность = Перечисления.бит_ПериодичностьПланирования.Месяц;
	КонецЕсли; 
	
	Возврат Периодичность;
	
КонецФункции

// Функция получает настройку видимости колонок по массиву статей оборотов. 
// Если аналитика, соответствующая колонке, используется хотя бы в одной статье колонка должна быть видима.
// Также анализируются назначенные доп. измерения - если измерение не назначено колонка не выводится.
// 
// Параметры:
//  МассивСтатей  		  - Массив.
//  НастройкиИзмерений 	  - Соответствие (По умолчанию = Неопределено).
// 
// Возвращаемое значение:
//   НастройкаВидимости   - Структура - Ключ:ИмяКолонки; Значение:Видимость.
// 
Функция ПолучитьНастройкуВидимостиКолонок(МассивСтатей, НастройкиИзмерений = Неопределено)  Экспорт
    	
	Если НастройкиИзмерений = Неопределено Тогда 		
		НастройкиИзмерений = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_НастройкиДополнительныхИзмерений");		
	КонецЕсли;
	
	Если МассивСтатей.Найти(Справочники.бит_СтатьиОборотов.ПустаяСсылка()) <> Неопределено Тогда
		МассивСтатей = Новый Массив;
		МассивСтатей.Добавить(Справочники.бит_СтатьиОборотов.ПустаяСсылка());	
	КонецЕсли;
	
   	НастройкаВидимости = Новый Структура;
	
	ТекстПолей_1 = "";
	ТекстПолей_2 = "";
	Для каждого РеквизитУчет Из бит_РаботаСДиалогамиСервер.СформироватьМассивРеквизитовСтатей() Цикл
	 	ТекстПолей_1 = ТекстПолей_1 
						+ "	ЕСТЬNULL(ВидимостьКолонок.Учет_" + РеквизитУчет + ", ИСТИНА) КАК " + РеквизитУчет + "," + Символы.ПС;	
		ТекстПолей_2 = ?(ТекстПолей_2 = "", "", ТекстПолей_2 + "," + Символы.ПС) 
						+ " МАКСИМУМ(бит_СтатьиОборотов.Учет_" + РеквизитУчет + ") КАК Учет_" + РеквизитУчет;	
	КонецЦикла;
	
	Запрос = Новый Запрос;
  	Запрос.УстановитьПараметр("МассивСтатей", МассивСтатей);				     
  	Запрос.Текст = "
	|ВЫБРАТЬ
	|" + ТекстПолей_1 + "
	|	ЕСТЬNULL(ВидимостьКолонок.Учет_Сумма, ИСТИНА) КАК НДС,
	|	ЕСТЬNULL(ВидимостьКолонок.Учет_Сумма, ИСТИНА) КАК СуммаНДС,
	|	ЕСТЬNULL(ВидимостьКолонок.Учет_Количество, ИСТИНА)
	|		ИЛИ ЕСТЬNULL(ВидимостьКолонок.Учет_Сумма, ИСТИНА) КАК Норма
	|ИЗ
	|	(ВЫБРАТЬ
	|		" + ТекстПолей_2 + "
	|	ИЗ
	|		Справочник.бит_СтатьиОборотов КАК бит_СтатьиОборотов
	|	ГДЕ
	|		бит_СтатьиОборотов.Ссылка В(&МассивСтатей)) КАК ВидимостьКолонок
	|";
	    			  
	Результат = Запрос.Выполнить();
   
   	Выборка = Результат.Выбрать();   
   	Если Выборка.Следующий() Тогда
	   
	   	Для каждого КолонкаРезультат Из Результат.Колонки Цикл
		   
		   	ИмяКолонки = КолонкаРезультат.Имя;
		   	флВидимость = Выборка[ИмяКолонки];
		   
			// Для дополнительных измерений анализируем используется измерение или нет.
			Если Найти(ИмяКолонки, "Аналитика_") > 0 Тогда
				Если НастройкиИзмерений[ИмяКолонки] = Неопределено Тогда
					флВидимость = Ложь;
				КонецЕсли; 
			КонецЕсли; 
		   
		   НастройкаВидимости.Вставить(ИмяКолонки,флВидимость);
		   
	   	КонецЦикла; // По колонкам результата 
	   
   	КонецЕсли; 

   	Возврат НастройкаВидимости;

КонецФункции

Процедура ПроверитьОбязательныеРазрезыСтатейОборотов(Объект, ИмяТаблицы, Отказ, Измерения=Неопределено, НастройкиИзмерений=Неопределено) Экспорт
	
	Если Измерения = Неопределено Тогда
		Измерения = ПолучитьИзмеренияБюджетирования("Произвольные", "Синоним");
	КонецЕсли;
	
	Если НастройкиИзмерений = Неопределено Тогда
		НастройкиИзмерений = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_НастройкиДополнительныхИзмерений");
	КонецЕсли;
	
	МетаОбъект	 = Объект.Метаданные();
	МетаТабЧасть = МетаОбъект.ТабличныеЧасти[ИмяТаблицы]; 
	ПредставлениеТабЧасти = МетаТабЧасть.Представление();
	
	МетаСтатьи = Метаданные.Справочники.бит_СтатьиОборотов;
	
	СтруктураОбязательныхРазрезов = Новый Структура;
	
	Для Каждого ТекИзмерение Из Измерения Цикл
		ИмяРеквизита = "Обязательный_" + ТекИзмерение.Ключ;
		
		Если НЕ бит_РаботаСМетаданными.ЕстьРеквизит(ИмяРеквизита, МетаСтатьи)
			ИЛИ НЕ бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти(ТекИзмерение.Ключ, МетаОбъект, ИмяТаблицы) Тогда
			Продолжить;
		КонецЕсли;
		
		СвойстваИзмерения = НастройкиИзмерений[ТекИзмерение.Ключ];
		Если СвойстваИзмерения = Неопределено Тогда
			СинонимРеквизита = ТекИзмерение.Значение;
		Иначе	
			СинонимРеквизита = СвойстваИзмерения.Синоним;
		КонецЕсли;
		
		СтруктураОбязательныхРазрезов.Вставить(ТекИзмерение.Ключ, СинонимРеквизита);
	КонецЦикла;
	
	Для Каждого ТекСтрока Из Объект[ИмяТаблицы] Цикл
		
		Для Каждого КлючЗначение Из СтруктураОбязательныхРазрезов Цикл
			
			Если ТекСтрока.СтатьяОборотов["Учет_"+КлючЗначение.Ключ]
				И ТекСтрока.СтатьяОборотов["Обязательный_"+КлючЗначение.Ключ]
				И НЕ ЗначениеЗаполнено(ТекСтрока[КлючЗначение.Ключ]) Тогда
				
				ТекстСообщения = ОбщегоНазначенияКлиентСервер.ТекстОшибкиЗаполнения("КОЛОНКА", ,КлючЗначение.Значение,
					ТекСтрока.НомерСтроки, ПредставлениеТабЧасти);
																					
				Поле = ИмяТаблицы + "[" + (ТекСтрока.НомерСтроки - 1) + "]." + КлючЗначение.Ключ;
				ОбщегоНазначения.СообщитьПользователю(ТекстСообщения, Объект, Поле, ,Отказ); 
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ЗависимыеОбороты

// Функция выполняет запрос для формирования зависимых оборотов.
// 
// Параметры:
//  ДатаЗаполнения 			- Дата - дата.
//  Сценарий 				- СправочникСсылка.бит_СценарииПланирования - сценарий.
//  ИзмеренияБюджетирования - Структура - измерения.
//  СтрокаТаблицы 			- СтрокаТабличнойЧасти - СтрокаТаблицыЗначений.
// 
// Возвращаемое значение:
//  РезультатЗапроса.
// 
Функция ВыполнитьЗапросДляФормированияЗависимыхОборотов(ДатаЗаполнения, Сценарий, ИзмеренияБюджетирования, СтрокаТаблицы)

	// Получаем имена справочников в зависимости от текущего решения.
	ИмяСправочникаСценарии = бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования();
	ИмяСправочникаЦФО 	   = бит_ОбщегоНазначения.ПолучитьИмяСправочникаЦФО();
	ИмяСправочникаПроекты  = бит_ОбщегоНазначения.ПолучитьИмяСправочникаПроекты();
	
	// Изменение кода. Начало. 07.06.2013{{	
	ТекстПоля    = "";
	ТекстУсловия = "";
	
	ПустоеЗначение = Неопределено;
	
	СтруктураПустых = Новый Структура;
	СтруктураПустых.Вставить("Сценарий"		 	   , "ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаСценарии + ".ПустаяСсылка)");	
	СтруктураПустых.Вставить("ЦФО"			 	   , "ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаЦФО + ".ПустаяСсылка)");
	СтруктураПустых.Вставить("Проект"		 	   , "ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаПроекты + ".ПустаяСсылка)");
	СтруктураПустых.Вставить("СтатьяОборотов"	   , "ЗНАЧЕНИЕ(Справочник.бит_СтатьиОборотов.ПустаяСсылка)");
	СтруктураПустых.Вставить("Контрагент"	 	   , "ЗНАЧЕНИЕ(Справочник.Контрагенты.ПустаяСсылка)");
	СтруктураПустых.Вставить("ДоговорКонтрагента"  , "ЗНАЧЕНИЕ(Справочник.ДоговорыКонтрагентов.ПустаяСсылка)");
	СтруктураПустых.Вставить("НоменклатурнаяГруппа", "ЗНАЧЕНИЕ(Справочник.НоменклатурныеГруппы.ПустаяСсылка)");
	СтруктураПустых.Вставить("БанковскийСчет"	   , "ЗНАЧЕНИЕ(Справочник.БанковскиеСчета.ПустаяСсылка)");
	
	Для каждого ТекИзмерение Из Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам.Измерения Цикл		
		
		ИмяИзмерения = ТекИзмерение.Имя;
		Если ИмяИзмерения = "Валюта" Тогда
			Продолжить;		
		КонецЕсли;
		
		// Поля запроса
		ТекстПоля = ТекстПоля + Символы.ПС + "	бит_ЗависимыеОборотыСрезПоследних." + ИмяИзмерения + ",";
		Если ИмяИзмерения <> "Сценарий" Тогда
			ТекстПоля = ТекстПоля + Символы.ПС + "	бит_ЗависимыеОборотыСрезПоследних." + ИмяИзмерения + "_Зависимый,";
		КонецЕсли;
				
		// Условия
		Если Не СтруктураПустых.Свойство(ИмяИзмерения, ПустоеЗначение) Тогда
			ПустоеЗначение = "НЕОПРЕДЕЛЕНО";			
		КонецЕсли;	
		ТекстУсловия = ТекстУсловия + Символы.ПС + ?(ТекстУсловия = "", "				", "				И") 
					   + " (" + ИмяИзмерения + " = &" + ИмяИзмерения + " ИЛИ " + ИмяИзмерения + " = " + ПустоеЗначение + ")";
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|" + ТекстПоля + "
	|	бит_ЗависимыеОборотыСрезПоследних.ПрофильРаспределения,
	|	бит_ЗависимыеОборотыСрезПоследних.КоэффициентКоличество,
	|	бит_ЗависимыеОборотыСрезПоследних.КоэффициентСумма,
	|	бит_ЗависимыеОборотыСрезПоследних.РеквизитКоличество,
	|	бит_ЗависимыеОборотыСрезПоследних.РеквизитСумма,
	|   бит_ЗависимыеОборотыСрезПоследних.ФункцияКоличество,
	|   бит_ЗависимыеОборотыСрезПоследних.ФункцияСумма,
	|   бит_ЗависимыеОборотыСрезПоследних.Регистратор,
	|   бит_ЗависимыеОборотыСрезПоследних.НомерСтроки,
	|	бит_ЗависимыеОборотыСрезПоследних.ДатаОкончания
	|ИЗ
	|	РегистрСведений.бит_ЗависимыеОбороты.СрезПоследних(
	|			&ДатаЗаполнения,
	|			" + ТекстУсловия + "
	|			) КАК бит_ЗависимыеОборотыСрезПоследних
	|ГДЕ
	|	(бит_ЗависимыеОборотыСрезПоследних.КоэффициентКоличество <> 0
	|			ИЛИ бит_ЗависимыеОборотыСрезПоследних.ФункцияКоличество <> ЗНАЧЕНИЕ(Справочник.бит_ПользовательскиеФункции.ПустаяСсылка)
	|			ИЛИ бит_ЗависимыеОборотыСрезПоследних.КоэффициентСумма <> 0
	|			ИЛИ бит_ЗависимыеОборотыСрезПоследних.ФункцияСумма <> ЗНАЧЕНИЕ(Справочник.бит_ПользовательскиеФункции.ПустаяСсылка))
	|	И (бит_ЗависимыеОборотыСрезПоследних.РеквизитКоличество <> ЗНАЧЕНИЕ(Перечисление.бит_РеквизитыДляРасчетаЗависимостей.ПустаяСсылка)
	|			ИЛИ бит_ЗависимыеОборотыСрезПоследних.РеквизитСумма <> ЗНАЧЕНИЕ(Перечисление.бит_РеквизитыДляРасчетаЗависимостей.ПустаяСсылка))
	|	И (КонецПериода(бит_ЗависимыеОборотыСрезПоследних.ДатаОкончания,День) >= &ДатаЗаполнения
	|					ИЛИ бит_ЗависимыеОборотыСрезПоследних.ДатаОкончания = &ПустаяДата)
	|";
	// Изменение кода. Конец. 07.06.2013}}			   
	
	// Установка параметров запроса			             	
	Запрос.УстановитьПараметр("ПустаяДата"    , Дата('00010101'));
	Запрос.УстановитьПараметр("ДатаЗаполнения", ДатаЗаполнения);
	Запрос.УстановитьПараметр("Сценарий"      , Сценарий);
	
	Для каждого КлючИЗначение Из ИзмеренияБюджетирования Цикл
	
		ИмяИзмерения = КлючИЗначение.Ключ;
		Если ИмяИзмерения = "Сценарий" Тогда		
			Продолжить;		
		КонецЕсли; 
		
		Запрос.УстановитьПараметр(ИмяИзмерения,СтрокаТаблицы[ИмяИзмерения]);
		
	КонецЦикла; 
	
	Результат = Запрос.Выполнить();

	Возврат Результат;
	
КонецФункции

// Функция инициализирует структуру для хранения результатов расчета зависимых оборотов.
// 
// Возвращаемое значение:
//  СтрРасчет - Строка.
// 
Функция КонструкторСтруктураРасчетаРесурса()
	
	СтрРасчет    = Новый Структура("Функция,Коэффициент,ПрофильРаспределения,ИмяРесурса,ИмяРеквизита,Результат,Аргумент");
	
	Возврат СтрРасчет;
	
КонецФункции

// Функция выполняет расчет количества и суммы для зависимых оборотов.
// 
// Параметры:
//  Выборка - ВыборкаИзРезультатаЗапроса.
//  СтрокаТабличнойЧасти - СтрокаТабличнойЧасти, СтрокаТаблицыЗначений.
//  НоваяСтрока          - СтрокаТабличнойЧасти, НоваяСтрока.
//  КомментироватьРасчет - Булево.
// 
Функция ЗависимыеОборотыВыполнитьРасчет(Выборка, СтрокаТабличнойЧасти, НоваяСтрока, КомментироватьРасчет = Ложь, Сценарий = Неопределено)
	
	ПарамРасчета = Новый Структура;
	ПарамРасчета.Вставить("Количество",  КонструкторСтруктураРасчетаРесурса());
	ПарамРасчета.Вставить("Сумма",		 КонструкторСтруктураРасчетаРесурса());
	ПарамРасчета.Вставить("Регистратор", Выборка.Регистратор);
	ПарамРасчета.Вставить("НомерСтроки", Выборка.НомерСтроки);
	
	Если ЗначениеЗаполнено(Выборка.ФункцияКоличество) Тогда
		
		НоваяСтрока.Количество = бит_ОбщегоНазначения.ВыполнитьПользовательскуюФункцию(
									Выборка.ФункцияКоличество,Выборка,СтрокаТабличнойЧасти,НоваяСтрока,Сценарий);
		
		Если КомментироватьРасчет Тогда
			ПарамРасчета.Количество.Результат = НоваяСтрока.Количество;
			ПарамРасчета.Количество.Функция   = Выборка.ФункцияКоличество;
			ПарамРасчета.Количество.ИмяРесурса= "Количество";
			ПарамРасчета.Количество.ПрофильРаспределения = Выборка.ПрофильРаспределения;
		КонецЕсли; 
	ИначеЕсли ЗначениеЗаполнено(Выборка.РеквизитКоличество) Тогда
		
		ИмяРеквизита = бит_ОбщегоНазначения.ПолучитьИмяЗначенияПеречисления(
							Перечисления.бит_РеквизитыДляРасчетаЗависимостей,Выборка.РеквизитКоличество);
		НоваяСтрока["Количество"] = СтрокаТабличнойЧасти[ИмяРеквизита]*Выборка.КоэффициентКоличество;
		
		Если КомментироватьРасчет Тогда
			ПарамРасчета.Количество.Результат    = НоваяСтрока.Количество;
			ПарамРасчета.Количество.Коэффициент  = Выборка.КоэффициентКоличество;
			ПарамРасчета.Количество.ИмяРеквизита = ИмяРеквизита;			
			ПарамРасчета.Количество.Аргумент     = СтрокаТабличнойЧасти[ИмяРеквизита];
			ПарамРасчета.Количество.ИмяРесурса	 = "Количество";
		    ПарамРасчета.Количество.ПрофильРаспределения = Выборка.ПрофильРаспределения;
		КонецЕсли; 
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(Выборка.ФункцияСумма) Тогда
		
		НоваяСтрока.Сумма = бит_ОбщегоНазначения.ВыполнитьПользовательскуюФункцию(Выборка.ФункцияСумма,
								Выборка,СтрокаТабличнойЧасти,НоваяСтрока,Сценарий);
		Если КомментироватьРасчет Тогда
			ПарамРасчета.Сумма.Результат = НоваяСтрока.Сумма;
			ПарамРасчета.Сумма.Функция   = Выборка.ФункцияСумма;
			ПарамРасчета.Сумма.ИмяРесурса= "Сумма";
			ПарамРасчета.Сумма.ПрофильРаспределения = Выборка.ПрофильРаспределения;
		КонецЕсли; 
	ИначеЕсли ЗначениеЗаполнено(Выборка.РеквизитСумма) Тогда
		
		ИмяРеквизита = бит_ОбщегоНазначения.ПолучитьИмяЗначенияПеречисления(
						Перечисления.бит_РеквизитыДляРасчетаЗависимостей,Выборка.РеквизитСумма);
		НоваяСтрока["Сумма"] = СтрокаТабличнойЧасти[ИмяРеквизита]*Выборка.КоэффициентСумма;
		
		Если КомментироватьРасчет Тогда
			ПарамРасчета.Сумма.Результат    = НоваяСтрока.Сумма;
			ПарамРасчета.Сумма.Коэффициент  = Выборка.КоэффициентСумма;
			ПарамРасчета.Сумма.ИмяРеквизита = ИмяРеквизита;
			ПарамРасчета.Сумма.Аргумент     = СтрокаТабличнойЧасти[ИмяРеквизита];
			ПарамРасчета.Сумма.ИмяРесурса	= "Сумма";
			ПарамРасчета.Сумма.ПрофильРаспределения = Выборка.ПрофильРаспределения;
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат ПарамРасчета;
	
КонецФункции

// Процедура заполняет измерения при формировании зависимых оборотов.
// 
// Параметры:
//  ИзмеренияБюджетирования - Структура.
//  Выборка              - ВыборкаИзРезультатаЗапроса.
//  СтрокаТабличнойЧасти - СтрокаТабличнойЧасти, СтрокаТаблицыЗначений.
//  НоваяСтрока          - СтрокаТабличнойЧасти, НоваяСтрока.
// 
Процедура ЗависимыеОборотыЗаполнитьИзмерения(ИзмеренияБюджетирования, Выборка, СтрокаТабличнойЧасти, НоваяСтрока)
	
	НоваяСтрока.СтатьяОборотов = Выборка.СтатьяОборотов_Зависимый;
	
	Для каждого КлючИЗначение Из ИзмеренияБюджетирования Цикл
		
		ИмяИзмерения = КлючИЗначение.Ключ;
		ИмяИзмеренияЗависимый = КлючИЗначение.Ключ+"_Зависимый";
		Если ВРег(ИмяИзмерения) = ВРег("Сценарий") Тогда
			
			Продолжить;
			
		КонецЕсли; 
		
		ЗначениеИзмерения = СтрокаТабличнойЧасти[ИмяИзмерения];
		ЗначениеЗависимый = Выборка[ИмяИзмеренияЗависимый];
		Если ЗначениеЗаполнено(ЗначениеЗависимый)  Тогда
			
			НоваяСтрока[ИмяИзмерения] = ЗначениеЗависимый;
			
		Иначе
			
			НоваяСтрока[ИмяИзмерения] = ЗначениеИзмерения;
			
		КонецЕсли; 
		
		// Проверка допустимости установки аналитик по статье.
		
		Если ВРег(ИмяИзмерения) = ВРег("ЦФО") ИЛИ ВРег(ИмяИзмерения) = ВРег("СтатьяОборотов") Тогда
			
			// По цфо учет ведется всегда - реквизита учет_<...> нет.
			Продолжить;
			
		КонецЕсли; 
		
		ИмяРеквизитаУчет = "Учет_"+КлючИЗначение.Ключ;
		Если НЕ НоваяСтрока.СтатьяОборотов[ИмяРеквизитаУчет] Тогда
			
			НоваяСтрока[ИмяИзмерения] = Неопределено;
			
		КонецЕсли; 
		
	КонецЦикла; // По измерениям бюджетирования
	
КонецПроцедуры

// Функция формирует комментарий выполнения расчета зависимых оборотов.
// 
// Параметры:
//  Выборка              - ВыборкаИзРезультатаЗапроса - выборка.
//  СтрокаТабличнойЧасти - СтрокаТабличнойЧасти - СтрокаТаблицыЗначений.
//  НоваяСтрока          - СтрокаТабличнойЧасти - НоваяСтрока.
// 
// Возвращаемое значение:
//  Результат - ТекстХТМЛ.
// 
Функция ЗависимыеОборотыКомментарийРасчета(ПарамРасчета)
	
	ТекстХТМЛ = "";
	
	Если ТипЗнч(ПарамРасчета) = Тип("Структура") Тогда
		
		// Заголовок
		ВремСтрока = НСтр("ru = 'Комментарий расчета зависимых оборотов'");
		ТекстХТМЛ  = "<p><h3>"+ВремСтрока+"</h3></p>";
		
		// Документ установки зависимых оборотов
		ВремСтрока  = НСтр("ru = 'Выполнен расчет по настройке:'");
		ТекстСсылки = СтрШаблон(НСтр("ru = '%1, строка № %2'"), ПарамРасчета.Регистратор, ПарамРасчета.НомерСтроки);
		Ссылка 		= СтрШаблон("#Документ.бит_УстановкаЗависимыхОборотов/%1/%2", 
							ПарамРасчета.Регистратор.УникальныйИдентификатор(), ПарамРасчета.НомерСтроки);
				 
		ТекстХТМЛ = ТекстХТМЛ+"<p><b><i>"+ВремСтрока+"</i></b><br><a id = ""CalcRef"" href = """+Ссылка+""" >"+ТекстСсылки+"</a><p>";
		
		// Расчет суммы и количества
		ТекстСумма      = ЗависимыеОборотыКомментарийРасчетаРесурса(ПарамРасчета.Сумма, НСтр("ru = 'Расчет суммы:'"), "ЧЦ=15; ЧДЦ=2");
		ТекстКоличество = ЗависимыеОборотыКомментарийРасчетаРесурса(ПарамРасчета.Количество, НСтр("ru = 'Расчет количества:'"), "ЧЦ=15; ЧДЦ=3");		
		
		ТекстХТМЛ = ТекстХТМЛ+"<p>";
		ТекстХТМЛ = ТекстХТМЛ+ТекстСумма;
		ТекстХТМЛ = ТекстХТМЛ+ТекстКоличество;
		
		Если ПустаяСтрока(ТекстСумма) И ПустаяСтрока(ТекстКоличество) Тогда
			ТекстХТМЛ = ТекстХТМЛ+НСтр("ru ='Расчеты не выполнены.'");
		КонецЕсли; 
		ТекстХТМЛ = ТекстХТМЛ+"</p>"
	КонецЕсли; 
	
	Возврат ТекстХТМЛ;
	
КонецФункции

// Функция выводит комментарий расчета ресурса (суммы или количества).
// 
// Параметры:
//  СтрПар - Структура
//  СтрЗаголовок - Строка
//  СтрФормат    - Строка
// 
// Возвращаемое значение:
//  ТекстХТМЛ - Строка.
// 
Функция ЗависимыеОборотыКомментарийРасчетаРесурса(СтрПар, СтрЗаголовок, СтрФормат)
	
	ТекстХТМЛ = "";
	
	Если ТипЗнч(СтрПар) = Тип("Структура") И ТипЗнч(СтрПар.Результат) = Тип("Число") Тогда
		
		// Выполнялся расчет показателя
		ТекстХТМЛ = ТекстХТМЛ+"<b><i>"+СтрЗаголовок+"</b></i><br>";
		
		Если ЗначениеЗаполнено(СтрПар.ПрофильРаспределения) Тогда
			ТекстПрофильРаспределения		= "*ПрофильРаспределения";
			ТекстПрофильРаспределенияРасчет = "*%ПрофильРаспределения%";
			ТекстРезультат = "%Результат"+СтрПар.ИмяРесурса+"%";
		Иначе
			ТекстПрофильРаспределения		= "";
			ТекстПрофильРаспределенияРасчет = "";
			ТекстРезультат = Формат(СтрПар.Результат,СтрФормат);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СтрПар.Функция) Тогда
			
			// Расчет выполнялся через пользовательскую функцию.
			ТекстСсылки = Строка(СтрПар.Функция)+"()";
			Ссылка = "#Справочник.бит_ПользовательскиеФункции/"+Строка(СтрПар.Функция.УникальныйИдентификатор());
			
			ТекстХТМЛ = ТекстХТМЛ+ТекстРезультат+" = <a id = ""UserFunction"" href = """+Ссылка+""">"+ТекстСсылки+"</a>"+ТекстПрофильРаспределенияРасчет+"<br>";
			
		Иначе	
			
			// Расчет выполнялся умножением на коэффициент.
			ТекстХТМЛ = ТекстХТМЛ+ТекстРезультат+" = "+СтрПар.Коэффициент+"*"+СтрПар.ИмяРеквизита+ТекстПрофильРаспределения+"<br>";
			ТекстХТМЛ = ТекстХТМЛ+ТекстРезультат+" = "+СтрПар.Коэффициент+"*"+СтрПар.Аргумент+ТекстПрофильРаспределенияРасчет+"<br>";		   
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат ТекстХТМЛ;
	
КонецФункции

// Функция выполняет фильтрацию строк  настроек зависимых оборотов, 
// по которым необходимо выполнять расчет для данной строки оборотов бюджета.
// 
// Параметры:
//  СтрокаТаблицыДокумента - СтрокаТаблицы - строка таблицы.
//  СтрокаЗависимыхОборотов - СтрокаТаблицы - строка оборотов.
//  ПроверяемыеПоля - Структура - поля.
//  ДатаЗаполнения - Булево - Дата.
// 
// Возвращаемое значение:
//  флВыполнено - Булево.
// 
Функция УсловиеНаПоляЗависимыхОборотов(СтрокаТаблицыДокумента, СтрокаЗависимыхОборотов, ПроверяемыеПоля, ДатаЗаполнения)

	флВыполнено = Истина;
	
	Если СтрокаЗависимыхОборотов.Период > ДатаЗаполнения Тогда
		
		флВыполнено = Ложь;
		
	КонецЕсли; 
	
	Для каждого КиЗ Из ПроверяемыеПоля Цикл
	
		ИмяПоля = КиЗ.Ключ;
		ПустоеЗначение = КиЗ.Значение;
		
		Если НЕ (СтрокаТаблицыДокумента[ИмяПоля] = СтрокаЗависимыхОборотов[ИмяПоля] 
			      ИЛИ НЕ ЗначениеЗаполнено(СтрокаЗависимыхОборотов[ИмяПоля]) ) Тогда
		
			флВыполнено = Ложь;
			Прервать;
		
		КонецЕсли; 
	
	КонецЦикла; 

	Если флВыполнено Тогда
		Если СтрокаЗависимыхОборотов.КоэффициентКоличество = 0
			И СтрокаЗависимыхОборотов.КоэффициентСумма = 0
			И НЕ ЗначениеЗаполнено(СтрокаЗависимыхОборотов.ФункцияКоличество)
			И НЕ ЗначениеЗаполнено(СтрокаЗависимыхОборотов.ФункцияСумма) Тогда
		
			флВыполнено = Ложь;
		КонецЕсли; 
		
		Если НЕ ЗначениеЗаполнено(СтрокаЗависимыхОборотов.РеквизитКоличество) И НЕ ЗначениеЗаполнено(СтрокаЗависимыхОборотов.РеквизитСумма) Тогда
			флВыполнено = Ложь;
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(СтрокаЗависимыхОборотов.ДатаОкончания) И КонецДня(СтрокаЗависимыхОборотов.ДатаОкончания) < ДатаЗаполнения  Тогда
			флВыполнено = Ложь;
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат флВыполнено;
	
КонецФункции

// Процедура вычисляет приоритет настройки зависимых оборотов.
// 
// Параметры:
//  СтрокаТаблицыДокумента - СтрокаТаблицыЗначений.
//  СтрокаЗависимыхОборотов - СтрокаТаблицыЗначений.
//  ПроверяемыеПоля - Структура.
// 
Процедура ВычислитьПриоритетСтрокиЗависимыхОборотов(СтрокаТаблицыДокумента, СтрокаЗависимыхОборотов, ПроверяемыеПоля)

	Для каждого КиЗ Из ПроверяемыеПоля Цикл
	
		ИмяПоля = КиЗ.Ключ;
		ПустоеЗначение = КиЗ.Значение;
		
		Если СтрокаТаблицыДокумента[ИмяПоля] = СтрокаЗависимыхОборотов[ИмяПоля] 
			  И ЗначениеЗаполнено(СтрокаЗависимыхОборотов[ИмяПоля]) Тогда
		
			СтрокаЗависимыхОборотов.Приоритет = СтрокаЗависимыхОборотов.Приоритет + 1;
		
		КонецЕсли; 
			
	КонецЦикла; 

	ИмяПоля = "СтатьяОборотов";
	Если СтрокаТаблицыДокумента[ИмяПоля] = СтрокаЗависимыхОборотов[ИмяПоля] 
			  И ЗначениеЗаполнено(СтрокаЗависимыхОборотов[ИмяПоля]) Тогда
	
			СтрокаЗависимыхОборотов.Приоритет = СтрокаЗависимыхОборотов.Приоритет + 1;
	
	КонецЕсли; 
	
КонецПроцедуры

// Функция формирует перечень полей по которым будет выполняться проверка приоритета настроек трансляции.
// 
// Возвращаемое значение:
//  ПроверяемыеПоля - Структура.
// 
Функция ПодготовитьПроверяемыеПоляЗавОборотов()

		// Получаем имена справочников в зависимости от текущего решения.
		ИмяСправочникаСценарии = бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования();
		ИмяСправочникаЦФО 	   = бит_ОбщегоНазначения.ПолучитьИмяСправочникаЦФО();
		ИмяСправочникаПроекты  = бит_ОбщегоНазначения.ПолучитьИмяСправочникаПроекты();		
		
		ПроверяемыеПоля = Новый Структура;
		ПроверяемыеПоля.Вставить("ЦФО"			 	   , "ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаЦФО + ".ПустаяСсылка)");
		Если бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
			
			ПроверяемыеПоля.Вставить("Проект"		 	   , "ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаПроекты + ".ПустаяСсылка)");
			ПроверяемыеПоля.Вставить("Контрагент"	 	   , "ЗНАЧЕНИЕ(Справочник.Контрагенты.ПустаяСсылка)");
			ПроверяемыеПоля.Вставить("ДоговорКонтрагента"  , "ЗНАЧЕНИЕ(Справочник.ДоговорыКонтрагентов.ПустаяСсылка)");
			ПроверяемыеПоля.Вставить("НоменклатурнаяГруппа", "ЗНАЧЕНИЕ(Справочник.НоменклатурныеГруппы.ПустаяСсылка)");
			ПроверяемыеПоля.Вставить("БанковскийСчет"	   , "ЗНАЧЕНИЕ(Справочник.БанковскиеСчета.ПустаяСсылка)");
			
		КонецЕсли; 
		
		КоличествоДопАналитик = бит_МеханизмДопИзмерений.ПолучитьМаксимальноеКоличествоДополнительныхИзмерений();
		Для Н = 1 По КоличествоДопАналитик Цикл
		
			ПроверяемыеПоля.Вставить("Аналитика_"+н, "Неопределено");
		
		КонецЦикла; 

	Возврат ПроверяемыеПоля;
	
КонецФункции

#КонецОбласти

// Процедура синхронизирует справочники, отражающие структуру предприятия и ЦФО.
// 
// Параметры:
//  Источник - СправочникОбъект.
// 
Функция СинхронизироватьСтруктурнуюЕдинцуРеглЦФО(Источник)
	
	СинхрЦФО = НайтиСинхрЦФО(Источник.Ссылка);
	
	МетаИсточник = Источник.Метаданные();
	
	Если НЕ ЗначениеЗаполнено(СинхрЦФО) Тогда
		
		// Не удалось найти синхронизированное ЦФО - нужно создать.
		
		ЦФООбъект = Справочники.Подразделения.СоздатьЭлемент();
		ЦФООбъект.УстановитьНовыйКод();		
		
	Иначе
		
		// Нашли синхронизированное ЦФО - синхронизируем наименование и пометку удаления.
		ЦФООбъект = СинхрЦФО.ПолучитьОбъект();
		
	КонецЕсли; 
	
	ЦФООбъект.Наименование = Источник.Наименование;
	ЦФООбъект.СтруктурнаяЕдиницаРегл = Источник.Ссылка;
	ЦФООбъект.ПометкаУдаления = Источник.ПометкаУдаления;
	
	Если МетаИсточник.Имя = "Организации" Тогда
		
		Если Источник.ЮридическоеФизическоеЛицо = Перечисления.ЮридическоеФизическоеЛицо.ЮридическоеЛицо Тогда
			
			ЦФООбъект.ЯвляетсяЮрЛицом = Истина;
			
		КонецЕсли; 
		
	ИначеЕсли МетаИсточник.Имя = "ПодразделенияОрганизаций" Тогда	
		
		Если ЗначениеЗаполнено(Источник.Родитель) Тогда
			
			ЦФООбъект.Родитель = НайтиСинхрЦФО(Источник.Родитель);
			
		Иначе
			
			ЦФООрг = НайтиСинхрЦФО(Источник.Владелец);
			
			Если НЕ ЗначениеЗаполнено(ЦФООрг) Тогда
			
				ЦФООрг = СинхронизироватьСтруктурнуюЕдинцуРеглЦФО(Источник.Владелец);
			
			КонецЕсли; 
			
			ЦФООбъект.Родитель = ЦФООрг;
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	бит_ОбщегоНазначения.ЗаписатьСправочник(ЦФООбъект,"","Ошибки", Истина);
	
	флЕстьРегистр = ?(НЕ Метаданные.РегистрыСведений.Найти("бит_ЦФО_Подразделения") = Неопределено, Истина, Ложь);		
	
	Если флЕстьРегистр И ЗначениеЗаполнено(ЦФООбъект.Ссылка) Тогда
		
		 Запрос = Новый Запрос;
		 Запрос.УстановитьПараметр("Подразделение", Источник.Ссылка);
		 Запрос.Текст = 
		 "ВЫБРАТЬ ПЕРВЫЕ 1
		 |	бит_ЦФО_Подразделения.ЦФО,
		 |	бит_ЦФО_Подразделения.Подразделение
		 |ИЗ
		 |	РегистрСведений.бит_ЦФО_Подразделения КАК бит_ЦФО_Подразделения
		 |ГДЕ
		 |	бит_ЦФО_Подразделения.Подразделение = &Подразделение";
						
		 Результат = Запрос.Выполнить();
		 
		 Если Результат.Пустой() Тогда
			 МенеджерЗаписи = РегистрыСведений.бит_ЦФО_Подразделения.СоздатьМенеджерЗаписи();
			 МенеджерЗаписи.Подразделение = Источник.Ссылка;
			 МенеджерЗаписи.ЦФО = ЦФООбъект.Ссылка;
			 Попытка
				 МенеджерЗаписи.Записать();
			 Исключение
				 ТекстСообщения = СтрШаблон(НСтр("ru = 'Не удалось записать соответствие подразделения и ЦФО по причине: %1'"),
				 					КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				ОбщегоНазначения.СообщитьПользователю(ТекстСообщения); 				 
			 КонецПопытки;		 
		 КонецЕсли; 
	КонецЕсли; 
	
	Возврат ЦФООбъект.Ссылка;
	
КонецФункции

Функция ПараметрыУчета()
	
	ПараметрыУчета = Новый Структура;
	ПоляУчета = Новый Структура;

	Если бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
		ПоляУчета.Вставить("Аналитика_1",	"Контрагент");
		ПоляУчета.Вставить("Аналитика_2",	"ДоговорКонтрагента");
		ПоляУчета.Вставить("Аналитика_3",	"Проект");
		ПоляУчета.Вставить("Аналитика_4",	"НоменклатурнаяГруппа");
		ПоляУчета.Вставить("Аналитика_5",	"БанковскийСчет");
		ПоляУчета.Вставить("Аналитика_6",	"Аналитика_1");
		ПоляУчета.Вставить("Аналитика_7",	"Аналитика_2");
		ПоляУчета.Вставить("Аналитика_8",	"Аналитика_3");
		ПоляУчета.Вставить("Аналитика_9",	"Аналитика_4");
		ПоляУчета.Вставить("Аналитика_10",	"Аналитика_5");
		ПоляУчета.Вставить("Аналитика_11",	"Аналитика_6");
		ПоляУчета.Вставить("Аналитика_12",	"Аналитика_7");
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	СтатьиОборотов.Ссылка КАК СтатьяОборотов,
		|	СтатьиОборотов.Учет_Количество КАК Количество,
		|	СтатьиОборотов.Учет_Сумма КАК Сумма,
		|	СтатьиОборотов.Учет_Контрагент КАК Контрагент,
		|	СтатьиОборотов.Учет_ДоговорКонтрагента КАК ДоговорКонтрагента,
		|	СтатьиОборотов.Учет_Проект КАК Проект,
		|	СтатьиОборотов.Учет_НоменклатурнаяГруппа КАК НоменклатурнаяГруппа,
		|	СтатьиОборотов.Учет_БанковскийСчет КАК БанковскийСчет,
		|	СтатьиОборотов.Учет_Аналитика_1 КАК Аналитика_1,
		|	СтатьиОборотов.Учет_Аналитика_2 КАК Аналитика_2,
		|	СтатьиОборотов.Учет_Аналитика_3 КАК Аналитика_3,
		|	СтатьиОборотов.Учет_Аналитика_4 КАК Аналитика_4,
		|	СтатьиОборотов.Учет_Аналитика_5 КАК Аналитика_5,
		|	СтатьиОборотов.Учет_Аналитика_6 КАК Аналитика_6,
		|	СтатьиОборотов.Учет_Аналитика_7 КАК Аналитика_7
		|ИЗ
		|	Справочник.бит_СтатьиОборотов КАК СтатьиОборотов
		|ГДЕ
		|	СтатьиОборотов.Ссылка В(&СтатьиОборотов)";
	Иначе
		ПоляУчета.Вставить("Аналитика_1",	"Аналитика_1");
		ПоляУчета.Вставить("Аналитика_2",	"Аналитика_2");
		ПоляУчета.Вставить("Аналитика_3",	"Аналитика_3");
		ПоляУчета.Вставить("Аналитика_4",	"Аналитика_4");
		ПоляУчета.Вставить("Аналитика_5",	"Аналитика_5");
		ПоляУчета.Вставить("Аналитика_6",	"Аналитика_6");
		ПоляУчета.Вставить("Аналитика_7",	"Аналитика_7");
		ПоляУчета.Вставить("Аналитика_8",	"Аналитика_8");
		ПоляУчета.Вставить("Аналитика_9",	"Аналитика_9");
		ПоляУчета.Вставить("Аналитика_10",	"Аналитика_10");
		ПоляУчета.Вставить("Аналитика_11",	"Аналитика_11");
		ПоляУчета.Вставить("Аналитика_12",	"Аналитика_12");
		
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	СтатьиОборотов.Ссылка КАК СтатьяОборотов,
		|	СтатьиОборотов.Учет_Количество КАК Количество,
		|	СтатьиОборотов.Учет_Сумма КАК Сумма,
		|	СтатьиОборотов.Учет_Аналитика_1 КАК Аналитика_1,
		|	СтатьиОборотов.Учет_Аналитика_2 КАК Аналитика_2,
		|	СтатьиОборотов.Учет_Аналитика_3 КАК Аналитика_3,
		|	СтатьиОборотов.Учет_Аналитика_4 КАК Аналитика_4,
		|	СтатьиОборотов.Учет_Аналитика_5 КАК Аналитика_5,
		|	СтатьиОборотов.Учет_Аналитика_6 КАК Аналитика_6,
		|	СтатьиОборотов.Учет_Аналитика_7 КАК Аналитика_7,
		|	СтатьиОборотов.Учет_Аналитика_8 КАК Аналитика_8,
		|	СтатьиОборотов.Учет_Аналитика_9 КАК Аналитика_9,
		|	СтатьиОборотов.Учет_Аналитика_10 КАК Аналитика_10,
		|	СтатьиОборотов.Учет_Аналитика_11 КАК Аналитика_11,
		|	СтатьиОборотов.Учет_Аналитика_12 КАК Аналитика_12
		|ИЗ
		|	Справочник.бит_СтатьиОборотов КАК СтатьиОборотов
		|ГДЕ
		|	СтатьиОборотов.Ссылка В(&СтатьиОборотов)";
	КонецЕсли;
	
	ПараметрыУчета.Вставить("ПоляУчета",	ПоляУчета);
	ПараметрыУчета.Вставить("ТекстЗапроса",	ТекстЗапроса);
	
	Возврат ПараметрыУчета;
	
КонецФункции

// Функция выполняет поиск ЦФО, синхронизированного с регл. подразделением/организацией.
// 
// Параметры:
//   ИсточникСсылка - СправочникСсылка.
// 
// Возвращаемое значение:
//  СинхрЦФО - СправочникСсылка.Подразделения, Неопределено.
// 
Функция НайтиСинхрЦФО(ИсточникСсылка)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СтруктурнаяЕдиницаРегл", ИсточникСсылка);
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Подразделения.Ссылка
	|ИЗ
	|	Справочник.Подразделения КАК Подразделения
	|ГДЕ
	|	Подразделения.СтруктурнаяЕдиницаРегл = &СтруктурнаяЕдиницаРегл";
	
	Результат = Запрос.Выполнить();				
	Выборка = Результат.Выбрать();
	СинхрЦФО = Неопределено;
	Если Выборка.Следующий() Тогда
		СинхрЦФО = Выборка.Ссылка;
	КонецЕсли; 
	
	Возврат СинхрЦФО;
	
КонецФункции

#КонецОбласти

// БИТ_YK_н 01/16
// Аналог СформироватьЗависимыеОборотыПоНаборуЗаписей. Вызывается из внешних алгоритмов МХО. 
Процедура СформироватьЗависимыеОборотыПоНаборуЗаписейМХО(ДокументОбъект, НаборОбороты, ТаблицаИсточник) Экспорт
	
	ТаблицаПриемник = ТаблицаИсточник.СкопироватьКолонки();
	ТаблицаПриемник.Колонки.Добавить("ЭтоКоэффициент", Новый ОписаниеТипов("Булево"));
	
	ИзмеренияБюджетирования = бит_Бюджетирование.ПолучитьИзмеренияБюджетирования("все","имя");
	
	// формируем зависимые обороты в ТаблицуПриемник
	Для каждого СтрокаТаблицы Из ТаблицаИсточник Цикл
		
		бит_Бюджетирование.СформироватьЗависимыеОборотыВТаблицу(СтрокаТаблицы.Период
		,СтрокаТаблицы
		,ТаблицаИсточник.Колонки
		,ТаблицаПриемник
		,ИзмеренияБюджетирования);
		
	КонецЦикла; 
	
	Если ТаблицаПриемник.Количество() > 0 Тогда
		
		// выполним валютные пересчеты в ТаблицеПриемник
		ПерваяСтрока    = ТаблицаПриемник[0];
		Сценарий        = ПерваяСтрока.Сценарий;
		ВалютаДокумента = ПерваяСтрока.Валюта;
		
		ДокМодель = Документы.бит_БюджетнаяОперация.СоздатьДокумент();
		ДокМодель.Сценарий  = Сценарий;
		ДокМодель.Дата      = ПерваяСтрока.Период;
		СтруктураКурсыВалют = бит_Бюджетирование.ПолучитьСтруктуруКурсовВалютСценария(ДокМодель, ПерваяСтрока.Период, Новый Структура("Регл, Упр, Сценарий"));
		
		СтрКурсаСц = СтруктураКурсыВалют.Сценарий;
		СтрКурсаДок = Новый Структура("Валюта, Курс, Кратность");
		
		СтрКурсаДок = бит_КурсыВалют.ПолучитьКурсВалюты(ВалютаДокумента, ПерваяСтрока.Период);		 
		
		
		СтруктураКурсыВалют.Вставить("Документ",СтрКурсаДок);
		
		КурсыПоПериодам = Неопределено;
		Если Сценарий.ИспользоватьКурсыСценария Тогда
			
			// получим таблицу периодов
			ТаблицаПериодов = ТаблицаПриемник.Выгрузить();
			ТаблицаПериодов.Свернуть("Период");
			
			// установим настройки для получения курсов по периодам
			СтруктураПараметров = бит_Бюджетирование.ЗаполнитьСтруктуруПараметровПолученияКурсовПоПериодам(Сценарий,ВалютаДокумента);
			
			// получим курсы по периодам
			КурсыПоПериодам = бит_КурсыВалют.ПолучитьКурсыВалютПоПериодам(ТаблицаПериодов,Сценарий,СтруктураПараметров);
			
		КонецЕсли; 
		
		бит_Бюджетирование.ВыполнитьПересчетыВТаблицеОборотов(ТаблицаПриемник,КурсыПоПериодам,СтруктураКурсыВалют);
		
		
		// заполним полученные записи по зависимым оборотам в набор оборотов	
		
		// Формирование записей в регистр идет дважды в процессе проведения документов (трансляция + МХО).
		// Поэтому движения по регистру битСтатьиОборотовПоЗависимымОборотам не должны затираться.
		Номер_ = 0;
		
		НаборДв = ДокументОбъект.Движения.Найти("битСтатьиОборотовПоЗависимымОборотам");
		Если НаборДв <> Неопределено Тогда
			ЭтоРасходныйДокумент = Истина;   // Это ПоступлениеТоваровУслуг или бит_ок_ОперацияАксапты
		Иначе
			ЭтоРасходныйДокумент = Ложь;
		КонецЕсли;
		
		Если ЭтоРасходныйДокумент Тогда 
			ДокументОбъект.Движения.битСтатьиОборотовПоЗависимымОборотам.Прочитать();
			Номер_ = НаборОбороты.Количество() - ТаблицаИсточник.Количество();
		КонецЕсли;
		
		Для каждого СтрокаТаблицы Из ТаблицаПриемник Цикл
			
			НоваяЗапись = НаборОбороты.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, СтрокаТаблицы);
			НоваяЗапись.Активность = Истина;
			
			Номер_ = Номер_ + 1;
			Если ЭтоРасходныйДокумент И СтрокаТаблицы.СтатьяОборотов.ТипСтатьи = Перечисления.бит_ТипыСтатейОборотов.БДДС  Тогда 
				СтрокаСвязи = ДокументОбъект.Движения.битСтатьиОборотовПоЗависимымОборотам.Добавить();
				СтрокаСвязи.ПоступлениеТоваровУслуг  = ДокументОбъект.Ссылка;
				СтрокаСвязи.НомерСтрокиИсходный 	 = Номер_;
				СтрокаСвязи.СтатьяОборотовБДР 		 = НаборОбороты[СтрокаСвязи.НомерСтрокиИсходный-1].СтатьяОборотов;
				СтрокаСвязи.СтатьяОборотовБДДС   	 = СтрокаТаблицы.СтатьяОборотов;			 
				СтрокаСвязи.НомерСтрокиБДДС 		 = НаборОбороты.Количество();			 
			КонецЕсли;	  	 
			
		КонецЦикла;
		
		Если ЭтоРасходныйДокумент Тогда  
			ДокументОбъект.Движения.битСтатьиОборотовПоЗависимымОборотам.Записать();	
		КонецЕсли;
		
	КонецЕсли;
КонецПроцедуры // БИТ_YK_к
