
#Область СлужебныйПрограммныйИнтерфейс

#Область Диалоги

// Процедура вызывает процедуру "Состояние".
// 
// Параметры:
//  Текст - Строка.
// 
Процедура ВывестиСостояниеПользователю(Текст) Экспорт
    
    #Если Клиент Тогда
        Состояние(Текст);
    #КонецЕсли
    
КонецПроцедуры // ВывестиСостояниеПользователю()

// Процедура выводит сообщение пользователи и добавляет текст сообщения в протокол.
// 
// Параметры:
//  Текст  - Строка.
//  Статус - СтатусСообщения.
// 
//  РежимСообщений   	  - Строка, по умолчанию "Все";
//  ВестиПротоколЗагрузки - Булево, по умолчанию Ложь.
//  ПротоколЗагрузки 	  - ПолеТекстовогоДокумента, по умолчанию Неопределено.
// 
Процедура СообщитьПользователюИВПротокол(Текст, Статус = Неопределено, РежимСообщений = "Все", 
										 ВестиПротоколЗагрузки = Ложь, ПротоколЗагрузки = Неопределено,
										 СообщатьОбОшибкахЗаписи = Ложь, СообщатьОЗаписиЭлементов = Ложь) Экспорт
    
    ВывестиСообщение = Истина;
    
    Если РежимСообщений = "Ошибка" Тогда
        ВывестиСообщение = СообщатьОбОшибкахЗаписи;
    ИначеЕсли РежимСообщений = "Запись" Тогда 
        ВывестиСообщение = СообщатьОЗаписиЭлементов;
    КонецЕсли;
    
    Если ВывестиСообщение Тогда
        
        ОбщегоНазначения.СообщитьПользователю(Текст);
        
        Если ВестиПротоколЗагрузки Тогда
            ПротоколЗагрузки.ДобавитьСтроку(ПолучитьТекстПоСтатусуДляПротокола(Статус) + Строка(Текст));
        КонецЕсли;
        
    КонецЕсли;
    
КонецПроцедуры // СообщитьПользователюИВПротокол()

#КонецОбласти

#Область РаботаСМетаданными
	
// Функция определяет вид объекта по метаданным объекта.
// 
// Параметры:
//  МетаданныеОбъекта  - ОбъектМетаданных.
// 
// Возвращаемое значение:
//   Результат - Строка (Справочник / Документ / Отчет / Обработка / РегистрСведений).
// 
Функция ПолучитьВидОбъектаПоМетаданным(МетаданныеОбъекта) Экспорт
    
    Результат = "";
    
    Если Метаданные.Справочники.Содержит(МетаданныеОбъекта) Тогда
        Результат = "Справочник";
    ИначеЕсли Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда	
        Результат = "Документ";
    ИначеЕсли Метаданные.Отчеты.Содержит(МетаданныеОбъекта) Тогда
        Результат = "Отчет";
    ИначеЕсли Метаданные.Обработки.Содержит(МетаданныеОбъекта) Тогда
        Результат = "Обработка";
    ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеОбъекта) Тогда
        Результат = "РегистрСведений";
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(МетаданныеОбъекта) Тогда
        Результат = "РегистрБухгалтерии";
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(МетаданныеОбъекта) Тогда
        Результат = "РегистрНакопления";	
    ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеОбъекта) Тогда
        Результат = "ПланВидовХарактеристик";
    КонецЕсли; 
           
    Возврат Результат;
    
КонецФункции // ПолучитьВидОбъектаПоМетаданным()

// Функция получает имя типа объекта.
// 
// Параметры:
//  ТекИмяОбъекта - Строка - Краткое имя объекта
//  ТекВидОбъекта - Строка.
// 
// Возвращаемое значение:
//   Результат - Строка
// 
Функция ПолучитьИмяТипаОбъекта(ТекИмяОбъекта, ТекВидОбъекта) Экспорт
    
	Если ТекВидОбъекта = "Справочник"
		Или ТекВидОбъекта = "Документ"
        Или ТекВидОбъекта = "Перечисление"
		Или ТекВидОбъекта = "ПланВидовХарактеристик"
		Или ТекВидОбъекта = "ПланСчетов"
		Или ТекВидОбъекта = "ПланВидовРасчета" 
		Или ТекВидОбъекта = "ПланОбмена" Тогда
		
        Результат = ТекВидОбъекта + "Ссылка." + ТекИмяОбъекта;
        
    ИначеЕсли ТекВидОбъекта = "Обработка" 
        Или ТекВидОбъекта = "Отчет" Тогда	
        Результат = ТекВидОбъекта + "Объект." + ТекИмяОбъекта;
        
    ИначеЕсли ТекВидОбъекта = "РегистрСведений" Тогда
        Результат = "РегистрСведенийНаборЗаписей." + ТекИмяОбъекта;
    КонецЕсли; 
    
	Возврат Результат;
    
КонецФункции // ПолучитьИмяТипаОбъекта()

// Функция получает полное имя объекта.
// 
// Параметры:
//  ТекИмяОбъекта - Строка - Краткое имя объекта
//  ТекВидОбъекта - Строка.
// 
// Возвращаемое значение:
//   Результат - Строка
// 
Функция ПолучитьПолноеИмяОбъекта(ТекИмяОбъекта, ТекВидОбъекта) Экспорт
	
	Результат = Строка(ТекВидОбъекта) + "." + ТекИмяОбъекта;
    Возврат Результат;
	
КонецФункции // ПолучитьПолноеИмяОбъекта()

// Функция определяет имя объекта ссылочного типа по описанию типов.
// 
// Параметры:
// ОписаниеТипов   - ОписаниеТипов - содержит тип, имя объекта которого нужно определить.
// ИмяКоллекции    - Строка - имя коллекции объектов метаданный: "Справочники","Документы" и т.п.
// НачалоИмениТипа - Строка - начало строкового представления типа : "СправочникСсылка", "ДокументСсылка" и т.п.
// 
// Возвращаемое значение:
//  РезСтруктура   - Структура (Ключи: "Имя","Синоним","ИмяТипа"; Значения: Строка). 
//                   Неопределено (если имя не удалось определить). 
// 
Функция ПолучитьИмяОбъектаПоОписаниюТипов(ОписаниеТипов, ИмяКоллекции, НачалоИмениТипа) Экспорт
    
    РезСтруктура = Неопределено;
    
    Для каждого Мета Из Метаданные[ИмяКоллекции] Цикл
        
        ИмяТипа = НачалоИмениТипа+"."+Мета.Имя;
        Если ОписаниеТипов.СодержитТип(Тип(ИмяТипа)) Тогда
            
            РезСтруктура = Новый Структура;
            РезСтруктура.Вставить("Имя"    ,Мета.Имя);
            РезСтруктура.Вставить("Синоним",Мета.Синоним);
            РезСтруктура.Вставить("ИмяТипа",ИмяТипа);
            
            Прервать;
        КонецЕсли; 
        
    КонецЦикла; 
    
    Возврат РезСтруктура;
    
КонецФункции // ПолучитьИмяОбъектаПоОписаниюТипов()

// Функция получает вид объекта по переданному типу.
// 
// Параметры:
//  ТекТип - Тип.
// 
// Возвращаемое значение:
//  ВидОбъекта - Строка.
// 
Функция ПолучитьВидОбъектаПоТипу(ТекТип) Экспорт
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(ТекТип);
	
	ТекОписание = Новый ОписаниеТипов(МассивТипов);
	ТекЗначение = ТекОписание.ПривестиЗначение();
	
	ВидОбъекта = "";
	
	Если ЗначениеПринадлежитКоллекцииМетаданных("Справочники", ТекЗначение) Тогда
		ВидОбъекта = "Справочник";
		
	ИначеЕсли ЗначениеПринадлежитКоллекцииМетаданных("Документы", ТекЗначение) Тогда        
		ВидОбъекта = "Документ";
		
	ИначеЕсли ЗначениеПринадлежитКоллекцииМетаданных("Перечисления", ТекЗначение) Тогда
		ВидОбъекта = "Перечисление";
		
	ИначеЕсли ЗначениеПринадлежитКоллекцииМетаданных("ПланыВидовХарактеристик", ТекЗначение) Тогда        
		ВидОбъекта = "ПланВидовХарактеристик";
		
	ИначеЕсли ЗначениеПринадлежитКоллекцииМетаданных("ПланыСчетов", ТекЗначение) Тогда        
		ВидОбъекта = "ПланСчетов";
		
	ИначеЕсли ЗначениеПринадлежитКоллекцииМетаданных("ПланыВидовРасчета", ТекЗначение) Тогда        
		ВидОбъекта = "ПланВидовРасчета";
		
	ИначеЕсли ЗначениеПринадлежитКоллекцииМетаданных("ПланыОбмена", ТекЗначение) Тогда        
		ВидОбъекта = "ПланОбмена";
		
	Иначе
		ВидОбъекта = "Все";
		
	КонецЕсли;
	
	Возврат ВидОбъекта;
	
КонецФункции // ПолучитьВидОбъектаПоТипу()

 // Функция определяет принадлежит значение коллекции метаданных или нет.
// 
// Параметры:
//  ИмяКоллекции  - Строка.
//  ТекущееЗначение - ЛюбаяСсылка.
// 
// Возвращаемое значение:
//   ПринадлежитКоллекции - Булево.
// 
Функция ЗначениеПринадлежитКоллекцииМетаданных(ИмяКоллекции,ТекущееЗначение) Экспорт
	
	Если ЭтоПримитивныйТип(ТекущееЗначение) Тогда
	
		ПринадлежитКоллекции = Ложь;
	
	Иначе
		
		ПринадлежитКоллекции = Метаданные[ИмяКоллекции].Найти(ТекущееЗначение.Метаданные().Имя) <> Неопределено;
				
	КонецЕсли; 
	
	Возврат ПринадлежитКоллекции;

КонецФункции // ЗначениеПринадлежитКоллекцииМетаданных()

// Функция определяет принадлежит ли тип переданного значения к примитивным типам.
// 
// Параметры:
// 	ТекущееЗначение - любое значение.
// 
// Возвращаемое значение:
// 	ПримитивныйТип - булево.
// 
Функция ЭтоПримитивныйТип(ТекущееЗначение) Экспорт
	
	ПримитивныйТип = Ложь;
	
	Если ТипЗнч(ТекущееЗначение) = Тип("Строка") 
		 ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Число")
		 ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Дата")
		 ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Булево")
		 ИЛИ ТипЗнч(ТекущееЗначение) = Тип("ХранилищеЗначения")	
		 ИЛИ ТипЗнч(ТекущееЗначение) = Тип("УникальныйИдентификатор")
		 ИЛИ ТекущееЗначение = Неопределено
		 ИЛИ ТекущееЗначение = NULL Тогда
	
		ПримитивныйТип = Истина;
	
	КонецЕсли;
	
	Возврат ПримитивныйТип;
	
КонецФункции

#КонецОбласти

#Область Проверки
	
// Проверяет правильность заполнения шапки объекта.
// Если какой-то из реквизтов шапки, влияющий на выполнение действия не заполнен,
// то выставляется флаг отказа в выполнении действия.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
// 
// Параметры: 
//  Объект                     - проверяемый объект, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                      - Флаг отказа в выполнении действия.
//  Заголовок                  - строка, заголовок сообщения об ошибке выполнения действия.
// 
Процедура ПроверитьЗаполнениеШапкиОбъекта(Объект, СтруктураОбязательныхПолей, Отказ = Ложь, Заголовок = "") Экспорт

	МетаданныеРеквизиты = Объект.Метаданные().Реквизиты;

	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = Объект[КлючЗначение.Ключ];
		ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();

		Если НЕ ЗначениеЗаполнено(Значение) Тогда 

			Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда 
				СтрокаСообщения = "Не заполнено значение реквизита """ + СокрЛП(ПредставлениеРеквизита) + """!";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;

			ОшибкаПриВыполненииДействия(СтрокаСообщения, Отказ, Заголовок);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеШапкиОбъекта()

// Процедура проверяет правильность заполнения настройки загрузки.
// 
// Параметры:
//  ПравилаЗагрузки        - ТаблицаЗначений, правила загрузки для проверки.
//  СтруктураСвойствОбъекта - Структура, СтрокаТаблицыЗначений (Состав: ВидОбъекта, ИмяОбъекта).
// 
//  Отказ - Булево, флаг ошибки в правилах загрузки.
// 
Процедура ПроверитьПравильностьЗаполненияНастройкиЗагрузки(Знач ПравилаЗагрузки, СтруктураСвойствОбъекта, Отказ, Заголовок = "") Экспорт
    
    Если ПравилаЗагрузки.Количество() = 0
        Или Отказ Тогда
        // Проверять не чего.
        Возврат;
    КонецЕсли;
    
    // Проверим правильность заполненности правил загрузки.
    ПроверитьТабЧатьПравилаЗагрузкиПоСтрочно(ПравилаЗагрузки, СтруктураСвойствОбъекта, Отказ, Заголовок);
    
    Если Не Отказ Тогда
        
        СтруктураОбязательныхПолей = Новый Структура("ИмяРеквизита", "Имя реквизита");
		
		Если Не ПравилаЗагрузки.Найти("Без_Сопоставления", "ИмяРеквизита") = Неопределено Тогда
			
			КолВоСтрока = ПравилаЗагрузки.Количество();
			
			// Удалим строки со значением "Без_Сопоставления".
			Для Ном = 1 По КолВоСтрока Цикл
				
				ТекСтрока = ПравилаЗагрузки[КолВоСтрока - Ном];
				
				Если ТекСтрока.ИмяРеквизита = "Без_Сопоставления" Тогда
					ПравилаЗагрузки.Удалить(ТекСтрока);
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		МассивВидовДанных = УдалитьПовторяющиесяЭлементыМассива(ПравилаЗагрузки.ВыгрузитьКолонку("ВидДанных"));
		
		Для Каждого ТекВидДанных Из МассивВидовДанных Цикл
			
			СтрокиДляПроверки = ПравилаЗагрузки.НайтиСтроки(Новый Структура("ВидДанных", ТекВидДанных));
			
			// Проверим наличие дублей в таблице значений "ПравилаЗагрузки".
			ПроверитьДублированиеЗначенийВТаблице(СтрокиДляПроверки, СтруктураОбязательныхПолей, "Правила загрузки", Отказ, Заголовок);
			
		КонецЦикла;
		
		// Если Не Отказ 
		// 	И Не ВРег(СтруктураСвойствОбъекта.ВидОбъекта) = ВРег("РегистрСведений") Тогда
		Если Не Отказ 
			И Не ВРег(СтруктураСвойствОбъекта.ВидОбъекта) = ВРег("РегистрСведений")
			И Не СтруктураСвойствОбъекта.ИспользоватьНестандартныйАлгоритмПоиска Тогда
            
            // Проверим указано хоть одно ключевое поле.
			Если ПравилаЗагрузки.Найти(Истина, "КлючевоеПоле") = Неопределено Тогда
                СообщитьОбОшибке("На закладке ""Ключевые поля"" не указано ни одного ключевого поля для поиска объекта в ИБ!", Отказ, Заголовок);
            КонецЕсли;
            
        КонецЕсли;
        
    КонецЕсли;
    
КонецПроцедуры // ПроверитьПравильностьЗаполненияНастройкиЗагрузки()

#КонецОбласти 

#Область ОбработкаОшибок

// Функция убирает из текста сообщения слущебную информацию.
// 
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения.
// 
// Возвращаемое значение:
//   Строка.
// 
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // СформироватьТекстСообщения()

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
// 
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
// 
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено, ВызыватьИсключение = Истина) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ВызыватьИсключение Тогда
			Если ЗначениеЗаполнено(Заголовок) Тогда
				ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
				Заголовок = "";
			КонецЕсли;			
			ВызватьИсключение (ТекстСообщения);
		КонецЕсли;
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ОбщегоНазначения.СообщитьПользователю(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

// Формирует сообщение при ошибках выполнения действия.
// 
// Параметры: 
//  ТекстСообщения - Исходный текст, выводимого сообщения,
//  Отказ          - Флаг отказа в выполнении действия,
//  Заголовок      - Заголовок начала серии сообщений об ошибках выполнения действия (не обязательный).
// 
Процедура ОшибкаПриВыполненииДействия(ТекстСообщения, Отказ, Заголовок="") Экспорт

	СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);

КонецПроцедуры // ОшибкаПриВыполненииДействия()

#КонецОбласти

#Область РаботаСМассивами

// Удалает повторяющиеся элементы массива.
// 
// Параметры:
//  Массив                     - Массив.
//  НеИспользоватьНеопределено - Булево.
// 
// Возвращаемое значение:
//  Массив - Массив.
// 
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМасссиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМасссиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

#КонецОбласти

#Область РаботаСоСтроками

// Функция удаляет из строки символ с кодом 160.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
// 
// Возвращаемое значение:
//  Результат - Строка.
// 
Функция УбитьНеразрывныйПробел(ИсходнаяСтрока) Экспорт
	
	ИнтересныйСимвол = Символ(160); 
	Результат = СтрЗаменить(ИсходнаяСтрока, ИнтересныйСимвол, "");
	
	Возврат Результат;
	
КонецФункции // УбитьНеразрывныйПробел()

// Функция удаляет из строки символ с кодом 160 и пробелы.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
// 
// Возвращаемое значение:
//  Результат - Строка.
// 
Функция УбитьЛишнее(ИсходнаяСтрока) Экспорт
	
	ИнтересныйСимвол = Символ(160); 
	Результат = СтрЗаменить(ИсходнаяСтрока, ИнтересныйСимвол, "");
	
	// И на всякий случай просто пробелы
	Результат = СтрЗаменить(Результат, " ", "");
	
	Возврат Результат;
	
КонецФункции // УбитьЛишнее()

// Восстанавливает дату по строке.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
// 
// Возвращаемое значение:
//  Результат - Дата.
// 
Функция ПолучитьДату(ИсходнаяСтрока) Экспорт
    
    Если НЕ ЗначениеЗаполнено(ИсходнаяСтрока) Тогда
        Результат = Дата('00010101');
    Иначе	
        СтрДень  = Лев(ИсходнаяСтрока , 2);
        СтрМесяц = Сред(ИсходнаяСтрока, 4, 2);
        СтрГод   = Сред(ИсходнаяСтрока, 7, 4);
        
        Если СтрДлина(СтрГод) = 2 Тогда
            СтрГод = "20" + СтрГод;
        КонецЕсли; 
        
        ТекДатаСтр = СтрГод + СтрМесяц + СтрДень;
        
        Попытка
            Результат = Дата(ТекДатаСтр);
        Исключение
            Результат = Дата('00010101');
        КонецПопытки;
        
    КонецЕсли; 
    
    Возврат Результат;
    
КонецФункции // ПолучитьДату()

// Восстанавливает число по строке.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
// 
// Возвращаемое значение:
//   Результат - Число.
// 
Функция ПолучитьЧисло(ИсходнаяСтрока) Экспорт

    Если НЕ ЗначениеЗаполнено(ИсходнаяСтрока) Тогда
        Результат = 0;
    Иначе
        Попытка
            Результат = Число(ИсходнаяСтрока);	
        Исключение
            Результат = 0;
        КонецПопытки;
    КонецЕсли; 
    
    Возврат Результат;
    
КонецФункции // ПолучитьЧисло()

// Восстанавливает булево по строке.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
// 
// Возвращаемое значение:
//   Результат - Булево.
// 
Функция ПолучитьБулево(ИсходнаяСтрока) Экспорт

    Если НЕ ЗначениеЗаполнено(ИсходнаяСтрока) Тогда
        Результат = Ложь;
    Иначе
		
		ИсходноеЗначение = ВРег(СокрЛП(ИсходнаяСтрока));
		
		Результат = ?(ИсходноеЗначение 	  = "1" 
					 Или ИсходноеЗначение = "ИСТИНА"
					 Или ИсходноеЗначение = "ДА"
					 Или ИсходноеЗначение = "YES", Истина, Ложь);
    КонецЕсли; 
    
    Возврат Результат;
    
КонецФункции // ПолучитьБулево()

// Функция Восстанавливает значение в указанном типе (простейшем) по строке.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
// 
// Возвращаемое значение:
//   Результат - Строка, Дата, Число, Булево.
// 
Функция ПолучитьЗначениеСтрокиВУказанномТипе(ИсходнаяСтрока, ТипДляПреобразования) Экспорт
	
	СтрокаТип = Строка(ТипДляПреобразования);
	
	Если СтрокаТип = "Строка" Тогда
		Результат = УбитьНеразрывныйПробел(СокрЛП(ИсходнаяСтрока));
		
	ИначеЕсли СтрокаТип = "Дата" Тогда
		Результат = ПолучитьДату(УбитьЛишнее(СокрЛП(ИсходнаяСтрока)));
		
	ИначеЕсли СтрокаТип = "Число" Тогда
		Результат = ПолучитьЧисло(УбитьЛишнее(СокрЛП(ИсходнаяСтрока)));
		
	ИначеЕсли СтрокаТип = "Булево" Тогда
		Результат = ПолучитьБулево(УбитьНеразрывныйПробел(СокрЛП(ИсходнаяСтрока)));
	Иначе
		
		Результат = ИсходнаяСтрока;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьЗначениеСтрокиВУказанномТипе()

#КонецОбласти

#Область УправлениеОбработкой

// Функция получает настройку загрузки из Excel для объекта.
// 
// Параметры:
//  ВидОбъекта - Строка  (Справочник/Документ/...).
//  ИмяОбъекта - Строка.
// 
// Возвращаемое значение.
//  НастройкаДляЗагрузки - СправочникСсылка.бит_НастройкиЗагрузкиИзExcel.
// 
Функция ПолучитьНастройкуЗагрузкиИзExcelДляОбъекта(ВидОбъекта, ИмяОбъекта)  Экспорт
    
    // Получаем значения по которым будет производится отбор в запросе.
    ИмяОбъектаПолное = ПолучитьПолноеИмяОбъекта(ИмяОбъекта, ВидОбъекта);
    
    Запрос = Новый Запрос;
    Запрос.УстановитьПараметр("ВидОбъекта"      , ВидОбъекта);
    Запрос.УстановитьПараметр("ИмяОбъекта"      , ИмяОбъекта);
    Запрос.УстановитьПараметр("ИмяОбъектаПолное", ИмяОбъектаПолное);
    
    Запрос.Текст = "ВЫБРАТЬ
        |    бит_НастройкиЗагрузкиИзExcel.Ссылка,
        |    бит_НастройкиЗагрузкиИзExcel.ОсновнаяНастройка
        |ИЗ
        |    Справочник.бит_НастройкиЗагрузкиИзExcel КАК бит_НастройкиЗагрузкиИзExcel
        |ГДЕ
        |    бит_НастройкиЗагрузкиИзExcel.ВидОбъекта = &ВидОбъекта
        |    И бит_НастройкиЗагрузкиИзExcel.ИмяОбъекта = &ИмяОбъекта
        |    И бит_НастройкиЗагрузкиИзExcel.ИмяОбъектаПолное = &ИмяОбъектаПолное";
        
    Выборка = Запрос.Выполнить().Выбрать();
    
    Если Выборка.НайтиСледующий(Новый Структура("ОсновнаяНастройка", Истина)) Тогда
        НастройкаДляЗагрузки = Выборка.Ссылка;
    Иначе
        
        Если Выборка.Следующий() Тогда
            НастройкаДляЗагрузки = Выборка.Ссылка;
        Иначе
            НастройкаДляЗагрузки = Справочники.бит_НастройкиЗагрузкиИзExcel.ПустаяСсылка();
        КонецЕсли;
        
    КонецЕсли;
    
    Возврат НастройкаДляЗагрузки;
    
КонецФункции // ПолучитьНастройкуЗагрузкиИзExcelДляОбъекта()

#КонецОбласти 

#Область ПроверкаДублей
	
// Процедура проверяет наличие дублей значений в таблице.
// Если значение какого-то из реквизтов, влияющего на выполнение действия продублировано,
// то выставляется флаг отказа в выполнении действия.
// 
// Параметры:
//  ТаблицаДляПроверки          - ТаблицаЗначений, для проверки дублирования строк
//  СтруктураОбязательныхПолей  - структура, содержащая имена полей, которые собственно и надо проверить.
//  ПредставлениеТабличнойЧасти - строка, название табличной части для вывода пользователю.
// 
//  Отказ                       - флаг отказа в проведении.
//  Заголовок                   - строка, заголовок сообщения об ошибке выполнения действия,
//                                по умолчанию пустая строка.
// 
Процедура ПроверитьДублированиеЗначенийВТаблице(ТаблицаДляПроверки, СтруктураОбязательныхПолей, 
                                            	ПредставлениеТабличнойЧасти, Отказ, Заголовок = "") Экспорт

	ПредставлениеТабЧасти = ПредставлениеТабличнойЧасти;
	
	Если ТипЗнч(ТаблицаДляПроверки) = Тип("Массив") Тогда
		ТабличнаяЧасть = ТаблицаДляПроверки;
	Иначе
		ТабличнаяЧасть = ТаблицаДляПроверки.Скопировать();
	КонецЕсли;
    
    СписокТаблиц = Новый Структура;
    
    ТаблицаСтрок = Новый ТаблицаЗначений;
    ТаблицаСтрок.Колонки.Добавить("Значение");
    ТаблицаСтрок.Колонки.Добавить("НомераСтрок");
    
    // Цикл по проверяемым полям
    Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл
        
        ТекущийКлюч = КлючЗначение.Ключ;
        
        ТаблицаСтрок.Очистить();
        
        МассивТекЗначений = Новый Массив;
        
        // Цикл по строкам табличной части.
        Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
            
            Значение = СтрокаТаблицы[ТекущийКлюч];
            
            НайденноеЗначение = МассивТекЗначений.Найти(Значение);
            
            Если НайденноеЗначение = Неопределено Тогда
                МассивТекЗначений.Добавить(Значение);
            Иначе
                НовСтрока = ТаблицаСтрок.Добавить();
                НовСтрока.Значение    = Значение;
                НовСтрока.НомераСтрок = СтрокаТаблицы.НомерСтроки;
            КонецЕсли;
            
        КонецЦикла;
        
        Если ТаблицаСтрок.Количество() > 0 Тогда
            СписокТаблиц.Вставить(ТекущийКлюч, ТаблицаСтрок);
        КонецЕсли;
        
    КонецЦикла;
    
    Для Каждого КлючЗначение ИЗ СписокТаблиц Цикл
        
        ТаблицаСДанными = КлючЗначение.Значение;
        
        // Получаем таблицу с данными для вывода пользователю на экран.
        ТаблицаДляВывода = ПроставитьНомераСтрокДляЗначений(ТаблицаСДанными);
        
        // Получаем представление реквизита из структуры.
        ПредставлениеРеквизита = СтруктураОбязательныхПолей[КлючЗначение.Ключ];
		
		ТекстСообщения = НСтр("ru = 'В табличной части ""%1"", дублируются значения колонки ""%2"" в строках:'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ПредставлениеТабЧасти, ПредставлениеРеквизита);
        СообщитьОбОшибке(ТекстСообщения, Отказ, Заголовок);
        
        Для Каждого ТекСтрока Из ТаблицаДляВывода Цикл
            ОбщегоНазначения.СообщитьПользователю("     """ + ТекСтрока.Значение + """ - " + ТекСтрока.НомераСтрок);
        КонецЦикла;
        
    КонецЦикла;
    
КонецПроцедуры // ПроверитьДублированиеЗначенийВТабличнойЧасти()

#КонецОбласти

#Область РаботаСExcel

// Функция создает COMОбъект - "Excel.Application".
// 
// Параметры:
//  Отказ 		- Булево, по умолчанию Ложь.
//  ЭтоЗагрузка - Булево, признак инициализации Excel для чтения, по умолчанию Ложь.
// 
// Возвращаемое значение:
//   Excel - ComObject("Excel.Application"), в случае неудачи Неопределено.
// 
Функция СоздатьПриложениеExcel(Отказ = Ложь, ЭтоЗагрузка = Ложь,ВестиПротокол=Ложь,Протокол=Неопределено) Экспорт
	
	Попытка
		
		// Загрузка Microsoft Excel.
		ВывестиСостояниеПользователю("Загрузка Microsoft Excel...");
		Excel = Новый COMОбъект("Excel.Application");
		
		Если ЭтоЗагрузка Тогда
			Excel.DisplayAlerts = False;
		КонецЕсли;
	
	Исключение
		Отказ = Истина;
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстСообщения = НСтр("ru = 'Ошибка загрузки Microsoft Excel.
									|Необходимо проверить установку и настройки Microsoft Excel на сервере 1С.'");
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Ошибка загрузки Microsoft Excel на сервере 1С.'"), ОбщегоНазначения.КодОсновногоЯзыка(), 
			УровеньЖурналаРегистрации.Ошибка,,, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Excel;
	
КонецФункции // СоздатьПриложениеExcel()

// Функция открывает Excel файл.
// 
// Параметры:
//  Excel	   - ComObject("Excel.Application").
//  ПутьКФайлу - Строка, полный путь где лежит файл.
//  Отказ 	   - Булево, по умолчанию Ложь.
// 
// Возвращаемое значение:
//   ExcelФайл - ComObject, в случае неудачи Неопределено.
// 
Функция ОткрытьExcelФайл(Excel, ПутьКФайлу, Отказ = Ложь,ВестиПротокол=Ложь,Протокол=Неопределено) Экспорт
	
	Попытка
        // Открытие файла Microsoft Excel
        ВывестиСостояниеПользователю(НСтр("ru = 'Открытие файла Microsoft Excel...'"));
        ExcelФайл = Excel.WorkBooks.Open(ПутьКФайлу);
	Исключение
		Отказ = Истина;
		ТекстСообщения = НСтр("ru = 'Ошибка при открытии файла: %1.'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ПутьКФайлу);
        ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
        СообщитьПользователюИВПротокол(ТекстСообщения + Символы.ПС + ОписаниеОшибки(), СтатусСообщения.Важное,,ВестиПротокол,Протокол);
		Возврат Неопределено;
    КонецПопытки;
	
	Возврат ExcelФайл;
	
КонецФункции // ОткрытьExcelФайл()

// Функция возвращает список листов в файле Excel.
// 
// Параметры:
//  ExcelФайл - ComObject.
//  Отказ 	  - Булево, по умолчанию Ложь.
// 
//  СообщатьОбОшибке - Булево, по умолчанию Истина.
//  ДопСообщение     - Строка, текст дополнительного сообщения для вывода в случае неудачи,
// 					   по умолчанию "".
// 
// Возвращаемое значение:
//   МассивЛистов - Массив, в случае неудачи Неопределено.
// 
Функция ПолучитьСписокЛистовExcel(ExcelФайл, Отказ = Ложь, 
						 СообщатьОбОшибке = Истина, ДопСообщение = "") Экспорт
	
						 
	МассивЛистов = Новый Массив();
	Попытка
		// Открытие листа файла Microsoft Excel.
        ВывестиСостояниеПользователю(НСтр("ru = 'Получение списка листов файла Microsoft Excel...'"));
		Для Каждого ТекЛист Из ExcelФайл.Sheets Цикл
			МассивЛистов.Добавить(ТекЛист.Name);
		КонецЦикла;
	Исключение
		
		Отказ = Истина;
		
		Если СообщатьОбОшибке Тогда
			
			ТекстСообщения = НСтр("ru = 'Ошибка получения списка листов книги MS Excel. Описание ошибки: %1'");
			ТекстСообщения = СтрШаблон(ТекстСообщения, ОписаниеОшибки());
	        ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
			Если ПустаяСтрока(ДопСообщение) Тогда
				ОбщегоНазначения.СообщитьПользователю("	" + ДопСообщение);	
			КонецЕсли;
			
		КонецЕсли;
		
        Возврат Неопределено;
    КонецПопытки;
	
	Возврат МассивЛистов;
	
КонецФункции // ПолучитьСписокЛистовExcel()

// Функция открывает Excel лист.
// 
// Параметры:
//  ExcelФайл - ComObject.
//  ИмяЛиста  - Строка, имя листа для открытия.
//  Отказ 	  - Булево, по умолчанию Ложь.
// 
//  СообщатьОбОшибке - Булево, по умолчанию Истина.
//  ДопСообщение     - Строка, текст дополнительного сообщения для вывода в случае неудачи,
// 					   по умолчанию "".
// 
// Возвращаемое значение:
//   ExcelЛист - ComObject, в случае неудачи Неопределено.
// 
Функция ОткрытьExcelЛист(ExcelФайл, ИмяЛиста, Отказ = Ложь, 
						 СообщатьОбОшибке = Истина, ДопСообщение = "") Экспорт
	
	// Указываем лист в книге для получения данных.
	Попытка
		// Открытие листа файла Microsoft Excel.
        ВывестиСостояниеПользователю(НСтр("ru = 'Открытие листа файла Microsoft Excel...'"));
        ExcelЛист = ExcelФайл.Sheets(ИмяЛиста);
	Исключение
		
		Отказ = Истина;
		
		Если СообщатьОбОшибке Тогда
			
			ТекстСообщения = НСтр("ru = 'Лист с именем ""%1"" в файле не найден.'");
			ТекстСообщения = СтрШаблон(ТекстСообщения, ИмяЛиста);
        	ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
			Если ПустаяСтрока(ДопСообщение) Тогда
				ОбщегоНазначения.СообщитьПользователю("	" + ДопСообщение);	
			КонецЕсли;
			
		КонецЕсли;
		
        Возврат Неопределено;
    КонецПопытки;
	
	Возврат ExcelЛист;
	
КонецФункции // ОткрытьExcelЛист()

// Функция закрывает открытый файл Excel.
// 
// Параметры:
//  ExcelФайл - ComObject.
// 
// Возвращаемое значение:
//  ФайлЗакрыт - Булево.
// 
Функция ЗакрытьExcelФайл(ExcelФайл) Экспорт
	
	ФайлЗакрыт = Истина;
	
	Попытка 
        ExcelФайл.Close();
	Исключение                 
		ФайлЗакрыт = Ложь;
        ТекстСообщения = НСтр("ru = 'Не удалось закрыть файл источник %1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ОписаниеОшибки());
        ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
    КонецПопытки;
	
	Возврат ФайлЗакрыт;
	
КонецФункции // ЗакрытьExcelФайл()

// Функция закрывает приложение Excel.
// 
// Параметры:
//  Excel 		- ComObject("Excel.Application").
//  ЭтоЗагрузка - Булево, признат что Excel был открыт для чтения, по умолчанию Ложь.
// 
// Возвращаемое значение:
//  ExcelЗакрыт - Булево.
// 
Функция ЗакрытьПриложениеExcel(Excel, ЭтоЗагрузка = Ложь) Экспорт
	
	ExcelЗакрыт = Истина;
	
	Попытка 
		
		Если ЭтоЗагрузка Тогда
			Excel.DisplayAlerts = True;		
		КонецЕсли;
		
        Excel.Quit();
		
	Исключение                 
		ExcelЗакрыт = Ложь;
		ТекстСообщения = НСтр("ru = 'Не удалось закрыть приложение Excel %1'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ОписаниеОшибки());
        ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
    КонецПопытки;
	
	Возврат ExcelЗакрыт;
	
КонецФункции // ЗакрытьПриложениеExcel()

// Функция формирует структуру с таблицами значений данных из Excel для загружаемых объектов.
// 	Есть адаптация данной процедуры для работы на клиенте в модуле формы обработки бит_ИмпортОбъектовИзExcel.
// 
// Параметры:
// 
//  ТаблицаОбъектов - ТаблицаЗначений, объекты для которых необходимо получить данные.
//                    Обязательные колонки:
// 					   		ИмяЗакладкиВExcel - Строка, имя страницы с которой необходимо считать данные.
// 					   		ИмяОбъекта		  - Строка, имя объекта для которого осущ. загрузка.
//                     		ОтображаемоеИмя   - Строка, имя для вывода сообщений пользователю.
// 							ВидОбъекта		  - Строка, "Справочник, Документ".
// 
//  СтруктураПараметров - Структура.
//                         Обязательные ключи:
// 								ФайлИсточник - Строка, путь к файлу для загрузки.
// 
//  Отказ           - Булево.
// 
// Возвращаемое значение:
//  Данные - Структура.
// 			  Состав: Ключ 	   - имя объекта.
// 			  		  Значение - ТаблицаЗначений.
// 
Функция ПолучитьДанныеИзExcelПоНастройкеДляЗагрузки(ТаблицаОбъектов, СтруктураПараметров, Отказ) Экспорт
	
	// Получаем данные из структуры параметров.
	ФайлИсточник	 		   = СтруктураПараметров.ФайлИсточник;
	
	ПротоколЗагрузки 		   = ?(СтруктураПараметров.Свойство("ПротоколЗагрузки"), 
						 		   СтруктураПараметров.ПротоколЗагрузки, Неопределено);
							  
	СоотвПредстОбъектов   	   = ?(СтруктураПараметров.Свойство("СоотвПредстОбъектов"), 
							  	   СтруктураПараметров.СоотвПредстОбъектов, 
							       бит_ОбменДаннымиЭксельКлиентСервер.ПолучитьСоответствиеПредставленийВидовОбъектов());
								   
	ЗаписатьИзменения		   = ?(СтруктураПараметров.Свойство("ЗаписатьИзменения"), 
							  	   СтруктураПараметров.ЗаписатьИзменения, Ложь);
							  
	ВестиПротоколЗагрузки 	   = ?(СтруктураПараметров.Свойство("ВестиПротоколЗагрузки"), 
							  	   СтруктураПараметров.ВестиПротоколЗагрузки, Ложь);
							  
	СообщатьОбОшибкахЗаписи    = ?(СтруктураПараметров.Свойство("СообщатьОбОшибкахЗаписи"), 
								   СтруктураПараметров.СообщатьОбОшибкахЗаписи, Ложь);
							  
	СообщатьОЗаписиЭлементов   = ?(СтруктураПараметров.Свойство("СообщатьОЗаписиЭлементов"), 
							       СтруктураПараметров.СообщатьОЗаписиЭлементов, Ложь);
								 
	МассивНеРазрешимыхСимволов = ?(СтруктураПараметров.Свойство("МассивНеРазрешимыхСимволов"), 
							       СтруктураПараметров.МассивНеРазрешимыхСимволов, Неопределено);
								   
	НомерНачальнойКолонки 	   = ?(СтруктураПараметров.Свойство("НомерНачальнойКолонки"), 
							  	   СтруктураПараметров.НомерНачальнойКолонки, 1);
							  
	НомерНачальнойСтроки  	   = ?(СтруктураПараметров.Свойство("НомерНачальнойСтроки"), 
							  	   СтруктураПараметров.НомерНачальнойСтроки, 1);
								   
	НомерКонечнойСтроки  	   = ?(СтруктураПараметров.Свойство("НомерКонечнойСтроки"), 
							  	   СтруктураПараметров.НомерКонечнойСтроки, 0);
								   
	БыстроеСчитываниеДанных    = ?(СтруктураПараметров.Свойство("БыстроеСчитываниеДанных"), 
							  	   СтруктураПараметров.БыстроеСчитываниеДанных, Истина);
								   
	// Если номер начальной строки и колонки равны 1, тогда быстрое считывание данных разрешено.
	БыстроеСчитываниеДанных	   = ?(НомерНачальнойСтроки = 1 И НомерНачальнойКолонки = 1 И НомерКонечнойСтроки = 0,
								   БыстроеСчитываниеДанных, Ложь);
								   
	// Создадим приложение Excel.
	Excel = СоздатьПриложениеExcel(Отказ, Истина, ВестиПротоколЗагрузки, ПротоколЗагрузки);
	
	Если Excel = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Откроем указанный файл.
	ExcelФайл = ОткрытьExcelФайл(Excel, ФайлИсточник, Отказ, ВестиПротоколЗагрузки, ПротоколЗагрузки);
	
    Если ExcelФайл = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

    Данные = Новый Структура;
    
    // Перебираем "ТаблицаОбъектов"
    Для Каждого ТекСтрока ИЗ ТаблицаОбъектов Цикл
		
		// Получаем имя листа.
		ИмяЛиста = ТекСтрока.ИмяЗакладкиВExcel;
		
		// Откроем лист Excel.
		ExcelЛист = ОткрытьExcelЛист(ExcelФайл, ИмяЛиста, Отказ, Ложь); 
		
		Если ExcelЛист = Неопределено Тогда
			
			// Сообщим пользователю и в протокол.
            СообщитьПользователюИВПротокол("Лист с именем """ + ИмяЛиста + """ в файле источнике не найден!", 
										   СтатусСообщения.Важное,, ВестиПротоколЗагрузки, ПротоколЗагрузки,
										   СообщатьОбОшибкахЗаписи, СообщатьОЗаписиЭлементов);	
										   
            СообщитьПользователюИВПротокол("Загрузка " + СоотвПредстОбъектов.Получить(ВРег(ТекСтрока.ВидОбъекта)) 
										   + " """ + ТекСтрока.ОтображаемоеИмя + """ не выполнена!", СтатусСообщения.Информация,,
										   ВестиПротоколЗагрузки, ПротоколЗагрузки, СообщатьОбОшибкахЗаписи, СообщатьОЗаписиЭлементов);	
            
            Данные.Вставить(ТекСтрока.ИмяОбъекта, Новый ТаблицаЗначений);
			
			Продолжить;
		КонецЕсли;
		
        ВывестиСостояниеПользователю("Получение данных для " + СоотвПредстОбъектов.Получить(ВРег(ТекСтрока.ВидОбъекта)) + " """ + ТекСтрока.ОтображаемоеИмя + """...");
		
		ИмяЛистаИсточник = бит_ПроформыКлиентСервер.ListSourceSheetName();
		Попытка
			ЛистИсточникСписков = ExcelФайл.Sheets(ИмяЛистаИсточник);
			ЕстьСписки = Истина;
		Исключение
			ЕстьСписки = Ложь;
		КонецПопытки;
		
		Если ЕстьСписки Тогда
			// Чтение источников выпадающих списков
			СпискиИсточники = бит_ПроформыКлиентСервер.ПрочитатьСпискиИсточники(ExcelФайл);
		Иначе
			СпискиИсточники = Новый Соответствие;
		КонецЕсли;
		
        // Получаем таблицу значения для объекта.
        СтруктураДанных = бит_ОбменДаннымиЭксельКлиентСервер.ПолучитьТаблицуДанных(ExcelЛист, ТекСтрока, НомерНачальнойКолонки, НомерНачальнойСтроки, 
												МассивНеРазрешимыхСимволов, БыстроеСчитываниеДанных, НомерКонечнойСтроки);
        
        Данные.Вставить(ТекСтрока.ИмяОбъекта, СтруктураДанных.ТаблицаДанных);
		Данные.Вставить("НастройкиКолонок", СтруктураДанных.НастройкиКолонок);
		Данные.Вставить("СпискиИсточники", СпискиИсточники);
		
    КонецЦикла;
	
	// Закроем открытый файл.
	ФайлЗакрыт = ЗакрытьExcelФайл(ExcelФайл);
	
	// Закроем приложение Excel.
	ExcelЗакрыт = ЗакрытьПриложениеExcel(Excel, Истина);
	
	Если Не ФайлЗакрыт Или Не ExcelЗакрыт Тогда
        мЗаписатьИзменения = Ложь;
    КонецЕсли;
	
    Возврат Данные;
    
КонецФункции // ПолучитьДанныеИзExcelПоНастройкеДляЗагрузки()

#КонецОбласти

#Область ОформлениеExcel
	
// Процедура устанавливает шрифт для текущего листа Excel.
// 
// Параметры:
//  Excel 		 - ComObject("Excel.Application").
//  РазмерШрифта - Число.
// 
Процедура УстановитьШрифтДляТекущегоЛиста(Excel, РазмерШрифта) Экспорт
	
	// Выделим все ячейки текущего листа.
	Excel.Cells.Select();
	
	// Установим указанный размер шрифта.
	Excel.Selection.Font.Size = РазмерШрифта;
	
	// Спозиционируемся на позиции А1.
	Excel.Range("A1").Select();
	
КонецПроцедуры // УстановитьШрифтДляТекущегоЛиста()

// Процедура устанавливает границы для ячейки.
// 
// Параметры:
//  ExcelЯчейка - ComObject, Ячейка страницы Excel.
// 
//  Левую	- Бюлево, по умолчанию Истина;
//  Правую	- Бюлево, по умолчанию Истина;
//  Нижную	- Бюлево, по умолчанию Истина;
//  Верхную - Бюлево, по умолчанию Истина;
// 
Процедура Удалить_УстановитьГраницыДляЯчейки(ExcelЯчейка, 
									 Левую   = Истина, 
									 Правую  = Истина, 
									 Нижную  = Истина, 
									 Верхную = Истина) Экспорт
	
	Если Левую Тогда
		// Устанавливаем левую границу.
		ExcelЯчейка.Borders(7).LineStyle  = 1.5;
	КонецЕсли;
	
	Если Правую Тогда
		// Устанавливаем правую границу.
		ExcelЯчейка.Borders(10).LineStyle = 1.5;
	КонецЕсли;
	
	Если Нижную Тогда
		// Устанавливаем нижнюю границу.
		ExcelЯчейка.Borders(9).LineStyle  = 1.5;
	КонецЕсли;
	
	Если Верхную Тогда
		// Устанавливаем верхнюю границу.
		ExcelЯчейка.Borders(8).LineStyle  = 1.5;
	КонецЕсли;

КонецПроцедуры // Удалить_УстановитьГраницыДляЯчейки()

// Процедура устанавливает границы для ячеек (таблицы).
// 
// Параметры:
//  Excel     - ComObject("Excel.Application").
//  НачЯчейка - ComObject, ячейка для начала выделения диапазона ячеек.
//  КонЯчейка - ComObject, ячейка для окончания выделения диапазона ячеек.
// 
//  Левую	- Бюлево, по умолчанию Истина;
//  Правую	- Бюлево, по умолчанию Истина;
//  Нижную	- Бюлево, по умолчанию Истина;
//  Верхную - Бюлево, по умолчанию Истина;
// 
Процедура УстановитьГраницыДляЯчеек(Excel, НачЯчейка, КонЯчейка, 
									Левую   = Истина, 
									Правую  = Истина, 
									Нижную  = Истина, 
									Верхную = Истина,
									Вертикальные   = Истина,
									Горизонтальные = Истина) Экспорт
									
	// Получим адреса ячеек для выделения.
	АдресНачЯчейки = ПолучитьБуквенноЧисловойАдресЯчейкиExcel(НачЯчейка);
	АдресКонЯчейки = ПолучитьБуквенноЧисловойАдресЯчейкиExcel(КонЯчейка);
	
	// Выделим ячейки для установки границ.
	Excel.Range("" + АдресНачЯчейки + ":" + АдресКонЯчейки).Select();
	
	ExcelЯчейки = Excel.Selection;
	
	Если Левую Тогда
		// Устанавливаем левую границу.
		ExcelЯчейки.Borders(7).LineStyle  = 1.5;
	КонецЕсли;
	
	Если Верхную Тогда
		// Устанавливаем верхнюю границу.
		ExcelЯчейки.Borders(8).LineStyle  = 1.5;
	КонецЕсли;
	
	Если Нижную Тогда
		// Устанавливаем нижнюю границу.
		ExcelЯчейки.Borders(9).LineStyle  = 1.5;
	КонецЕсли;
	
	Если Правую Тогда
		// Устанавливаем правую границу.
		ExcelЯчейки.Borders(10).LineStyle = 1.5;
	КонецЕсли;
	
	Если Вертикальные Тогда
		// Устанавливаем вертикальные границы.
		ExcelЯчейки.Borders(11).LineStyle  = 1.5;
	КонецЕсли;
	
	Если Горизонтальные Тогда
		// Устанавливаем горизонтальные границы.
		ExcelЯчейки.Borders(12).LineStyle = 1.5;
	КонецЕсли;
	
КонецПроцедуры // УстановитьГраницыДляЯчеек()

// Процедура устанавливает/снимает полужирный текст для ячейки листа Excel.
// 
// Параметры:
//  ExcelЯчейка - ComObject, Ячейка страницы Excel.
//  Полужирный  - Булево, по умолчанию Истина.
// 
Процедура Установить_СнятьПолужирныйТекстДляЯчейки(ExcelЯчейка, Полужирный = Истина) Экспорт
	
	ExcelЯчейка.Font.Bold = ?(Полужирный, True, False);
	
КонецПроцедуры // Установить_СнятьПолужирныйТекстДляЯчейки()

// Процедура устанавливает ширину колонок для текущего листа Excel.
// 
// Параметры:
//  Excel 		    - ComObject("Excel.Application").
//  ИмяКолонкиExcel - Строка, имя колонки в Excel (A, B, C, D...),
// 					  для получения имени колонки можно воспользоваться функцией:
// 					  "ПолучитьИмяКолонкиДляЯчейкиExcel(ExcelЯчейка)".
// 
//  ШиринаКолонки   - Число.
// 
Процедура УстановитьШиринуКолонокиЛиста(Excel, ИмяКолонкиExcel, ШиринаКолонки) Экспорт
	
	// Установим ширину колонки.
	Excel.Columns(ИмяКолонкиExcel + ":" + ИмяКолонкиExcel).Select();
	Excel.Selection.ColumnWidth = ШиринаКолонки;
	
КонецПроцедуры // УстановитьШиринуКолонокиЛиста()

// Функция получает буквенно числовой адрес ячейки в формате "А2, B3 и т.д.".
// 
// Параметры:
//  ExcelЯчейка - ComObject, Ячейка страницы Excel.
// 
// Возвращаемое значение:
//  АдресЯчейкиExcel - Строка.
// 
Функция ПолучитьБуквенноЧисловойАдресЯчейкиExcel(ExcelЯчейка) Экспорт
	
	// Получим буквенно числовой адрес ячейки.
	АдресЯчейкиExcel = СтрЗаменить(ExcelЯчейка.Address, "$", "");
	
	Возврат АдресЯчейкиExcel;
	
КонецФункции // ПолучитьБуквенноЧисловойАдресЯчейкиExcel()

// Функция получает имя колонки для ячейки.
// 
// Параметры:
//  ExcelЯчейка - ComObject, Ячейка страницы Excel.
// 
// Возвращаемое значение:
//  ИмяКолонкиExcel - Строка.
// 
Функция ПолучитьИмяКолонкиДляЯчейкиExcel(ExcelЯчейка) Экспорт
	
	// Получим буквенное обозначение колонки Excel.
	ИмяКолонкиExcel = Лев(СтрЗаменить(ExcelЯчейка.Address, "$", ""), 1);
	
	Возврат ИмяКолонкиExcel;
	
КонецФункции // ПолучитьИмяКолонкиДляЯчейкиExcel()

// Процедура скрывает/отображает колонку листа Excel.
// 
// Параметры:
//  Excel 		    - ComObject("Excel.Application").
//  ИмяКолонкиExcel - Строка, имя колонки в Excel (A, B, C, D...),
// 					  для получения имени колонки можно воспользоваться функцией:
// 					  "ПолучитьИмяКолонкиДляЯчейкиExcel(ExcelЯчейка)".
// 
//  Скрыть - Булево, по умолчанию Истина.
// 
Процедура Скрыть_ОтобразитьКолонкуЛистаExcel(Excel, ИмяКолонкиExcel, Скрыть = Истина) Экспорт
	
	// Скроем видимость колонки.
	Excel.Columns(ИмяКолонкиExcel + ":" + ИмяКолонкиExcel).Select();
	Excel.Selection.EntireColumn.Hidden = ?(Скрыть, True, False);
	
КонецПроцедуры // Скрыть_ОтобразитьКолонкуЛистаExcel()

// Процедура скрывает/отображает строку листа Excel.
// 
// Параметры:
//  Excel 		- ComObject("Excel.Application").
//  НомерСтроки - Число.
//  Скрыть 		- Булево, по умолчанию Истина.
// 
Процедура Скрыть_ОтобразитьСтрокуЛистаExcel(Excel, НомерСтроки, Скрыть = Истина) Экспорт
	
	// Скроем видимость строки.
	Excel.Rows("" + НомерСтроки + ":" + НомерСтроки).Select();
	Excel.Selection.EntireRow.Hidden = ?(Скрыть, True, False);
	
КонецПроцедуры // Скрыть_ОтобразитьСтрокуЛистаExcel()

// Процедура заливает цветом ячейку листа Excel.
// 
// Параметры:
//  ExcelЯчейка - ComObject, Ячейка страницы Excel.
//  ИндексЦвета - Число, от 1 до 56.
// 
Процедура ЗалитьЯчейкуЦветом(ExcelЯчейка, ИндексЦвета) Экспорт
	
	ExcelЯчейка.Interior.ColorIndex = ИндексЦвета;
	
КонецПроцедуры // ЗалитьЯчейкуЦветом()

// Процедура заливает цветом ячейки листа Excel.
// 
// Параметры:
//  Excel       - ComObject("Excel.Application").
//  НачЯчейка   - ComObject, ячейка для начала заливки диапазона ячеек цветом.
//  КонЯчейка   - ComObject, ячейка для окончания заливки диапазона ячеек цветом.
//  ИндексЦвета - Число, от 1 до 56.
// 
Процедура ЗалитьЯчейкиЦветом(Excel, НачЯчейка, КонЯчейка, ИндексЦвета) Экспорт
	
	// Получим адреса ячеек для заливки.
	АдресНачЯчейки = ПолучитьБуквенноЧисловойАдресЯчейкиExcel(НачЯчейка);
	АдресКонЯчейки = ПолучитьБуквенноЧисловойАдресЯчейкиExcel(КонЯчейка);
	
	// Выделим ячейки для заливки цветом.
	Excel.Range("" + АдресНачЯчейки + ":" + АдресКонЯчейки).Select();
	
	Excel.Selection.Interior.ColorIndex = ИндексЦвета;
	
КонецПроцедуры // ЗалитьЯчейкиЦветом()

// Процедура группирует строки листа Excel.
// 
// Параметры:
//  Excel 			  - ComObject("Excel.Application").
//  НачалоГруппировки - Число, номер строки начала группировки.
//  КонецГруппировки  - Число, номер строки окончания группировки.
// 
Процедура СгруппироватьСтрокиЛистаExcel(Excel, НачалоГруппировки, КонецГруппировки) Экспорт
	
	Excel.Rows("" + НачалоГруппировки + ":" + КонецГруппировки).Select();
	Excel.Selection.Rows.Group();
	
КонецПроцедуры // СгруппироватьСтрокиЛистаExcel()

#КонецОбласти

// Функция возврашает фильтр для выбора файлов Excel.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  ТекстФильтра - Строка.
// 
Функция ПолучитьФильтрДляВыбораФайлаExcel() Экспорт

	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код (	
	//ТекстФильтра = "Все файлы Excel (*.xls, *.xlsx)|*.xls; *.xlsx|" 
	//			   + "Файлы Excel (*.xlsx)|*.xlsx|Файлы Excel 97-2003 (*.xls)|*.xls|";
	ТекстФильтра = "Все файлы Excel (*.xls, *.xlsx, *.xlsb)|*.xls; *.xlsx; *.xlsb|" 
				   + "Файлы Excel (*.xlsx)|*.xlsx|Файлы Excel 97-2003 (*.xls)|*.xls|Двоичный файл книги Microsoft Excel (*.xlsb)|*.xlsb|";
	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код )
	
	Возврат ТекстФильтра;
	
КонецФункции // ПолучитьФильтрДляВыбораФайлаExcel()

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
// 
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
// 
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Функция возвращает структуру имен ссылочных типов.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  СтруктураСсылочныхТипов - Структура.
// 
Функция ПолучитьСтруктуруИменСсылочныхТиповДляЗагрузки() Экспорт
    
    МенеджерТипы = Перечисления.бит_ТипыЗагружаемыхОбъектовИзExcel;
    СтрокаКлючи  = "Тип, ИмяКоллекции, НачалоИмениТипа";
	
    // Формируем структуру имен - ссылочных типов.
    СтруктураСсылочныхТипов = Новый Структура;                                                   
    СтруктураСсылочныхТипов.Вставить("Справочник"	   		 , Новый Структура(СтрокаКлючи, МенеджерТипы.СправочникСсылка  	 		 , "Справочники" 	  		, "Справочник"));
    СтруктураСсылочныхТипов.Вставить("Документ"		   		 , Новый Структура(СтрокаКлючи, МенеджерТипы.ДокументСсылка    	 		 , "Документы"   	  		, "Документ"));
    СтруктураСсылочныхТипов.Вставить("Перечисление"	   		 , Новый Структура(СтрокаКлючи, МенеджерТипы.ПеречислениеСсылка	 		 , "Перечисления"	  		, "Перечисление"));
	СтруктураСсылочныхТипов.Вставить("ПланВидовХарактеристик", Новый Структура(СтрокаКлючи, МенеджерТипы.ПланВидовХарактеристикСсылка, "ПланыВидовХарактеристик", "ПланВидовХарактеристик")); 
	СтруктураСсылочныхТипов.Вставить("ПланСчетов"	   		 , Новый Структура(СтрокаКлючи, МенеджерТипы.ПланСчетовСсылка  	 		 , "ПланыСчетов" 	  		, "ПланСчетов")); 
	СтруктураСсылочныхТипов.Вставить("ПланВидовРасчета"		 , Новый Структура(СтрокаКлючи, МенеджерТипы.ПланВидовРасчетаСсылка		 , "ПланыВидовРасчета"		, "ПланВидовРасчета"));
	СтруктураСсылочныхТипов.Вставить("ПланОбмена"	   		 , Новый Структура(СтрокаКлючи, МенеджерТипы.ПланОбменаСсылка  	 		 , "ПланыОбмена" 	  		, "ПланОбмена"));
	
    Возврат СтруктураСсылочныхТипов;
    
КонецФункции // ПолучитьСтруктуруИменСсылочныхТиповДляЗагрузки()

// Функция возвращает соответствие имен ссылочных типов для полей без сопоставления реквизиту.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  СоотСсылочныхТипов - Соответствие.
// 
Функция ПолучитьСоответствиеИменСсылочныхТиповДляПолейБезСопоставленияРеквизиту() Экспорт
	
	МенеджерТипы = Перечисления.бит_ТипыЗагружаемыхОбъектовИзExcel;
	СтрокаКлючи  = "ИмяКоллекции, СинонимКоллекции, СписокИмен";
	
    // Формируем соответствие имен ссылочных типов.
    СоотСсылочныхТипов = Новый Соответствие;                                                   
    СоотСсылочныхТипов.Вставить(МенеджерТипы.СправочникСсылка	   		 , Новый Структура(СтрокаКлючи, "Справочники" 	 		 , "Справочник"  	   		 , ПолучитьСписокИменКоллекцииМетаданных("Справочники")));
	СоотСсылочныхТипов.Вставить(МенеджерТипы.ДокументСсылка  	   		 , Новый Структура(СтрокаКлючи, "Документы"   	 		 , "Документ"	 	   		 , ПолучитьСписокИменКоллекцииМетаданных("Документы")));
	СоотСсылочныхТипов.Вставить(МенеджерТипы.ПеречислениеСсылка	   		 , Новый Структура(СтрокаКлючи, "Перечисления"	 		 , "Перечисление"	   		 , ПолучитьСписокИменКоллекцииМетаданных("Перечисления")));
	СоотСсылочныхТипов.Вставить(МенеджерТипы.ПланВидовХарактеристикСсылка, Новый Структура(СтрокаКлючи, "ПланыВидовХарактеристик", "План видов характеристик", ПолучитьСписокИменКоллекцииМетаданных("ПланыВидовХарактеристик")));
	СоотСсылочныхТипов.Вставить(МенеджерТипы.ПланСчетовСсылка	   		 , Новый Структура(СтрокаКлючи, "ПланыСчетов" 	 		 , "План счетов"  	   		 , ПолучитьСписокИменКоллекцииМетаданных("ПланыСчетов")));
	СоотСсылочныхТипов.Вставить(МенеджерТипы.ПланВидовРасчетаСсылка		 , Новый Структура(СтрокаКлючи, "ПланыВидовРасчета"		 , "План видов расчета"		 , ПолучитьСписокИменКоллекцииМетаданных("ПланыВидовРасчета")));
	СоотСсылочныхТипов.Вставить(МенеджерТипы.ПланОбменаСсылка	   		 , Новый Структура(СтрокаКлючи, "ПланыОбмена" 	 		 , "План обмена"  	   		 , ПолучитьСписокИменКоллекцииМетаданных("ПланыОбмена")));
	
    Возврат СоотСсылочныхТипов;
    
КонецФункции // ПолучитьСоответствиеИменСсылочныхТиповДляПолейБезСопоставленияРеквизиту()

// Функция получает соответствие типов и видов объектов.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  СоотвТипВидОбъекта - Соответствие;
// 
Функция ПолучитьСоответствиеТиповИВидовОбъектов() Экспорт
	
	МенеджерТипы = Перечисления.бит_ТипыЗагружаемыхОбъектовИзExcel;
	
    // Формируем соответствие тип - вид объекта.
    СоотвТипВидОбъекта = Новый Соответствие;                                                   
    СоотвТипВидОбъекта.Вставить(МенеджерТипы.СправочникСсылка	   		 , "Справочник");
    СоотвТипВидОбъекта.Вставить(МенеджерТипы.ДокументСсылка  	   		 , "Документ");
    СоотвТипВидОбъекта.Вставить(МенеджерТипы.ПеречислениеСсылка	   		 , "Перечисление");
	СоотвТипВидОбъекта.Вставить(МенеджерТипы.ПланВидовХарактеристикСсылка, "ПланВидовХарактеристик");
    СоотвТипВидОбъекта.Вставить(МенеджерТипы.ПланСчетовСсылка	   		 , "ПланСчетов"); 
	СоотвТипВидОбъекта.Вставить(МенеджерТипы.ПланВидовРасчетаСсылка		 , "ПланВидовРасчета");
	СоотвТипВидОбъекта.Вставить(МенеджерТипы.ПланОбменаСсылка	   		 , "ПланОбмена");
	
    Возврат СоотвТипВидОбъекта;
	
КонецФункции // ПолучитьСоответствиеТиповИВидовОбъектов()

// Функция получает вид объекта из соответствия тип - вид объекта.
// 
// Параметры:
//  СоотТипВидОбъекта - Соответствие.
//  ТипОбъекта		  - ПеречислениеСсылка.бит_ТипыЗагружаемыхОбъектовИзExcel.
// 
// Возвращаемое значение:
//  ВидОбъекта - Строка.
// 
Функция ПолучитьВидОбъектаИзСоответствия(СоотТипВидОбъекта, ТипОбъекта) Экспорт
	
	ВидОбъекта = СоотТипВидОбъекта.Получить(ТипОбъекта);
	ВидОбъекта = ?(ВидОбъекта = Неопределено, "", ВидОбъекта);
	
	Возврат ВидОбъекта;
	
КонецФункции // ПолучитьВидОбъектаИзСоответствия()

// Функция определяет картинку по имени коллекции метаданных.
// 
// Параметры:
//  ИмяКоллекции - Строка.
// 
// Возвращаемое значение:
//   РезКартинка - Картинка
// 
Функция ОпределитьКартинкуВидаОбъектаПоИмениКоллекцииМетаданных(ИмяКоллекции) Экспорт

	РезКартинка = Неопределено;
	
	#Если Клиент Тогда
		
	КартинкиОбъектов = Новый Соответствие;
	КартинкиОбъектов.Вставить("Справочники" 	 	   , БиблиотекаКартинок.СправочникОбъект);
	КартинкиОбъектов.Вставить("Документы"   	 	   , БиблиотекаКартинок.ДокументОбъект);
	КартинкиОбъектов.Вставить("Перечисления"	 	   , БиблиотекаКартинок.Перечисление);
	КартинкиОбъектов.Вставить("ПланыВидовХарактеристик", БиблиотекаКартинок.ПланВидовХарактеристикОбъект);
	КартинкиОбъектов.Вставить("ПланыСчетов" 	 	   , БиблиотекаКартинок.ПланСчетовОбъект);
	КартинкиОбъектов.Вставить("ПланыВидовРасчета"	   , БиблиотекаКартинок.ПланВидовРасчетаОбъект);
	КартинкиОбъектов.Вставить("ПланыОбмена" 	 	   , БиблиотекаКартинок.ПланОбменаОбъект);
	
	РезКартинка = КартинкиОбъектов[ИмяКоллекции];
	
	#КонецЕсли
	
	Возврат РезКартинка;

КонецФункции // ОпределитьКартинкуВидаОбъектаПоИмениКоллекцииМетаданных()

// Функция возвращает структуру имен простейших типов.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  СтруктураПростыхТипов - Структура.
// 
Функция ПолучитьСтруктуруИменПростейщихТиповДляЗагрузки() Экспорт
    
    МенеджерТипы = Перечисления.бит_ТипыЗагружаемыхОбъектовИзExcel;
	СтрокаКлючи  = "Тип, Значение";
    
    // Формируем структуру простейщих типов.
    СоответствиеПростыхТипов = Новый Соответствие;
    СоответствиеПростыхТипов.Вставить(Тип("Число") , Новый Структура(СтрокаКлючи, МенеджерТипы.Число , 0));
    СоответствиеПростыхТипов.Вставить(Тип("Строка"), Новый Структура(СтрокаКлючи, МенеджерТипы.Строка, ""));
    СоответствиеПростыхТипов.Вставить(Тип("Дата")  , Новый Структура(СтрокаКлючи, МенеджерТипы.Дата  , Дата("00010101")));
    СоответствиеПростыхТипов.Вставить(Тип("Булево"), Новый Структура(СтрокаКлючи, МенеджерТипы.Булево, ""));
    
    Возврат СоответствиеПростыхТипов;
    
КонецФункции // ПолучитьСтруктуруИменПростейщихТиповДляЗагрузки()

// Функция возвращает реквизиты объекта загрузки.
// 
// Параметры:
//  СтруктураСсылочныхТипов - Структура.
//  СтруктураСвойствОбъекта  - Структура, СтрокаТаблицыЗначений (Состав: ВидОбъекта, ИмяОбъекта).
// 
// Возвращаемое значение:
//  ТаблицаРеквизитов - ТаблицаЗначений.
// 
Функция ПолучитьРеквизитыОбъектаЗагрузки(СтруктураСсылочныхТипов, СтруктураСвойствОбъекта) Экспорт
	
	// Хранит вид обрабатываемых данных.
	Перем ВидДанных;
	
	Если ТипЗнч(СтруктураСвойствОбъекта) = Тип("Структура") Тогда
		СтруктураСвойствОбъекта.Свойство("ВидДанных", ВидДанных);
	КонецЕсли;
	
    ТаблицаРеквизитов = Новый ТаблицаЗначений;
	ТаблицаРеквизитов.Колонки.Добавить("ВидДанных");
    ТаблицаРеквизитов.Колонки.Добавить("ИмяРеквизита");
    ТаблицаРеквизитов.Колонки.Добавить("Представление");
    ТаблицаРеквизитов.Колонки.Добавить("Реквизит");
	
	ВидДанныхЕсть 	 = ЗначениеЗаполнено(ВидДанных);
    СимволыДляПоиска = СтруктураСвойствОбъекта.ВидОбъекта;
    
    // Если это регистр сведений, тогда
	Если СимволыДляПоиска = "РегистрСведений" Тогда
		
		МетаОбъекта = Метаданные.РегистрыСведений[СтруктураСвойствОбъекта.ИмяОбъекта];
		
		// Добавим реквизиты.
		Если Не МетаОбъекта.ПериодичностьРегистраСведений = Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Период");
		КонецЕсли;
		
		СтруктураДанных = Новый Структура;
		СтруктураДанных.Вставить("Измерения", МетаОбъекта.Измерения);
		СтруктураДанных.Вставить("Ресурсы"  , МетаОбъекта.Ресурсы);
		СтруктураДанных.Вставить("Реквизиты", МетаОбъекта.Реквизиты);
		
		Для Каждого КлючЗначение Из СтруктураДанных Цикл 
			
			ТекРеквизиты = КлючЗначение.Значение;
			
			Для Каждого ТекРеквизит Из ТекРеквизиты Цикл
				// Добавим реквизит.
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, ТекРеквизит);
			КонецЦикла;
			
		КонецЦикла;
		
		Если ВидДанныхЕсть Тогда
			// Добавим реквизит.
			ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Без_Сопоставления", "<...> - без сопоставления");
		КонецЕсли;
		
	Иначе
        // Иначе, это не регистр сведений.
		
        РезСтруктура = СтруктураСсылочныхТипов[СимволыДляПоиска];
		МетаОбъекта  = Метаданные[РезСтруктура.ИмяКоллекции][СтруктураСвойствОбъекта.ИмяОбъекта];
		
		// Это реквизиты шапки объекта.
		Если Не ВидДанныхЕсть
			Или ВидДанных = "Шапка" Тогда
			
			// Если это справочник, тогда
			// добавим дополнительные реквизиты.
			Если СимволыДляПоиска = "Справочник" Тогда
				
				// Добавим реквизиты.
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Код");
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Наименование");
				
				Если МетаОбъекта.Владельцы.Количество() <> 0 Тогда
					ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Владелец");
				КонецЕсли;
				
				Если МетаОбъекта.Иерархический Тогда
					
					// Если это иерархия групп и элементов, тогда.
					Если МетаОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
						ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "ЭтоГруппа", "Это группа");
					КонецЕсли;
					
					// Добавим реквизит.
					ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Родитель");
					
				КонецЕсли;
				
				// Иначе если это документ, тогда
				// добавим дополнительные реквизиты.
			ИначеЕсли СимволыДляПоиска = "Документ" Тогда
				
				// Добавим реквизиты.
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Дата" , "Дата документа");
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Номер", "Номер документа");
				
			КонецЕсли;
			
			РеквизитыОбъекта = МетаОбъекта.Реквизиты;
			
			Для Каждого ТекРеквизит Из РеквизитыОбъекта Цикл 
				// Добавим реквизит.
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, ТекРеквизит);
			КонецЦикла;
			
			// Добавим реквизит.
			ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "ПометкаУдаления", "Пометка удаления");
			
			Если ВидДанныхЕсть Тогда
				// Добавим реквизит.
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов,, "Без_Сопоставления", "<...> - без сопоставления");
			КонецЕсли;
				
		КонецЕсли;
		
		Если Не ВидДанныхЕсть
			Или (ВидДанныхЕсть И Не ВидДанных = "Шапка") Тогда
			
			// Это реквизиты табличной части объекта.
			
			СтруктураРеквизитов = Новый Структура;
			
			Если Не ВидДанныхЕсть Тогда
				
				Для Каждого ТекТабЧасть Из МетаОбъекта.ТабличныеЧасти Цикл
					СтруктураРеквизитов.Вставить(ТекТабЧасть.Имя, ТекТабЧасть.Реквизиты);
				КонецЦикла;
				ДобавитьСвойстваРегистровВСтруктуруРеквизитов(МетаОбъекта, СтруктураРеквизитов);
			ИначеЕсли ВидДанныхЕсть И Не ВидДанных = "Шапка" Тогда
				
				Если Лев(ВидДанных, 9) = "Движения_" Тогда
					ДобавитьСвойстваРегистровВСтруктуруРеквизитов(МетаОбъекта, СтруктураРеквизитов, ВидДанных);
				Иначе	
					СтруктураРеквизитов.Вставить(ВидДанных, МетаОбъекта.ТабличныеЧасти[ВидДанных].Реквизиты);
				КонецЕсли;
				
			КонецЕсли;
			
			Для Каждого КлючЗначение Из СтруктураРеквизитов Цикл
				
				ИмяТабЧасти 	   = КлючЗначение.Ключ;
				РеквизитыТЧОбъекта = КлючЗначение.Значение;
				
				Если Лев(ИмяТабЧасти, 9) = "Движения_" Тогда
					Для Каждого ТекСвойство Из РеквизитыТЧОбъекта Цикл
						Для Каждого ТекРеквизит Из ТекСвойство Цикл 
							// Добавим реквизит.
							ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов, ИмяТабЧасти, ТекРеквизит, ТекРеквизит);
						КонецЦикла;
					КонецЦикла;
				Иначе
					Для Каждого ТекРеквизит Из РеквизитыТЧОбъекта Цикл 
						// Добавим реквизит.
						ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов, ИмяТабЧасти, ТекРеквизит);
					КонецЦикла;
				КонецЕсли;
				
			КонецЦикла;
			
			Если ВидДанныхЕсть Тогда
				// Добавим реквизит.
				ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов, ИмяТабЧасти, 
												   "Без_Сопоставления", "<...> - без сопоставления");
			КонецЕсли;
	
		КонецЕсли;
			
    КонецЕсли; // Если СимволыДляПоиска = "РегистрСведений" Тогда.
	
    Возврат ТаблицаРеквизитов;
    
КонецФункции // ПолучитьРеквизитыОбъектаЗагрузки()

// Функция возвращает реквизиты объекта текущей строки 
// табличного поля ПравилаЗагрузки для выбора.
// 
// Параметры:
//  СтруктураСсылочныхТипов - Структура.
//  ТекущаяСтрока           - СтрокаТабличнойЧасти, СтрокаТаблицыЗначений.
//  Сообщать				- Булево.
// 
// Возвращаемое значение:
//  ТаблицаРеквизитов - ТаблицаЗначений.
// 
Функция ПолучитьРеквизитыОбъектаТекущейСтроки(СтруктураСсылочныхТипов, ТекущаяСтрока, Сообщать = Истина) Экспорт
    
    ТаблицаРеквизитов = Новый ТаблицаЗначений;
    ТаблицаРеквизитов.Колонки.Добавить("ИмяРеквизита");
    ТаблицаРеквизитов.Колонки.Добавить("Представление");
    ТаблицаРеквизитов.Колонки.Добавить("Реквизит");
	
	// Получим соответствие тип - вид объекта.
	СоотТипВидОбъекта = ПолучитьСоответствиеТиповИВидовОбъектов();
	СимволыДляПоиска  = ПолучитьВидОбъектаИзСоответствия(СоотТипВидОбъекта, ТекущаяСтрока.Тип);
	
    // Если это ссылочный тип и не перечисление, тогда.
    Если ЗначениеЗаполнено(СимволыДляПоиска)
        И СимволыДляПоиска <> "Перечисление"
        И СтруктураСсылочныхТипов.Свойство(СимволыДляПоиска) Тогда
        
        РезСтруктура = СтруктураСсылочныхТипов[СимволыДляПоиска];
        
        Попытка
            РеквизитыОбъекта = Метаданные[РезСтруктура.ИмяКоллекции][ТекущаяСтрока.ИмяОбъекта].Реквизиты;
            
            // Добавим дополнительные реквизиты.
            
            // Если это справочник, тогда
			Если СимволыДляПоиска = "Справочник"
				Или СимволыДляПоиска = "ПланВидовХарактеристик"
				Или СимволыДляПоиска = "ПланСчетов"
				Или СимволыДляПоиска = "ПланВидовРасчета" 
				Или СимволыДляПоиска = "ПланОбмена" Тогда
                
                НовСтрока = ТаблицаРеквизитов.Добавить();
                НовСтрока.ИмяРеквизита = "Код";
                                          
                НовСтрока = ТаблицаРеквизитов.Добавить();
                НовСтрока.ИмяРеквизита = "Наименование";
                
                // Иначе если это документ, тогда
            ИначеЕсли СимволыДляПоиска = "Документ" Тогда
                
                НовСтрока = ТаблицаРеквизитов.Добавить();
                НовСтрока.ИмяРеквизита = "Номер";
                НовСтрока.Представление = "Номер документа";
                
            КонецЕсли;
            
            Для Каждого ТекРеквизит Из РеквизитыОбъекта Цикл 
                
                НовСтрока = ТаблицаРеквизитов.Добавить();
                НовСтрока.ИмяРеквизита  = ТекРеквизит.Имя;
                НовСтрока.Представление = ТекРеквизит.Синоним;
                НовСтрока.Реквизит      = ТекРеквизит;
                
            КонецЦикла;
            
		Исключение
			
			Если Сообщать Тогда 
				ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Реквизиты объекта не получены для выбора. Не правильно указано имя объекта.'"));
			КонецЕсли;
				
        КонецПопытки;
        
    КонецЕсли;
    
    Возврат ТаблицаРеквизитов;
    
КонецФункции // ПолучитьРеквизитыОбъектаТекущейСтроки()

// Процедура сортирует строки таблицы правил по правилам:
// Вверху необходимо разместить строки с именем реквизита "Без_Сопоставления".
// Последним необходимо разместить строки с типом "ПроизвольныйАлгоритм".
// 
// Параметры:
//  ПравилаЗагрузки - ТаблицаЗначений.
// 
Процедура ОтсортироватьТаблицуПравил(ПравилаЗагрузки) Экспорт
	
	Если ПравилаЗагрузки.Колонки.Количество() = 0 Тогда
		// Сортировать не чего.
		Возврат;
	КонецЕсли;
	
	// Вверху необходимо разместить строки с именем реквизита "Без_Сопоставления".
	ЕстьЗначенияБезСопоставления = (Не ПравилаЗагрузки.Найти("Без_Сопоставления", "ИмяРеквизита") = Неопределено);
	
	ПроизвольныйАлгоритм = Перечисления.бит_ТипыЗагружаемыхОбъектовИзExcel.ПроизвольныйАлгоритм;
	
	// Последним необходимо разместить строки с типом "ПроизвольныйАлгоритм".
	ЕстьПроизвольныйАлгоритм = (Не ПравилаЗагрузки.Найти(ПроизвольныйАлгоритм, "Тип") = Неопределено);
	
	Если ЕстьЗначенияБезСопоставления
		Или ЕстьПроизвольныйАлгоритм Тогда
		
		СчетчикСтрок = 1;
		
		ОтсортированнаяТаблицаПравил = ПравилаЗагрузки.Скопировать();
		ОтсортированнаяТаблицаПравил.Очистить();
		
		Если ЕстьЗначенияБезСопоставления Тогда
			
			НайденныеСтроки = ПравилаЗагрузки.НайтиСтроки(Новый Структура("ИмяРеквизита", "Без_Сопоставления"));
			
			Для Каждого ТекСтрока Из НайденныеСтроки Цикл
				
				НоваяСтрока = ОтсортированнаяТаблицаПравил.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекСтрока);
				
				НоваяСтрока.НомерСтроки = СчетчикСтрок;
				
				СчетчикСтрок = СчетчикСтрок + 1;
				
			КонецЦикла;
			
		КонецЕсли;
		
		Для Каждого ТекСтрока Из ПравилаЗагрузки Цикл
			
			Если Не (ТекСтрока.ИмяРеквизита = "Без_Сопоставления"
				Или ТекСтрока.Тип = ПроизвольныйАлгоритм) Тогда
				
				НоваяСтрока = ОтсортированнаяТаблицаПравил.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекСтрока);
				
				НоваяСтрока.НомерСтроки = СчетчикСтрок;
				
				СчетчикСтрок = СчетчикСтрок + 1;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ЕстьПроизвольныйАлгоритм Тогда
			
			НайденныеСтроки = ПравилаЗагрузки.НайтиСтроки(Новый Структура("Тип", ПроизвольныйАлгоритм));
			
			Для Каждого ТекСтрока Из НайденныеСтроки Цикл
				
				НоваяСтрока = ОтсортированнаяТаблицаПравил.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекСтрока);
				
				НоваяСтрока.НомерСтроки = СчетчикСтрок;
				
				СчетчикСтрок = СчетчикСтрок + 1;
				
			КонецЦикла;
			
		КонецЕсли;
		
		ПравилаЗагрузки = ОтсортированнаяТаблицаПравил;
		
	КонецЕсли;
	
КонецПроцедуры // ОтсортироватьТаблицуПравил()

// Процедура обновляет дерево правил загрузки.
// 
// Параметры:
//  ПравилаЗагрузки		  - ТаблицаЗначений.
//  ПравилаЗагрузкиДерево - ДеревоЗначений.
//  СтруктураПараметров   - Структура.
//  КлючевыеПоля		  - ТабличноеПоле.
// 
Процедура ОбновитьДеревоПравилЗагрузки(ПравилаЗагрузки, ПравилаЗагрузкиДерево, СтруктураПараметров, 
									   КлючевыеПоля = Неопределено, БезРеквизитовТЧ = Ложь) Экспорт
	
	ПравилаЗагрузкиДерево.Строки.Очистить();
	
	СтруктураСсылочныхТипов = СтруктураПараметров.СтруктураСсылочныхТипов;
	ВидЗагружаемогоОбъекта	= СтруктураПараметров.ВидОбъекта;
	ИмяЗагружаемогоОбъекта	= СтруктураПараметров.ИмяЗагружаемогоОбъекта;
	ЗаполнятьИДСтроки		= СтруктураПараметров.ЗаполнятьИДСтроки;
	БезСопоставления	    = СтруктураПараметров.БезСопоставления;
	
	СтрокаШапка = ПравилаЗагрузкиДерево.Строки.Добавить();
	СтрокаШапка.ВидДанных	   = "Шапка";
	СтрокаШапка.ВерхнийУровень = Истина;
	
	ДанныеШапки = ПравилаЗагрузки.НайтиСтроки(Новый Структура("ВидДанных", "Шапка"));
	
	Для Каждого ТекСтрока Из ДанныеШапки Цикл
		
		Если БезСопоставления
			И ВРег(ТекСтрока.ИмяРеквизита) = ВРег("Без_Сопоставления") Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = СтрокаШапка.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекСтрока);
		
		Если ЗаполнятьИДСтроки Тогда
			НоваяСтрока.ИД = Новый УникальныйИдентификатор();
		КонецЕсли;
		
	КонецЦикла;
	
	СимволыДляПоиска = ВидЗагружаемогоОбъекта;
    
    // Если это не регистр сведений, тогда
    Если Не СимволыДляПоиска = "РегистрСведений" Тогда
        
        РезСтруктура = СтруктураСсылочныхТипов[СимволыДляПоиска];
        МетаОбъекта  = Метаданные[РезСтруктура.ИмяКоллекции][ИмяЗагружаемогоОбъекта];
		
		ТабличныеЧасти = МетаОбъекта.ТабличныеЧасти;
		
		СтрокаТабличныеЧасти = Неопределено;
		
		Если Не ТабличныеЧасти.Количество() = 0 Тогда
			
			СтрокаТабличныеЧасти = ПравилаЗагрузкиДерево.Строки.Добавить();
			СтрокаТабличныеЧасти.ВидДанных	    = "Табличные части";
			СтрокаТабличныеЧасти.ВерхнийУровень = Истина;
			
			Для Каждого ТекТабЧасть Из ТабличныеЧасти Цикл
				
				СтрокаТабЧасть = СтрокаТабличныеЧасти.Строки.Добавить();
				СтрокаТабЧасть.ВидДанных	  = ТекТабЧасть.Имя;
				СтрокаТабЧасть.ВерхнийУровень = Истина;
				
				Если БезРеквизитовТЧ Тогда
					Продолжить;
				КонецЕсли;
				
				ДанныеТабЧасти = ПравилаЗагрузки.НайтиСтроки(Новый Структура("ВидДанных", ТекТабЧасть.Имя));
				
				Для Каждого ТекСтрока Из ДанныеТабЧасти Цикл
					
					Если БезСопоставления
						И ВРег(ТекСтрока.ИмяРеквизита) = ВРег("Без_Сопоставления") Тогда
						Продолжить;
					КонецЕсли;
					
					НоваяСтрока = СтрокаТабЧасть.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекСтрока);
					
					Если ЗаполнятьИДСтроки Тогда
						НоваяСтрока.ИД = Новый УникальныйИдентификатор();
					КонецЕсли;
					
				КонецЦикла;
					
			КонецЦикла;
			
		КонецЕсли;
		
		ДобавитьТаблицыДвиженийРучныхОпераций(МетаОбъекта, ПравилаЗагрузкиДерево, СтрокаТабличныеЧасти, ПравилаЗагрузки, СтруктураПараметров);
		
	КонецЕсли;
	
	Если Не КлючевыеПоля = Неопределено Тогда
		СтруктураОтбора = Новый Структура;
		СтруктураОтбора.Вставить("ВидДанных", "Шапка");
		КлючевыеПоля.ОтборСтрок = Новый ФиксированнаяСтруктура(СтруктураОтбора);
	КонецЕсли;
	
КонецПроцедуры // ОбновитьДеревоПравилЗагрузки()

Функция ЭтоДокументРучнаяОперация(МетаОбъект) Экспорт
	
	ЭтоРучнаяОперация = Ложь;
	
	РучныеОперации = Новый Массив;
	
	РучныеОперации.Добавить("ОперацияБух");
	РучныеОперации.Добавить("бит_ОперацияБюджетирование");
	РучныеОперации.Добавить("бит_ОперацияУправленческий");
	
	Если ТипЗнч(МетаОбъект) = Тип("Строка") Тогда
		НайденныйЭлемент = РучныеОперации.Найти(МетаОбъект);
	Иначе
		НайденныйЭлемент = РучныеОперации.Найти(МетаОбъект.Имя);
	КонецЕсли;
	
	Если НЕ НайденныйЭлемент = Неопределено Тогда
		ЭтоРучнаяОперация = Истина;
	КонецЕсли;
	
	Возврат ЭтоРучнаяОперация;
	
КонецФункции

// Функция возврашает структуру полученных таблиц в результате
// разбиения таблицы правил загрузки.
// 
// 		Заробъем таблицу правил на две таблицы:
// 		1) "ПравилаЗагрузкиШапки" - правила загрузки шапки.
// 		2) "ПравилаЗагрузкиТЧ" 	 - правила загрузки значений табличных частей.
// 
// Параметры:
//  ПравилаЗагрузки - ТаблицаЗначений.
// 
// Возвращаемое значение:
//  СтруктураТаблиц - Структура, ключи "ПравилаЗагрузкиШапки, ПравилаЗагрузкиТЧ".
// 
Функция РазбитьТаблицуПравилЗагрузкиНаДвеТаблицы(ПравилаЗагрузки) Экспорт
	
	СтруктураТаблиц = Новый Структура();
	СтруктураТаблиц.Вставить("ПравилаЗагрузкиШапки", Новый ТаблицаЗначений);
	СтруктураТаблиц.Вставить("ПравилаЗагрузкиТЧ"   , Новый ТаблицаЗначений);
	
	Если ПравилаЗагрузки.Количество() = 0 Тогда
		Возврат СтруктураТаблиц;
	КонецЕсли;
	
	// Заробъем таблицу правил на две таблицы:
	// 1) "ПравилаЗагрузкиШапки" - правила загрузки шапки.
	// 2) "ПравилаЗагрузкиТЧ" 	 - правила загрузки значений табличных частей.
	
	ПравилаЗагрузкиШапки = ПравилаЗагрузки.Скопировать();
	ПравилаЗагрузкиШапки.Очистить();
	
	НайденныеСтроки = ПравилаЗагрузки.НайтиСтроки(Новый Структура("ВидДанных", "Шапка"));
	ЗагрузитьВТаблицуЗначений(НайденныеСтроки, ПравилаЗагрузкиШапки);
	
	ПравилаЗагрузкиТЧ = ПравилаЗагрузки.Скопировать();
	
	// Удалим найденные строки из таблицы "ТаблицаСДаннымиТЧ".
	Для Каждого ТекСтрока Из НайденныеСтроки Цикл
		
		Отбор = Новый Структура;
		Отбор.Вставить("ВидДанных"	 , ТекСтрока.ВидДанных);
		Отбор.Вставить("ИмяРеквизита", ТекСтрока.ИмяРеквизита);
		
		СтрокаДляУдаления = ПравилаЗагрузкиТЧ.НайтиСтроки(Отбор);
		
		Если Не СтрокаДляУдаления.Количество() = 0 Тогда
			ПравилаЗагрузкиТЧ.Удалить(СтрокаДляУдаления[0]);
		КонецЕсли;
		
	КонецЦикла;
	
	СтруктураТаблиц.Вставить("ПравилаЗагрузкиШапки", ПравилаЗагрузкиШапки);
	СтруктураТаблиц.Вставить("ПравилаЗагрузкиТЧ"   , ПравилаЗагрузкиТЧ);
	
	Возврат СтруктураТаблиц;
	
КонецФункции // РазбитьТаблицуПравилЗагрузкиНаДвеТаблицы()

// Функция возвращает элемент данных регистра сведений из коллекции "Измерерния, Ресурсы, Реквизиты".
// 
// Параметры:
//  ИмяРегистра  - Строка.
//  ИмяРеквизита - Строка.
// 
// Возвращаемое значение:
//  ТекЭлемент - МетаданныеРегистра[Измерерние, Ресурс, Реквизит].
// 
Функция ПолучитьЭлементДанныхРегистраСведедний(ИмяРегистра, ИмяРеквизита) Экспорт
	
	ТекЭлемент  = Неопределено;
	МетаОбъекта = Метаданные.РегистрыСведений[ИмяРегистра];
	
	// Получим реквизит регистра сведений.
	Если Не МетаОбъекта.Измерения.Найти(ИмяРеквизита) = Неопределено Тогда
		ТекЭлемент = МетаОбъекта.Измерения[ИмяРеквизита];
		
	ИначеЕсли Не МетаОбъекта.Ресурсы.Найти(ИмяРеквизита) = Неопределено Тогда
		ТекЭлемент = МетаОбъекта.Ресурсы[ИмяРеквизита];
		
	ИначеЕсли Не МетаОбъекта.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		ТекЭлемент = МетаОбъекта.Реквизиты[ИмяРеквизита];
		
	КонецЕсли;
	
	Возврат ТекЭлемент;
	
КонецФункции // ПолучитьЭлементДанныхРегистраСведедний()

// Процедура удаляет из строки массив указанных символов.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
//  МассивСимволов - Массив.
// 
Процедура УдалитьИзСтрокиМассивСимволов(ИсходнаяСтрока, МассивСимволов) Экспорт
	
	// Удалим неразрешимые символы.
	Для Каждого ТекСимвол Из МассивСимволов Цикл
		ИсходнаяСтрока = СтрЗаменить(ИсходнаяСтрока, ТекСимвол, "");
	КонецЦикла;
	
КонецПроцедуры // УдалитьИзСтрокиМассивСимволов()

// Процедура адаптирована для работы как на стороне сервера, так и на стороне клиента
// 	перенесена в общий модуль бит_ОбменДаннымиЭксельКлиентСервер.
// 
// функция добавляет колонку в таблицу данных.
// 
// Параметры
//  ТаблицаДанных - ТаблицаЗначений, в которую необходимо добавить колонку.
//  ИмяКолонки    - Строка.
// 
//  МассивНеРазрешимыхСимволов - Массив.
// 
// Возвращаемое значение:
//  КолонкаДобавлена - Булево.
// 
Функция Удалить_ДобавитьКолонкуВТаблицуДанных(ТаблицаДанных, ИмяКолонки, МассивНеРазрешимыхСимволов = Неопределено) Экспорт
	
	Если МассивНеРазрешимыхСимволов = Неопределено Тогда
		МассивНеРазрешимыхСимволов = бит_ОбменДаннымиЭксельКлиентСервер.ПолучитьМассивНеРазрешимыхСимволов();
	КонецЕсли;
	
	КолонкаДобавлена = Ложь;
	
	// Удалим неразрешимые символы из имени колонки.
	УдалитьИзСтрокиМассивСимволов(ИмяКолонки, МассивНеРазрешимыхСимволов);
	
	ИмяКолонки = ВРег(ИмяКолонки);
	
	// Если имя колонки не заполнено, тогда
	Если НЕ ЗначениеЗаполнено(ИмяКолонки)  Тогда
		Возврат КолонкаДобавлена;
	КонецЕсли;
	
	Попытка
		
		Если ТаблицаДанных.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			ТаблицаДанных.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Строка"));
		КонецЕсли;
		
	Исключение
		ТекстСообщения = НСтр("ru = 'Не удалось добавить колонку %1.'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ИмяКолонки);
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		Возврат КолонкаДобавлена;
	КонецПопытки;
	
	КолонкаДобавлена = Истина;
	
	Возврат КолонкаДобавлена;
	
КонецФункции // ДобавитьКолонкуВТаблицуДанных()

// Функция получает текст по статусу для вывода в окно протокола.
// 
// Параметры:
//  Статус - СтатусСообщения.
// 
// Возвращаемое значение:
//  ТекстПоСтатусу - Строка, текст по статусу для вывода в окно протокола.
// 
Функция ПолучитьТекстПоСтатусуДляПротокола(Статус) Экспорт
    
    ТекстПоСтатусу = "";
    
    Если Статус = СтатусСообщения.Обычное Тогда
        ТекстПоСтатусу = "-> ";
    ИначеЕсли Статус = СтатусСообщения.Информация Тогда
        ТекстПоСтатусу = "Info: ";
    ИначеЕсли Статус = СтатусСообщения.Внимание Тогда
        ТекстПоСтатусу = "!: ";
    ИначеЕсли Статус = СтатусСообщения.Важное Тогда
        ТекстПоСтатусу = "!!: ";
    ИначеЕсли Статус = СтатусСообщения.ОченьВажное Тогда
        ТекстПоСтатусу = "!!!: ";
    КонецЕсли;
	
	Возврат ТекстПоСтатусу;
    
КонецФункции // ПолучитьТекстПоСтатусуДляПротокола()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Процедура проверяет таблицу правил загрузки по строчно.
// 
// Параметры:
//  ПравилаЗагрузки        - ТаблицаЗначений, правила загрузки для проверки.
//  СтруктураСвойствОбъекта - Структура, СтрокаТаблицыЗначений (Состав: ВидОбъекта, ИмяОбъекта).
// 
//  Отказ - Булево, флаг ошибки в правилах загрузки.
// 
Процедура ПроверитьТабЧатьПравилаЗагрузкиПоСтрочно(ПравилаЗагрузки, СтруктураСвойствОбъекта, Отказ, Заголовок)

	Если ПравилаЗагрузки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
		
	// Получим структуру имен - ссылочных типов.
	СтруктураСсылочныхТипов = ПолучитьСтруктуруИменСсылочныхТиповДляЗагрузки();
	
	// Получаем реквизиты объекта загрузки.
	ТаблицаРеквизитов = ПолучитьРеквизитыОбъектаЗагрузки(СтруктураСсылочныхТипов, СтруктураСвойствОбъекта);
	
	// Сформируем массив с именами реквизитов в верхнем регистре.
	// Для осуществления поиска.
	МассивДляПоиска = Новый Массив;
	Для Каждого ТекСтрока Из ТаблицаРеквизитов Цикл
		МассивДляПоиска.Добавить(ВРег(ТекСтрока.ВидДанных + "_" + ТекСтрока.ИмяРеквизита));
	КонецЦикла;
	
	// Получим соответствие тип - вид объекта.
	СоотТипВидОбъекта = ПолучитьСоответствиеТиповИВидовОбъектов();
	ТипыОбъектов 	  = Перечисления.бит_ТипыЗагружаемыхОбъектовИзExcel;
	
	Для Каждого ТекСтрока Из ПравилаЗагрузки Цикл
		
		СтрокаНачалаСообщенияОбОшибке = "В строке номер """ + СокрЛП(ТекСтрока.НомерСтроки) + """ табличной части ""Правила загрузки"": ";
		
		Если Не (ЗначениеЗаполнено(ТекСтрока.ПоУмолчанию) И Не ТекСтрока.ТолькоДляПустых)
			И Не ЗначениеЗаполнено(ТекСтрока.ИмяВФайле) Тогда
			СтрокаСообщения = "Не заполнено значение реквизита ""Имя в файле""!";
			СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(ТекСтрока.ИмяРеквизита) Тогда
			СтрокаСообщения = "Не заполнено значение реквизита ""Имя реквизита""!";
			СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
		Иначе
			// Проверим правильность указания имени реквизита объекта.
			
			Если Не ТекСтрока.ИмяРеквизита = "Без_Сопоставления" Тогда
				
				// Проверим наличие реквизита у объекта.
				ИндексСтроки = МассивДляПоиска.Найти(ВРег(ТекСтрока.ВидДанных + "_" + ТекСтрока.ИмяРеквизита));
				
				// Если реквизит не найден, тогда
				Если ИндексСтроки = Неопределено Тогда
					СтрокаСообщения = "Не правильно указано значение реквизита ""Имя реквизита""!";
					СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок)
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// Если тип заполнен, тогда
		Если ЗначениеЗаполнено(ТекСтрока.Тип) Тогда
			
			// Для произвольного алгоритма, обязательно указание алгоритма получения значения.
			Если ТекСтрока.Тип = ТипыОбъектов.ПроизвольныйАлгоритм Тогда
				
				Если НЕ ЗначениеЗаполнено(ТекСтрока.ИмяОбъекта) Тогда
					СтрокаСообщения = "Не заполнено значение реквизита ""Пользовательская функция""!";
					СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
				КонецЕсли;
				
			Иначе
				
				// Получаем символы для поиска.
				СимволыДляПоиска = ПолучитьВидОбъектаИзСоответствия(СоотТипВидОбъекта, ТекСтрока.Тип);
				
				// Если это ссылочный тип, тогда
				// проверим заполненность имени объекта и реквизита поиска.
				Если ЗначениеЗаполнено(СимволыДляПоиска) 
					И СтруктураСсылочныхТипов.Свойство(СимволыДляПоиска) Тогда
					
					Если НЕ ЗначениеЗаполнено(ТекСтрока.ИмяОбъекта) Тогда
						СтрокаСообщения = "Не заполнено значение реквизита ""Имя объекта""!";
						СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
					Иначе
						// Проверим правильность указания имени объекта и имени реквизита поиска.
						ПроверитьПравильностьУказанияИмениОбъектаИИмениРеквизитаПоиска(СтруктураСсылочныхТипов, СимволыДляПоиска,
						ТекСтрока, СтрокаНачалаСообщенияОбОшибке,
						Отказ, Заголовок);
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
		Иначе
			СтрокаСообщения = "Не заполнено значение реквизита ""Тип""!";
			СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
		КонецЕсли;
		
	КонецЦикла; // Для Каждого ТекСтрока Из ПравилаЗагрузки Цикл.
        
КонецПроцедуры // ПроверитьТабЧатьПравилаЗагрузкиПоСтрочно()

// Процедура проверяет правильность указания имени объекта
// и имени реквизита поиска.
// 
// Параметры:
//  СтруктураСсылочныхТипов - Структура.
//  СимволыДляПоиска        - Строка, текст для поиска значений в структуре "СтруктураСсылочныхТипов".
// 
//  СтрокаТекПравило     - СтрокаТаблицыЗначений, СтрокаВыборкиЗапроса.
//  НачСообщенияОбОшибке - Строка, текст начального сообщения об ошибке.
//  Отказ                - Булево, флаг ошибки указания имени.
//  Заголовок            - Строка.
// 
Процедура ПроверитьПравильностьУказанияИмениОбъектаИИмениРеквизитаПоиска(СтруктураСсылочныхТипов, СимволыДляПоиска, СтрокаТекПравило,
                                                                         СтрокаНачалаСообщенияОбОшибке, Отказ, Заголовок = "")

    СтруктураДанных = СтруктураСсылочныхТипов[СимволыДляПоиска];
    
    // Если удастся установить тип объекта, тогда
    // имя объекта указано правильно.
    Попытка
        // Получим тип объекта.
        ТипОбъекта = Тип(ПолучитьИмяТипаОбъекта(СтрокаТекПравило.ИмяОбъекта, СтруктураДанных.НачалоИмениТипа));
        ИмяОбъектаПравильное = Истина;
    Исключение
        ИмяОбъектаПравильное = Ложь;
        СтрокаСообщения = "Не правильно указано значение реквизита ""Имя объекта""!";
        СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
    КонецПопытки;
    
    // Если имя объекта указано правильно, проверим заполненность
    // и правильность имени реквизита поиска объекта.
    Если ИмяОбъектаПравильное 
        И Не СтруктураДанных.НачалоИмениТипа = "Перечисление" Тогда
        
        РеквизитЗаполнен = ЗначениеЗаполнено(СтрокаТекПравило.РеквизитПоиска);
        
        Если Не РеквизитЗаполнен Тогда
            СтрокаСообщения = "Не заполнено значение реквизита ""Реквизит поиска""!";
            СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок);
        КонецЕсли;
        
        Если РеквизитЗаполнен Тогда
            
            // Получаем реквизиты текущего объекта для проверки правильности указания имени реквизита поиска.
            ТаблицаРеквизитов = ПолучитьРеквизитыОбъектаТекущейСтроки(СтруктураСсылочныхТипов, СтрокаТекПравило);
            
            МассивДляПоиска = Новый Массив;
            
            // Сформируем массив с именами реквизитов в верхнем регистре.
            // Для осуществления поиска.
            Для Каждого ТекСтрока Из ТаблицаРеквизитов Цикл
                МассивДляПоиска.Добавить(ВРег(ТекСтрока.ИмяРеквизита));
            КонецЦикла;
            
            // Проверим наличие реквизита у объекта.
            ИндексСтроки = МассивДляПоиска.Найти(ВРег(СтрокаТекПравило.РеквизитПоиска));
            
            // Если реквизит не найден, тогда
            Если ИндексСтроки = Неопределено Тогда
                СтрокаСообщения = "Не правильно указано значение реквизита ""Реквизит поиска""!";
                СообщитьОбОшибке(СтрокаНачалаСообщенияОбОшибке + СтрокаСообщения, Отказ, Заголовок)
            КонецЕсли;
            
        КонецЕсли;
        
    КонецЕсли;
    
КонецПроцедуры // ПроверитьПравильностьУказанияИмениОбъектаИИмениРеквизитаПоиска()

// Функция возвращает таблицу для вывода
// Функция относится к процедуре "ПроверитьДублированиеЗначенийВТабличнойЧасти".
// 
// Параметры:
//  ТаблицаСДанными - Тип "ТаблицаЗначений" .
// 
Функция ПроставитьНомераСтрокДляЗначений(ТаблицаСДанными)
    
    ТаблицаДляПеребора = ТаблицаСДанными.Скопировать();
    ТаблицаДляПеребора.Свернуть("Значение");
    
    ТаблицаДляВывода = ТаблицаСДанными.Скопировать();
    ТаблицаДляВывода.Очистить();
    
    Для Каждого ТекЗначение ИЗ ТаблицаДляПеребора Цикл
        
        Отбор = Новый Структура;
        Отбор.Вставить("Значение", ТекЗначение.Значение);
        
        НайденныеСтроки = ТаблицаСДанными.НайтиСтроки(Отбор);
        
        Если ЗначениеЗаполнено(НайденныеСтроки) Тогда
            
            НомераСтрок = "№ ";
            
            Для Каждого ТекСтрока ИЗ НайденныеСтроки Цикл
                НомераСтрок = НомераСтрок + ?(НомераСтрок = "№ ", "", ", ") + ТекСтрока.НомераСтрок;
            КонецЦикла;
            
            НовСтрока = ТаблицаДляВывода.Добавить();
            НовСтрока.Значение    = ТекЗначение.Значение;
            НовСтрока.НомераСтрок = НомераСтрок;
            
        КонецЕсли;
        
    КонецЦикла;
    
    Возврат ТаблицаДляВывода;
    
КонецФункции // ПроставитьНомераСтрокДляЗначений()

// Функция получает список имен коллекции метаданных по имени коллекции метаданных.
// 
// Параметры:
//  ИмяКоллекции - Строка.
// 
// Возвращаемое значение:
//   СписокИмен - СписокЗначений.
// 
Функция ПолучитьСписокИменКоллекцииМетаданных(ИмяКоллекции)
	
	СписокИмен = Новый СписокЗначений;
	
	КоллекцияМетаданных = Метаданные[ИмяКоллекции];
	КартинкаКоллекции   = ОпределитьКартинкуВидаОбъектаПоИмениКоллекцииМетаданных(ИмяКоллекции);
	
	Для Каждого ТекМетаданные Из КоллекцияМетаданных Цикл
		СписокИмен.Добавить(ТекМетаданные.Имя, ТекМетаданные.Синоним,, КартинкаКоллекции);
	КонецЦикла;
	
	СписокИмен.СортироватьПоПредставлению();
	
	Возврат СписокИмен;
	
КонецФункции // ПолучитьСписокИменКоллекцииМетаданных()

// Процедура добавляет реквизит в таблицы реквизитов.
// 
// Параметры:
//  ТаблицаРеквизитов - ТаблицаЗначений.
//  ВидДанных         - Строка. Необязательный - по умолчанию "Шапка".
//  ТекРеквизит       - МетаданныеРеквизитОбъекта, Строка.
//  Представление     - Строка. Необязательный - по умолчанию "".
// 
Процедура ДобавитьРеквизитВТаблицуРеквизитов(ТаблицаРеквизитов, ВидДанных = "Шапка", ТекРеквизит, Представление = "")
	
	НовСтрока = ТаблицаРеквизитов.Добавить();
	НовСтрока.ВидДанных = ВидДанных;
	
	Если ТипЗнч(ТекРеквизит) = Тип("Строка") Тогда
		
		НовСтрока.ИмяРеквизита  = ТекРеквизит;
		НовСтрока.Представление = Представление;
		
	ИначеЕсли ТипЗнч(ТекРеквизит) = Тип("Структура") Тогда
		
		НовСтрока.ИмяРеквизита = ТекРеквизит.Имя;
		НовСтрока.Представление= ТекРеквизит.Синоним;
		НовСтрока.Реквизит	   = ТекРеквизит.ОписаниеТипов;
		
	Иначе
		
		НовСтрока.ИмяРеквизита  = ТекРеквизит.Имя;
		НовСтрока.Представление = ТекРеквизит.Синоним;
		НовСтрока.Реквизит      = ТекРеквизит;
		
	КонецЕсли;
		
КонецПроцедуры // ДобавитьРеквизитВТаблицуРеквизитов()

Процедура ДобавитьСвойстваРегистровВСтруктуруРеквизитов(МетаОбъект, СтруктураРеквизитов, ВидДанных="")
	
	Если НЕ ЭтоДокументРучнаяОперация(МетаОбъект) Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ВидДанных)
		И НЕ Лев(ВидДанных, 9) = "Движения_" Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустаяСтрока(ВидДанных) Тогда
		ИмяРегистра = "";
	Иначе	
		ИмяРегистра = СтрЗаменить(ВидДанных, "Движения_", "");
	КонецЕсли; 
	
	Для Каждого ТекРегистр Из МетаОбъект.Движения Цикл
		
		Если НЕ ПустаяСтрока(ИмяРегистра)
			И НЕ ТекРегистр.Имя = ИмяРегистра Тогда
			Продолжить;
		КонецЕсли;
		
		ВидРегистра = ПолучитьВидОбъектаПоМетаданным(ТекРегистр);
		
		МассивСвойств = Новый Массив;
		
		Если ВидРегистра = "РегистрБухгалтерии" Тогда
			ДобавитьСвойстваРегистраБухгалтерии(ТекРегистр, МассивСвойств);
		Иначе
			МассивСвойств.Добавить(ТекРегистр.Измерения);
			МассивСвойств.Добавить(ТекРегистр.Ресурсы);
			МассивСвойств.Добавить(ТекРегистр.Реквизиты);
		КонецЕсли;
		
		СтруктураРеквизитов.Вставить("Движения_"+ТекРегистр.Имя, МассивСвойств);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьСвойстваРегистраБухгалтерии(МетаРегистр, МассивСвойств)
	
	СвойстваРегистра = Новый Массив;
	
	МассивБалансовыхИзмерений 	= Новый Массив;
	МассивНеБалансовыхИзмерений = Новый Массив;
	МассивБалансовыхРесурсов 	= Новый Массив;
	МассивНеБалансовыхРесурсов 	= Новый Массив;
	МассивРеквизитов 			= Новый Массив;
	
	// Измерения
	Для Каждого ТекущееИзмерение Из МетаРегистр.Измерения Цикл
		
		Если ТекущееИзмерение.Балансовый Тогда
			МассивБалансовыхИзмерений.Добавить(ТекущееИзмерение);
		Иначе
			МассивНеБалансовыхИзмерений.Добавить(ТекущееИзмерение);
		КонецЕсли;
		
	КонецЦикла;
	
	// Ресурсы
	Для Каждого ТекущийРесурс Из МетаРегистр.Ресурсы Цикл
		
		Если ТекущийРесурс.Балансовый Тогда
			МассивБалансовыхРесурсов.Добавить(ТекущийРесурс);
		Иначе
			МассивНеБалансовыхРесурсов.Добавить(ТекущийРесурс);
		КонецЕсли;
		
	КонецЦикла;
	
	// Реквизиты
	Для Каждого ТекущийРеквизит Из МетаРегистр.Реквизиты Цикл
		
		МассивРеквизитов.Добавить(ТекущийРеквизит);
		
	КонецЦикла;
	
	ПоддержкаКорреспонденции = МетаРегистр.Корреспонденция;
	
	ПланСчетовРегистра = МетаРегистр.ПланСчетов;
	
	МаксКоличествоСубконто = ПланСчетовРегистра.МаксКоличествоСубконто;
	
	// Заполняем таблицу по частям
	
	// 1 (Период, НомерСтроки, Регистратор, балансовые измерения).
	
	// СвойстваРегистра.Добавить("Период");
	
	Для Каждого ТекущееИзмерение Из МассивБалансовыхИзмерений Цикл
		
		СвойстваРегистра.Добавить(ТекущееИзмерение);
		
	КонецЦикла;
			
	МассивСторонПроводки = Новый Массив;
	
	Если ПоддержкаКорреспонденции Тогда
		МассивСторонПроводки.Добавить("Дт");
		МассивСторонПроводки.Добавить("Кт");
	Иначе
		МассивСторонПроводки.Добавить("");
	КонецЕсли;
	
	Для Каждого СторонаПроводки Из МассивСторонПроводки Цикл
		
		// 2,5 (Счет, Не балансовые измерения)
		
		Структура = Новый Структура;
		Структура.Вставить("Имя", "Счет"+СторонаПроводки);
		Структура.Вставить("Синоним", "Счет"+СторонаПроводки);
		Структура.Вставить("ОписаниеТипов", Новый ОписаниеТипов("ПланСчетовСсылка."+ПланСчетовРегистра.Имя));
		
		СвойстваРегистра.Добавить(Структура);
		
		Для Каждого ТекущееИзмерение Из МассивНеБалансовыхИзмерений Цикл
			
			Структура = Новый Структура;
			Структура.Вставить("Имя", ТекущееИзмерение.Имя+СторонаПроводки);
			Структура.Вставить("Синоним", ТекущееИзмерение.Имя+СторонаПроводки);
			Структура.Вставить("ОписаниеТипов", ТекущееИзмерение.Тип);
			
			СвойстваРегистра.Добавить(Структура);
			
		КонецЦикла;
		
		// 3,6 (Субконто)
		
		Для Ном = 1 по МаксКоличествоСубконто Цикл
			
			Структура = Новый Структура;
			Структура.Вставить("Имя", "Субконто"+СторонаПроводки+Ном);
			Структура.Вставить("Синоним", "Субконто"+СторонаПроводки+Ном);
			Структура.Вставить("ОписаниеТипов", ПланСчетовРегистра.ВидыСубконто.Тип);
			
			СвойстваРегистра.Добавить(Структура);
			
		КонецЦикла;
		
		// 4,7 (Количество, Валюта, Вал.сумма - не балансовые ресурсы).
		
		Для Каждого ТекущийРесурс Из МассивНеБалансовыхРесурсов Цикл
			
			Структура = Новый Структура;
			Структура.Вставить("Имя", ТекущийРесурс.Имя+СторонаПроводки);
			Структура.Вставить("Синоним", ТекущийРесурс.Имя+СторонаПроводки);
			Структура.Вставить("ОписаниеТипов", ТекущийРесурс.Тип);
			
			СвойстваРегистра.Добавить(Структура);
			
		КонецЦикла;
		
	КонецЦикла; // Стороны проводки
	
	// 8 (Сумма - балансовые ресурсы)
	
	Для Каждого ТекущийРесурс Из МассивБалансовыхРесурсов Цикл
		
		СвойстваРегистра.Добавить(ТекущийРесурс);
		
	КонецЦикла;
	
	// 9 (Содержание - реквизиты)
	
	Для Каждого ТекущийРеквизит Из МассивРеквизитов Цикл
		
		СвойстваРегистра.Добавить(ТекущийРеквизит);
		
	КонецЦикла;
	
	МассивСвойств.Добавить(СвойстваРегистра);
	
КонецПроцедуры

Процедура ДобавитьТаблицыДвиженийРучныхОпераций(МетаОбъект, ПравилаЗагрузкиДерево, СтрокаТабличныеЧасти, ПравилаЗагрузки, СтруктураПараметров)
	
	Если НЕ ЭтоДокументРучнаяОперация(МетаОбъект) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнятьИДСтроки		= СтруктураПараметров.ЗаполнятьИДСтроки;
	БезСопоставления	    = СтруктураПараметров.БезСопоставления;
	
	Если СтрокаТабличныеЧасти = Неопределено Тогда
		
		СтрокаТабличныеЧасти = ПравилаЗагрузкиДерево.Строки.Добавить();
		СтрокаТабличныеЧасти.ВидДанных	    = "Табличные части";
		СтрокаТабличныеЧасти.ВерхнийУровень = Истина;
		
	КонецЕсли;
	
	Для Каждого ТекРегистр Из МетаОбъект.Движения Цикл
		
		СтрокаДвижениеТабЧасть = СтрокаТабличныеЧасти.Строки.Добавить();
		СтрокаДвижениеТабЧасть.ВидДанных	  = "Движения_"+ТекРегистр.Имя;
		СтрокаДвижениеТабЧасть.ВерхнийУровень = Истина;
		
		ДанныеРегистра = ПравилаЗагрузки.НайтиСтроки(Новый Структура("ВидДанных", "Движения_"+ТекРегистр.Имя));
		
		Для Каждого ТекСтрока Из ДанныеРегистра Цикл
			
			Если БезСопоставления
				И ВРег(ТекСтрока.ИмяРеквизита) = ВРег("Без_Сопоставления") Тогда
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока = СтрокаДвижениеТабЧасть.Строки.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекСтрока);
			
			Если ЗаполнятьИДСтроки Тогда
				НоваяСтрока.ИД = Новый УникальныйИдентификатор();
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти
