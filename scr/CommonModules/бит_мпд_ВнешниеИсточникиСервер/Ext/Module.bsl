
#Область СлужебныйПрограммныйИнтерфейс

#Область ПолучениеДанныхВнешнимиИсточниками

// Процедура получает данные по источнику из внешней ИБ.
// 
// Параметры:
//  ИсточникДанных  - СправочникСсылка.ИсточникиДанныхДляРасчетовБюджетирования.
//  ГраницаНач      - Дата,Граница .
//  ГраницаКон      - Дата,Граница.
//  СтрПар          - Структура.
// 
// Возвращаемое значение:
//   ТаблицаДанных  - ТаблицаЗначений, РезультатЗапроса.
// 
Функция ПолучитьДанныеПоИсточникуВнешняяБаза(ИсточникДанных, ГраницаНач ,ГраницаКон ,СтрПар) Экспорт
								  
    Параметры = СтрПар.Параметры;
	Настройка = СтрПар.Настройка;
	Поля      = СтрПар.Поля;
	ОтборВОтчете               = СтрПар.ОтборВОтчете;
	ВозвращатьРезультатЗапроса = СтрПар.ВозвращатьРезультатЗапроса;
	НастройкаПодключения       = СтрПар.НастройкаПодключения;
	ПулПодключений             = СтрПар.ПулПодключений;
	ЭтоHTTPЗапрос = ?(ИсточникДанных.ЗапросБД.Вид = Перечисления.бит_мпд_ВидыЗапросов.ЗапросHTTP, Истина, Ложь);
	
	// Определяем по какой настройке подключения работат.
	Если НЕ ЗначениеЗаполнено(НастройкаПодключения) Тогда
		
		ТекНастройкаПодключения = ИсточникДанных.НастройкаПодключения;
		
	Иначе	
		
		ТекНастройкаПодключения = НастройкаПодключения;
		
	КонецЕсли; 							  
	
	// Находим соединение или подключаемся
	Если ЭтоHTTPЗапрос Тогда
		
		Соединение = Неопределено;
		
	Иначе	
		
		Если НЕ ПулПодключений = Неопределено Тогда
			
			Соединение = ПулПодключений[ТекНастройкаПодключения];
			
		Иначе
			
			Соединение = бит_мпд_ПовтИсп.ПодключитьКОМ(ТекНастройкаПодключения);
			
		КонецЕсли; 							  
		
	КонецЕсли; 
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	Если Соединение = Неопределено И НЕ ЭтоHTTPЗапрос Тогда
		
		Возврат ТаблицаДанных;
		
	КонецЕсли; 
	
	ВидИбИсточник        = Справочники.бит_мпд_ВидыИнформационныхБаз.ТекущаяИнформационнаяБаза;
	ВидИбПриемник        = ТекНастройкаПодключения.ВидИнформационнойБазы;
	ПравилаПоискаТекВнеш = РегистрыСведений.бит_мпд_НазначениеПравилПоискаДанных.ПолучитьПравилаПоиска(ВидИбИсточник,ВидИбПриемник);
	ПравилаПоискаВнешТек = РегистрыСведений.бит_мпд_НазначениеПравилПоискаДанных.ПолучитьПравилаПоиска(ВидИбПриемник,ВидИбИсточник);
	
	Если ЭтоHTTPЗапрос Тогда
		
		СтрПравила = Новый Структура;
		СтрПравила.Вставить("ТекВнеш", ПравилаПоискаТекВнеш);
		СтрПравила.Вставить("ВнешТек", ПравилаПоискаВнешТек);
		
		ТаблицаДанных = ПолучитьДанныеHTTPЗапросом(ИсточникДанных, ГраницаНач, ГраницаКон, СтрПар, СтрПравила);
		
	Иначе	
		
		ПостроительЗапроса                         = Соединение.NewObject("ПостроительЗапроса");
		ПостроительЗапроса.Текст                   = ИсточникДанных.ЗапросБД.ТекстЗапроса;
		ПостроительЗапроса.ДобавлениеПредставлений = Соединение.ТипДобавленияПредставлений.НеДобавлять;
		
		// Сохраненные настройки построителя
		НастройкаИсточника = ИсточникДанных.НастройкиПостроителя.Получить();
		
		Если Настройка = Неопределено Тогда
			СохраненнаяНастройка=НастройкаИсточника;
		Иначе
			СохраненнаяНастройка=Настройка;
		КонецЕсли; 
		
		Если ТипЗнч(НастройкаИсточника) = Тип("Структура") Тогда
			
			Для Каждого Параметр Из НастройкаИсточника.ПараметрыПостроителя Цикл
				НайденноеЗначение = ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоискаТекВнеш, Параметр.Значение, Истина);
				ПостроительЗапроса.Параметры.Вставить(Параметр.Ключ,НайденноеЗначение);
			КонецЦикла;
			
		КонецЕсли; 
		
		// Заполнение выбранных полей построителя по настройке источника данных.
		бит_МеханизмПолученияДанных.ЗаполнитьВыбранныеПоля(ПостроительЗапроса, ИсточникДанных); 
		
		// Заполним параметры построителя
		Если ТипЗнч(Параметры) = Тип("Структура") Тогда
			
			Для каждого КлючИЗначение Из Параметры Цикл
				
				НайденноеЗначение = ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоискаТекВнеш, КлючИЗначение.Значение, Истина);			
				ПостроительЗапроса.Параметры.Вставить(КлючИЗначение.Ключ,НайденноеЗначение);
				
			КонецЦикла; 
			
		КонецЕсли; 
		
		// Создадим аналогичные границы в подключенной базе.
		ГраницаНачВнеш = ГраницаВнешняяБаза(Соединение,ГраницаНач);
		ГраницаКонВнеш = ГраницаВнешняяБаза(Соединение,ГраницаКон);
		
		// Установим "Предопределенные" параметры построителя.
		флКонецГраница = ТипЗнч(ГраницаКон) = Тип("Граница");
		бит_МеханизмПолученияДанных.УстановитьОбязательныеПараметры(ПостроительЗапроса,ГраницаНачВнеш,ГраницаКонВнеш,флКонецГраница);
		
		// Отбор заполняем по элементу данных
		УстановитьОтборЭлементаДанных(Соединение, ПостроительЗапроса,СохраненнаяНастройка, ПравилаПоискаТекВнеш, Истина);
		
		// Заполним отборы, установленные в форме отчета.
		УстановитьОтборОтчета(Соединение, ПостроительЗапроса, ОтборВОтчете, ПравилаПоискаТекВнеш, Истина);
		
		Если НЕ СтрПар.Измерения = Неопределено Тогда
			
			бит_МеханизмПолученияДанных.УстановитьИзмеренияСтроки(СтрПар.Измерения, ПостроительЗапроса,,Соединение);
			
		КонецЕсли; 	
		
		бит_МеханизмПолученияДанных.УстановитьПорядокПостроителя(ИсточникДанных.Порядок, ПостроительЗапроса, Соединение.НаправлениеСортировки);
		
		// Выполнение запроса
		ПостроительЗапроса.Выполнить();
		Результат = ПостроительЗапроса.Результат;
		
		Если ВозвращатьРезультатЗапроса Тогда
			
			ТаблицаДанных = Результат;
			
		Иначе	
			
			ТаблицаДанныхКом = Результат.Выгрузить();
			
			МетаКом = Соединение.Метаданные;
			ПреобразоватьВнешниеДанные(Соединение, ТекНастройкаПодключения, МетаКом, ТаблицаДанныхКом, ТаблицаДанных, ПравилаПоискаВнешТек);
			бит_МеханизмПолученияДанных.ПодставитьСинонимыИсточника(ТаблицаДанных,ИсточникДанных);
			
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат ТаблицаДанных;
	
КонецФункции // ПолучитьДанные()

// Функция.
// 
// Параметры:
// 
// 
// Возвращаемое значение:
//  Результат - Строка.
// 
Функция ПреобразоватьЗначениеВнешняяТекущая(Соединение
	                                          , НастройкаПодключения
											  , ЗначениеКом
											  , Список = Неопределено
											  , ПравилаПоиска
											  , КэшПоиска) Экспорт

	Если Список = Неопределено Тогда
	
		Список = Новый СписокЗначений;
	
	КонецЕсли; 
	
	МетаКом = Соединение.Метаданные;
	
	Если бит_ОбщегоНазначения.ЭтоПримитивныйТип(ЗначениеКом) Тогда
		
		РезЗначение = ЗначениеКом;	
		
	Иначе
		
		Попытка
			
			МетаЗначение = ЗначениеКом.Метаданные();
			
		Исключение
			
			МетаЗначение = Неопределено;   
			
		КонецПопытки;	
		
		Если НЕ МетаЗначение = Неопределено Тогда
			
			ИмяПолное = МетаЗначение.ПолноеИмя();
			
			Если Найти(ИмяПолное,"Перечисление.") = 0 Тогда
				
				ТекИД        = Соединение.String(ЗначениеКом.УникальныйИдентификатор());
				
			Иначе
				
				СтруктураИмен   = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяПолное);
				ПеречислениеКом = Соединение.Перечисления[СтруктураИмен.ИмяОбъекта];
				ТекИД           = ПолучитьИмяЗначенияПеречисленияВнеш(Соединение, ПеречислениеКом, ЗначениеКом);
				
			КонецЕсли;			
			
			КлючЗначения = ИмяПолное+"?ref="""+ТекИД+"""";
			
			РезЗначение = КэшПоиска[КлючЗначения];
			
			Если РезЗначение = Неопределено Тогда
				
				Правило = ПравилаПоиска[ИмяПолное];
				
				СтрПар = Новый Структура("Правило,Направление,ЗначениеПоиска,ИмяОбъектаПолное");
				СтрПар.Правило          = Правило;
				СтрПар.Направление      = "ВнешняяТекущая";
				СтрПар.ЗначениеПоиска   = ЗначениеКом;
				СтрПар.ИмяОбъектаПолное = ИмяПолное;
				
				РезЗначение = ВыполнитьПоискПоПравилу(Соединение, СтрПар);
				
				КэшПоиска.Вставить(КлючЗначения, РезЗначение);
				
			КонецЕсли; 
			
			
			Если РезЗначение = Неопределено Тогда
				
				Если ОбъектПринадлежитКоллекцииМетаданных(МетаКом,"Документы",МетаЗначение.Имя) Тогда
					
					ТекПредставление = МетаЗначение.Синоним+" № "+ЗначениеКом.Номер+НСтр("ru=' от '")+ЗначениеКом.Дата;
					
				ИначеЕсли ОбъектПринадлежитКоллекцииМетаданных(МетаКом,"ПланыСчетов",МетаЗначение.Имя) Тогда
					
					ТекПредставление = ЗначениеКом.Код;
					
				Иначе
					
					ТекПредставление = Соединение.String(ЗначениеКом);
					
				КонецЕсли; 	
				
				Если ПустаяСтрока(ТекПредставление) Тогда
					
					ТекПредставление = " ";
					
				КонецЕсли; 
				
				СтрРасшифровки = Новый Структура("ИмяКласса, НастройкаПодключения, ПолноеИмя, ИД, Значение, Представление", "ЗначениеВнешнейБазы");
				СтрРасшифровки.НастройкаПодключения = НастройкаПодключения;
				СтрРасшифровки.ПолноеИмя = МетаЗначение.ПолноеИмя();
				
				Если Найти(СтрРасшифровки.ПолноеИмя,"Перечисление.") = 0 Тогда
					
					СтрРасшифровки.ИД        = Соединение.String(ЗначениеКом.УникальныйИдентификатор());
					
				КонецЕсли; 
				СтрРасшифровки.Представление = ТекПредставление;
				
				// Изменение кода. Начало. 20.11.2012{{
				// ЭлементСписка = Список.Добавить();
				// ЭлементСписка.Значение      = СтрРасшифровки;
				// ЭлементСписка.Представление = ТекПредставление;
				// 
				// РезЗначение = ЭлементСписка;				  
				РезЗначение = СтрРасшифровки;
				// Изменение кода. Конец. 20.11.2012}}
				
				КэшПоиска.Вставить(КлючЗначения, РезЗначение);				
				
			КонецЕсли; 
						
		КонецЕсли; // НЕ МетаЗначение = Неопределено
		
	КонецЕсли; // Проверка типов ЗначениеКом

	Возврат РезЗначение;
	
КонецФункции // ПреобразоватьЗначениеВнешняяТекущая()

// Функция выполняет преобразование ОписанияТипов из текущей базы во внешнюю.
// 
// Параметры:
//  Соединение      - ComObject
//  ОписаниеВнешняя - ОписаниеТипов.
// 
// Возвращаемое значение:
//  ОписаниеТекущая - ОписаниеТипов.
// 
Функция ПреобразоватьОписаниеТиповВнешняяТекущая(Соединение, ОписаниеВнешняя, ПравилаПоиска = Неопределено) Экспорт
	
	ОписаниеТекущая = Неопределено;
	
	МетаКореньВнешняя  = Соединение.Метаданные;
	МассивТиповВнешняя = ОписаниеВнешняя.Типы();
	МассивТиповТекущая = Новый Массив;
	
	Для каждого ТипВнешний Из МассивТиповВнешняя Цикл
		
		МетаВнешний = МетаКореньВнешняя.НайтиПоТипу(ТипВнешний);
		
		Если НЕ МетаВнешний = Неопределено Тогда
			
			// Ссылочные тип - попытаемся преобразовать
			ИмяПолное   = МетаВнешний.ПолноеИмя();
			
			Если НЕ ПравилаПоиска = Неопределено Тогда
				
				// Если заданы правила поиска пытаемся найти в приемнике имя объекта, соответсвующее источнику.
				Правило = ПравилаПоиска[ИмяПолное];
				
				Если НЕ Правило = Неопределено Тогда
					
					
					РеквизитыПравила = ОпределитьИменаРеквизитовПравила(Правило,"ВнешняяТекущая");
					ИмяПолноеТек = Правило["ИмяОбъектаПолное_"+РеквизитыПравила.НомерПриемника];
					
					СтрИмен = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяПолноеТек);
					
				Иначе
					
					СтрИмен = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяПолное);				 
					
				КонецЕсли; 
				
			Иначе	
				
				СтрИмен = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяПолное);
				
			КонецЕсли; 
			
			ИмяТипа = СтрИмен.ИмяКласса+"Ссылка."+СтрИмен.ИмяОбъекта;		 
			
			
		Иначе	
			
			// Примитивные тип - просто создаем
			ИмяТипа = Соединение.String(ТипВнешний);
			
		КонецЕсли; 
		
		Попытка
			
			ТипТекущая = Тип(ИмяТипа);
			МассивТиповТекущая.Добавить(ТипТекущая);
			
		Исключение
			
		КонецПопытки;
		
	КонецЦикла; // МассивТиповВнешняя
	
	
	Если МассивТиповТекущая.Количество() = 0 Тогда
		
		МассивТиповТекущая.Добавить(Тип("Строка"));
		
	КонецЕсли; 
	
	ОписаниеТекущая = Новый ОписаниеТипов(МассивТиповТекущая);
	
	Возврат ОписаниеТекущая;
	
КонецФункции // ПреобразоватьОписаниеТиповВнешняяТекущая()

// Функция определяет принадлежит объект указанной коллекции метаданных или нет.
// 
// Параметры:
//  МетаКорень    - ComObject
//  ИмяКоллекции  - Строка
//  ИмяОбъекта    - Строка
// 
// Возвращаемое значение:
//   флПринадлежит   - Булево
// 
Функция ОбъектПринадлежитКоллекцииМетаданных(МетаКорень, ИмяКоллекции, ИмяОбъекта) Экспорт

	Если МетаКорень[ИмяКоллекции].Найти(ИмяОбъекта) = НЕОПРЕДЕЛЕНО Тогда
		флПринадлежит = Ложь;
	Иначе	
		флПринадлежит = Истина;
	КонецЕсли; 
	
	Возврат флПринадлежит;

КонецФункции // ОбъектПринадлежитКоллекцииМетаданных()
 
// Процедура устанавливаем в построитель отбор, установленный в отчете в поле Отбор.
// 
// Параметры:
//  ПостроительЗапроса  - Построитель
//  ОтборВОтчете        - ТаблицаЗначений.
// 
Процедура УстановитьОтборОтчета(Соединение, ПостроительЗапроса, ОтборВОтчете, ПравилаПоиска, ВыводитьСообщения = Ложь)  Экспорт

	// Заполним отборы, установленные в форме отчета.
	Если ОтборВОтчете <> Неопределено Тогда
		
		Для каждого СтрокаОтбор Из ОтборВОтчете Цикл
			
			Если СтрокаОтбор.Использование Тогда
				ИмяПоля       = СтрокаОтбор.Имя;
				ПолеНастройки = ПостроительЗапроса.ДоступныеПоля.Найти(ИмяПоля);
				Если ПолеНастройки <> Неопределено И ПолеНастройки.Отбор Тогда
					
					НовыйЭлОтбора = ПостроительЗапроса.Отбор.Добавить(ИмяПоля);
					
					ИмяВидаСравнения = бит_ОбщегоНазначенияКлиентСервер.ИмяВидаСравнения(СтрокаОтбор.ВидСравнения);
					
					ВидСравненияВнеш = Соединение.ВидСравнения[ИмяВидаСравнения];
					
					НовыйЭлОтбора.ВидСравнения  = ВидСравненияВнеш;
					
					НайденноеЗначение = ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоиска, СтрокаОтбор.Значение, Истина);
					
					Если НайденноеЗначение = Неопределено Тогда
						
						НовыйЭлОтбора.Использование = Ложь;						
						
						Если ВыводитьСообщения Тогда
							
							ТекстСообщения = НСтр("ru = 'Отбор ""%1% %2% %3%"" не был установлен!'");
							ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
																										,ИмяПоля
																										,Строка(СтрокаОтбор.ВидСравнения)
																										,Строка(СтрокаОтбор.Значение));
							
							бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);																			 
							
						КонецЕсли; 
						
						
					Иначе
						
						НовыйЭлОтбора.Значение      = НайденноеЗначение;
						НовыйЭлОтбора.Использование = Истина;																		
					
					КонецЕсли; 
					
				КонецЕсли; 
			КонецЕсли; // Использование 
			
		КонецЦикла; // По строкам отборов отчета
		
	КонецЕсли; // Отбор установлен

КонецПроцедуры // УстановитьОтборОтчета()

// Процедура устанавливает в построитель отбор, сохраненный в элементе данных.
// 
// Параметры:
//  ПостроительЗапроса   - ПостроительЗапроса
//  СохраненнаяНастройка - Структура.
// 
Процедура УстановитьОтборЭлементаДанных(Соединение, ПостроительЗапроса,СохраненнаяНастройка, ПравилаПоиска, ВыводитьСообщения = Ложь)  Экспорт

	// Отбор заполняем по элементу данных
	Если ТипЗнч(СохраненнаяНастройка)=Тип("Структура") Тогда
		
		Для каждого ЭлементОтбора Из СохраненнаяНастройка.Отбор Цикл
			
			Попытка
				ОписаниеЭлемента = ЭлементОтбора.ПутьКДанным;
				НовыйЭлОтбора    = ПостроительЗапроса.Отбор.Добавить(ОписаниеЭлемента);
				ЗаполнитьЭлементОтбора(Соединение, ЭлементОтбора ,НовыйЭлОтбора, ПравилаПоиска, ВыводитьСообщения);
			Исключение
				бит_ОбщегоНазначения.бит_Сообщить(ОписаниеОшибки());
			КонецПопытки;
			
		КонецЦикла; // По элементам отбора
		
	КонецЕсли; // Настройка - структура

КонецПроцедуры // УстановитьОтборЭлементаДанных()

// Процедура заполняет элемент отбора по элементу отбора- источнику.
// 
// Параметры:
//  ЭлементОтбораИсточник  - ЭлементОтбора
//  ЭлементОтбораПриемник  - ЭлементОтбора.
// 
Процедура ЗаполнитьЭлементОтбора(Соединение, ЭлементОтбораИсточник, ЭлементОтбораПриемник, ПравилаПоиска, ВыводитьСообщения = Ложь) Экспорт
	
	ИмяВидаСравнения = бит_ОбщегоНазначенияКлиентСервер.ИмяВидаСравнения(ЭлементОтбораИсточник.ВидСравнения);
	
	ЭлементОтбораПриемник.ВидСравнения = Соединение.ВидСравнения[ИмяВидаСравнения];
	
	Если бит_ОбщегоНазначения.ЭтоВидСравненияДляИнтервала(ЭлементОтбораИсточник.ВидСравнения) Тогда
		ЭлементОтбораПриемник.ЗначениеС    = ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоиска, ЭлементОтбораИсточник.ЗначениеС, ВыводитьСообщения);
		ЭлементОтбораПриемник.ЗначениеПо   = ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоиска, ЭлементОтбораИсточник.ЗначениеПо, ВыводитьСообщения);		
	Иначе	
		ЭлементОтбораПриемник.Значение     = ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоиска, ЭлементОтбораИсточник.Значение, ВыводитьСообщения);
	КонецЕсли; 
	
	ЭлементОтбораПриемник.Использование = ЭлементОтбораИсточник.Использование;
	ЭлементОтбораПриемник.Представление = ЭлементОтбораИсточник.Представление;
	
КонецПроцедуры // бит_ЗаполнитьЭлементОтбора()


// Функция осуществляет поиск значения во внешней ИБ по значение из текущей ИБ.
// 
// Параметры:
//  Соединение        - ComObject
//  ЗначениеДляПоиска - Произвольный.
// 
// Возвращаемое значение:
//  НайденноеЗначение - Строка.
// 
Функция ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоиска, ЗначениеДляПоиска, ВыводитьСообщения = Ложь)  Экспорт

	НайденноеЗначение = Неопределено;
	
	// Проверим является значение для поиска ссылочным, в противном случае поиск выполнять не нужно.
	Если бит_ОбщегоНазначения.ЭтоПримитивныйТип(ЗначениеДляПоиска) Тогда
		
		НайденноеЗначение = ЗначениеДляПоиска;
		
	ИначеЕсли ТипЗнч(ЗначениеДляПоиска) = Тип("Граница") Тогда	
		
		НайденноеЗначение = ГраницаВнешняяБаза(Соединение,ЗначениеДляПоиска);
		
	ИначеЕсли ТипЗнч(ЗначениеДляПоиска) = Тип("СписокЗначений") Тогда
		
		НайденноеЗначение = Соединение.NewObject("СписокЗначений");
		Для каждого Элемент Из ЗначениеДляПоиска Цикл
		
			КонвЗначение = ВыполнитьПоискВоВнешнейБазе(Соединение, ПравилаПоиска, Элемент.Значение);
			
			НайденноеЗначение.Добавить(КонвЗначение, Элемент.Представление, Элемент.Пометка);
		
		КонецЦикла; 
		
	Иначе	
		
		МетаОбъект = ЗначениеДляПоиска.Метаданные();
		ИмяПолное  = МетаОбъект.ПолноеИмя();
		
		Правило = ПравилаПоиска[ИмяПолное];
		
		СтрПар = Новый Структура("Правило,Направление,ЗначениеПоиска,ИмяОбъектаПолное");
		СтрПар.Правило          = Правило;
		СтрПар.Направление      = "ТекущаяВнешняя";
		СтрПар.ЗначениеПоиска   = ЗначениеДляПоиска;
		СтрПар.ИмяОбъектаПолное = ИмяПолное;
		
		НайденноеЗначение = ВыполнитьПоискПоПравилу(Соединение, СтрПар);
		
	КонецЕсли; 

	Если ВыводитьСообщения Тогда
		
		Если ЗначениеЗаполнено(ЗначениеДляПоиска) И НайденноеЗначение = Неопределено Тогда
			
			Если ЗначениеЗаполнено(ИмяПолное) Тогда
				
				ИмяТипа = "("+ИмяПолное+")"
				
			Иначе	
				
				ИмяТипа = "";
				
			КонецЕсли; 
			ТекстСообщения = НСтр("ru = 'Не удалось найти значение ""%1%"" %2% во внешней базе!'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
			                                                                              ,Строка(ЗначениеДляПоиска)
																						  ,ИмяТипа);
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат НайденноеЗначение;
	
КонецФункции // ВыполнитьПоискВнешняяБаза()


// Функция выполняет поиск значения по правилу в базе, подключенной через внешнее соединение.
// 
// Параметры:
//  Соединение - ComObject
//  Правило    - СправочникСсылка.бит_мпд_ПравилаПоискаДанных.
// 
// Возвращаемое значение:
//  НайденноеЗначение - Произвольный.
// 
Функция ВыполнитьПоискПоПравилу(Соединение, СтруктураПараметров, РежимСообщений = "Ошибки")  Экспорт

	РежимыВывода = бит_ОбщегоНазначения.ОпределитьРежимыВывода(РежимСообщений);
	
	Правило = СтруктураПараметров.Правило;
	// ИмяОбъектаПолное = СтруктураПараметров.ИмяОбъектаПолное;
	
	ЗначениеПоиска   = СтруктураПараметров.ЗначениеПоиска;
	Направление      = СтруктураПараметров.Направление;
	
	НайденноеЗначение = Неопределено;
	
	Если ЗначениеЗаполнено(Правило) Тогда
		
		НомерИсточника = ОпределитьНомерРеквизитаИсточника(Правило,СтруктураПараметров.Направление);
		НомерПриемника = ОпределитьНомерРеквизитаПриемника(НомерИсточника);
		ИмяОбъектаПолное = Правило["ИмяОбъектаПолное_"+НомерПриемника];
		
		// Выполним поиск значения по правилам
		ТаблицаПравила = Правило.ПравилаПоиска.Выгрузить();
		
		ТаблицаВрем = ТаблицаПравила.Скопировать();
		ТаблицаВрем.Свернуть("Приоритет");
		ТаблицаВрем.Сортировать("Приоритет");
		МассивПриоритет = ТаблицаВрем.ВыгрузитьКолонку("Приоритет");
		
		Для каждого Приоритет Из МассивПриоритет Цикл
			
			СтрОтбор = Новый Структура("Приоритет",Приоритет);
			
			СтрокиПравил = ТаблицаПравила.НайтиСтроки(СтрОтбор);
			
			Если СтрокиПравил.Количество() > 0 Тогда
			
				 ПерваяСтрока = СтрокиПравил[0];
				 
				 СтруктураИмен = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяОбъектаПолное);
				 
				 Если ПерваяСтрока.СпособПоискаДанных = Перечисления.бит_мпд_СпособыПоискаДанных.ПоВнутреннимИдентификаторам Тогда
					 
					// Поиск по внутреннему идентификатору 
					НайденноеЗначение = бит_мпд_КлиентСервер.НайтиПоИД(Соединение, СтруктураПараметров, СтруктураИмен, "ПоСсылке", РежимыВывода.ВыводитьОшибки);
					
				 ИначеЕсли ПерваяСтрока.СпособПоискаДанных = Перечисления.бит_мпд_СпособыПоискаДанных.ПоИменам Тогда
					 
					// Поиск по именам для перечислений и предопределенных элементов справочников.
					НайденноеЗначение = НайтиПоИмени(Соединение, СтруктураПараметров, СтруктураИмен, "ПоИмени", РежимыВывода.ВыводитьОшибки);
					
				 ИначеЕсли ПерваяСтрока.СпособПоискаДанных = Перечисления.бит_мпд_СпособыПоискаДанных.ПоСоответствиюИмен Тогда
					 
					// Поиск по именам для перечислений и предопределенных элементов справочников.
					НайденноеЗначение = НайтиПоИмени(Соединение, СтруктураПараметров, СтруктураИмен, "ПоСоответствию", РежимыВывода.ВыводитьОшибки);
					
				 Иначе	
					 
					// Поиск по реквизитам и условиям 
					НайденноеЗначение = НайтиПоУсловию(Соединение, СтруктураПараметров, СтрокиПравил, РежимыВывода.ВыводитьОшибки);
					  
				 КонецЕсли; 
				 
				 Если НЕ НайденноеЗначение = Неопределено Тогда
				 
				 	 Прервать;
				 
				 КонецЕсли; 
				 
			КонецЕсли; 
						
		КонецЦикла; // МассивПриоритет
		
	КонецЕсли; // ЗначениеЗаполнено(Правило)
	
	
	Возврат НайденноеЗначение;
	
КонецФункции // ВыполнитьПоискПоПравилу()

// Функция выполняет поиск значения во внешней базе по имени.
// 
// Параметры:
//  Соединение          - ComObject.
//  СтруктураПараметров - Структура.
//  СтруктураИмен       - Структура.
//  Режим               - Строка.
//  ВыводитьОшибки      - Булево.
// 
// Возвращаемое значение:
//  НайденноеЗначение - Произвольный.
// 
Функция НайтиПоИмени(Соединение, СтруктураПараметров, СтруктураИмен, Режим, ВыводитьОшибки = Ложь) Экспорт

	НайденноеЗначение = Неопределено;
	
	Правило          = СтруктураПараметров.Правило;
	ИмяОбъектаПолное = СтруктураПараметров.ИмяОбъектаПолное;
	ЗначениеПоиска   = СтруктураПараметров.ЗначениеПоиска;
	Направление      = СтруктураПараметров.Направление;	
	
	флПриемникВнешняя = ?(ВРег(Направление) = ВРег("ТекущаяВнешняя"),Истина,Ложь);
	
	РеквизитыПравила = ОпределитьИменаРеквизитовПравила(Правило,Направление);
	
	Если СтруктураИмен.ИмяКоллекции = "Перечисления" Тогда
		
		Если флПриемникВнешняя Тогда
			ИмяЗначения = бит_ОбщегоНазначения.ПолучитьИмяЗначенияПеречисления(Перечисления[СтруктураИмен.ИмяОбъекта],ЗначениеПоиска);		
		Иначе	
			ИмяЗначения = ПолучитьИмяЗначенияПеречисленияВнеш(Соединение,Соединение.Перечисления[СтруктураИмен.ИмяОбъекта],ЗначениеПоиска); 
		КонецЕсли; 
		ИмяПеречисленияПоиск = Правило["ИмяОбъектаПолное_"+РеквизитыПравила.НомерПриемника];
		
		
		// Определим имя перечисления в приемнике
		Если ВРег(Режим) = ВРег("ПоИмени") Тогда
			
			// Имена совпадают в приемнике и источнике
			ИмяЗначенияВнеш = ИмяЗначения;
			
		ИначеЕсли ВРег(Режим) = ВРег("ПоСоответствию") Тогда	
			
			Имена = Новый Соответствие;
			
			ИмяКолонкиИсточник = "ИмяЗначения_"+РеквизитыПравила.НомерИсточника;
			ИмяКолонкиПриемник = "ИмяЗначения_"+РеквизитыПравила.НомерПриемника;			
			
			Для каждого СтрокаТаблицы Из Правило.СоответствиеИмен Цикл
				
				Имена.Вставить(СтрокаТаблицы[ИмяКолонкиИсточник],СтрокаТаблицы[ИмяКолонкиПриемник]);
				
			КонецЦикла; // Правило.СоответствиеИмен
			
			ИмяЗначенияВнеш = Имена[ИмяЗначения];
			
		КонецЕсли; 
		
		Если НЕ ИмяЗначенияВнеш = Неопределено Тогда
			
			СтруктураИменВнеш = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяПеречисленияПоиск);
			
			Попытка
				
				Если флПриемникВнешняя Тогда
					
					ПеречислениеПоиск   = Соединение.Перечисления[СтруктураИменВнеш.ИмяОбъекта];
					
				Иначе	
					
					ПеречислениеПоиск   = Перечисления[СтруктураИменВнеш.ИмяОбъекта];
					
				КонецЕсли; 
				
				НайденноеЗначение = ПеречислениеПоиск[ИмяЗначенияВнеш];				
				
			Исключение
				
				Если ВыводитьОшибки Тогда
					
					ТекстСообщения = НСтр("ru = 'Ошибка поиска объекта ""%1%"" по имени ""%2%""! Описание ошибки ""%3%"".'");
					ИмяОбъектаПолное = СтруктураИмен.ИмяКласса+"."+СтруктураИмен.ИмяОбъекта;
					ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
																								,ИмяОбъектаПолное
																								,ИмяЗначенияВнеш
																								,Строка(ОписаниеОшибки()));
					
					бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);																			 
					
				КонецЕсли; 
				
			КонецПопытки; 
			
		КонецЕсли; // НЕ ИмяПеречисленияВнеш = Неопределено
		
		
	ИначеЕсли СтруктураИмен.ИмяКоллекции = "Справочники" Тогда	
		
		
		
	КонецЕсли; 

	Возврат НайденноеЗначение;
	
КонецФункции // НайтиПоИмени()

// Функция определяет является ли текущий вид информационной базы внешним.
// 
// Параметры:
//  ВидИнформационнойБазы - СправочникСсылка.бит_мпд_ВидыИнформационныхБаз.
// 
// Возвращаемое значение:
//  Результат - Строка.
// 
Функция ЭтоВнешняяБаза(ВидИнформационнойБазы) Экспорт
	
	Если ВидИнформационнойБазы = Справочники.бит_мпд_ВидыИнформационныхБаз.ТекущаяИнформационнаяБаза 
		ИЛИ НЕ ЗначениеЗаполнено(ВидИнформационнойБазы) Тогда	
		
		флЭтоВнешняяБаза = Ложь;
		
	Иначе
		
		флЭтоВнешняяБаза = Истина;	
		
	КонецЕсли;		 
	
	Возврат флЭтоВнешняяБаза;
	
КонецФункции // ЭтоВнешняяБаза()

// Процедура подключается к внешней базе.
// 
// Параметры:
//  СостояниеПодключения 	- ПеречислениеСсылка.бит_мпд_СостоянияПодключенияИБ.
//  ВидТекущейИБ  			- СправочникСсылка.бит_мпд_ВидыИнформационныхБаз.
//  ВидПодключеннойИБ       - СправочникСсылка.бит_мпд_ВидыИнформационныхБаз.
//  ТипСоединения 			- Строка.
//  ТекстОшибки 			- Строка.
// 
// Возвращаемое значение:
//  СОМОбъект ИЛИ Неопределено.
// 
Функция ПолучитьСоединениеИБ(СостояниеПодключения, ВидТекущейИБ, ВидПодключеннойИБ, ТипСоединения, АдресКомОбъекта = Неопределено, ТекстОшибки = Неопределено) Экспорт
	
	флЭтоВнешняяБаза = ЭтоВнешняяБаза(ВидТекущейИБ);
	Если ТекстОшибки = Неопределено Тогда
		ТекстОшибки = "";
	КонецЕсли;
	
	ПеречСостоянияПодключения = Перечисления.бит_мпд_СостоянияПодключенияИБ;
	
	Если флЭтоВнешняяБаза Тогда
		
		Если СостояниеПодключения = ПеречСостоянияПодключения.ВнешняяБаза_Подключена И ЗначениеЗаполнено(АдресКомОбъекта) Тогда
			
			СоединениеИБ = ПолучитьИзВременногоХранилища(АдресКомОбъекта);
			Если СоединениеИБ = Неопределено Тогда
				СостояниеПодключения = ПеречСостоянияПодключения.ВнешняяБаза_НеПодключена;			
			КонецЕсли;
			
		КонецЕсли;
		
		Если СостояниеПодключения = ПеречСостоянияПодключения.ВнешняяБаза_НеПодключена 
			ИЛИ НЕ ЗначениеЗаполнено(СостояниеПодключения)
			ИЛИ НЕ ЗначениеЗаполнено(АдресКомОбъекта)
			ИЛИ ВидПодключеннойИБ <> ВидТекущейИБ Тогда
			
			НастройкиИбПоУмолчанию = ВидТекущейИБ.НастройкаПодключенияПоУмолчанию;
			
			// Попытка установки соединения с внешней базой.
			Если ЗначениеЗаполнено(НастройкиИбПоУмолчанию) Тогда
				
				Если ТипСоединения = "КОМ" Тогда
					СоединениеИБ = бит_мпд_ПовтИсп.ПодключитьКОМ(НастройкиИбПоУмолчанию);
				ИначеЕсли ТипСоединения = "ОЛЕ" Тогда
					СоединениеИБ = бит_мпд_ПовтИсп.ПодключитьОЛЕ(НастройкиИбПоУмолчанию);
				КонецЕсли;
				
			Иначе	   
				
				ТекстСообщения = НСтр("ru = 'Для вида информационной базы '") 
								 + Строка(ВидТекущейИБ) 
								 + НСтр("ru = ' не указана настройка подключения по-умолчанию!'");
				ТекстОшибки = ТекстОшибки + Символы.ПС + ТекстСообщения;
				
			КонецЕсли; 
			
		КонецЕсли;	
		
		Если СоединениеИБ = Неопределено Тогда
			
			ТекстСообщения = НСтр("ru = 'Не установлено соединение с внешней базой! Вызов конструктора невозможен.'");
			ТекстОшибки 		 = ТекстОшибки + Символы.ПС + ТекстСообщения;
			СостояниеПодключения = ПеречСостоянияПодключения.ВнешняяБаза_НеПодключена;
			
		Иначе
			
			ВидПодключеннойИБ 	 = ВидТекущейИБ;
			СостояниеПодключения = ПеречСостоянияПодключения.ВнешняяБаза_Подключена;
			
		КонецЕсли; 
		  		
	Иначе
		
		// Текущая база
		СостояниеПодключения = ПеречСостоянияПодключения.ТекущаяБаза;
		ВидПодключеннойИБ 	 = ВидТекущейИБ;
		
	КонецЕсли;
	
	Возврат СоединениеИБ;

КонецФункции // ПолучитьСоединениеИБ()

// Функция определяет картинку по виду объекта метаданных.
// 
// Параметры:
//  ВидОбъекта  - ПеречислениеСсылка.бит_мпд_ВидыОбъектовМетаданных.
// 
// Возвращаемое значение:
//   РезКартинка   - Картинка.
// 
Функция ОпределитьКартинкуВидаМетаданных(ВидОбъекта) Экспорт

	РезКартинка = Неопределено;
	
	КартинкиОбъектов = Новый Соответствие;
	КартинкиОбъектов.Вставить(Перечисления.бит_мпд_ВидыОбъектовМетаданных.Справочник            ,БиблиотекаКартинок.Справочник);
	КартинкиОбъектов.Вставить(Перечисления.бит_мпд_ВидыОбъектовМетаданных.Документ              ,БиблиотекаКартинок.ДокументОбъект);
	КартинкиОбъектов.Вставить(Перечисления.бит_мпд_ВидыОбъектовМетаданных.ПланВидовХарактеристик,БиблиотекаКартинок.ПланВидовХарактеристик);
	КартинкиОбъектов.Вставить(Перечисления.бит_мпд_ВидыОбъектовМетаданных.ПланСчетов            ,БиблиотекаКартинок.ПланСчетов);
	КартинкиОбъектов.Вставить(Перечисления.бит_мпд_ВидыОбъектовМетаданных.Перечисление    		,БиблиотекаКартинок.Перечисление);
		
	РезКартинка = КартинкиОбъектов[ВидОбъекта];
	
	Возврат РезКартинка;

КонецФункции // ОпределитьКартинкуВидаМетаданных()
	
// Функция получает данные по HTTP запросу.
// 
// Параметры:
//   ИсточникДанных - СправочникСсылка.бит_ИсточникиДанных.
//   ГраницаНач - Граница.
//   ГраницаКон - Граница.
//   СтрПар - Структура.
//   СтрПравила - Структура.
// 
// Возвращаемое значение:
//  ТаблицаДанных - ТаблицаЗначений.
// 
Функция ПолучитьДанныеHTTPЗапросом(ИсточникДанных, ГраницаНач, ГраницаКон, СтрПар, СтрПравила)  Экспорт
	
	
	НастройкаПодключения = СтрПар.НастройкаПодключения;
	Путь = НастройкаПодключения.ИмяСервера+"/"+НастройкаПодключения.ИмяБазы;	
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	ТаблицаРезультат = Новый ТаблицаЗначений;
	
	// Извлекаем поля по ИД
	КэшПолей = Новый Соответствие;
	КэшПоиска = Новый Соответствие;
	
	Для каждого СтрокаПоля Из ИсточникДанных.Поля Цикл
		
		Если СтрокаПоля.Использование 
			И ВРег(СтрокаПоля.ВидПоля) = ВРег("Поле") Тогда
			
			СтрОтбор = Новый Структура;
			СтрОтбор.Вставить("Имя", СтрокаПоля.Имя); 
			
			НайденныеСтроки = ИсточникДанных.ЗапросБД.ДоступныеПоля.НайтиСтроки(СтрОтбор);
			
			ТекстЗапросаПоле = "";
			ИмяТипа = "";
			Если НайденныеСтроки.Количество() > 0 Тогда
				
				ПерваяСтрока = НайденныеСтроки[0];
				ТекстЗапросаПоле = ПерваяСтрока.ТекстЗапроса;
				ИмяТипа = ПерваяСтрока.ТипСтр;
			
			КонецЕсли; 
			
			Если ЗначениеЗаполнено(ТекстЗапросаПоле) Тогда
				
				МассивЭлементовВнеш = бит_мпд_ПовтИспВызов.ИзвлечьДанныеПоляHTTP(ТекстЗапросаПоле, НастройкаПодключения);
				КэшЭлементов = Новый Соответствие;
				
				Для каждого ТекЭлемент Из МассивЭлементовВнеш Цикл
					
					ПреобразованноеЗначение = ПреобразоватьЗначениеВнешняяТекущаяHTTP(ТекЭлемент, ИмяТипа, СтрПравила.ВнешТек, НастройкаПодключения, КэшПоиска);
					КэшЭлементов[ТекЭлемент.ИД]  = ПреобразованноеЗначение;
					
				КонецЦикла; 
				
				КэшПолей.Вставить(СтрокаПоля.Имя, КэшЭлементов);
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; // По полям
	
	СтрРесурсы = "";
	СтрПоля = "";
	
	
	ЗаменаИмен = Новый Структура;
	Для каждого СтрокаПоля Из ИсточникДанных.Поля Цикл
		
		Если СтрокаПоля.Использование Тогда
			
			Если СтрокаПоля.ВидПоля = "Ресурс" Тогда
				
				ТекОписание = Новый ОписаниеТипов("Число");
				ТекОписаниеРезультат = Новый ОписаниеТипов("Число");
				
			Иначе	
				
				СтрОтбор = Новый Структура("Имя", СтрокаПоля.Имя);
				
				НайденныеСтроки = ИсточникДанных.ЗапросБД.ДоступныеПоля.НайтиСтроки(СтрОтбор);
				
				Если НайденныеСтроки.Количество() > 0 Тогда
					
					ПерваяСтрока = НайденныеСтроки[0];
					ТекОписаниеРезультат = Неопределено;
					
					ТекОписание = бит_ОбщегоНазначенияКлиентСервер.ПолучитьОписаниеИзСтроки(ПерваяСтрока.ТипСтр+"/Строка(40)",,Новый ОписаниеТипов("Строка"));
					
					
				Иначе
					
					ТекОписание = Новый ОписаниеТипов("Строка");
					ТекОписаниеРезультат = Неопределено;
					
					
				КонецЕсли; 
				
			КонецЕсли; 			
			Если НЕ ПустаяСтрока(СтрокаПоля.Синоним) Тогда
				ИмяКолонки = СтрокаПоля.Синоним;
				ЗаменаИмен.Вставить(СтрокаПоля.Имя, СтрокаПоля.Синоним);
			Иначе	
				ИмяКолонки = СтрокаПоля.Имя;
			КонецЕсли; 
			ТаблицаДанных.Колонки.Добавить(ИмяКолонки, ТекОписание);
			ТаблицаРезультат.Колонки.Добавить(ИмяКолонки, ТекОписаниеРезультат);
			
			
			Если ВРег(СтрокаПоля.ВидПоля) = ВРег("Ресурс") Тогда
				
				СтрРесурсы = СтрРесурсы+?(ПустаяСтрока(СтрРесурсы),"",",")+ИмяКолонки;
				
			КонецЕсли; 
			
			Если ВРег(СтрокаПоля.ВидПоля) = ВРег("Поле") Тогда
				
				СтрПоля = СтрПоля+?(ПустаяСтрока(СтрПоля),"",",")+ИмяКолонки;
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	// Подготовка текста запроса
	ТекстЗапроса = ИсточникДанных.ЗапросБД.ТекстЗапроса;
	
	Если Найти(ТекстЗапроса, "&НачалоПериода") > 0 Тогда
	
		 Если ТипЗнч(ГраницаНач) = Тип("Граница") Тогда
			 
			 ТекДата = ГраницаНач.Значение;
			 
		 Иначе	
			 
			 ТекДата = ГраницаНач;
			 
		 КонецЕсли; 
		 
		 ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&НачалоПериода", Формат(ТекДата,"ДФ=yyyy-MM-ddTHH:mm:ss"));
		 
	КонецЕсли; 
	
	Если Найти(ТекстЗапроса, "&КонецПериода") > 0 Тогда
	
		 Если ТипЗнч(ГраницаКон) = Тип("Граница") Тогда
			 
			 ТекДата = ГраницаКон.Значение;
			 
		 Иначе	
			 
			 ТекДата = ГраницаКон;
			 
		 КонецЕсли; 
		 
		 ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&КонецПериода", Формат(ТекДата,"ДФ=yyyy-MM-ddTHH:mm:ss"));
		 
	КонецЕсли; 
	
	Для каждого КиЗ Из СтрПар.Параметры Цикл
	
		Если ТипЗнч(КиЗ.Значение) = Тип("Дата") Тогда
		
		 ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&"+КиЗ.Ключ, Формат(КиЗ.Значение,"ДФ=yyyy-MM-ddTHH:mm:ss"));
		
		КонецЕсли; 
	
	КонецЦикла; 
	
	СтрОтвет = бит_мпд_ПовтИспВызов.ИзвлечьДанныеИсточникаHTTP(ТекстЗапроса, НастройкаПодключения);
	
	Чтение = Новый ЧтениеXML;
	
	// Заполнение таблицы
	Чтение.УстановитьСтроку(СтрОтвет);
	
	НоваяСтрока = Неопределено;
	флУстановитьЗначение = Ложь;
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.НачалоЭлемента 
			И Чтение.Имя = "d:element"  Тогда
			
			 НоваяСтрока = ТаблицаДанных.Добавить();
			
		КонецЕсли; 
		
		Если Чтение.ТипУзла = ТипУзлаXML.НачалоЭлемента 
			 И НЕ НоваяСтрока = Неопределено 
			 И Найти(Чтение.Имя, "d:") > 0 
			 И НЕ Чтение.Имя = "d:element" Тогда
		
			 ИмяКолонки = СтрЗаменить(Чтение.Имя, "d:","");
			 ИмяКолонкиТаблицы = ИмяКолонки;
			 Если ЗаменаИмен.Свойство(ИмяКолонки) Тогда
			 
			 	  ИмяКолонкиТаблицы = ЗаменаИмен[ИмяКолонки];
			 
			 КонецЕсли; 
			 флУстановитьЗначение = Истина;
			 
		
		КонецЕсли; 
		
		Если Чтение.ТипУзла = ТипУзлаXML.Текст 
			 И флУстановитьЗначение 
			 И ЗначениеЗаполнено(ИмяКолонки)  Тогда
		
			 флУстановитьЗначение = Ложь;
			 
			 Если НЕ ТаблицаДанных.Колонки.Найти(ИмяКолонкиТаблицы) = Неопределено Тогда
				 
				 ТекЗначение = Чтение.Значение;
				 ТекКэш = КэшПолей[ИмяКолонки];
				 Если НЕ ТекКэш = Неопределено Тогда
				 
				 	 ЗначениеПоиска = ТекКэш[ТекЗначение];
					 
					 // Структуры, моделирующие значения, которые не удалось преобразовать подставим позднее.
					 Если НЕ ТипЗнч(ЗначениеПоиска) = Тип("Структура") Тогда
						 НоваяСтрока[ИмяКолонкиТаблицы] = ЗначениеПоиска;
					 Иначе	
						 НоваяСтрока[ИмяКолонкиТаблицы] = ТекЗначение;
					 КонецЕсли; 
					 
					 // НоваяСтрока[ИмяКолонкиТаблицы] = ЗначениеПоиска;
					 
				 Иначе	  
					 
		             НоваяСтрока[ИмяКолонкиТаблицы] = ТекЗначение;
					 
				 КонецЕсли; 
				 
				 
			 КонецЕсли; 
		
		КонецЕсли; 
		
	КонецЦикла; // По узлам
	
	ТаблицаДанных.Свернуть(СтрПоля,СтрРесурсы);
	ТаблицаДанных.Сортировать(СтрПоля);
	
	// Фильтрация таблицы с помощью построителя
	Построитель = Новый ПостроительЗапроса;
	Построитель.ИсточникДанных = Новый ОписаниеИсточникаДанных(ТаблицаДанных);
	
	// Сохраненные настройки построителя
	НастройкаИсточника = ИсточникДанных.НастройкиПостроителя.Получить();
	Настройка = СтрПар.Настройка;
	Если Настройка = Неопределено Тогда
		СохраненнаяНастройка=НастройкаИсточника;  // Отбор источника данных
	Иначе
		СохраненнаяНастройка=Настройка; // Отбор элемента данных
	КонецЕсли; 
	
	// Отбор заполняем по элементу данных
	бит_МеханизмПолученияДанных.УстановитьОтборЭлементаДанных(Построитель,СохраненнаяНастройка);
	
	Построитель.Выполнить();
	
	ТаблицаДанных = Построитель.Результат.Выгрузить();
	
	Для каждого СтрокаДанные Из ТаблицаДанных Цикл
		
		СтрокаРезультат = ТаблицаРезультат.Добавить();
		Для каждого КолонкаДанных Из ТаблицаДанных.Колонки Цикл
		
			ИмяКолонки = КолонкаДанных.Имя;
			ТекЗнч = СтрокаДанные[ИмяКолонки];
			
			Если ТипЗнч(ТекЗнч) = Тип("Строка") Тогда
				
				// Возможно это не преобразованная ссылка, попробуем найти модельную структуру.
				 ТекКэш = КэшПолей[ИмяКолонки+"_Key"];
				 Если НЕ ТекКэш = Неопределено Тогда
				 
				 	 ТекЗнч = ТекКэш[ТекЗнч];
				 
				 КонецЕсли; 
			
			КонецЕсли; 
			
			СтрокаРезультат[ИмяКолонки] = ТекЗнч;
			
		КонецЦикла; 
	
	КонецЦикла; 
	
	Возврат ТаблицаРезультат;
	
КонецФункции // ПолучитьДанныеHTTPЗапросом()

// Функция выполняет перевод имени класса с русского на английский и наооброт.
// 
// Параметры:
//   ИмяКласса - строка
//   ЦелевойЯзык - Строка
// 
// Возвращаемое значение:
//  ИмяКлассаПеревод - Строка.
// 
Функция ПеревестиИмяКласса(ИмяКласса, ЦелевойЯзык = "ru") Экспорт

	Словарь = Новый Соответствие;
	Словарь.Вставить("Catalog","Справочник");
	Словарь.Вставить("Document","Документ");
	Словарь.Вставить("Enum","Перечисление");
	Словарь.Вставить("ChartOfAccounts","ПланСчетов");
	Словарь.Вставить("ChartOfCharacteristicTypes","ПланВидовХарактеристик");
	
	Если ЦелевойЯзык = "en" Тогда
	
		Для каждого КиЗ Из Словарь Цикл
		
			Словарь.Вставить(КиЗ.Значение, КиЗ.Ключ);
		
		КонецЦикла; 
	
	КонецЕсли; 

	ИмяКлассаПеревод = Словарь[ИмяКласса];
	
	Если НЕ ЗначениеЗаполнено(ИмяКлассаПеревод) Тогда
	
		ИмяКлассаПеревод = ИмяКласса;
	
	КонецЕсли; 
	
	Возврат ИмяКлассаПеревод;
	
КонецФункции // ПеревестиИмяКласса()

// Функция выполняет перевод имени класса с русского на английский и наооброт.
// 
// Параметры:
//   ИмяКласса - строка
//   ЦелевойЯзык - Строка
// 
// Возвращаемое значение:
//  ИмяКлассаПеревод - Строка.
// 
Функция ПеревестиИмяПоля(ИмяПоля, ЦелевойЯзык = "ru") Экспорт

	Словарь = Новый Соответствие;
	Словарь.Вставить("Code","Код");
	Словарь.Вставить("Description","Наименование");
	Словарь.Вставить("DeletionMark","ПометкаУдаления");
	Словарь.Вставить("IsFolder","ЭтоГруппа");
	Словарь.Вставить("Parent","Родитель");	
	Словарь.Вставить("Owner","Владелец");		
	Словарь.Вставить("Date","Дата");
	Словарь.Вставить("Number","Номер");
	Словарь.Вставить("ValueType","ТипЗначения");
	Словарь.Вставить("Period","Период");
	
	Словарь.Вставить("Order","Порядок");
	Словарь.Вставить("OffBalance","Забалансовый");	
	
	Словарь.Вставить("ExtDimensionType","ВидСубконто");	
	Словарь.Вставить("Predefined"   ,"Предопределенный");
	Словарь.Вставить("TurnoversOnly","ТолькоОбороты");
	
	Если ЦелевойЯзык = "en" Тогда
	
		Для каждого КиЗ Из Словарь Цикл
		
			Словарь.Вставить(КиЗ.Значение, КиЗ.Ключ);
		
		КонецЦикла; 
	
	КонецЕсли; 

	Перевод = Словарь[ИмяПоля];
	
	Если НЕ ЗначениеЗаполнено(Перевод) Тогда
	
		Перевод = ИмяПоля;
	
	КонецЕсли; 
	
	Возврат Перевод;
	
КонецФункции // ПеревестиИмяПоля()

// Функция извлекает данные расшифровки из внешней базы HTTP запросом.
// 
// Параметры:
//  Расшифровка - Структура
// 
// Возвращаемое значение:
//  ДанныеРасшифровки - Структура.
// 
Функция ПолучитьДанныеРасшировкиHTTP(Расшифровка) Экспорт
	
	ДанныеРасшифровки = Новый Структура("ИмяКласса,Выполнено,ОписаниеОшибки,Объект", "ДанныеРасшифровываемогоОбъекта", Ложь,"", Новый Структура());
	
	// Формируем текст HTTP запроса для извлечения расшифровываемого объекта.
	Имена = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(Расшифровка.ПолноеИмя);
	
	ТекстЗапроса = бит_мпд_КлиентСервер.ПризнакОбращенияОДата()+"%ИмяКлассаАнгл%_%ИмяОбъекта%(guid'%ИД%')";
	
	ИмяКлассаАнгл = ПеревестиИмяКласса(Имена.ИмяКласса,"en");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"%ИмяКлассаАнгл%", ИмяКлассаАнгл);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"%ИмяОбъекта%"   , Имена.ИмяОбъекта);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"%ИД%"           , Расшифровка.ИД);
	
	// Выполняем HTTP запрос
	НастройкаПодключения = Расшифровка.НастройкаПодключения;
	Путь = НастройкаПодключения.ИмяСервера+"/"+НастройкаПодключения.ИмяБазы;	
	
	СоединениеHTTP = Новый HTTPСоединение(Путь,,НастройкаПодключения.Пользователь,НастройкаПодключения.Пароль);
	ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса);
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	
	ТекЭлемент = Неопределено;
	Если ОтветHTTP.КодСостояния = 200 Тогда
		
		// Разбираем информацию
		СтрОтвет = ОтветHTTP.ПолучитьТелоКакСтроку();
		
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(СтрОтвет);
		
		Пока Чтение.Прочитать() Цикл
			
			
			Если Чтение.ТипУзла = ТипУзлаXML.НачалоЭлемента 
				И Чтение.Имя = "m:properties" Тогда
				
				ТекЭлемент = Новый Структура;
				
			КонецЕсли; 
			
			Если НЕ ТекЭлемент = Неопределено Тогда
				
				Если Чтение.ТипУзла = ТипУзлаXML.НачалоЭлемента 
					И Найти(Чтение.Имя, "d:")>0 Тогда
					
					ИмяПоля = СтрЗаменить(Чтение.Имя, "d:","");
					Если ВРег(ИмяПоля) = ВРег("Ref_Key") Тогда
						
						ИмяПоля = "ИД";	
						
					ИначеЕсли Найти(ИмяПоля, "_Key") > 0 
						      ИЛИ Найти(ИмяПоля, "_Type") > 0 Тогда
						
						// Не выводим ИД ссылок в расшифровку
						флУстановитьЗначение = Ложь;
						Продолжить;
						
					КонецЕсли; 
					флУстановитьЗначение = Истина;
					
				КонецЕсли; 
				
				Если Чтение.ТипУзла = ТипУзлаXML.Текст 
					И флУстановитьЗначение 
					И ЗначениеЗаполнено(ИмяПоля)  Тогда
					
					ИмяПоля = ПеревестиИмяПоля(ИмяПоля,"ru");
					ТекЗначение = Чтение.Значение;
					Если ВРег(ТекЗначение) = ВРег("false") Тогда
					
						ТекЗначение = Истина;
						
					ИначеЕсли Врег(ТекЗначение) = ВРег("true") Тогда
						
						ТекЗначение = Ложь;
					
					КонецЕсли; 
					ТекЭлемент.Вставить(ИмяПоля, ТекЗначение);
					флУстановитьЗначение = Ложь;
					
				КонецЕсли;
				
				Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента 
					И Чтение.Имя = "m:properties" Тогда
					
					ДанныеРасшифровки.Объект = ТекЭлемент;
					
				КонецЕсли; 
				
			КонецЕсли; 
			
		КонецЦикла;
		
	Иначе	
		
		ДанныеРасшифровки.ОписаниеОшибки =  НСтр("ru = 'Не удалось выполнить расшифровку.  Код ошибки: %1%.'");
		ДанныеРасшифровки.ОписаниеОшибки = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ДанныеРасшифровки.ОписаниеОшибки, ОтветHTTP.КодСостояния); 
		
	КонецЕсли; 
	
	Возврат ДанныеРасшифровки;
	
КонецФункции // ПолучитьДанныеРасшировкиHTTP()

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Процедура преобразует данные полученные во внешней базе через Ком в ТаблицуЗначений.
// 
// Параметры:
//  МетаКом       - ComObject.
//  ТаблицаКом    - ComObject.
//  ТаблицаДанных - ТаблицаЗначений.
// 
Процедура ПреобразоватьВнешниеДанные(Соединение, НастройкаПодключения, МетаКом, ТаблицаКом, ТаблицаДанных, ПравилаПоиска)

	Список = Новый СписокЗначений;
	
	// Создадим колонки результирующей таблицы
	Для каждого КолонкаКом Из ТаблицаКом.Колонки Цикл
		
		флЭтоЧисло = ЭтоЧисловаяКомКолонка(КолонкаКом);
		
		Если флЭтоЧисло Тогда
			ОписаниеЧисло = Новый ОписаниеТипов("Число");
			НоваяКолонка = ТаблицаДанных.Колонки.Добавить(,ОписаниеЧисло);
		Иначе
			НоваяКолонка = ТаблицаДанных.Колонки.Добавить();
		КонецЕсли; 
		
		НоваяКолонка.Имя = КолонкаКом.Имя;
		НоваяКолонка.Заголовок = КолонкаКом.Заголовок;
		
	КонецЦикла; 
	
	// Извлечем данные из КомОбъектов КомТаблицы.
	КэшПоиска = Новый Соответствие;
	Для каждого СтрокаКом Из ТаблицаКом Цикл
		
		НоваяСтрока = ТаблицаДанных.Добавить();
		
		Для каждого КолонкаКом Из ТаблицаКом.Колонки Цикл
			
			ЗначениеКом = СтрокаКом[КолонкаКом.Имя];
			
			НоваяСтрока[КолонкаКом.Имя] = ПреобразоватьЗначениеВнешняяТекущая(Соединение
			                                                                    , НастройкаПодключения
																				, ЗначениеКом
																				, Список
																				, ПравилаПоиска
																				, КэшПоиска);
					
		КонецЦикла; // ТаблицаКом.Колонки
	
	КонецЦикла; // ТаблицаКом

	
КонецПроцедуры // ПреобразоватьВнешниеДанные()

// Функция создает границу в базе, подключенной через внешнее соединение.
// 
// Параметры:
//  Соединение - ComObject
//  ГраницаТекБаза - Граница
// 
// Возвращаемое значение:
//  Результат - Дата,ComObject.
// 
Функция ГраницаВнешняяБаза(Соединение, ГраницаТекБаза)

	Если ТипЗнч(ГраницаТекБаза) = Тип("Граница") Тогда
		
		ВидГраницыВнешБаза = ВидГраницыВнешняяБаза(Соединение, ГраницаТекБаза.ВидГраницы);
		ГраницаВнешБаза    = Соединение.NewObject("Граница",ГраницаТекБаза.Значение,ВидГраницыВнешБаза);
		
	Иначе
		
		ГраницаВнешБаза = ГраницаТекБаза;
		
	КонецЕсли; 

	Возврат ГраницаВнешБаза;
	
КонецФункции // ГраницаВнешняяБаза()

// Функция создает ВидГраницы в базе, подключенной через внешнее соединение.
// 
// Параметры:
//  Соединение     - ComObject
//  ГраницаТекБаза - Граница
// 
// Возвращаемое значение:
//  ВидГраницыВнешБаза - ComObject.
// 
Функция ВидГраницыВнешняяБаза(Соединение,ВидГраницыТек)
	
	Если ВидГраницыТек = ВидГраницы.Исключая Тогда
		
		ВидГраницыВнешБаза = Соединение.ВидГраницы.Исключая;
		
	Иначе	
		
		ВидГраницыВнешБаза = Соединение.ВидГраницы.Включая;
		
	КонецЕсли; 	
	
	Возврат ВидГраницыВнешБаза;
	
КонецФункции // ВидГраницыВнешняяБаза()

// Функция определяет является ли данная колонка КомОбъекта - ТаблицаЗначений числовой.
// 
// Параметры:
//  КолонкаКом - ComObject.
// 
// Возвращаемое значение:
//  флЧисловаяКолонка - Булево.
// 
Функция ЭтоЧисловаяКомКолонка(КолонкаКом)
 
 	флЧисловаяКолонка = Ложь;
 	
	Если КолонкаКом.ТипЗначения.КвалификаторыЧисла.Разрядность>0 Тогда
	
		флЧисловаяКолонка = Истина;
	
	КонецЕсли; 
 
 	Возврат флЧисловаяКолонка;
 	
КонецФункции // ЭтоЧисловаяКолонка()

// Функция осуществляет поиск по объектов во внешней базе по Реквизитам и Значениям.
// 
// Параметры:
//  Соединение - ComObject.
//  СтруктураПараметров - Структура.
//  СтрокиПравил        - Массив.
//  ВыводитьОшибки      - Булево.
// 
// Возвращаемое значение:
//  НайденноеЗначение - Произвольный.
// 
Функция НайтиПоУсловию(Соединение, СтруктураПараметров, СтрокиПравил, ВыводитьОшибки)
	
	Правило = СтруктураПараметров.Правило;
	НомерИсточника = ОпределитьНомерРеквизитаИсточника(Правило,СтруктураПараметров.Направление);
	НомерПриемника = ОпределитьНомерРеквизитаПриемника(НомерИсточника);
	ИмяОбъектаПолное = Правило["ИмяОбъектаПолное_"+НомерПриемника];
	ЗначениеПоиска   = СтруктураПараметров.ЗначениеПоиска;
	Направление      = СтруктураПараметров.Направление;	
	
	НайденноеЗначение = Неопределено;
	
	// Поиск по реквизитам и значениям
	РеквизитыПравила = ОпределитьИменаРеквизитовПравила(Правило, Направление);
	
	Если ВРег(СтруктураПараметров.Направление) = ВРег("ВнешняяТекущая") Тогда
		
		Запрос = Новый Запрос;
		
	ИначеЕсли ВРег(СтруктураПараметров.Направление) = ВРег("ТекущаяВнешняя") Тогда
		
		Запрос = Соединение.NewObject("Запрос");
		
	КонецЕсли; 
	
	// Шаблон текста запроса для поиска
	ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ 1
	|	ТаблицаПоиска.Ссылка
	|ИЗ
	|	"+ИмяОбъектаПолное+" КАК ТаблицаПоиска
	|ГДЕ
	|	%Условия%";
	
	ТекстУсловия = "";				
	
	// Сформируем текст условия для запроса по строка ПравилаПоиска и установим параметры запроса.
	инд = 1;				
	Для каждого стрПравило Из СтрокиПравил  Цикл
		
		ИмяПараметра = "Параметр_"+инд;
		
		Если стрПравило.СпособПоискаДанных = Перечисления.бит_мпд_СпособыПоискаДанных.ПоЗначению Тогда
			
			ЗначениеПараметра = стрПравило.ЗначениеПоиска;
			
		Иначе
			
			// Получим значение реквизита источника
			ИмяРеквизитаИсточника = стрПравило[РеквизитыПравила.ИмяИсточника];  			
			Попытка
				
				ЗначениеПараметра = ЗначениеПоиска[ИмяРеквизитаИсточника];
				
			Исключение
				
				
				Если ВыводитьОшибки Тогда
				
					ТекстСообщения = "Не удалось получить значение реквизита %1% объекта %2%!";
					ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
					                                                                            ,ИмяРеквизитаИсточника
																								,ИмяОбъектаПолное);
					бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);																			

			    КонецЕсли; 
			
				ЗначениеПараметра = Неопределено;  
				
			КонецПопытки;
			
		КонецЕсли; 
		
		Запрос.УстановитьПараметр(ИмяПараметра,ЗначениеПараметра);
		
		ИмяРеквизитаПриемника = стрПравило[РеквизитыПравила.ИмяПриемника];  					   
		ТекстУсловия = ТекстУсловия
						+?(ПустаяСтрока(ТекстУсловия),"",Символы.ПС+" И ")
						+"ТаблицаПоиска."
						+ИмяРеквизитаПриемника
						+" = &"
						+ИмяПараметра;
		
		инд = инд+1;
	КонецЦикла; // СтрокиПравил				
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"%Условия%",ТекстУсловия);
	
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		
		Результат = Запрос.Выполнить();
		
	Исключение
		
		
		Если ВыводитьОшибки Тогда
			
			ТекстСообщения = НСтр("ru = 'Ошибка поиска объекта ""%1%""! Способ поиска ""%2%"". Описание ошибки ""%3%"".'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
																						,ИмяОбъектаПолное
																						,стрПравило.СпособПоискаДанных
																						,Строка(ОписаниеОшибки()));
			
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);																			 
			
		КонецЕсли; 
		
		
		Результат = Неопределено;
		
	КонецПопытки;
	
	Если НЕ Результат = Неопределено Тогда
		
		Выборка = Результат.Выбрать();
		
		Если Выборка.Следующий() Тогда
			НайденноеЗначение = Выборка.Ссылка;
		КонецЕсли; 
		
	КонецЕсли; 
	
	
	Возврат НайденноеЗначение;
	
КонецФункции // НайтиПоУсловию()

// Функция.
// 
// Параметры:
// 
// 
// Возвращаемое значение:
//  Результат - Строка.
// 
Функция ОпределитьИменаРеквизитовПравила(Правило,Направление)

	Имена = Новый Структура("ИмяИсточника,ИмяПриемника,НомерИсточника,НомерПриемника");
	
	НомерИсточника = ОпределитьНомерРеквизитаИсточника(Правило,Направление);
	НомерПриемника = ОпределитьНомерРеквизитаПриемника(НомерИсточника);
	Имена.ИмяИсточника = "ИмяРеквизита_"+Формат(НомерИсточника, "ЧГ=");
	Имена.ИмяПриемника = "ИмяРеквизита_"+Формат(НомерПриемника, "ЧГ=");
	Имена.НомерИсточника = Формат(НомерИсточника, "ЧГ=");
	Имена.НомерПриемника = Формат(НомерПриемника, "ЧГ=");
	
	Возврат Имена;
	
КонецФункции // ОпределитьИменаРеквизитовПриемникИсточник()

// Функция определяет номер реквизита приемника в правиле поиска данных в зависимости от направления обмена.
// 
// Параметры:
//  Правило - СправочникСсылка.бит_мпд_ПравилаПоискаДанных
//  Направление - Строка - "ТекущаяВнешняя", "ВнешняяТекущая".
// 
// Возвращаемое значение:
//  НомерРеквизита - Число.
// 
Функция ОпределитьНомерРеквизитаИсточника(Правило,Направление)

	
	Если ВРег(Направление) = ВРег("ТекущаяВнешняя") Тогда
		
		Если Правило.ВидИнформационнойБазы_1 = Справочники.бит_мпд_ВидыИнформационныхБаз.ТекущаяИнформационнаяБаза Тогда
			
				НомерРеквизита = 1;
			
		Иначе	
			
				НомерРеквизита = 2;
			
		КонецЕсли; 
		
	Иначе
		
		Если Правило.ВидИнформационнойБазы_1 = Справочники.бит_мпд_ВидыИнформационныхБаз.ТекущаяИнформационнаяБаза Тогда
			
				НомерРеквизита = 2;
			
		Иначе	
			
				НомерРеквизита = 1;
			
		КонецЕсли; 
		
	
	КонецЕсли; 

	Возврат НомерРеквизита;
	
КонецФункции // ОпределитьНомерРеквизитаПравила()

// Функция вычисляет номер реквизита источника в правиле поиска в зависимости от НомераРеквизитаИсточника.
// 
// Параметры:
//  НомерРеквизитаИсточника - Число.
// 
// Возвращаемое значение:
//  НомерРеквизита - Число.
// 
Функция ОпределитьНомерРеквизитаПриемника(НомерРеквизитаИсточника)

	НомерРеквизита = 3-НомерРеквизитаИсточника;

	Возврат НомерРеквизита;
	
КонецФункции // ОпределитьНомерРеквизитаПриемника()

// Функция определяет имя значения перечисления во внешней базе.
// 
// Параметры:
//   Соединение - ComObject
//   ПеречислениеКом - ComObject
//   ЗначениеКом     - ComObject
// 
// 
// Возвращаемое значение:
//  ИмяЗначения - Строка.
// 
Функция ПолучитьИмяЗначенияПеречисленияВнеш(Соединение, ПеречислениеКом, ЗначениеКом)
	
	ИмяЗначения = "";
	
	ЗначенияПеречисленияМета = ЗначениеКом.Метаданные().ЗначенияПеречисления;
	
	Для каждого ЗначениеМета Из ЗначенияПеречисленияМета Цикл
		
		ТекИмя = ЗначениеМета.Имя;
		ТекЗначениеПеречисления = ПеречислениеКом[ТекИмя];
		
		Если Соединение.String(ЗначениеКом) = Соединение.String(ТекЗначениеПеречисления) Тогда
			
			ИмяЗначения = ТекИмя;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	Возврат ИмяЗначения;
	
КонецФункции // ПолучитьИмяЗначенияПеречисленияВнеш()

// Функция выполняет преобразование из внешней информационной базы в текущую в случае HTTP соединения.
// 
// Возвращаемое значение:
//  РезЗначение - Произвольный.
// 
Функция ПреобразоватьЗначениеВнешняяТекущаяHTTP(ВхЗначение, ИмяТипа, ПравилаПоиска, НастройкаПодключения, КэшПоиска)
	
	ИмяОбъектаПолное = СтрЗаменить(ИмяТипа, "Ссылка", ""); 
	СтруктураИмен   = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяОбъектаПолное);
	
	Если Найти(ИмяОбъектаПолное,"Перечисление.") = 0 Тогда
		
		ТекИД        = ВхЗначение.ИД;
		
	Иначе
		
		// СтруктураИмен   = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяПолное);
		// ПеречислениеКом = Соединение.Перечисления[СтруктураИмен.ИмяОбъекта];
		// ТекИД           = ПолучитьИмяЗначенияПеречисленияВнеш(Соединение, ПеречислениеКом, ЗначениеКом);
		
	КонецЕсли;			
	
	КлючЗначения = ИмяОбъектаПолное+"?ref="""+ТекИД+"""";
	
	РезЗначение = КэшПоиска[КлючЗначения];
	
	Если РезЗначение = Неопределено Тогда
		
		Правило = ПравилаПоиска[ИмяОбъектаПолное];
		
		СтрПар = Новый Структура("Правило,Направление,ЗначениеПоиска,ИмяОбъектаПолное");
		СтрПар.Правило          = Правило;
		СтрПар.Направление      = "ВнешняяТекущая";
		СтрПар.ЗначениеПоиска   = вхЗначение;
		СтрПар.ИмяОбъектаПолное = ИмяОбъектаПолное;
		
		РезЗначение = ВыполнитьПоискПоПравилу(Неопределено, СтрПар);
		
		КэшПоиска.Вставить(КлючЗначения, РезЗначение);
		
	КонецЕсли; 
	
	// Не удалось найти значение в базе
	Если РезЗначение = Неопределено Тогда
		
		Если СтруктураИмен.ИмяКоллекции = "Документы" Тогда
			
			ТекПредставление = СтруктураИмен.ИмяОбъекта+" № "+ВхЗначение.Number+НСтр("ru=' от '")+ВхЗначение.Date;
			
		ИначеЕсли СтруктураИмен.ИмяКоллекции = "ПланыСчетов" Тогда
			
			ТекПредставление = ВхЗначение.Code;
			
		ИначеЕсли ВхЗначение.Свойство("Description") Тогда
			
			ТекПредставление = ВхЗначение.Description;
			
		Иначе	
			
			ТекПредставление = " ";
			
		КонецЕсли; 	
		
		Если ПустаяСтрока(ТекПредставление) Тогда
			
			ТекПредставление = " ";
			
		КонецЕсли; 
		
		СтрРасшифровки = Новый Структура("ИмяКласса, НастройкаПодключения, ПолноеИмя, ИД, Значение, Представление, Режим, НавигационнаяСсылка", "ЗначениеВнешнейБазы");
		СтрРасшифровки.НастройкаПодключения = НастройкаПодключения;
		СтрРасшифровки.ПолноеИмя            = ИмяОбъектаПолное;
		СтрРасшифровки.ИД                   = ВхЗначение.ИД;
		СтрРасшифровки.Представление        = ТекПредставление;
		СтрРасшифровки.Режим = "HTTP";
		
		НавигационнаяСсылка = "http://%ИмяСервера%/%ИмяБазы%/#e1cib/data/%ПолноеИмя%?ref=%ИД%";
        НавигационнаяСсылка = СтрЗаменить(НавигационнаяСсылка, "%ИмяСервера%", НастройкаПодключения.ИмяСервера);
        НавигационнаяСсылка = СтрЗаменить(НавигационнаяСсылка, "%ИмяБазы%"   , НастройкаПодключения.ИмяБазы);
        НавигационнаяСсылка = СтрЗаменить(НавигационнаяСсылка, "%ПолноеИмя%" , ИмяОбъектаПолное);
        НавигационнаяСсылка = СтрЗаменить(НавигационнаяСсылка, "%ИД%"        , СтрЗаменить(ВхЗначение.ИД,"-",""));
		
		СтрРасшифровки.НавигационнаяСсылка = НавигационнаяСсылка;
		
		РезЗначение = СтрРасшифровки;
		
		КэшПоиска.Вставить(КлючЗначения, РезЗначение);				
		
	КонецЕсли;	
	
	Возврат РезЗначение;
	
КонецФункции // ПреобразоватьЗначениеВнешняяТекущаяHTTP()

#КонецОбласти
