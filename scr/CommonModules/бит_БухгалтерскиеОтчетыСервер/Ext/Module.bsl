
////////////////////////////////////////////////////////////////////////////////
// Модуль содержит процедуры и функции формирования бухгалтерских отчетов
// по бюджетированию и управленческому учету.
// 
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

#Область РеквизитыИТаблицыФормы

// Процедура перезаполняет отборы по субконто в таблице отборов.
// 
// Параметры:
//  Отчет     	 - ДанныеФормыСтруктура.
//  ЭтаФорма     - УправляемаяФорма.
//  Ид 			 - Строка.
//  ЭтоУдаление  - Булево.
// 
Процедура ПерезаполнитьДанныеФормыПоСубконто(Отчет, ЭтаФорма, Ид = Неопределено, ЭтоУдаление = Ложь
											, ПерезаполнятьПризнакиУчета = Ложь, ПерезаполнятьТекстЗапроса = Истина) Экспорт

	СтруктураИзменяемых = Новый Структура;
	
	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто И Ид <> Неопределено Тогда
		// Изменение табличной части "Субконто + 
		// Заполнение структуры изменяемых по табличной части "Субконто".
		
		ТекущиеДанные = Отчет.Субконто.НайтиПоИдентификатору(Ид);
		Если ТекущиеДанные = Неопределено Тогда
			Возврат;		
		КонецЕсли;
		
		НомерТекСтроки = ТекущиеДанные.НомерСтроки;
		ИмяСубконто    = "Субконто" + НомерТекСтроки;
		ВидСубконто    = ТекущиеДанные.ВидСубконто;
			
		// Если вид субконто заполнен
		Если ЭтоУдаление Или Не ЗначениеЗаполнено(ВидСубконто) Тогда
			
			// Заполнение структуры изменяемых по табличной части "Субконто".
			СтруктураИзменяемых.Вставить(ИмяСубконто, "");
			Для Сч = НомерТекСтроки + 1 По Отчет.Субконто.Количество() Цикл
				СтруктураИзменяемых.Вставить("Субконто" + Сч, "Субконто" + (Сч - 1));
			КонецЦикла;
			
			// Удаление вида субконто из табличной части.
			Отчет.Субконто.Удалить(ТекущиеДанные);
				 						
		Иначе
			
			// Заполнение структуры изменяемых по текущему виду субконто табличной части "Субконто".
			СтруктураИзменяемых.Вставить(ИмяСубконто, ВидСубконто);
			
		КонецЕсли; // Если вид субконто заполнен
		
		// Новый массив субконто
		НовыйМассивСубконто = Новый Массив;
		Для каждого СтрокаСубконто Из Отчет.Субконто Цикл 		
			Если ЗначениеЗаполнено(СтрокаСубконто.ВидСубконто) Тогда
				НовыйМассивСубконто.Добавить(СтрокаСубконто.ВидСубконто);
			КонецЕсли;  			
		КонецЦикла;
		ЭтаФорма.фКэшЗначений.Вставить("МассивСубконто", НовыйМассивСубконто);
		
	ИначеЕсли ЭтаФорма.фКэшЗначений.ЕстьРкСчет Тогда
		// Заполнение структуры изменяемых по видам субконто текущего счета.
		
		// Новый массив субконто
		НовыйМассивСубконто = СформироватьМассивСубконтоПоСчету(Отчет.Счет);
		
		Если ЭтоУдаление Тогда
				 			
			СоответствиеСтарых = Новый Соответствие;
			СтарыйМассивСубконто = ЭтаФорма.фКэшЗначений.МассивСубконто;		
			Для Сч = 0 По СтарыйМассивСубконто.Количество() - 1 Цикл
				
				ВидСубконто = СтарыйМассивСубконто[Сч];
				ПрямойПутьСубконто = "Субконто" + (Сч + 1);
				СтруктураИзменяемых.Вставить(ПрямойПутьСубконто, "");
				СоответствиеСтарых.Вставить(ВидСубконто, ПрямойПутьСубконто);
				
			КонецЦикла;       		
			
			Для Сч = 0 По НовыйМассивСубконто.Количество() - 1 Цикл
				
				ВидСубконто = НовыйМассивСубконто[Сч];
				ПрямойПутьСубконто = "Субконто" + (Сч + 1);
				СтарыйПутьСубконто = СоответствиеСтарых.Получить(ВидСубконто);
				Если СтарыйПутьСубконто = Неопределено Тогда
			    	СтруктураИзменяемых.Вставить(ПрямойПутьСубконто, ВидСубконто);
				Иначе
					СтруктураИзменяемых.Вставить(СтарыйПутьСубконто, ПрямойПутьСубконто);
				КонецЕсли;
				
			КонецЦикла;
			
			ЭтаФорма.фКэшЗначений.Вставить("МассивСубконто", НовыйМассивСубконто);
			
		Иначе
			
			ЭтаФорма.фКэшЗначений.Вставить("МассивСубконто", НовыйМассивСубконто);
			Возврат;
			
		КонецЕсли;
						
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Признаки учета
	Если ПерезаполнятьПризнакиУчета Тогда
		ПерезаполнитьПризнакиУчета(Отчет, ЭтаФорма);
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Отборы
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		ПерезаполнитьТаблицуОтборов(Отчет, ЭтаФорма, СтруктураИзменяемых);
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Сортировка
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаСортировки Тогда
		ПерезаполнитьТаблицуСортировки(Отчет, ЭтаФорма, СтруктураИзменяемых);	
	КонецЕсли;
	
	// Детализация счета
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаДетализацииСчета Тогда
		ПерезаполнитьТаблицуДетализацииСчета(Отчет, ЭтаФорма);					   			
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Группировка
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаГруппировки Тогда
		ПерезаполнитьТаблицуГруппировки(Отчет, ЭтаФорма);	
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Перезаполнение текста запроса построителя.
	Если ПерезаполнятьТекстЗапроса Тогда
		ПерезаполнитьТекстЗапроса(Отчет, ЭтаФорма);	
	КонецЕсли;
		
КонецПроцедуры // ПерезаполнитьДанныеФормыПоСубконто()

// Процедура перезаполняет данные отчета и формы по регистру бухгалтерии.
// 
// Параметры:
//  Отчет     	   - ДанныеФормыСтруктура.
//  ЭтаФорма 	   - УправляемаяФорма.
//  ИмяТипаОбъекта - Строка.
// 
Процедура ПерезаполнитьДанныеПоРегиструБухгалтерии(Отчет, ЭтаФорма, ИмяТипаОбъекта) Экспорт

	ЭтаФорма.фИмяРегистраБухгалтерии = ?(ЗначениеЗаполнено(Отчет.РегистрБухгалтерии)
										, Отчет.РегистрБухгалтерии.ИмяОбъекта
										, "");
										
	Если ЗначениеЗаполнено(ЭтаФорма.фИмяРегистраБухгалтерии) Тогда
		
		МетаданныеПланСчетов = Метаданные.РегистрыБухгалтерии[ЭтаФорма.фИмяРегистраБухгалтерии].ПланСчетов;
		// Максимальное количество субконто
		МаксКоличествоСубконто = МетаданныеПланСчетов.МаксКоличествоСубконто; 
		ЭтаФорма.фКэшЗначений.Вставить("МаксКоличествоСубконто", МаксКоличествоСубконто);
		// Имя плана счетов регистра бухгалтерии.
		ИмяПланаСчетов = МетаданныеПланСчетов.Имя; 			
		// ПВХ плана счетов регистра бухгалтерии.
		ПВХПланаСчетов = ПланыВидовХарактеристик[Метаданные.ПланыСчетов[ИмяПланаСчетов].ВидыСубконто.Имя];
		ТипЗнчСубконтоРегистра = ТипЗнч(ПВХПланаСчетов.ПустаяСсылка());
		
		// Счет
		Если ЭтаФорма.фКэшЗначений.ЕстьРкСчет Тогда
			
			// Пустой счет регистра бухгалтерии по умолчанию.
			СчетПоУмолчанию = ПланыСчетов[Метаданные.РегистрыБухгалтерии[ЭтаФорма.фИмяРегистраБухгалтерии].ПланСчетов.Имя].ПустаяСсылка();
			Если ТипЗнч(СчетПоУмолчанию) <> ТипЗнч(Отчет.Счет) Тогда 
				Отчет.Счет = СчетПоУмолчанию;
				ПерезаполнитьДанныеФормыПоСубконто(Отчет, ЭтаФорма, , Истина);
			КонецЕсли;			
			
		КонецЕсли; // Если есть реквизит "Счет"
		
		// Кор счет
		Если ЭтаФорма.фКэшЗначений.ЕстьРкКорСчет Тогда
			
			// Пустой счет регистра бухгалтерии по умолчанию.
			СчетПоУмолчанию = ПланыСчетов[Метаданные.РегистрыБухгалтерии[ЭтаФорма.фИмяРегистраБухгалтерии].ПланСчетов.Имя].ПустаяСсылка();
			Если ТипЗнч(СчетПоУмолчанию) <> ТипЗнч(Отчет.КорСчет) И ТипЗнч(СчетПоУмолчанию) <> Тип("СписокЗначений") Тогда 
				Отчет.КорСчет = СчетПоУмолчанию;
			КонецЕсли;			
			
		КонецЕсли; // Если есть реквизит "Счет"
		
		// Табличная часть "Субконто"
		Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
			
			// Субконто
			КоличествоСубконто = Отчет.Субконто.Количество();
			Сч = КоличествоСубконто;
			Пока Сч > 0 Цикл
				
				СтрокаСубконто = Отчет.Субконто[Сч - 1];
				
				// Если видов субконто больше чем доступно
				Если Сч > МаксКоличествоСубконто Тогда
					
					// Удаление вида субконто несоответствующего новому регистру бухгалтерии
					// и очистка соответствующих данных формы.
					ПерезаполнитьДанныеФормыПоСубконто(Отчет, ЭтаФорма, СтрокаСубконто.ПолучитьИдентификатор(), Истина, , Ложь);
				
				Иначе
					
					ТекВидСубконто = СтрокаСубконто.ВидСубконто;
					Если Не ТипЗнч(ТекВидСубконто) = ТипЗнчСубконтоРегистра Тогда
						
						Если ТекВидСубконто <> Неопределено Тогда 
							НайденныйВид = ПВХПланаСчетов.НайтиПоНаименованию(ТекВидСубконто.Наименование);
							Если ЗначениеЗаполнено(НайденныйВид) Тогда
								// Замена вида субконто с новым типом и соответствующим именем и изменение соответствующих данных формы.
								СтрокаСубконто.ВидСубконто = НайденныйВид;
								ПерезаполнитьДанныеФормыПоСубконто(Отчет, ЭтаФорма, СтрокаСубконто.ПолучитьИдентификатор(), Ложь, , Ложь);
							Иначе
								// Удаление вида субконто и очистка соответствующих данных формы.
								ПерезаполнитьДанныеФормыПоСубконто(Отчет, ЭтаФорма, СтрокаСубконто.ПолучитьИдентификатор(), Истина, , Ложь);
							КонецЕсли;
						КонецЕсли;
						
					КонецЕсли;
				
				КонецЕсли; // Если видов субконто больше чем доступно.
				
				Сч = Сч - 1;
			
			КонецЦикла; 
			
			ПерезаполнитьТекстЗапроса(Отчет, ЭтаФорма);
						 			
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнчСубконтоРегистра);
			ЭтаФорма.Элементы.СубконтоВидСубконто.ОграничениеТипа = Новый ОписаниеТипов(МассивТипов);
			
		КонецЕсли; // Если есть табличная часть "Субконто"
		 		
		// Детализация счета
		Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаДетализацииСчета Тогда
			
			ПерезаполнитьТаблицуДетализацииСчета(Отчет, ЭтаФорма);
						   			
		КонецЕсли; // Если есть таблица формы "ДетализацииСчета".
		
		// Корреспонденции
		Если ЭтаФорма.фКэшЗначений.ЕстьРкКорреспонденции Тогда
			
			ЭтаФорма.Корреспонденции.Очистить();
			
			МассивТиповСчета = Новый Массив;
			МассивТиповСчета.Добавить(Тип("ПланСчетовСсылка." + ИмяПланаСчетов));
			ЭтаФорма.Элементы.КорреспонденцииСчетДт.ОграничениеТипа = Новый ОписаниеТипов(МассивТиповСчета);
			ЭтаФорма.Элементы.КорреспонденцииСчетКт.ОграничениеТипа = Новый ОписаниеТипов(МассивТиповСчета);
			   			
		КонецЕсли; // Если есть реквизит "Корреспонденции"
		
		// Правила вывода итогов
		Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаВыводаИтогов Тогда
			
			ЭтаФорма.ПравилаВыводаИтогов.Очистить();
			
			МассивТиповСчета = Новый Массив;
			МассивТиповСчета.Добавить(Тип("ПланСчетовСсылка." + ИмяПланаСчетов));
			ЭтаФорма.Элементы.ПравилаВыводаИтоговСчет.ОграничениеТипа = Новый ОписаниеТипов(МассивТиповСчета);
			   			
		КонецЕсли; // Если есть реквизит "ПравилаВыводаИтогов"
		
		// Правила развернутого сальдо
		Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаРазвернутогоСальдо Тогда
			
			ЭтаФорма.ПравилаРазвернутогоСальдо.Очистить();
			
			МассивТиповСчета = Новый Массив;
			МассивТиповСчета.Добавить(Тип("ПланСчетовСсылка." + ИмяПланаСчетов));
			ЭтаФорма.Элементы.ПравилаРазвернутогоСальдоСчет.ОграничениеТипа = Новый ОписаниеТипов(МассивТиповСчета);
			   			
		КонецЕсли; // Если есть реквизит "ПравилаРазвернутогоСальдо".
		     	
		// Показатель вывода суммы МУ
		Если бит_ОбщегоНазначения.ЕстьОбъектыМСФО() Тогда 
			
			Если Не ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда		 	
				
				//ижтиси, шадрин, 02.09.2015(
				ЕстьИзмерениеВыводитьВидДвижения = бит_ОбщегоНазначения.ЕстьИзмерениеВидДвиженияМСФОРегистраБухгалтерии(ЭтаФорма.фИмяРегистраБухгалтерии);
				Если ЭтаФорма.Элементы.Найти("ВыводитьВидДвижения") <> Неопределено Тогда
					ЭтаФорма.Элементы.ВыводитьВидДвижения.Видимость = ЕстьИзмерениеВыводитьВидДвижения;
					Если Не ЕстьИзмерениеВыводитьВидДвижения Тогда
						Отчет.ВыводитьВидДвижения = Ложь;
					КонецЕсли;
				КонецЕсли;
				//ижтиси, шадрин, 02.09.2015)
				
				ЕстьРесурсСуммаМУ = бит_ОбщегоНазначения.ЕстьРесурсСуммаМУРегистраБухгалтерии(ЭтаФорма.фИмяРегистраБухгалтерии);
				ЭтаФорма.Элементы.ВыводитьСуммуМУ.Видимость = ЕстьРесурсСуммаМУ;
				Если Не ЕстьРесурсСуммаМУ Тогда
					Отчет.ВыводитьСуммуМУ = Ложь;
				КонецЕсли;
				
			КонецЕсли; // Если это бюджетирование
		
		ИначеЕсли ЭтаФорма.Элементы.Найти("ВыводитьСуммуМУ") <> Неопределено Тогда
			
			ЭтаФорма.Элементы.ВыводитьСуммуМУ.Видимость = Ложь;
			
		КонецЕсли;		
				
		ЭтаФорма.фКэшЗначений.Вставить("ПустоеСубконто", ПВХПланаСчетов.ПустаяСсылка());
        
        // Типы выбора кор. субконто в таблице ТаблицаКорСубконто.
        Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаКорСубконто Тогда            
            ЭтаФорма.фКэшЗначений.Вставить("ТипыКорСубконто", Метаданные.ПланыСчетов[ЭтаФорма.фИмяРегистраБухгалтерии].ВидыСубконто.Тип);                         
        КонецЕсли;
	
	Иначе
		
		// Счет
		Если ЭтаФорма.фКэшЗначений.ЕстьРкСчет Тогда
			Отчет.Счет = Неопределено;
		КонецЕсли;
		
		// Табличная часть "Субконто"
		Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
			Отчет.Субконто.Очистить();	
		КонецЕсли;
		
		// Детализация счета
		Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаДетализацииСчета Тогда	
			ЭтаФорма.ДетализацияСчета.Очистить();   						   			
		КонецЕсли; 
		
		// Корреспонденции
		Если ЭтаФорма.фКэшЗначений.ЕстьРкКорреспонденции Тогда   			
			ЭтаФорма.Корреспонденции.Очистить();
			ЭтаФорма.Элементы.КорреспонденцииСчетДт.ОграничениеТипа = Новый ОписаниеТипов(Новый Массив);
			ЭтаФорма.Элементы.КорреспонденцииСчетКт.ОграничениеТипа = Новый ОписаниеТипов(Новый Массив);  			   			
		КонецЕсли;
		
		// Правила вывода итогов
		Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаВыводаИтогов Тогда			
			ЭтаФорма.ПравилаВыводаИтогов.Очистить();		
			ЭтаФорма.Элементы.ПравилаВыводаИтоговСчет.ОграничениеТипа = Новый ОписаниеТипов(Новый Массив);
		КонецЕсли;
		
		// Правила вывода развернутого сальдо
		Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаРазвернутогоСальдо Тогда			
			ЭтаФорма.ПравилаРазвернутогоСальдо.Очистить();		
			ЭтаФорма.Элементы.ПравилаРазвернутогоСальдоСчет.ОграничениеТипа = Новый ОписаниеТипов(Новый Массив);
		КонецЕсли;
				
		// Показатель вывода суммы МУ
		Если бит_ОбщегоНазначения.ЕстьОбъектыМСФО() И Не ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда		 	
			Отчет.ВыводитьСуммуМУ = Истина;
        КонецЕсли;
        
        // Типы выбора кор. субконто в таблице ТаблицаКорСубконто.
        Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаКорСубконто Тогда            
            ЭтаФорма.фКэшЗначений.Вставить("ТипыКорСубконто", Новый Массив);                         
        КонецЕсли;
		
	КонецЕсли;   	

КонецПроцедуры // ПерезаполнитьДанныеПоРегиструБухгалтерии()

// Процедура перезаполняет признаки учета на форме.
// 
// Параметры:
//  Отчет    			  - ДанныеФормыСтруктура.
//  ЭтаФорма 			  - УправляемаяФорма.
//  ПерезаполнятьЗначения - Булево.
// 
Процедура ПерезаполнитьПризнакиУчета(Отчет, ЭтаФорма, ПерезаполнятьЗначения = Истина) Экспорт
	
	Если Не ЭтаФорма.фКэшЗначений.ЕстьРкСчет И НЕ ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
		Возврат;
	КонецЕсли;
	
	ЕстьВалюта     = Ложь;
	ЕстьКоличество = Ложь;
	
	Если ЭтаФорма.фКэшЗначений.ЕстьРкСчет Тогда
		
        Если ЗначениеЗаполнено(Отчет.Счет) Тогда
            СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Отчет.Счет);
			ЕстьВалюта     = СвСч.Валютный;
			ЕстьКоличество = СвСч.Количественный;
		КонецЕсли;			
			
	ИначеЕсли ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда 
		СтруктураУчета = ОпределитьПризнакиУчетаСубконтоРегистраБухгалтерии("бит_Бюджетирование"
																		, ЭтаФорма.фКэшЗначений.МассивСубконто);	
		ЕстьВалюта	   = СтруктураУчета.ЕстьВалюта;
		ЕстьКоличество = СтруктураУчета.ЕстьКоличество;																		
	Иначе
		Если Не ЗначениеЗаполнено(ЭтаФорма.фИмяРегистраБухгалтерии) И ЗначениеЗаполнено(Отчет.РегистрБухгалтерии) Тогда
			ЭтаФорма.фИмяРегистраБухгалтерии = Отчет.РегистрБухгалтерии.ИмяОбъекта;
		КонецЕсли;
		Если ЗначениеЗаполнено(ЭтаФорма.фИмяРегистраБухгалтерии) Тогда
			СтруктураУчета = ОпределитьПризнакиУчетаСубконтоРегистраБухгалтерии(ЭтаФорма.фИмяРегистраБухгалтерии
																			, ЭтаФорма.фКэшЗначений.МассивСубконто);	
			ЕстьВалюта	   = СтруктураУчета.ЕстьВалюта;
			ЕстьКоличество = СтруктураУчета.ЕстьКоличество;																		
		КонецЕсли;
	КонецЕсли;
	
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПоВалютам Тогда
		
		Если ПерезаполнятьЗначения И Отчет.ПоВалютам Тогда
			Отчет.ПоВалютам = ЕстьВалюта;
		КонецЕсли;		
		ЭтаФорма.Элементы.ПоВалютам.Доступность = ЕстьВалюта;
		
	КонецЕсли;
	
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПоКоличеству Тогда
		
		Если ПерезаполнятьЗначения И Отчет.ПоКоличеству Тогда
			Отчет.ПоКоличеству = ЕстьКоличество;
		КонецЕсли;
		ЭтаФорма.Элементы.ПоКоличеству.Доступность = ЕстьКоличество;
		
	КонецЕсли;

КонецПроцедуры // ПерезаполнитьПризнакиУчета()

// Функция формирует список номеров журналов, присутствующих в базе.
// 
// Параметры:
//    РегистрБухгалтерии - РегистрБухгалтерииСсылка - Регистр бухгалтерии.
// 
// Возвращаемое значение:
//   СписокЗначений - Список номеров журналов, которые есть в базе.
// 
Процедура ПолучитьСписокНомеровЖурнала(ЭлементФормы, РегистрБухгалтерии = Неопределено) Экспорт
	
	ИмяРегистра = ?(РегистрБухгалтерии = Неопределено, "бит_Бюджетирование", РегистрБухгалтерии.ИмяОбъекта);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	Регистр.НомерЖурнала КАК НомерЖурнала
	|ИЗ
	|	РегистрБухгалтерии." + ИмяРегистра + " КАК Регистр
	|
	|УПОРЯДОЧИТЬ ПО
	|	НомерЖурнала
	|"; 	

	РезультатЗапроса = Запрос.Выполнить();
	ЭлементФормы.СписокВыбора.ЗагрузитьЗначения(РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("НомерЖурнала"));
		
КонецПроцедуры // ПолучитьСписокНомеровЖурнала()

// приводит значения строки отборов к нужному типу.
// 
// Параметры:
// 	СтрокаОтбора 		 - ДанныеФормыЭлементКоллекции.
//  ОписаниеТекущегоТипа - ОписаниеТипов.
// 
Процедура ПривестиЗначенияЭлементаОтбора(СтрокаОтбора, ОписаниеТекущегоТипа) Экспорт 
	
	СтрокаОтбора.ТипЗначения = ОписаниеТекущегоТипа;
	
	СтрокаОтбора.Значение   = ОписаниеТекущегоТипа.ПривестиЗначение(СтрокаОтбора.Значение);
	СтрокаОтбора.ЗначениеС  = ОписаниеТекущегоТипа.ПривестиЗначение(СтрокаОтбора.ЗначениеС);
	СтрокаОтбора.ЗначениеПо = ОписаниеТекущегоТипа.ПривестиЗначение(СтрокаОтбора.ЗначениеПо);
		
КонецПроцедуры // ПривестиЗначенияЭлементаОтбора()

// добавляет отбор по виду субконто в таблицу отборов.
// 
// Параметры:
// 	ТаблицаОтбор - ДанныеФормыКоллекция
//  ПутьКДанным  - Строка
//  ВидСубконто  - ПланВидовХарактеристикСсылка.бит_ВидыСубконто - Виды субконто.
// 
Процедура ДобавитьЭлементОтбораПоВидуСубконто(ТаблицаОтбор, ПутьКДанным, ВидСубконто) Экспорт 
	
	СтрокаОтбора = ТаблицаОтбор.Добавить();
		
	СтрокаОтбора.ПутьКДанным   = ПутьКДанным;
	СтрокаОтбора.Имя 	       = ПутьКДанным;
	СтрокаОтбора.Представление = ВидСубконто.Наименование; // + " (субконто)";
	
	ПривестиЗначенияЭлементаОтбора(СтрокаОтбора, ВидСубконто.ТипЗначения);
		
КонецПроцедуры // ДобавитьЭлементОтбораПоВидуСубконто()

// добавляет отбор по сценарию в таблицу отборов.
// 
// Параметры:
// 	ЭтаФорм      - Управляемая форма.
//  СтрокаОтбора - ДанныеФормыЭлементКоллекции.
// 
Процедура ДобавитьОтборПоСценарию(ЭтаФорма, СтрокаОтбора = Неопределено) Экспорт 
	
	СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить();
		
	СтрокаОтбора.ПутьКДанным   = "Сценарий";
	СтрокаОтбора.Имя 		   = "Сценарий";
	СтрокаОтбора.Представление = "Сценарий";
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("СправочникСсылка." + бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования()));
	ОписаниеТекущегоТипа = Новый ОписаниеТипов(МассивТипов);
	ПривестиЗначенияЭлементаОтбора(СтрокаОтбора, ОписаниеТекущегоТипа);
		
КонецПроцедуры // ДобавитьОтборПоСценарию()

// добавляет отбор по ЦФО в таблицу отборов.
// 
// Параметры:
// 	ЭтаФорма - Управляемая форма.
// 
Процедура ДобавитьОтборПоЦФО(ЭтаФорма) Экспорт 
	
	СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить();
		
	СтрокаОтбора.ПутьКДанным   = "ЦФО";
	СтрокаОтбора.Имя 		   = "ЦФО";
	СтрокаОтбора.Представление = "ЦФО";
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("СправочникСсылка." + бит_ОбщегоНазначения.ПолучитьИмяСправочникаЦФО()));
	ОписаниеТекущегоТипа = Новый ОписаниеТипов(МассивТипов);
	ПривестиЗначенияЭлементаОтбора(СтрокаОтбора, ОписаниеТекущегоТипа);
		
КонецПроцедуры // ДобавитьОтборПоЦФО()

// добавляет отбор по валюте в таблицу отборов.
// 
// Параметры:
// 	ЭтаФорма - Управляемая форма.
// 
Процедура ДобавитьОтборПоВалюте(ЭтаФорма) Экспорт 
	
	СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить();
		
	СтрокаОтбора.ПутьКДанным   = "Валюта";
	СтрокаОтбора.Имя 		   = "Валюта";
	СтрокаОтбора.Представление = "Валюта";
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("СправочникСсылка.Валюты"));
	ОписаниеТекущегоТипа = Новый ОписаниеТипов(МассивТипов);
	ПривестиЗначенияЭлементаОтбора(СтрокаОтбора, ОписаниеТекущегоТипа);
		
КонецПроцедуры // ДобавитьОтборПоВалюте()

// Процедура обрабатывает изменение вида сравнения в таблице отбор.
// 
// Параметры:
//  Отчет            - ДанныеФормыСтруктура.
//  ПредВидСравнения - ВидСравнения.
// 
Процедура ИзменениеВидаСравненияСценария(Отчет, ПредВидСравнения) Экспорт
	
	Если ПредВидСравнения = Отчет.СценарийВидСравнения Тогда
		Возврат;
	КонецЕсли;
		
	флТекВидДляСписка  = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(Отчет.СценарийВидСравнения);
	флПредВидДляСписка = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(ПредВидСравнения);
	
	Если флТекВидДляСписка Тогда
		
		Если НЕ флПредВидДляСписка Тогда
			
			Список             = Новый СписокЗначений;
			Список.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.СценарииПланирования");
			
			// Создадим список
			Если ЗначениеЗаполнено(Отчет.Сценарий) Тогда 				
				Список.Добавить(Отчет.Сценарий);  				
			КонецЕсли; 
			Отчет.Сценарий = Список;
									
		КонецЕсли; // НЕ флПредВидДляСписка
		
	Иначе	
		
		Если флПредВидДляСписка Тогда
			
			// Уничтожим список
			Если ТипЗнч(Отчет.Сценарий) = Тип("СписокЗначений") Тогда
				
				Список = Отчет.Сценарий;
				Если Список.Количество() > 0 Тогда
					Отчет.Сценарий = Список[0].Значение;
				Иначе	
					Отчет.Сценарий = Справочники.СценарииПланирования.ПустаяСсылка();
				КонецЕсли; 
				
			КонецЕсли; 			
			
		КонецЕсли; // ФлПредВидДляСписка
		
	КонецЕсли; // ФлТекВидДляСписка 
	
КонецПроцедуры // ИзменениеВидаСравнения()

// устанавливает отбор по сценарию в таблицу отборов.
// 
// Параметры:
//  Отчет 	 		 - ДанныеФормыСтруктура.
//  ЭтаФорма 		 - УправляемаяФорма.
//  ПредВидСравнения - ВидСравнения.
// 
Процедура УстановитьОтборПоСценарию(Отчет, ЭтаФорма, ПредВидСравнения = Неопределено) Экспорт 
	
	Если Не ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда 
		ИзменениеВидаСравненияСценария(Отчет, ПредВидСравнения);
		Возврат;	
	КонецЕсли;
	
	НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("Имя", "Сценарий"));
	Если НайденныеСтроки.Количество() > 0 Тогда
		
		СтрокаОтбораПоСценарию = НайденныеСтроки[0];
		
		ПредВидСравнения = СтрокаОтбораПоСценарию.ВидСравнения;
		
		СтрокаОтбораПоСценарию.Использование = Отчет.СценарийИспользование;
		СтрокаОтбораПоСценарию.ВидСравнения  = Отчет.СценарийВидСравнения;
		СтрокаОтбораПоСценарию.Значение      = Отчет.Сценарий;  		   		
		
		Если ПредВидСравнения <> СтрокаОтбораПоСценарию.ВидСравнения Тогда
			бит_МеханизмПолученияДанных.ИзменениеВидаСравнения(СтрокаОтбораПоСценарию, ПредВидСравнения);
			Отчет.Сценарий = СтрокаОтбораПоСценарию.Значение;
		КонецЕсли;
		
	Иначе
		
		ДобавитьОтборПоСценарию(ЭтаФорма, СтрокаОтбораПоСценарию);
		
		СтрокаОтбораПоСценарию.Использование = Отчет.СценарийИспользование;
		СтрокаОтбораПоСценарию.ВидСравнения  = Отчет.СценарийВидСравнения;
		СтрокаОтбораПоСценарию.Значение      = Отчет.Сценарий;
				
	КонецЕсли;
	
КонецПроцедуры // УстановитьОтборПоСценарию()

// устанавливает отбор по ЦФО в таблицу отборов.
// 
// Параметры:
//  Отчет 	 - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура УстановитьОтборПоЦФО(Отчет, ЭтаФорма) Экспорт 
	 	
	НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("Имя", "ЦФО"));
	Если НайденныеСтроки.Количество() = 0 Тогда
		
		ДобавитьОтборПоЦФО(ЭтаФорма);
		
	КонецЕсли;                                       	
	
КонецПроцедуры // УстановитьОтборПоЦФО()

// устанавливает отбор по валюте в таблицу отборов.
// 
// Параметры:
//  Отчет 	 - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура УстановитьОтборПоВалюте(Отчет, ЭтаФорма) Экспорт 
	 	
	НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("Имя", "Валюта"));
	Если НайденныеСтроки.Количество() = 0 Тогда
		
		ДобавитьОтборПоВалюте(ЭтаФорма);
		
	КонецЕсли;                                       	
	
КонецПроцедуры // УстановитьОтборПоВалюте()

// Процедура перезаполняет отборы по субконто в таблице отборов.
// 
// Параметры:
//  Отчет     	 		- ДанныеФормыСтруктура.
//  ЭтаФорма     		- УправляемаяФорма.
//  СтруктураИзменяемых - Структура .
// 
Процедура ПерезаполнитьТаблицуОтборов(Отчет, ЭтаФорма, СтруктураИзменяемых) Экспорт

	Если ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда
		УстановитьОтборПоСценарию(Отчет, ЭтаФорма);
		УстановитьОтборПоЦФО(Отчет, ЭтаФорма);	
	КонецЕсли;
	ПерезаполнитьОтборПоВалюте(Отчет, ЭтаФорма);
		
	Если СтруктураИзменяемых.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Обратный цикл по таблице отборов
	Сч = ЭтаФорма.ТаблицаОтбор.Количество() - 1;
	Пока Сч >= 0 Цикл
	
		СтрокаОтбора = ЭтаФорма.ТаблицаОтбор[Сч]; 		
				
		ПутьКДанным = СтрокаОтбора.ПутьКДанным;	
		
		// Поиск значения в структуре по текущему пути.
		НайденноеЗнч 		= Неопределено;
		МассивПути 		    = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(ПутьКДанным, ".");
		ПутьБезРазделителей = ?(МассивПути.Количество() = 1, Истина, Ложь);
		ПрямойПутьСубконто  = МассивПути[0];
		СтруктураИзменяемых.Свойство(ПрямойПутьСубконто, НайденноеЗнч);
		
		Если НайденноеЗнч <> Неопределено Тогда
			                                       			
			Если ТипЗнч(НайденноеЗнч) = Тип("Строка") Тогда // Если Это удаление
				
				НовыйПрямойПутьСубконто = НайденноеЗнч;
				
				Если ПустаяСтрока(НовыйПрямойПутьСубконто) Тогда 					
					// Удаление строки отбора, связанной с удаляемым субконто.
					ЭтаФорма.ТаблицаОтбор.Удалить(СтрокаОтбора);    										
				ИначеЕсли ПутьБезРазделителей Тогда
					// Изменение строк отбора
					СтрокаОтбора.ПутьКДанным = НовыйПрямойПутьСубконто;
				Иначе
					// Изменение строк отбора
					СтрокаОтбора.ПутьКДанным = СтрЗаменить(СтрокаОтбора.ПутьКДанным, ПрямойПутьСубконто, НовыйПрямойПутьСубконто);	                                   					
				КонецЕсли;
							
			Иначе
				
				ВидСубконто = НайденноеЗнч;
				
				// Изменение строк отбора
				Если ПутьБезРазделителей Тогда
					Если СтрокаОтбора.ТипЗначения <> ВидСубконто.ТипЗначения Тогда			
						СтрокаОтбора.Представление = ВидСубконто.Наименование;
						бит_БухгалтерскиеОтчетыСервер.ПривестиЗначенияЭлементаОтбора(СтрокаОтбора, ВидСубконто.ТипЗначения);												
					КонецЕсли;
				Иначе	
					// Удаление строк отбора с путями через точку, для которых (вероятно) имя субконто не актуально.
				    ЭтаФорма.ТаблицаОтбор.Удалить(СтрокаОтбора);
				КонецЕсли;   				 		
								
			КонецЕсли;		
		
		КонецЕсли; // Если НайденноеЗнч <> Неопределено
		
		Сч = Сч - 1;
		
	КонецЦикла; // Обратный цикл по таблице отборов
	
	// Добавление отборов по умолчанию по изменяемым видам субконто.
	Для каждого КлЗнч Из СтруктураИзменяемых Цикл
		
		ВидСубконто = КлЗнч.Значение;
		Если ТипЗнч(ВидСубконто) <> Тип("Строка") Тогда
			
			ПрямойПутьСубконто = КлЗнч.Ключ;
			
			НайденныеСтрокиОтбора = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("ПутьКДанным", ПрямойПутьСубконто));
			Если НайденныеСтрокиОтбора.Количество() = 0 Тогда					
				бит_БухгалтерскиеОтчетыСервер.ДобавитьЭлементОтбораПоВидуСубконто(ЭтаФорма.ТаблицаОтбор, ПрямойПутьСубконто, ВидСубконто);			
			КонецЕсли;
			
		КонецЕсли;   			
	
	КонецЦикла; // Цикл по структуре изменяемых
	
КонецПроцедуры // ПерезаполнитьТаблицуОтборов()

// Таблица сортировки

// Процедура перезаполняет отборы по субконто в таблице отборов.
// 
// Параметры:
//  Отчет     	 		- ДанныеФормыСтруктура.
//  ЭтаФорма     		- УправляемаяФорма.
//  СтруктураИзменяемых - Структура.
// 
Процедура ПерезаполнитьТаблицуСортировки(Отчет, ЭтаФорма, СтруктураИзменяемых) Экспорт

	ЭтаФорма.ТаблицаСортировки.Очистить();

	// Если СтруктураИзменяемых.Количество() = 0 Тогда
	// 	Возврат;
	// КонецЕсли;
	
КонецПроцедуры // ПерезаполнитьТаблицуСортировки()

#КонецОбласти

#Область НастройкиОтчетов

// Процедура обновляет панель сохраненных настроек.
// 
// Параметры:
//  Отчет     	 			  - ДанныеФормыСтруктура.
//  ЭтаФорма     			  - УправляемаяФорма.
//  Очищать  		 		  - Булево (По умолчанию = Ложь).
//  ОчищатьНастройки 		  - Булево (По умолчанию = Ложь).
//  ТекКлючНастройки 		  - Строка (По умолчанию = Неопределено).
//  ТекущийРегистрБухгалтерии - РегистрБухгалтерииСсылка.* (По умолчанию = Неопределено).
// 
Процедура ОбновитьПанельСохраненныхНастроекОтчета(Отчет, ЭтаФорма, ОчищатьПанельНастроек = Ложь, ОчищатьНастройки = Ложь
											, ТекКлючНастройки = Неопределено, ТекущийРегистрБухгалтерии = Неопределено) Экспорт

	ГруппаПанели = ЭтаФорма.Элементы.ГруппаПанельВыбораСохраненныхНастроек;
	
	Если ЭтаФорма.фКэшЗначений.ЭтоБюджетирование
		Или ТекущийРегистрБухгалтерии <> Неопределено
		Или Не ЗначениеЗаполнено(Отчет.РегистрБухгалтерии) Тогда
	    СтруктураПроверки = Неопределено;
	Иначе
		СтруктураПроверки =	Новый Структура("РегистрБухгалтерии", Отчет.РегистрБухгалтерии);	
	КонецЕсли; 
	
	СтруктураДоступности = бит_ОтчетыСервер.ПроверитьДоступностьВариантовНастроек(ЭтаФорма.фКлючОбъекта, Ложь, СтруктураПроверки);
		
	Если ОчищатьПанельНастроек Тогда		
		бит_РаботаСДиалогамиСервер.УдалитьЭлементыГруппыФормы(ЭтаФорма.Элементы, ГруппаПанели); 		
	КонецЕсли; 	
	
	// Обновление панели настроек
	бит_ОтчетыСервер.ОбновитьПанельСохраненныхНастроек(ЭтаФорма.Элементы, 
													ГруппаПанели, 
													ЭтаФорма.фКлючОбъекта, 
													ЭтаФорма.фСтруктураСохраненныхНастроек,
													СтруктураДоступности,
													,
													ЭтаФорма.фИмяЭлемента_ВыбраннаяНастройка);
													
	// Если не указана текущая настройка												
	Если ТекКлючНастройки = Неопределено Тогда												
		
				
		ТекСсылкаНастройки = бит_ОтчетыСервер.НайтиНастройкуПоУмолчаниюДляОбъекта(ЭтаФорма.фКлючОбъекта, Ложь, СтруктураДоступности);
		Если ТекСсылкаНастройки <> Неопределено Тогда
			ТекКлючНастройки = ТекСсылкаНастройки.КлючНастройки;
			ПрименитьНастройкиОтчета(Отчет, ЭтаФорма, ТекСсылкаНастройки, ТекущийРегистрБухгалтерии);
		КонецЕсли;
		
	КонецЕсли;
	
													
	Если ТекКлючНастройки <> Неопределено Тогда
		
		бит_ОтчетыСервер.ВыделитьТекущуюСохраненнуюНастройку(ЭтаФорма.Элементы, 
															ЭтаФорма.фСтруктураСохраненныхНастроек, 
															ЭтаФорма.фИмяЭлемента_ВыбраннаяНастройка,
															,
															ТекКлючНастройки);															
															
	Иначе
		ЭтаФорма.фИмяЭлемента_ВыбраннаяНастройка = "";
		Если ОчищатьНастройки Тогда
			УстановитьЗначенияНастроекОтчетовПоУмолчанию(Отчет, ЭтаФорма, ЭтаФорма.фКэшЗначений.ИмяТипаОбъекта);						
		КонецЕсли;
	КонецЕсли;		
		
КонецПроцедуры // ОбновитьПанельСохраненныхНастроекОтчета()

// Функция обновляет настройки отчета.
// 
// Параметры:
//  Отчет     	 			  - ДанныеФормыСтруктура.
//  ЭтаФорма     			  - УправляемаяФорма.
//  ИмяЭлемента  		 	  - Строка.
//  СоответствиеРезультатов   - Соответствие.
//  ТекущийРегистрБухгалтерии - РегистрБухгалтерииСсылка.* (По умолчанию = Неопределено).
//  ОрганизацияПериметр - Булево (ПоУмолчанию = Ложь).
// 
// ВозращаемоеЗначение:
//  Булево - настройки обновлены.
// 
Функция ОбновитьНастройки(Отчет, ЭтаФорма, ИмяЭлемента, СоответствиеРезультатов, ТекущийРегистрБухгалтерии = Неопределено, ОрганизацияПериметр = Ложь) Экспорт

	НастройкиОбновлены = Ложь;
	
	ЭтаФорма.Результат.Очистить();
	
	СтруктураНастроек = ЭтаФорма.фСтруктураСохраненныхНастроек[ИмяЭлемента]; 	
	Настройки = бит_ОтчетыСервер.ПолучитьНастройкиОтчета(СтруктураНастроек);
	Если Настройки <> Неопределено Тогда
		    		
		КлючНастройки = СтруктураНастроек.КлючНастройки;
		ПрименитьНастройкиОтчета(Отчет, ЭтаФорма, Настройки, ТекущийРегистрБухгалтерии, ОрганизацияПериметр);
		НастройкиОбновлены = Истина;
		
	КонецЕсли;
	
	// Выведем результат, если он уже формировался для текущей настройки.
	Если НастройкиОбновлены Тогда		
		СтруктураРез = СоответствиеРезультатов.Получить(КлючНастройки);
		Если СтруктураРез <> Неопределено Тогда
			ЭтаФорма.Результат.Вывести(СтруктураРез.Результат);
			ЭтаФорма.ДанныеРасшифровки = СтруктураРез.ДанныеРасшифровки;
			бит_ОбщегоНазначенияКлиентСервер.УстановитьСостояниеПоляТабличногоДокумента(ЭтаФорма.Элементы.Результат, "НеИспользовать");
		КонецЕсли; 		
	КонецЕсли;
	
	Возврат НастройкиОбновлены;

КонецФункции // ОбновитьНастройки()

// Процедура устанавливает настройки по умолчанию.
// 
// Параметры:
//  Отчет     	   - ДанныеФормыСтруктура.
//  ЭтаФорма 	   - УправляемаяФорма.
//  ИмяТипаОбъекта - Строка.
// 
Процедура УстановитьЗначенияНастроекОтчетовБюджетированияПоУмолчанию(Отчет, ЭтаФорма, ИмяТипаОбъекта) Экспорт

	// Показатели
	Отчет.ВыводитьСуммуРегл 	= Истина;
	Отчет.ВыводитьСуммуУпр 		= Истина;
	Отчет.ВыводитьСуммуСценарий = Истина;
	
	// Показатели вывода остатков и оборотов счета.
	Если Найти(ИмяТипаОбъекта, "бит_ОборотыСчета") > 0 Тогда
		Отчет.СальдоНачДт 	   = Истина;
		Отчет.СальдоНачКт 	   = Истина;
		Отчет.СальдоКонДт 	   = Истина;
		Отчет.СальдоКонКт 	   = Истина; 
		Отчет.ОборотДт 		   = Истина;
		Отчет.ОборотКт 		   = Истина; 		
		Отчет.ОборотДтКорСчета = Истина;
		Отчет.ОборотКтКорСчета = Истина;
	КонецЕсли;
	
	// Параметры
	Отчет.Период = Новый СтандартныйПериод();
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПериодичность Тогда
		Отчет.Периодичность = "";
	КонецЕсли;
	
	// Виды субконто
	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
		Отчет.Субконто.Очистить();		
	КонецЕсли;
		
	// Таблица отборов
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		
		// Очистка отборов
		ЭтаФорма.ТаблицаОтбор.Очистить();
	              	
		// Отборы по умолчанию
		ДобавитьОтборПоСценарию(ЭтаФорма);	  		 	
		Отчет.Сценарий 			    = Справочники[бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования()].ПустаяСсылка();
		Отчет.СценарийВидСравнения  = ВидСравнения.Равно;
		Отчет.СценарийИспользование = Ложь;
		ДобавитьОтборПоЦФО(ЭтаФорма);
		// Изменение кода. Начало. 08.05.2014{{
		Если бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация() Тогда
			ДобавитьОтборПоОрганизации(ЭтаФорма);
			Отчет.Организация 			    = Справочники.Организации.ПустаяСсылка();
			Отчет.ОрганизацияВидСравнения   = ВидСравнения.Равно;
			Отчет.ОрганизацияИспользование  = Ложь;
		КонецЕсли;
		// Изменение кода. Конец. 08.05.2014}}
		
	КонецЕсли;
	
	Если ЭтаФорма.Элементы.Найти("КорСчетВидСравнения") <> Неопределено Тогда
		// Отчет.КорСчет = Отчет.Счет;
		Отчет.КорСчетВидСравнения  = ВидСравнения.Равно;
		Отчет.КорСчетИспользование = Ложь;
	КонецЕсли;
	
	// Показатели вывода остатков и оборотов счета.
	Если Найти(ИмяТипаОбъекта, "бит_ОборотыМеждуСубконто") > 0 Тогда
		
		Отчет.Сценарий 			    = Справочники[бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования()].ПустаяСсылка();
		Отчет.СценарийВидСравнения  = ВидСравнения.Равно;
		Отчет.СценарийИспользование = Ложь;
		// Изменение кода. Начало. 08.05.2014{{
		Если бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация() Тогда
			Отчет.Организация 			    = Справочники.Организации.ПустаяСсылка();
			Отчет.ОрганизацияВидСравнения   = ВидСравнения.Равно;
			Отчет.ОрганизацияИспользование  = Ложь;
		КонецЕсли;

	Иначе	
		
		ПерезаполнитьПризнакиУчета(Отчет, ЭтаФорма);

		// Текст запроса
		ОтчетОб = ДанныеФормыВЗначение(Отчет, Тип(ИмяТипаОбъекта));
		ОтчетОб.ЗаполнитьНачальныеНастройки();
		ЭтаФорма.фТекстЗапроса = ОтчетОб.ПостроительОтчета.Текст;
		
	КонецЕсли;
	
	// Показывать заголовок
	ЭтаФорма.фПоказыватьЗаголовок = Истина;
	      		      
КонецПроцедуры // УстановитьЗначенияНастроекОтчетовБюджетированияПоУмолчанию()

// Процедура устанавливает настройки по умолчанию.
// 
// Параметры:
//  Отчет     	   - ДанныеФормыСтруктура.
//  ЭтаФорма 	   - УправляемаяФорма.
//  ИмяТипаОбъекта - Строка.
// 
Процедура УстановитьЗначенияНастроекОтчетовУправленческогоУчетаПоУмолчанию(Отчет, ЭтаФорма, ИмяТипаОбъекта) Экспорт

	// Показатели
	Отчет.ВыводитьСуммуРегл 	= Истина;
	Отчет.ВыводитьСуммуУпр 		= Истина;
	Если бит_ОбщегоНазначения.ЕстьОбъектыМСФО() Тогда
		Отчет.ВыводитьСуммуМУ = Ложь;
	КонецЕсли;
	
	// Показатели вывода остатков и оборотов счета.
	Если Найти(ИмяТипаОбъекта, "бит_ОборотыСчета") > 0 Тогда
		Отчет.СальдоНачДт 	   = Истина;
		Отчет.СальдоНачКт 	   = Истина;
		Отчет.СальдоКонДт 	   = Истина;
		Отчет.СальдоКонКт 	   = Истина; 
		Отчет.ОборотДт 		   = Истина;
		Отчет.ОборотКт 		   = Истина; 		
		Отчет.ОборотДтКорСчета = Истина;
		Отчет.ОборотКтКорСчета = Истина;
	КонецЕсли;      		

	// Параметры
	Отчет.Период = Новый СтандартныйПериод();
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПериодичность Тогда
		Отчет.Периодичность = "";
	КонецЕсли;
	
	// Виды субконто
	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
		Отчет.Субконто.Очистить();		
	КонецЕсли;
	
	// Признаки учета
	ПерезаполнитьПризнакиУчета(Отчет, ЭтаФорма);
	
	// Регистр бухгалтерии и данные, связанные с ним.
	Если Не ЗначениеЗаполнено(Отчет.РегистрБухгалтерии) Тогда 		
		// Список выбора регистров бухгалтерии.
		СписокРегистров = бит_УправленческийУчет.СформироватьСписокОбъектовДляВыбора(Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии, "бит_Дополнительный");
		Если Не СписокРегистров.Количество() = 0 Тогда  			
			// Получим регистр бухгалтерии для настройки по умолчанию.
			Отчет.РегистрБухгалтерии = СписокРегистров[0].Значение;		
		КонецЕсли; 		
	КонецЕсли;
	ПерезаполнитьДанныеПоРегиструБухгалтерии(Отчет, ЭтаФорма, ИмяТипаОбъекта);	
	
	// Таблица отборов
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		// Очистка отборов
		ЭтаФорма.ТаблицаОтбор.Очистить();
		// ДобавитьОтборПоВалюте(ЭтаФорма);
		Если ЭтаФорма.Элементы.Найти("ОрганизацияВидСравнения") <> Неопределено Тогда
			ДобавитьОтборПоОрганизации(ЭтаФорма, , Истина);
		КонецЕсли;
	КонецЕсли;
	
	Если ЭтаФорма.Элементы.Найти("ОрганизацияВидСравнения") <> Неопределено Тогда
		Отчет.Организация 			   = Справочники.Организации.ПустаяСсылка();
		Отчет.ОрганизацияВидСравнения  = ВидСравнения.Равно;
		Отчет.ОрганизацияИспользование = Ложь;
	КонецЕсли;
	
	Если ЭтаФорма.Элементы.Найти("КорСчетВидСравнения") <> Неопределено Тогда
		// Отчет.КорСчет = Отчет.Счет;
		Отчет.КорСчетВидСравнения  = ВидСравнения.Равно;
		Отчет.КорСчетИспользование = Ложь;
	КонецЕсли;

	// Текст запроса
	ОтчетОб = ДанныеФормыВЗначение(Отчет, Тип(ИмяТипаОбъекта));
	ОтчетОб.РегистрБухгалтерии = Отчет.РегистрБухгалтерии;
	ОтчетОб.ЗаполнитьНачальныеНастройки();
	ЭтаФорма.фТекстЗапроса = ОтчетОб.ПостроительОтчета.Текст;

	// Показывать заголовок
	ЭтаФорма.фПоказыватьЗаголовок = Истина;
	
КонецПроцедуры // УстановитьЗначенияНастроекОтчетовУправленческогоУчетаПоУмолчанию()

// Процедура устанавливает настройки по умолчанию.
// 
// Параметры:
//  Отчет     	   - ДанныеФормыСтруктура.
//  ЭтаФорма 	   - УправляемаяФорма.
//  ИмяТипаОбъекта - Строка.
// 
Процедура УстановитьЗначенияНастроекОтчетовПоУмолчанию(Отчет, ЭтаФорма, ИмяТипаОбъекта) Экспорт
	
	Если ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда
		
		УстановитьЗначенияНастроекОтчетовБюджетированияПоУмолчанию(Отчет, ЭтаФорма, ИмяТипаОбъекта);
		
	Иначе
		
		УстановитьЗначенияНастроекОтчетовУправленческогоУчетаПоУмолчанию(Отчет, ЭтаФорма, ИмяТипаОбъекта);
		
	КонецЕсли;
	      		      
КонецПроцедуры // УстановитьЗначенияНастроекОтчетовПоУмолчанию()

// синхронизирует данные отчет по данным формы.
// 
// Параметры:
//  Отчет    - ДанныеФормыСтруктура.
//  ОтчетОб  - Объект.
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура СинхронизироватьДанныеОтчета(Отчет, ОтчетОб, ЭтаФорма) Экспорт 
	
	// Основные реквизиты
	ЗаполнитьЗначенияСвойств(ОтчетОб, Отчет);
	
	// Виды субконто
	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
		ОтчетОб.Субконто.Загрузить(Отчет.Субконто.Выгрузить());
	КонецЕсли;
	
	// По валютам
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПоВалютам Тогда
		ОтчетОб.ЕстьВалюта = ЭтаФорма.Элементы.ПоВалютам.Доступность;
	КонецЕсли;
	// По количеству
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПоКоличеству Тогда
		ОтчетОб.ЕстьКоличество = ЭтаФорма.Элементы.ПоКоличеству.Доступность;
	КонецЕсли;
	
	ОтчетОб.ЗаполнитьНачальныеНастройки();
		
	// Отборы
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		// Таблица отборов
		СинхронизироватьОтборыПостроителяПоТаблицеНаФорме(ОтчетОб, ЭтаФорма.ТаблицаОтбор);
	КонецЕсли;
	
	// Таблица сортировки
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаСортировки Тогда
		СинхронизироватьСортировкуПостроителяПоТаблицеНаФорме(ОтчетОб, ЭтаФорма.ТаблицаСортировки);	
	КонецЕсли;	
	
	// Детализация счета
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаДетализацииСчета Тогда
		СинхронизироватьДетализацииСчетаПоТаблицеНаФорме(ОтчетОб, ЭтаФорма.ДетализацияСчета);
	КонецЕсли; 
	
	// Правила вывода итогов
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаВыводаИтогов Тогда 
		СинхронизироватьТаблицуПравилПоТаблицеНаФорме(ОтчетОб.ПравилаВыводаИтогов, ЭтаФорма.ПравилаВыводаИтогов);
	КонецЕсли;
	
	// Правила развернутого сальдо
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаРазвернутогоСальдо Тогда 
		СинхронизироватьТаблицуПравилПоТаблицеНаФорме(ОтчетОб.ПравилаРазвернутогоСальдо, ЭтаФорма.ПравилаРазвернутогоСальдо);
	КонецЕсли; 	
	
	// Корреспонденции
	Если ЭтаФорма.фКэшЗначений.ЕстьРкКорреспонденции Тогда 
		СинхронизироватьКорреспонденцииПоТаблицеНаФорме(ОтчетОб, ЭтаФорма.Корреспонденции);
	КонецЕсли;
	
	// Таблица кор. субконто
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаКорСубконто Тогда
		СинхронизироватьТаблицуКорСубконто(ОтчетОб.ТаблицаКорСубконто, ЭтаФорма.ТаблицаКорСубконто);
	КонецЕсли;
	
	// Таблица группировки
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаГруппировки Тогда
		СинхронизироватьТаблицаГруппировки(ОтчетОб.ТаблицаГруппировки, ЭтаФорма.ТаблицаГруппировки);
	КонецЕсли;
	                                		
КонецПроцедуры // СинхронизироватьДанныеОтчета()

// Функция Возвращает структуру параметров отчета для сохранения.
// 
// Параметры:
//  ОтчетОбъект          - ОтчетОбъект.
//  ИсключаемыеРеквизиты - Структура, реквизиты значения которых не надо сохранять,
//                        по умолчанию Неопределено.
// 
// Возвращаемое значение:
//  СтруктураНастроек - Структура.
// 
Функция ПолучитьСтруктуруПараметровДляСохранения(ОтчетОбъект, ИсключаемыеРеквизиты = Неопределено) Экспорт
    
    МетеданныеОбъекта = ОтчетОбъект.Метаданные();
    
    СтруктураНастроек = Новый Структура;
    РеквизитыОбъекта  = МетеданныеОбъекта.Реквизиты;
    ТабЧастиОбъекта   = МетеданныеОбъекта.ТабличныеЧасти;
    
    Если ИсключаемыеРеквизиты = Неопределено Тогда
        ИсключаемыеРеквизиты = Новый Структура;
    КонецЕсли;
    
	Для каждого Реквизит Из РеквизитыОбъекта Цикл
		Если ИсключаемыеРеквизиты.Свойство(Реквизит.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		СтруктураНастроек.Вставить(Реквизит.Имя, ОтчетОбъект[Реквизит.Имя])
	КонецЦикла;
    
    Для каждого ТабЧасть Из ТабЧастиОбъекта Цикл
		Если ИсключаемыеРеквизиты.Свойство(ТабЧасть.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		СтруктураНастроек.Вставить(ТабЧасть.Имя, ОтчетОбъект[ТабЧасть.Имя].Выгрузить())
	КонецЦикла;
    
    // Если есть построитель отчета, тогда сохраним настройки построителя.
    Если Не ОтчетОбъект.Метаданные().Реквизиты.Найти("ПостроительОтчета") = Неопределено Тогда
        СтруктураНастроек.Вставить("ТекстПостроителяОтчета", ОтчетОбъект.ПостроительОтчета.Текст);
        СтруктураНастроек.Вставить("НастройкиПостроителя"  , ОтчетОбъект.ПостроительОтчета.ПолучитьНастройки(Истина, Истина, Истина, Истина));
    КонецЕсли;
    
    Возврат СтруктураНастроек;
    
КонецФункции // ПолучитьСтруктуруПараметровДляСохранения()

// Функция создает структуру, хранящую настройки.
// 
// Параметры:
//  Отчет    - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
// 
Функция УпаковатьНастройкиОтчетаВСтруктуру(Отчет, ЭтаФорма) Экспорт

	СтруктураНастроек = Новый Структура;
	Для каждого Реквизит Из Метаданные.Отчеты[СтрЗаменить(ЭтаФорма.фПолноеИмяОтчета, "Отчет.", "")].Реквизиты Цикл
		ИмяРеквизита = Реквизит.Имя;
		Если ИмяРеквизита = "ПостроительОтчета" 
			ИЛИ ИмяРеквизита = "ПравилаВыводаИтогов"
			ИЛИ ИмяРеквизита = "ПравилаРазвернутогоСальдо" Тогда
			Продолжить;
		КонецЕсли;  		
		СтруктураНастроек.Вставить(ИмяРеквизита, Отчет[ИмяРеквизита]);	
	КонецЦикла; 
	
	// Сохранение настроек построителя
	ОтчетОб = ДанныеФормыВЗначение(Отчет, Тип(ЭтаФорма.фКэшЗначений.ИмяТипаОбъекта));
	СинхронизироватьДанныеОтчета(Отчет, ОтчетОб, ЭтаФорма);
	
	Если Метаданные.Отчеты.Найти("бит_ОборотыМеждуСубконто_Бюджетирование") <> Неопределено
		И ТипЗнч(ОтчетОб) = Тип("ОтчетОбъект.бит_ОборотыМеждуСубконто_Бюджетирование") Тогда
		
		СтруктураНастроек.Вставить("фТекстЗапроса", ЭтаФорма.фТекстЗапроса);
		СтруктураНастроек.Вставить("СхемаКомпоновки", ЭтаФорма.СхемаКомпоновкиДанных);

		ТаблицаСубконто = ЭтаФорма.ГруппировкиСубконто.Выгрузить();
		СтруктураНастроек.Вставить("ТаблицаСубконто", бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ТаблицаСубконто));
		
		СтруктураНастроек.Вставить("НастройкиКомпоновщика", Отчет.КомпоновщикНастроек.Настройки);
		
	    СтруктураНастроек.Вставить("Организация",              ОтчетОб.Организация);
		СтруктураНастроек.Вставить("ОрганизацияВидСравнения",  ОтчетОб.ОрганизацияВидСравнения);
		СтруктураНастроек.Вставить("ОрганизацияИспользование", ОтчетОб.ОрганизацияИспользование);

		СтруктураНастроек.Вставить("Сценарий",              ОтчетОб.Сценарий);
		СтруктураНастроек.Вставить("СценарийВидСравнения",  ОтчетОб.СценарийВидСравнения);
		СтруктураНастроек.Вставить("СценарийИспользование", ОтчетОб.СценарийИспользование);
		
		ТаблицаКорСубконто = Отчет.КорСубконто.Выгрузить();

		СтруктураНастроек.Вставить("КорСубконто", бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ТаблицаКорСубконто));
		
	Иначе

		НастройкиПостроителя = Новый ХранилищеЗначения(ОтчетОб.ПостроительОтчета.ПолучитьНастройки(Истина, Истина, Истина, Истина));
		СтруктураНастроек.Вставить("НастройкиПостроителя", НастройкиПостроителя);
		
	КонецЕсли;
	
	// Табличная часть "Субконто"
	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
		ТаблицаСубконто = Отчет.Субконто.Выгрузить();
		СтруктураНастроек.Вставить("Субконто", бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ТаблицаСубконто));	
	КонецЕсли;
	
	// Правила вывода итогов
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаВыводаИтогов Тогда
		СтруктураНастроек.Вставить("ПравилаВыводаИтогов"
				, бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ОтчетОб.ПравилаВыводаИтогов));	
	КонецЕсли;
	
	// Правила развернутого сальдо
	Если ЭтаФорма.фКэшЗначений.ЕстьРкПравилаРазвернутогоСальдо Тогда
		СтруктураНастроек.Вставить("ПравилаРазвернутогоСальдо"
				, бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ОтчетОб.ПравилаРазвернутогоСальдо));	
	КонецЕсли;
			
	// Корреспонденции
	Если ЭтаФорма.фКэшЗначений.ЕстьРкКорреспонденции Тогда
		СтруктураНастроек.Вставить("Корреспонденции"
				, бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ОтчетОб.Корреспонденции));	
	КонецЕсли;
			
	// Таблица кор субконто
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаКорСубконто Тогда
		СтруктураНастроек.Вставить("ТаблицаКорСубконто"
				, бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ОтчетОб.ТаблицаКорСубконто));	
	КонецЕсли;
			
	// Таблица группировки
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаГруппировки Тогда
		СтруктураНастроек.Вставить("ТаблицаГруппировки"
				, бит_ОбщегоНазначения.УпаковатьТаблицуЗначений(ОтчетОб.ТаблицаГруппировки));	
	КонецЕсли;		
			
	Возврат СтруктураНастроек;
	
КонецФункции // УпаковатьНастройкиОтчетаВСтруктуру()

// Процедура сохраняет настройки формы.
// 
// Параметры:
//  СохраненнаяНастройка - СправочникСсылка.СохраненныеНастройки - сохраняемая настройка.
//  СтруктураНастроек    - Структура - параметры настройки формы.
// 
Процедура СохранитьНастройкуОбъекта(СохраненнаяНастройка, СтруктураНастроек) Экспорт

	ОбъектСохраненнаяНастройка = СохраненнаяНастройка.ПолучитьОбъект();
	
	Если СохраненнаяНастройка.Предопределенный Тогда
		СтруктураНастроек.Вставить("Изменялась", Истина);
	КонецЕсли;
	
	ОбъектСохраненнаяНастройка.ХранилищеНастроек = Новый ХранилищеЗначения(СтруктураНастроек);
	
	Попытка
		ОбъектСохраненнаяНастройка.Записать();
	Исключение
		ТекстСообщения = Нстр("ru = 'Настройка формы не записана: '") + Символы.ПС + "- " + ОписаниеОшибки();
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
	КонецПопытки;
	
КонецПроцедуры // СохранитьНастройкуОбъекта()

// Процедура применяет сохраненную настройку отчета.
// 
// Параметры:
//  ОтчетОбъект 				- ОтчетОбъект.
//  ЗаполнитьНачальныеНастройки - Булево (По умолчанию = Ложь).
//  ЗаполнитьТабЧасти           - Булево (По умолчанию = Ложь).
//  ЭтоБюджетирование			- Булево (По умолчанию = Ложь).
// 
Процедура ПрименитьСохраненнуюНастройку(ОтчетОбъект, ЗаполнитьНачальныеНастройки = Ложь, ЗаполнитьТабЧасти = Ложь, ЭтоБюджетирование = Ложь) Экспорт
	
	СохраненнаяНастройка = ОтчетОбъект.СохраненнаяНастройка;
	Если ТипЗнч(СохраненнаяНастройка) = Тип("Структура") Тогда
		СтруктураПараметров = СохраненнаяНастройка;
	Иначе	
		Если ОтчетОбъект.СохраненнаяНастройка = Неопределено 
		ИЛИ ОтчетОбъект.СохраненнаяНастройка.Пустая() Тогда
	        // Применять нечего.
			Возврат;
		КонецЕсли;
		СтруктураПараметров = ОтчетОбъект.СохраненнаяНастройка.ХранилищеНастроек.Получить();
		Если СтруктураПараметров = Неопределено Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли; 
	
	ЗаполнитьЗначенияСвойств(ОтчетОбъект, СтруктураПараметров);
	
	Если ОтчетОбъект.Метаданные().Реквизиты.Найти("Периодичность") <> Неопределено И Не СтруктураПараметров.Свойство("Периодичность") 
		И СтруктураПараметров.Свойство("Период") И ТипЗнч(СтруктураПараметров.Период) = Тип("Строка") Тогда
	 	ОтчетОбъект.Периодичность = СтруктураПараметров.Период;
	КонецЕсли;
	
	Если СтруктураПараметров.Свойство("ДатаНач") И СтруктураПараметров.Свойство("ДатаКон")
		И ОтчетОбъект.Метаданные().Реквизиты.Найти("Период") <> Неопределено 
		И ТипЗнч(ОтчетОбъект.Период) = Тип("СтандартныйПериод") Тогда
		ОтчетОбъект.Период = Новый СтандартныйПериод(СтруктураПараметров.ДатаНач, СтруктураПараметров.ДатаКон);	
	КонецЕсли;
	
	Если СтруктураПараметров.Свойство("ПравилаВыводаИтогов") 
		И ТипЗнч(СтруктураПараметров.ПравилаВыводаИтогов) = Тип("ХранилищеЗначения") Тогда 
		ОтчетОбъект.ПравилаВыводаИтогов = СтруктураПараметров.ПравилаВыводаИтогов.Получить(); 
	КонецЕсли;
	
	Если СтруктураПараметров.Свойство("ПравилаРазвернутогоСальдо") 
		И ТипЗнч(СтруктураПараметров.ПравилаРазвернутогоСальдо) = Тип("ХранилищеЗначения") Тогда 
		ОтчетОбъект.ПравилаРазвернутогоСальдо = СтруктураПараметров.ПравилаРазвернутогоСальдо.Получить(); 
	КонецЕсли;
	
	Если СтруктураПараметров.Свойство("Корреспонденции") 
		И ТипЗнч(СтруктураПараметров.Корреспонденции) = Тип("ХранилищеЗначения") Тогда 
		ОтчетОбъект.Корреспонденции = СтруктураПараметров.Корреспонденции.Получить(); 
	КонецЕсли;
	
	// Таблица кор субконто
	Если СтруктураПараметров.Свойство("ТаблицаКорСубконто") 
		И ТипЗнч(СтруктураПараметров.ТаблицаКорСубконто) = Тип("ХранилищеЗначения") Тогда 
		ОтчетОбъект.ТаблицаКорСубконто = СтруктураПараметров.ТаблицаКорСубконто.Получить();
	ИначеЕсли ОтчетОбъект.Метаданные().Реквизиты.Найти("ТаблицаКорСубконто") <> Неопределено Тогда
		ОтчетОбъект.ТаблицаКорСубконто.Очистить();
	КонецЕсли;	
	
	// Таблица группировки
	Если ОтчетОбъект.Метаданные().Реквизиты.Найти("ТаблицаГруппировки") <> Неопределено Тогда
		ОтчетОбъект.ТаблицаГруппировки.Очистить();
		Если СтруктураПараметров.Свойство("ТаблицаГруппировки")  
			И ТипЗнч(СтруктураПараметров.ТаблицаГруппировки) = Тип("ХранилищеЗначения") Тогда 
				ОтчетОбъект.ТаблицаГруппировки = СтруктураПараметров.ТаблицаГруппировки.Получить();	
		КонецЕсли;
	КонецЕсли;
           	
	Если СтруктураПараметров.Свойство("РегистрБухгалтерии") Тогда
		
		ОтчетОбъект.ИмяРегистраБухгалтерии = СтруктураПараметров.РегистрБухгалтерии.ИмяОбъекта;
		
		Если Не ОтчетОбъект.Метаданные().Реквизиты.Найти("ВыводитьСуммуМУ") = Неопределено Тогда
			
			// Проверим наличие ресурса с именем "СуммаМУ".
			ОтчетОбъект.мЕстьРесурсСуммаМУ = бит_ОбщегоНазначения.ЕстьРесурсСуммаМУРегистраБухгалтерии(ОтчетОбъект.ИмяРегистраБухгалтерии);
			
			Если Не СтруктураПараметров.Свойство("ВыводитьСуммуМУ") 
				И ОтчетОбъект.ВыводитьСуммуМУ Тогда
				
				ОтчетОбъект.ВыводитьСуммуМУ = Ложь;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
    Если ЗаполнитьТабЧасти Тогда
        
        МетеданныеОбъекта = ОтчетОбъект.Метаданные();
        ТабЧастиОбъекта   = МетеданныеОбъекта.ТабличныеЧасти;
        
        Для каждого ТабЧасть Из ТабЧастиОбъекта Цикл
			
			Если Не СтруктураПараметров.Свойство(ТабЧасть.Имя) Тогда
                Продолжить;
            КонецЕсли; 
			
			ОтчетОбъект[ТабЧасть.Имя].Очистить();
			
			Попытка
				ОтчетОбъект[ТабЧасть.Имя].Загрузить(СтруктураПараметров[ТабЧасть.Имя]);
			Исключение	
				ТаблицаСохр = СтруктураПараметров[ТабЧасть.Имя].Получить();
				Для каждого СтрТабл Из ТаблицаСохр Цикл
					НоваяСтрТч = ОтчетОбъект[ТабЧасть.Имя].Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрТч, СтрТабл);			
				КонецЦикла; 				
			КонецПопытки;
			
        КонецЦикла;
        
    КонецЕсли;
    
    Если ЗаполнитьНачальныеНастройки Тогда
        
        // После установки параметров можно заполнять текст построителя.
        ОтчетОбъект.ЗаполнитьНачальныеНастройки();
        
        НастройкиПостроителя = Неопределено;
        СтруктураПараметров.Свойство("НастройкиПостроителя", НастройкиПостроителя);
		Если Метаданные.Отчеты.Найти("бит_ОборотыМеждуСубконто_Бюджетирование") <> Неопределено
			И ТипЗнч(ОтчетОбъект) <> Тип("ОтчетОбъект.бит_ОборотыМеждуСубконто_Бюджетирование") Тогда
			Если НастройкиПостроителя <> Неопределено Тогда
				Попытка
					ОтчетОбъект.ПостроительОтчета.УстановитьНастройки(НастройкиПостроителя, Истина, Истина, Истина, Истина);
				Исключение
					ОтчетОбъект.ПостроительОтчета.УстановитьНастройки(НастройкиПостроителя.Получить(), Истина, Истина, Истина, Истина);
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
        
    КонецЕсли;
    
    Если СтруктураПараметров.Свойство("НастройкиПостроителя") Тогда
        
		Если ПустаяСтрока(ОтчетОбъект.ПостроительОтчета.Текст) 
		    И СтруктураПараметров.Свойство("ТекстПостроителяОтчета")
		    И Не ПустаяСтрока(СтруктураПараметров.ТекстПостроителяОтчета) Тогда
		    // Попробуем вытащить текст построителя из структуры паремтров.
		    СтруктураПараметров.Свойство("ТекстПостроителяОтчета", ОтчетОбъект.ПостроительОтчета.Текст);
		КонецЕсли;
        
  		Попытка
			ОтчетОбъект.ПостроительОтчета.УстановитьНастройки(СтруктураПараметров.НастройкиПостроителя, Истина, Истина, Истина, Истина);
		Исключение
			ОтчетОбъект.ПостроительОтчета.УстановитьНастройки(СтруктураПараметров.НастройкиПостроителя.Получить(), Истина, Истина, Истина, Истина);
		КонецПопытки;
		
	КонецЕсли;
	
	Если Метаданные.Отчеты.Найти("бит_ОборотыМеждуСубконто_Бюджетирование") <> Неопределено
		И ТипЗнч(ОтчетОбъект) = Тип("ОтчетОбъект.бит_ОборотыМеждуСубконто_Бюджетирование") Тогда
		
        ОтчетОбъект.КомпоновщикНастроек.ЗагрузитьНастройки(СтруктураПараметров.НастройкиКомпоновщика);
		
		ВидДляСписка  = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(СтруктураПараметров.СценарийВидСравнения);

		Если Не ЗначениеЗаполнено(СтруктураПараметров.Сценарий) Тогда
			Если ВидДляСписка Тогда
				Список             = Новый СписокЗначений;
				Список.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.СценарииПланирования");
				ОтчетОбъект.Сценарий = Список;
			Иначе
			    ОтчетОбъект.Сценарий = Справочники.СценарииПланирования.ПустаяСсылка();
			КонецЕсли;			
		КонецЕсли;
		
		ОтчетОбъект.СценарийВидСравнения  = СтруктураПараметров.СценарийВидСравнения;
		ОтчетОбъект.СценарийИспользование = СтруктураПараметров.СценарийИспользование;	
		
		// Изменение кода. Начало. 07.05.2014{{
		Если бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация() Тогда
			
			ВидДляСписка  = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(СтруктураПараметров.ОрганизацияВидСравнения);

			Если Не ЗначениеЗаполнено(СтруктураПараметров.Организация) Тогда
				Если ВидДляСписка Тогда
					Список             = Новый СписокЗначений;
					Список.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.Организации");
					ОтчетОбъект.Организация = Список;
				Иначе
				    ОтчетОбъект.Организация = Справочники.Организации.ПустаяСсылка();
				КонецЕсли;			
			КонецЕсли;

			ОтчетОбъект.ОрганизацияВидСравнения   = СтруктураПараметров.ОрганизацияВидСравнения;
			ОтчетОбъект.ОрганизацияИспользование  = СтруктураПараметров.ОрганизацияИспользование ;
			
		КонецЕсли;
			
	Иначе

		Если ЭтоБюджетирование Тогда
			
			// Сценарий
			ОтборПоСценарию = ОтчетОбъект.ПостроительОтчета.Отбор.Найти("Сценарий");
			Если ОтборПоСценарию = Неопределено Тогда
				
				Если ОтчетОбъект.ПостроительОтчета.ДоступныеПоля.Найти("Сценарий") = Неопределено Тогда
					ОтчетОбъект.ЗаполнитьНачальныеНастройки();
				КонецЕсли;
				
				ОтборПоСценарию = ОтчетОбъект.ПостроительОтчета.Отбор.Добавить("Сценарий");
				ОтборПоСценарию.ВидСравнения  = ВидСравнения.Равно;
				ОтборПоСценарию.Значение      = ОтчетОбъект.Сценарий;
				ОтборПоСценарию.Использование = ЗначениеЗаполнено(ОтчетОбъект.Сценарий);
				
				ОписаниеТиповСценарий = Новый ОписаниеТипов("СправочникСсылка." + бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования());
				Попытка
					ОтборПоСценарию.ТипЗначения = ОписаниеТиповСценарий;			
				Исключение                                              			
				КонецПопытки;
				                                                        			
			КонецЕсли;  
			
			ОтчетОбъект.Сценарий 			  = ОтборПоСценарию.Значение;
			ОтчетОбъект.СценарийВидСравнения  = ОтборПоСценарию.ВидСравнения;
			ОтчетОбъект.СценарийИспользование = ОтборПоСценарию.Использование;	
				
			// Организация
			Если  бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация()Тогда
				
				// Изменение кода. Начало. 07.05.2014{{
					
				ОтборПоОрганизации = ОтчетОбъект.ПостроительОтчета.Отбор.Найти("Организация");
				Если ОтборПоОрганизации = Неопределено Тогда
					
					Если ОтчетОбъект.ПостроительОтчета.ДоступныеПоля.Найти("Организация") = Неопределено Тогда
						ОтчетОбъект.ЗаполнитьНачальныеНастройки();
					КонецЕсли;
					
					ОтборПоОрганизации = ОтчетОбъект.ПостроительОтчета.Отбор.Добавить("Организация");
					ОтборПоОрганизации.ВидСравнения  = ВидСравнения.Равно;
					ОтборПоОрганизации.Значение      = ?(ЗначениеЗаполнено(ОтчетОбъект.Организация),ОтчетОбъект.Организация, Справочники.Организации.ПустаяСсылка());
					ОтборПоОрганизации.Использование = ЗначениеЗаполнено(ОтчетОбъект.Организация);
					
					МассивТипов = Новый Массив;
					МассивТипов.Добавить(Тип("СправочникСсылка.Организации"));
					ОписаниеТиповОрганизация = Новый ОписаниеТипов(МассивТипов);
					Попытка
						ОтборПоОрганизации.ТипЗначения = ОписаниеТиповОрганизация;			
					Исключение                                              			
					КонецПопытки;
																						
				КонецЕсли;  
				
				ОтчетОбъект.Организация 			  = ОтборПоОрганизации.Значение;
				ОтчетОбъект.ОрганизацияВидСравнения   = ОтборПоОрганизации.ВидСравнения;
				ОтчетОбъект.ОрганизацияИспользование  = ОтборПоОрганизации.Использование;
				
			Иначе
				
				ОтчетОбъект.ОрганизацияИспользование  =  Ложь;
				
			КонецЕсли;
			// Изменение кода. Конец. 07.05.2014}}
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ПрименитьСохраненнуюНастройку()

// Процедура устанавливает заголовок поля организации.
// 
// Параметры:
//  Нет.
// 
Процедура УстановитьЗаголовокПоляОрганизации(ЭлементОрганизация, Отчет) Экспорт
	
	ЭлементОрганизация.Заголовок = ?(Отчет.Организация = Неопределено 
									 ИЛИ ТипЗнч(Отчет.Организация) = Тип("СправочникСсылка.Организации")
									 ИЛИ ТипЗнч(Отчет.Организация) = Тип("СписокЗначений")
												, "Организация"
												, "Периметр");
		
КонецПроцедуры // УстановитьЗаголовокПоляОрганизации()

// Процедура синхронизирует форму с настройками отчета.
// 
// Параметры:
//  Отчет    	 		- ДанныеФормыСтруктура.
//  ЭтаФорма 	 		- УправляемаяФорма.
//  ВыбНастройка 		- Справочникссылка.бит_СохраненныеНастройки.
//  ОрганизацияПериметр - Булево (ПоУмолчанию = Ложь).
// 
Процедура ПрименитьНастройкиОтчета(Отчет, ЭтаФорма, ВыбНастройка, ТекущийРегистрБухгалтерии = Неопределено, ОрганизацияПериметр = Ложь) Экспорт

	КэшЗначений = ЭтаФорма.фКэшЗначений;
	ЭтаФорма.Результат.Очистить();
	
	// ----------------------------------------------------------------------
	// Загрузка данных из настройки
	ОтчетОб = ДанныеФормыВЗначение(Отчет, Тип(КэшЗначений.ИмяТипаОбъекта));
	ОтчетОб.СохраненнаяНастройка = ВыбНастройка;
	ОтчетОб.ПрименитьНастройку();
	
	СтруктураПараметров = ?(ТипЗнч(ВыбНастройка) = Тип("Структура"), ВыбНастройка, ВыбНастройка.ХранилищеНастроек.Получить());
	
	Если Метаданные.Отчеты.Найти("бит_ОборотыМеждуСубконто_Бюджетирование") <> Неопределено
		И ТипЗнч(ОтчетОб) = Тип("ОтчетОбъект.бит_ОборотыМеждуСубконто_Бюджетирование") Тогда
		                           				
		ЭтаФорма.СхемаКомпоновкиДанных = СтруктураПараметров.СхемаКомпоновки;
		ЭтаФорма.ГруппировкиСубконто.Загрузить(бит_ОбщегоНазначения.РаспаковатьТаблицуЗначений(СтруктураПараметров.ТаблицаСубконто));
		ОтчетОб.ИнициализироватьКомпоновщик(СтруктураПараметров.фТекстЗапроса, ЭтаФорма);
		ЗначениеВДанныеФормы(ОтчетОб, Отчет);
		
	Иначе 
		
		ЗначениеВДанныеФормы(ОтчетОб, Отчет);
		
		бит_ОбщегоНазначенияКлиентСервер.УстановитьСостояниеПоляТабличногоДокумента(ЭтаФорма.Элементы.Результат, "НеАктуальностьОтчета");
		
		// ----------------------------------------------------------------------
		// Текст запроса
		ЭтаФорма.фТекстЗапроса = ОтчетОб.ПостроительОтчета.Текст;
		
		// ----------------------------------------------------------------------
		// МассивСубконто
		Если ОтчетОб.ПостроительОтчета.Параметры.Свойство("МассивСубконто") Тогда
			КэшЗначений.Вставить("МассивСубконто", ОтчетОб.ПостроительОтчета.Параметры.МассивСубконто);
		КонецЕсли;
		
		// ----------------------------------------------------------------------
		// Регистр бухгалтерии
		Если Не КэшЗначений.ЭтоБюджетирование Тогда 		
			УстановитьЗаголовокПоляОрганизации(ЭтаФорма.Элементы.Организация, Отчет); 		
			Если Отчет.РегистрБухгалтерии <> ТекущийРегистрБухгалтерии Тогда		
				ПерезаполнитьДанныеПоРегиструБухгалтерии(Отчет, ЭтаФорма, КэшЗначений.ИмяТипаОбъекта);
				ТекущийРегистрБухгалтерии = Отчет.РегистрБухгалтерии; 			
			КонецЕсли;  		
		КонецЕсли;
		
		// ----------------------------------------------------------------------
		// Счет
		Если КэшЗначений.ЕстьРкСчет Тогда  		
			ПерезаполнитьДанныеФормыПоСубконто(Отчет, ЭтаФорма, , Ложь, , Истина);
		КонецЕсли;
		
		// ----------------------------------------------------------------------
		// ПризнакиУчета
		ПерезаполнитьПризнакиУчета(Отчет, ЭтаФорма, Ложь);
			
		// ----------------------------------------------------------------------
		// Таблица отборов
		Если КэшЗначений.ЕстьТаблицаОтборов Тогда
			ЭтаФорма.ТаблицаОтбор.Очистить();
			Для каждого ЭлементОтбораПостроителя Из ОтчетОб.ПостроительОтчета.Отбор Цикл
				СтрокаТаблицыОтбора = ЭтаФорма.ТаблицаОтбор.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаТаблицыОтбора, ЭлементОтбораПостроителя);	
			КонецЦикла;   		
		КонецЕсли;
		
				   		
		// ----------------------------------------------------------------------
		// Детализация счета
		Если КэшЗначений.ЕстьТаблицаДетализацииСчета Тогда
			
			ЭтаФорма.ДетализацияСчета.Очистить();
			Для каждого ЭлементДетализацииСчета Из ОтчетОб.ПостроительОтчета.ИзмеренияСтроки Цикл
				СтрокаДетализацииСчета = ЭтаФорма.ДетализацияСчета.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаДетализацииСчета, ЭлементДетализацииСчета);
				СтрокаТипаИзмерения = СтрЗаменить(Трег(ЭлементДетализацииСчета.ТипИзмерения), " ", "");
				СтрокаДетализацииСчета.ТипИзмерения = ТипГруппировкиКомпоновкиДанных[СтрокаТипаИзмерения];
			КонецЦикла;
			
		КонецЕсли;
		
		// ----------------------------------------------------------------------
		// Таблица группировки	
		Если КэшЗначений.ЕстьТаблицаГруппировки Тогда
			
			ЭтаФорма.ТаблицаГруппировки.Очистить();
			
			Если СтруктураПараметров.Свойство("ТаблицаГруппировки") Тогда
				Для каждого ЭлементТб Из ОтчетОб.ТаблицаГруппировки Цикл
					СтрокаТабл = ЭтаФорма.ТаблицаГруппировки.Добавить();	
					ЗаполнитьЗначенияСвойств(СтрокаТабл, ЭлементТб);
				КонецЦикла;
			ИначеЕсли Отчет.Свойство("Субконто") Тогда
				КолонкиТз = ДанныеФормыВЗначение(ЭтаФорма.ТаблицаГруппировки, Тип("ТаблицаЗначений")).Колонки;
				Для каждого Эл Из ОтчетОб.Субконто Цикл
					СтрокаТабл = ЭтаФорма.ТаблицаГруппировки.Добавить();
					СтрокаТабл.Имя = "Субконто" + Строка(Эл.НомерСтроки);
					СтрокаТабл.Представление = Эл.ВидСубконто.Наименование;
					Если КолонкиТз.Найти("Использование") <> Неопределено Тогда
						СтрокаТабл.Использование = Истина;
					ИначеЕсли КолонкиТз.Найти("ПутьКДанным") <> Неопределено Тогда	
					 	СтрокаТабл.ПутьКДанным  = СтрокаТабл.Имя;
						СтрокаТабл.ТипИзмерения = ТипИзмеренияПостроителяОтчета.Элементы;
					КонецЕсли;
				КонецЦикла;  	
			КонецЕсли;
					
		КонецЕсли;
		
		// ----------------------------------------------------------------------
		// Сортировка
		Если КэшЗначений.ЕстьТаблицаСортировки Тогда
			
			ЭтаФорма.ТаблицаСортировки.Очистить();
			Для каждого ЭлементСортировкиПостроителя Из ОтчетОб.ПостроительОтчета.Порядок Цикл
				СтрокаТаблицыСортировки = ЭтаФорма.ТаблицаСортировки.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаТаблицыСортировки, ЭлементСортировкиПостроителя);
				Если ЭлементСортировкиПостроителя.Направление = НаправлениеСортировки.Возр Тогда
					СтрокаТаблицыСортировки.Направление = НаправлениеСортировкиКомпоновкиДанных.Возр;
				ИначеЕсли ЭлементСортировкиПостроителя.Направление = НаправлениеСортировки.Убыв	Тогда
					СтрокаТаблицыСортировки.Направление = НаправлениеСортировкиКомпоновкиДанных.Убыв;
				КонецЕсли;
			КонецЦикла;
		
		КонецЕсли;
			
		// ----------------------------------------------------------------------
		// Таблица развернутого сальдо
		Если КэшЗначений.ЕстьРкПравилаРазвернутогоСальдо Тогда
			
			ЭтаФорма.ПравилаРазвернутогоСальдо.Очистить();
			Для каждого ЭлементПравил Из ОтчетОб.ПравилаРазвернутогоСальдо Цикл
				СтрокаПравил = ЭтаФорма.ПравилаРазвернутогоСальдо.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаПравил, ЭлементПравил, , "РазворотПоСубконто");			
				Для каждого СтрокаРазворотаИзНастройки Из ЭлементПравил.РазворотПоСубконто Цикл
					СтрокаРазворота = СтрокаПравил.РазворотПоСубконто.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаРазворота, СтрокаРазворотаИзНастройки);			
				КонецЦикла;
			КонецЦикла;
			
		КонецЕсли;	
		
		// ----------------------------------------------------------------------
		// Корреспонденции 	
		Если КэшЗначений.ЕстьРкКорреспонденции Тогда
			
			ЭтаФорма.Корреспонденции.Очистить();
			                    
			Для каждого ЭлементКорреспонденции Из ОтчетОб.Корреспонденции Цикл
				СтрокаКорреспонденции = ЭтаФорма.Корреспонденции.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаКорреспонденции, ЭлементКорреспонденции, , "Субконто");
				Для каждого СтрокаСубконтоИзНастройки Из ЭлементКорреспонденции.Субконто Цикл
					СтрокаСубконто = СтрокаКорреспонденции.Субконто.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаСубконто, СтрокаСубконтоИзНастройки);				
				КонецЦикла;
			КонецЦикла;
			
			ЭтаФорма.Элементы.ТаблицаОтборКорреспонденции.ОтборСтрок = Новый ФиксированнаяСтруктура("ИдСтрокиКорреспонденции", 0);
			ЭтаФорма.ТаблицаОтборКорреспонденции.Очистить();
			Для каждого СтрокаКор Из ЭтаФорма.Корреспонденции Цикл    		
				ЗаполнитьТаблицуОтборовПоСчетамСтрокиКорреспонденции(Отчет, ЭтаФорма, СтрокаКор.ПолучитьИдентификатор());		
			КонецЦикла;
			
		КонецЕсли;
		
		// ----------------------------------------------------------------------
		// Детализация кор. счетов
		Если КэшЗначений.ЕстьРкПравилаВыводаИтогов Тогда
			
			ЭтаФорма.ПравилаВыводаИтогов.Очистить();
			Для каждого ЭлементПравил Из ОтчетОб.ПравилаВыводаИтогов Цикл
				СтрокаПравил = ЭтаФорма.ПравилаВыводаИтогов.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаПравил, ЭлементПравил, , "РазворотПоСубконто");			
				Для каждого СтрокаРазворотаИзНастройки Из ЭлементПравил.РазворотПоСубконто Цикл
					СтрокаРазворота = СтрокаПравил.РазворотПоСубконто.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаРазворота, СтрокаРазворотаИзНастройки);			
				КонецЦикла;
			КонецЦикла;
			
		КонецЕсли;
		
		// ----------------------------------------------------------------------
		// Таблица кор субконто 	
		Если КэшЗначений.ЕстьТаблицаКорСубконто Тогда
			
			ЭтаФорма.ТаблицаКорСубконто.Очистить();
			                    
			Для каждого ЭлементТб Из ОтчетОб.ТаблицаКорСубконто Цикл
				СтрокаТабл = ЭтаФорма.ТаблицаКорСубконто.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаТабл, ЭлементТб);
			КонецЦикла;
					
		КонецЕсли;
				
	КонецЕсли;
	
КонецПроцедуры // ПрименитьНастройкиОтчета()

// Формирование полной копии отбора типового модуля "УправлениеОтчетами".
// 
// Параметры
//  Отбор  - Отбор - Исходный отбор, копию которого необходимо получить.
// 
// Возвращаемое значение:
//   ТаблицаЗначений - Копия исходного отбора.
// 
Функция ПолучитьКопиюОтбораВТЗ(Отбор) Экспорт

	Копия = Новый ТаблицаЗначений;
	Копия.Колонки.Добавить("ВидСравнения");
	Копия.Колонки.Добавить("Значение");
	Копия.Колонки.Добавить("ЗначениеПо");
	Копия.Колонки.Добавить("ЗначениеС");
	Копия.Колонки.Добавить("Имя");
	Копия.Колонки.Добавить("Использование");
	Копия.Колонки.Добавить("Представление");
	Копия.Колонки.Добавить("ПутьКДанным");
	Копия.Колонки.Добавить("ТипЗначения");
	
	Для каждого ЭлементОтбора Из Отбор Цикл  	
		ЗаполнитьЗначенияСвойств(Копия.Добавить(), ЭлементОтбора); 	
	КонецЦикла;
	
	Возврат Копия;

КонецФункции // ПолучитьКопиюОтбораВТЗ()

// Заполнение отбора значениями из таблицы значений.
// Соответствие полей устанавливается по представлению и типам значений.
// 
// Параметры
//  Отбор  - Отбор           - Отбор, который требуется заполнить значениями.
//  ТЗ     - ТаблицаЗначений - Таблица содержит значения для отбора.
//                             Структура колонок повторяет структуру отбора.
// 
Процедура УстановитьОтборИзТаблицы(Отбор, ТЗ, Организация = Неопределено, Период = Неопределено) Экспорт

	Для каждого ЭлементОтбора Из Отбор Цикл
	
		СтрокаТаблицы = Неопределено;
		
		Для каждого ТекСтрока Из ТЗ Цикл
			
			Если ТекСтрока.Представление = ЭлементОтбора.Представление
				 И ТекСтрока.ТипЗначения = ЭлементОтбора.ТипЗначения Тогда
				
				Если ПустаяСтрока(ТекСтрока.Представление)
					И ПустаяСтрока(ТекСтрока.ПутьКданным) Тогда 					
					Продолжить;					
				КонецЕсли;
				
				СтрокаТаблицы = ТекСтрока;   				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
			
		Если СтрокаТаблицы <> Неопределено Тогда
			
			ТекВидСравнения = СтрокаТаблицы.ВидСравнения;
			
			Если СтрокаТаблицы.Имя = "Организация" И Организация <> Неопределено И Период <> Неопределено Тогда
				Если ТипЗнч(Организация) <> Тип("СправочникСсылка.Организации") Тогда
					МассивОрганизаций = бит_БухгалтерскиеОтчетыСервер.ПолучитьЗначениеПараметраОрганизации(Организация, Период);
					Если ТекВидСравнения = ВидСравнения.Равно Тогда
					 	ТекВидСравнения   =  ВидСравнения.ВСписке;
					ИначеЕсли ТекВидСравнения = ВидСравнения.НеРавно Тогда	
					 	ТекВидСравнения   =  ВидСравнения.НеВСписке;
					КонецЕсли;
					СписокОрганизаций = Новый СписокЗначений;
					СписокОрганизаций.ЗагрузитьЗначения(МассивОрганизаций);
					ЭлементОтбора.ВидСравнения = ТекВидСравнения;
					ЭлементОтбора.Значение 	   = СписокОрганизаций;
					ЗаполнитьЗначенияСвойств(ЭлементОтбора, СтрокаТаблицы, "ЗначениеПо, ЗначениеС, Использование");
					Продолжить;
				КонецЕсли;			
			КонецЕсли;
			
			ЭлементОтбора.ВидСравнения = ТекВидСравнения;
			ЗаполнитьЗначенияСвойств(ЭлементОтбора, СтрокаТаблицы, "Значение, ЗначениеПо, ЗначениеС, Использование");
			
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // УстановитьОтборИзТаблицы()

// Функция получает тип измерения по умолчанию.
// 
// Параметры:
//  ТипЗначения - Тип.
// 
// Возвращаемое значение:
//  Элементы - Элементы.
// 
Функция ПолучитьТипИзмеренияПоУмолчанию(ТипЗначения) Экспорт
	
	Для каждого Тип Из ТипЗначения.Типы() Цикл
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
			Если ОбъектМетаданных.Иерархический Тогда
				Возврат ПолучитьТипИзмеренияПостроителяОтчетаПоУмолчанию();
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТипИзмеренияПостроителяОтчета.Элементы;
	
КонецФункции // ПолучитьТипИзмеренияПоУмолчанию()

// Процедура устанавливает тип измерения по умолчанию.
// 
// Параметры:
//  ТекущиеДанные 	  - ТекущиеДанные.
//  ПостроительОтчета - ПостроительОтчета.
// 
Процедура УстановитьТипИзмеренияПоУмолчанию(ТекущиеДанные, ПостроительОтчета, Счет = Неопределено) Экспорт
	
	ПутьКДанным = ТекущиеДанные.ПутьКДанным;
	
	Если Найти(ПутьКДанным, "КорСубконто") > 0 Тогда
		Префикс = "КорСубконто";
	ИначеЕсли Найти(ПутьКДанным, "Субконто") > 0 Тогда
		Префикс = "Субконто";
	Иначе
		Возврат;
	КонецЕсли;
	
	ИндексВидСубконто = Число(Сред(ПутьКДанным, СтрДлина(Префикс) + 1, 1)) - 1;
	Путь = СтрЗаменить(ПутьКДанным, ".", ".Поля.");
	
	Если Счет <> Неопределено Тогда 
		
		Если Найти(ТекущиеДанные.ПутьКДанным, ".") = 0 Тогда
			НомерСубконто = Число(Прав(ТекущиеДанные.ПутьКДанным, 1));
            СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
            ТипЗначения = СвСч["ВидСубконто" + НомерСубконто + "ТипЗначения"]; 		
			ТекущиеДанные.ТипИзмерения = ПолучитьТипИзмеренияПоУмолчанию(ТипЗначения);
		Иначе	
			ТекущиеДанные.ТипИзмерения = ТипИзмеренияПостроителяОтчета.Элементы;
		КонецЕсли;   		
		
	ИначеЕсли ПостроительОтчета.ДоступныеПоля.Количество() > 0 Тогда
		
		Выполнить("ТипЗначения = ПостроительОтчета.ДоступныеПоля." + Путь + ".ТипЗначения");  		
		ТекущиеДанные.ТипИзмерения = ПолучитьТипИзмеренияПоУмолчанию(ТипЗначения);
		
	Иначе
		
		ТекущиеДанные.ТипИзмерения = ТипИзмеренияПостроителяОтчета.Элементы;
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьТипИзмеренияПоУмолчанию()

// Корреспонденции

// Процедура очищает таблицу отборов по ид строки корреспонденции.
// 
// Параметры:
//  ЭтаФорма - УправляемаяФорма.
//  Ид  	 - Число.
//  ДтКт     - Строка (по умолчанию = Неопределено).
// 
Процедура ОчиститьТаблицуОтборовПоИдСтрокиКорреспонденции(ЭтаФорма, Ид, ДтКт = Неопределено) Экспорт

	Сч = ЭтаФорма.ТаблицаОтборКорреспонденции.Количество() - 1;
	Пока Сч >= 0 Цикл
	
		СтрокаТаблицы = ЭтаФорма.ТаблицаОтборКорреспонденции[Сч];
		Если СтрокаТаблицы.ИдСтрокиКорреспонденции = Ид 
			И (ДтКт = Неопределено Или Лев(СтрокаТаблицы.Представление, 2) = ДтКт) Тогда
			
			ЭтаФорма.ТаблицаОтборКорреспонденции.Удалить(СтрокаТаблицы);
								
		КонецЕсли;
		
		Сч = Сч - 1;
	
	КонецЦикла;	

КонецПроцедуры // ОчиститьТаблицуОтборовПоИдСтрокиКорреспонденции()

// Процедура заполняет таблицу отборов по счетам в строке корреспонденции.
// 
// Параметры:
//  Отчет    - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
//  Ид 	     - Число.
// 
Процедура ЗаполнитьТаблицуОтборовПоСчетамСтрокиКорреспонденции(Отчет, ЭтаФорма, Ид) Экспорт

	ЭтаФорма.фИмяРегистраБухгалтерии = ПолучитьИмяРегистраБухгалтерии(Отчет, ЭтаФорма);
	
	ТекущиеДанные = ЭтаФорма.Корреспонденции.НайтиПоИдентификатору(Ид);
	
	ПостроительОтчетаДляСубконтоКорреспонденции = Новый ПостроительОтчета;
	
	Если ТекущиеДанные <> Неопределено Тогда
	
		ЗаполнитьПостроительОтчетаДляСубконтоКорреспонденции(ЭтаФорма.фИмяРегистраБухгалтерии
															, ПостроительОтчетаДляСубконтоКорреспонденции
															, ТекущиеДанные.СчетДт
															, ТекущиеДанные.СчетКт
															, ТекущиеДанные.Субконто);
	
	Иначе
	
		ПостроительОтчетаДляСубконтоКорреспонденции.Текст = 
		"ВЫБРАТЬ
		|	ХозрасчетныйОборотыДтКт.СчетДт,
		|	ХозрасчетныйОборотыДтКт.СчетКт,
		|	0 КАК СуммаОборот
		|ИЗ
		|	РегистрБухгалтерии." + ЭтаФорма.фИмяРегистраБухгалтерии + ".ОборотыДтКт КАК ХозрасчетныйОборотыДтКт";
	
	КонецЕсли;
	
	ОчиститьТаблицуОтборовПоИдСтрокиКорреспонденции(ЭтаФорма, Ид);
	Для каждого ЭлементОтбораПостроителя Из ПостроительОтчетаДляСубконтоКорреспонденции.Отбор Цикл
		СтрокаТаблицыОтбора = ЭтаФорма.ТаблицаОтборКорреспонденции.Добавить();	
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыОтбора, ЭлементОтбораПостроителя);
		СтрокаТаблицыОтбора.ИдСтрокиКорреспонденции = Ид;
	КонецЦикла;

КонецПроцедуры // ЗаполнитьТаблицуОтборовПоСчетамСтрокиКорреспонденции()

// Формирует текст запроса по счету корреспонденции.
// 
// Параметры
//  фИмяРегистраБухгалтерии - Строка.
//  Счет  					- ПланыСчетовСсылка.
// 
Процедура ЗаполнитьПараметрыПоСтрокеКорреспонденции(ЭтаФорма, Счет, ДтКт) Экспорт

	ПостроительОтчетаДляСубконто = Новый ПостроительОтчета;
	МассивСубконто 				 = Новый Массив;
	
	Если ЗначениеЗаполнено(Счет) Тогда
		
		ТекстОтбор       = "";
		ТекстВыбораПолей = "";
				  	
		МаксКоличествоСубконто = Метаданные.ПланыСчетов[ЭтаФорма.фИмяРегистраБухгалтерии].МаксКоличествоСубконто;
		МассивСубконто         = Счет.ВидыСубконто.ВыгрузитьКолонку("ВидСубконто"); 			
        
        СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);	
		КоличествоСубконтоСчета = СвСч.КоличествоСубконто;
		Для н = 1 По КоличествоСубконтоСчета Цикл
			ТекстОтбор       = ТекстОтбор + ", Субконто" + ДтКт + н + ".* ";
			ТекстВыбораПолей = ТекстВыбораПолей + ", ОборотыДтКт.Субконто" + ДтКт + н;
		КонецЦикла;
				
		Если ДтКт = "Дт" Тогда
			МассивСубконтоДт = МассивСубконто;
			МассивСубконтоКт = Новый Массив;
		Иначе
			МассивСубконтоДт = Новый Массив;
			МассивСубконтоКт = МассивСубконто;
		КонецЕсли;
		
		ТекстОтбор        = Сред(ТекстОтбор      , 3);
		ТекстВыбораПолей  = Сред(ТекстВыбораПолей, 3);
		
		ЕстьВыбранныеПоля = ЗначениеЗаполнено(ТекстВыбораПолей);
		
		ТекстЗапроса = "
		|ВЫБРАТЬ
		|	0 КАК СуммаОборот
		|" + ?(ЕстьВыбранныеПоля, "{ВЫБРАТЬ " + ТекстВыбораПолей + "}", "") + "
		|ИЗ
		|	РегистрБухгалтерии." + ЭтаФорма.фИмяРегистраБухгалтерии + ".ОборотыДтКт(, , Запись, , &МассивСубконтоДт, , &МассивСубконтоКт, " 
																	+ ?(ЕстьВыбранныеПоля, "{" + ТекстОтбор + "}", "") + ") КАК ОборотыДтКт
		|";
		
		ПостроительОтчетаДляСубконто.Параметры.Вставить("МассивСубконтоДт", МассивСубконтоДт);
		ПостроительОтчетаДляСубконто.Параметры.Вставить("МассивСубконтоКт", МассивСубконтоКт);
		
		ПостроительОтчетаДляСубконто.Текст = ТекстЗапроса;
		
		// Проставим понятные пользователю имена полей.
		Сч = 0;
		Для каждого Элемент Из МассивСубконто Цикл
			Сч = Сч + 1;
			Поле = ПостроительОтчетаДляСубконто.ДоступныеПоля.Найти("Субконто" + ДтКт + Сч);
			Поле.ТипЗначения = Элемент.ТипЗначения;
			Поле.Представление = ДтКт + " " + Элемент.Наименование;
		КонецЦикла;
		
		// Добавим все субконто в поля отборов
		Сч = 0;
		Для каждого Элемент Из МассивСубконто Цикл
			Сч = Сч + 1;
			Поле = ПостроительОтчетаДляСубконто.Отбор.Добавить("Субконто" + ДтКт + Сч);
			Поле.Использование = Ложь;
		КонецЦикла;
		
		УстановитьТипыОтборовПостроителяПоСубконто(ПостроительОтчетаДляСубконто, МассивСубконто, ДтКт);
	
	КонецЕсли;

	ЭтаФорма.ФТекстЗапроса 				 = ПостроительОтчетаДляСубконто.Текст;
	ЭтаФорма.фКэшЗначений.МассивСубконто = МассивСубконто;

КонецПроцедуры // ЗаполнитьПараметрыПоСтрокеКорреспонденции()

// Процедура устанавливает в запрос параметр "Организация".
// 
// Параметры:
//  Запрос  	- Запрос.
//  Организация - СправочникСсылка.Организации, СправочникСсылка.бит_му_ПериметрыКонсолидации.
//  Период		- СтандартныйПериод.
// 
//ижтиси, шадрин, 01.09.2015(добавлен параметр СУсловиямиДляОсновногоПараметра)
//Процедура УстановитьПараметрЗапроса_Организация(Запрос, Организация, Период) Экспорт
//
//	Запрос.УстановитьПараметр("Организация" , ПолучитьЗначениеПараметраОрганизации(Организация, Период));
Процедура УстановитьПараметрЗапроса_Организация(Запрос, Организация, Период, СУсловиямиДляОсновногоПараметра = Ложь) Экспорт
//ижтиси, шадрин, 01.09.2015(добавлен параметр СУсловиямиДляОсновногоПараметра)
	
	Запрос.УстановитьПараметр("Организация" , ПолучитьЗначениеПараметраОрганизации(Организация, Период, СУсловиямиДляОсновногоПараметра));

КонецПроцедуры // УстановитьПараметр_Организация()

// Функция возвращает строку формата периода.
// 
// Параметры:
//  Периодичность - Строка, представление периодичности.
// 
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьСтрокуФорматаПериода(Знач Периодичность) Экспорт
	
	ФорматПериода = "";
	Если ЗначениеЗаполнено(Периодичность) Тогда
		
		Если Врег(Периодичность) = "ГОД" Тогда
			ФорматПериода = "ДФ = ""гггг """"г.""""""";
		ИначеЕсли Врег(Периодичность) = "ПОЛУГОДИЕ" Тогда
			ФорматПериода = "ДФ = """"""Полугодие с"""" дд.ММ.гггг """"""";
		ИначеЕсли Врег(Периодичность) = "КВАРТАЛ" Тогда
			ФорматПериода = "ДФ = ""к"""" квартал"""" гггг """"г.""""""";
		ИначеЕсли Врег(Периодичность) = "МЕСЯЦ" Тогда
			ФорматПериода = "ДФ = ""ММММ гггг """"г.""""""";
		ИначеЕсли Врег(Периодичность) = "ДЕКАДА" Тогда
			ФорматПериода = "ДФ = """"""Декада с"""" дд.ММ.гггг """"""";
		ИначеЕсли Врег(Периодичность) = "НЕДЕЛЯ" Тогда
			ФорматПериода = "ДФ = """"""Неделя с"""" дд.ММ.гггг """"""";
		ИначеЕсли Врег(Периодичность) = "ДЕНЬ" Тогда
			ФорматПериода = "ДЛФ = D";
		ИначеЕсли Врег(Периодичность) = "РЕГИСТРАТОР" Тогда
			ФорматПериода = "";
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ФорматПериода;
	
КонецФункции // ПолучитьСтрокуФорматаПериода()

// Функция возвращает представление периода строкой.
// 
// Параметры:
//  Периодичность - Строка, представление периода.
//  ДатаПериода   - Дата в интревале опредеяемого периода.
// 
// Возвращаемое значение:
//  Строка - Представление интервала.
// 
Функция ПолучитьПериодДатСтрокой(Знач Периодичность, Знач ДатаПериода) Экспорт

	Если Периодичность = "ДЕНЬ" Тогда
		ДатаНачала    = НачалоДня(ДатаПериода);
		ДатаОкончания = КонецДня(ДатаПериода);
	ИначеЕсли Периодичность = "НЕДЕЛЯ" Тогда
		ДатаНачала    = НачалоНедели(ДатаПериода);
		ДатаОкончания = КонецНедели (ДатаПериода);
	ИначеЕсли Периодичность = "МЕСЯЦ" Тогда
		ДатаНачала    = НачалоМесяца(ДатаПериода);
		ДатаОкончания = КонецМесяца (ДатаПериода);
	ИначеЕсли Периодичность = "КВАРТАЛ" Тогда
		ДатаНачала    = НачалоКвартала(ДатаПериода);
		ДатаОкончания = КонецКвартала (ДатаПериода);
	ИначеЕсли Периодичность = "ГОД" Тогда
		ДатаНачала    = НачалоГода(ДатаПериода);
		ДатаОкончания = КонецГода (ДатаПериода);
	КонецЕсли;

	Возврат ПредставлениеПериода(ДатаНачала, ДатаОкончания, "ФП=Истина")

КонецФункции // ПолучитьПериодДатСтрокой()

// Процедура выполняет заполнение параметров области.
// 
// Параметры:
//  Область - Область табличного документа, с параметрами для заполнения.
//  Выборка - ВыборкаИзРезультатаЗапроса.
// 
//  МассивРесурсов         - Массив.
//  ТекстОкончаниеРесурсов - Строка.
// 
//  НачИмяПараметра        - Строка, начальное имя параметра области,
//                           по умолчанию "Сумма".
//  СоотвИменПараметров    - Соответствие, Состав: Ключ     - окончание ресурса,
//                                                 Значение - имя параметра области,
//                           по умолчанию "Сумма".
// 
//  Булево - если значение равно нулю, тогда пишется "0,00" (По умолчанию Ложь).
// 
Процедура ЗаполнитьЗначениеПараметровОбластиПоМассивуРесурсов(Область, Выборка, МассивРесурсов, ТекстОкончаниеРесурсов, 
                                                              НачИмяПараметра = "Сумма", СоотвИменПараметров = Неопределено,
                                                              ОтображатьНулевыеЗначения = Ложь) Экспорт

	// BIT AMerkulov 02.03.2015	++														  
	Попытка		
	// BIT AMerkulov 02.03.2015	--	
    СтруктураОкончаний = Новый Структура(ТекстОкончаниеРесурсов);
    
    Для Каждого КлючЗначение Из СтруктураОкончаний Цикл
        
        ТекстСумма   = "";
        ТекОкончание = КлючЗначение.Ключ;
        
        Для Каждого ТекРесурс Из МассивРесурсов Цикл
            
            ТекСумма = Выборка[ТекРесурс + ?(ТекОкончание = "ПустойКлюч", "", ТекОкончание)];
            
            Если ОтображатьНулевыеЗначения Тогда
                СтрокаСумма = ?(ТекСумма <> 0, Формат(ТекСумма, "ЧЦ=15; ЧДЦ=2"), "0,00");
            Иначе
                СтрокаСумма = Формат(ТекСумма, "ЧЦ=15; ЧДЦ=2");
            КонецЕсли;
                
            ТекстСумма = ТекстСумма + ?(ПустаяСтрока(ТекстСумма), "", Символы.ПС) + СтрокаСумма;
            
        КонецЦикла;
        
        Если СоотвИменПараметров = Неопределено Тогда
            Область.Параметры[НачИмяПараметра + ТекОкончание] = ТекстСумма;
        Иначе
            Область.Параметры[СоотвИменПараметров.Получить(ТекОкончание)] = ТекстСумма
        КонецЕсли;
        
    КонецЦикла;
	// BIT AMerkulov 02.03.2015	++														  		
	Исключение
	КонецПопытки;
	// BIT AMerkulov 02.03.2015	--	
	
КонецПроцедуры // ЗаполнитьЗначениеПараметровОбластиПоМассивуРесурсов()

// Функция для счета возвращает количество субконто для него.
// 
// Параметры:
//  Счет 			  - ПланСчетовСсылка.
//  СоответсвиеСчетов - Соответсвие.
// 
// Возвращаемое значение:
//  Число.
// 
Функция ОпределитьДляСчетаПоСоответсвиеКоличествоСубконто(Знач Счет, СоответсвиеСчетов) Экспорт
	
	СоответсвиеСчетов = Новый Соответствие;
	
	КоличествоСубконтоСчета = СоответсвиеСчетов[Счет];
	Если КоличествоСубконтоСчета = - 1
		ИЛИ КоличествоСубконтоСчета = Неопределено Тогда
        
        СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
	
		КоличествоСубконтоСчета = СвСч.КоличествоСубконто;
		СоответсвиеСчетов[Счет] = КоличествоСубконтоСчета;
		
	КонецЕсли;

	Возврат КоличествоСубконтоСчета;
	
КонецФункции // ОпределитьДляСчетаПоСоответсвиеКоличествоСубконто()

// Функция удаляет при необходимости область из макета.
// 
// Параметры:
//  Макет 	   			- Макет.
//  ИмяОбласти 			- Строка.
//  НужноУдалятьОбласть - Булево.
// 
// Возвращаемое значение:
//   Макет.
// 
Функция УдалитьОбластьИзМакетаПриНеобходимости(Макет, Знач ИмяОбласти, Знач НужноУдалятьОбласть) Экспорт
	
	Если НЕ НужноУдалятьОбласть Тогда
		Макет.УдалитьОбласть(Макет.Область(ИмяОбласти), ТипСмещенияТабличногоДокумента.ПоГоризонтали);
	КонецЕсли;
	
КонецФункции // УдалитьОбластьИзМакетаПриНеобходимости()

// Функция возвращает часть запроса для иерархического вывода результатов отчета.
// 
// Параметры:
//  ТипИзмерения - Структура.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьПоТипуИзмеренияПостроителяОтчетаСтрокуЗапроса(Знач ТипИзмерения) Экспорт
	
	Если ТипИзмерения = ТипИзмеренияПостроителяОтчета.Иерархия Тогда
		Возврат " ИЕРАРХИЯ";
	ИначеЕсли ТипИзмерения = ТипИзмеренияПостроителяОтчета.ТолькоИерархия Тогда	
		Возврат " ТОЛЬКО ИЕРАРХИЯ";
	Иначе	
		Возврат "";
	КонецЕсли;
	
КонецФункции // ПолучитьПоТипуИзмеренияПостроителяОтчетаСтрокуЗапроса()

// Функция определяещая наличие дублирующегося параметра детализации.
// 
// Параметры:
//  ПостроительОтчета - ПостроительОтчета.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ОпределитьНаличиеДублирующегосяПараметраВИзмерениях(ПостроительОтчета) Экспорт
	
	СоответствиеТекущихИзмерений = Новый Соответствие;
	Для Сч = 0 По ПостроительОтчета.ИзмеренияСтроки.Количество() - 1  Цикл
		
		ПутьКДанным = ПостроительОтчета.ИзмеренияСтроки[Сч].ПутьКДанным;
		Если СоответствиеТекущихИзмерений[ПутьКДанным] <> Неопределено Тогда
			
			// Предупреждение
			ТекстСообщения = Нстр("ru = 'Повторяющееся поле детализации ""%1%""!'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ПостроительОтчета.ИзмеренияСтроки[Сч].Представление);
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			Возврат Истина;
			
		КонецЕсли;
		
		СоответствиеТекущихИзмерений.Вставить(ПостроительОтчета.ИзмеренияСтроки[Сч].ПутьКДанным, 0);
				
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции // ОпределитьНаличиеДублирующегосяПараметраВИзмерениях()

// Функция формирует выборку вложенных записей, если текущая запись не Неопределено.
// 
// Параметры:
//  Выборка 			   			  - ВыборкаИзЗапроса.
//  ОбходРезультатаЗапроса 			  - ОбходРезультатаЗапроса.
//  Измерение 			   			  - Строка.
//  ГруппировкиДляЗначенийГруппировок - Вид группировки (По умолчанию = Неопределено).
// 
// Возвращаемое значение:
//  Булево.
// 
Функция СформироватьВыборку(Выборка, ОбходРезультатаЗапроса, Измерение, ГруппировкиДляЗначенийГруппировок = Неопределено) Экспорт
	
	Если Выборка <> Неопределено Тогда
		Если ГруппировкиДляЗначенийГруппировок = Неопределено Тогда
			Выборка = Выборка.Выбрать(ОбходРезультатаЗапроса, Измерение);
		Иначе
			Выборка = Выборка.Выбрать(ОбходРезультатаЗапроса, Измерение, ГруппировкиДляЗначенийГруппировок);
		КонецЕсли;
		
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции // СформироватьВыборку()

// Функция проверяет выборку на наличие ненулевых оборотов.
// 
// Параметры:
//  Выборка 	 - ВыборкаИзЗапроса.
//  ПоКоличеству - Булево.
//  СтруктураРесурсов - Структура (По умолчанию = Неопределено) .
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоНулевойОборот(Выборка, ПоКоличеству, СтруктураРесурсов = Неопределено) Экспорт
    
    Если СтруктураРесурсов = Неопределено Тогда
		
		СуммаНоль = Выборка.СуммаОборотДт = 0 И Выборка.СуммаОборотКт = 0;
		
    Иначе
        
        СуммаНоль    = Истина;
        ЭтоСтруктура = ТипЗнч(СтруктураРесурсов) = Тип("Структура");
        
        Для Каждого ТекРесурс Из СтруктураРесурсов Цикл
            
            ТекКлюч = ?(ЭтоСтруктура, ТекРесурс.Ключ, ТекРесурс);
            
            СуммаОборотДт = Выборка[ТекКлюч + "ОборотДт"];
            СуммаОборотКт = Выборка[ТекКлюч + "ОборотКт"];
            
            СуммаНоль = ?(СуммаОборотДт <> NULL, СуммаОборотДт, 0) = 0 
                        И ?(СуммаОборотКт <> NULL, СуммаОборотКт, 0) = 0;
            Если Не СуммаНоль Тогда
                // Это не нулевой оборот.
                Прервать;
            КонецЕсли;
            
        КонецЦикла;
        
    КонецЕсли;
        
    КоличествоНоль = Не ПоКоличеству ИЛИ Выборка.КоличествоОборотДт = 0 И Выборка.КоличествоОборотКт = 0;
	Возврат СуммаНоль И КоличествоНоль;
	
КонецФункции // ЭтоНулевойОборот()

// Процедура устанавливает курсив в ячейке Таб. документа если выводится группа.
// 
// Параметры:
//  Ячейка	  - Ячейка.
//  ТипЗаписи - ТипЗаписиЗапроса.
// 
Процедура УстановитьКурсивПоТипуЗаписи(Ячейка, ТипЗаписи) Экспорт
	
	Если ТипЗаписи = ТипЗаписиЗапроса.ИтогПоИерархии Тогда
		Ячейка.Шрифт = Новый Шрифт(Ячейка.Шрифт , , , , Истина);
	Иначе
		Ячейка.Шрифт = Новый Шрифт(Ячейка.Шрифт , , , , Ложь);
	КонецЕсли;
	
КонецПроцедуры // УстановитьКурсивПоТипуЗаписи()

// Функция формирует строку представления измерений построителя отчета.
// 
// Параметры
//  КоллекцияИзмерений - ИзмеренияПостроителяОтчета, коллекция измерений построителя отчета.
// 
// Возвращаемое значение:
//   Строка - представление измерений построителя отчета.
// 
Функция СформироватьСтрокуИзмерений(КоллекцияИзмерений) Экспорт

	Если ТипЗнч(КоллекцияИзмерений) <> Тип("ИзмеренияПостроителяОтчета") Тогда
		Возврат "";
	КонецЕсли; 
	
	СтрокаИзмерений = "";
	
	Для а = 0 По КоллекцияИзмерений.Количество() - 1 Цикл
		Если а > 0 Тогда
			СтрокаИзмерений = СтрокаИзмерений + ", ";
		КонецЕсли;
		СтрокаИзмерений = СтрокаИзмерений + КоллекцияИзмерений[а].Представление;
	КонецЦикла;
	
	Возврат СтрокаИзмерений;

КонецФункции // СформироватьСтрокуГруппировок()

// Функция формирует описание ограничений по измерениям построителя.
// 
// Параметры:
//  ПостроительОтчета - ПостроительОтчета.
// 
// Возвращаемое значение:
//  ТекстПроИтоги - Строка.
// 
Функция СформироватьСтрокуОписанияИтоговПоИзмерениямПостроителя(ПостроительОтчета) Экспорт
	
	Если ПостроительОтчета.ИзмеренияСтроки.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	ТекстПроИтоги = "субконто: ";
		
	СтрокаИзмерений = "";
	Для Каждого Измерение Из ПостроительОтчета.ИзмеренияСтроки Цикл
		
		СтрокаИзмерений = СтрокаИзмерений + ", " + Измерение.Представление;
		
	КонецЦикла;
	
	ТекстПроИтоги = ТекстПроИтоги + Сред(СтрокаИзмерений, 3);
		
	Возврат ТекстПроИтоги;
	
КонецФункции // СформироватьСтрокуОписанияИтоговПоИзмерениямПостроителя()
                                            
// Функция возвращает нужно ли пропустить текущую строку выборки при выводе данных или нет.
// 
// Параметры:
//  Выборка 			   - ВыборкаИзЗапроса.
//  ПоПодстрокеСодержание  - Булево.
//  ПоПодстрокеСубконто    - Булево.
//  БезУчетаРегистра 	   - Булево.
//  Подстрока 			   - Строка.
//  МаксКоличествоСубконто - Число.
// 
// Возвращаемое значение:
//  Булево - Пропустить строку.
// 
Функция ОпределитьНеобходимоПропуститьСтрокуПриВыводеДанных(Выборка, Знач ПоПодстрокеСодержание, Знач ПоПодстрокеСубконто,
	Знач БезУчетаРегистра, Знач Подстрока, Знач МаксКоличествоСубконто) Экспорт
	
	Если НЕ (ПоПодстрокеСодержание ИЛИ ПоПодстрокеСубконто) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПодстрокаПоиска = ?(БезУчетаРегистра, НРег(Подстрока), Подстрока);
	
	// Поиск по ИЛИ на вхождение в содержание или в Субконто.
	Если ПоПодстрокеСодержание Тогда
		
		Если БезУчетаРегистра Тогда
			СтрокаНайдена = Найти(НРег(Выборка.Содержание), ПодстрокаПоиска) > 0;
		Иначе
			СтрокаНайдена = Найти(Выборка.Содержание, ПодстрокаПоиска) > 0;
		КонецЕсли;
		
		Если СтрокаНайдена Тогда
			// Строка уже найдена, дальше искать не надо.
			Возврат Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
			
	Если ПоПодстрокеСубконто Тогда
		
		Для Сч = 1 По МаксКоличествоСубконто Цикл
			
			СубконтоДт = ?(БезУчетаРегистра, НРег(Выборка["СубконтоДт" + Сч]), Выборка["СубконтоДт" + Сч]);
			СубконтоКт = ?(БезУчетаРегистра, НРег(Выборка["СубконтоКт" + Сч]), Выборка["СубконтоКт" + Сч]);
			
			Если Найти(СубконтоДт, ПодстрокаПоиска) > 0
				Или Найти(СубконтоКт, ПодстрокаПоиска) > 0 Тогда
						
				Возврат Ложь;
										
			КонецЕсли;
						
		КонецЦикла;
		
	КонецЕсли;
	
	// Ничего не нашли
	Возврат Истина;
	
КонецФункции // ОпределитьНеобходимоПропуститьСтрокуПриВыводеДанных()

// Процедура обводит области отчета.
// 
// Параметры:
//  ДокументРезультат - ТабличныйДокумент.
//  НачалоСекции  	  - Число.
//  Линия    		  - Число.
//  ЛинияЖирная 	  - Число.
// 
Процедура ОбвестиОбластиОтчета(ДокументРезультат, НачалоСекции = 0, Линия, ЛинияЖирная) Экспорт
	
	КонСтр = ДокументРезультат.ВысотаТаблицы;

	ДокументРезультат.Область(КонСтр, 2, КонСтр, 4).ГраницаСнизу  = Линия;
	ДокументРезультат.Область(КонСтр, 5, КонСтр, 8).ГраницаСнизу  = ЛинияЖирная;
	ДокументРезультат.Область(КонСтр, 9, КонСтр, 12).ГраницаСнизу = Линия;
	
	ДокументРезультат.Область(НачалоСекции, 2,КонСтр, 2).Объединить();
	ДокументРезультат.Область(НачалоСекции, 3,КонСтр, 3).Объединить();
	ДокументРезультат.Область(НачалоСекции, 2,КонСтр, 3).РазмещениеТекста = ТипРазмещенияТекстаТабличногоДокумента.Переносить;
	
КонецПроцедуры // ОбвестиОбластиОтчета()

// Ограничения

// Функция Объединяет ограничения.
// 
// Параметры:
//  Ограничение1 			     - Строка.
//  Ограничение2 				 - Строка.
//  СтрокаОбъединенияОграничений - Строка (По умолчанию = "И").
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ОбъединитьОграничения(Знач Ограничение1, Знач Ограничение2, Знач СтрокаОбъединенияОграничений = "И") Экспорт
	
	Если ПустаяСтрока(Ограничение1) Тогда
		Возврат Ограничение2;
	КонецЕсли;
	
	Если ПустаяСтрока(Ограничение2) Тогда
		Возврат Ограничение1;
	КонецЕсли;
	
	СтрокаОграничения = Ограничение1 + " " + СтрокаОбъединенияОграничений + " " + Ограничение2;
	
	Возврат СтрокаОграничения;
	
КонецФункции // ОбъединитьОграничения()

// Функция формирует строку ограничений для запроса по ограничениям построителя отчетов.
// 
// Параметры:
//  ПостроительОтчета 		   - ПостроительОтчета.
//  Запрос 					   - Запрос.
//  ТекстОтбораПоВидамСубконто - Строка (По умолчанию = Неопределено).
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьТекстОграниченийПоПостроителюОтчета(ПостроительОтчета, Запрос, ТекстОтбораПоВидамСубконто = Неопределено) Экспорт
	
	ТекстФильтры = "";
	
	Индекс = 0;
	Для Каждого СтрокаОтбора Из ПостроительОтчета.Отбор Цикл
		
		Индекс = Индекс + 1;
		Если Не СтрокаОтбора.Использование 
			ИЛИ ПустаяСтрока(СтрокаОтбора.ПутьКДанным) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		УстановитьПараметрыЗапросаПоСтрокеПостроителяОтчета(Запрос, СтрокаОтбора, Строка(Индекс));
						
		ТекстСтрокиПоля = "";
		Если СтрокаОтбора.ВидСравнения = ВидСравнения.ВИерархии
			И СтрокаОтбора.Значение <> Неопределено Тогда
			
			МетаданныеОграничения = СтрокаОтбора.Значение.Метаданные();	
			
			ТипВыражения = "";
			
			Если Метаданные.Справочники.Содержит(МетаданныеОграничения) Тогда  				
				ТипВыражения = "Справочник.";				
			ИначеЕсли Метаданные.Документы.Содержит(МетаданныеОграничения) Тогда 				
				ТипВыражения = "Документ."; 				
			ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеОграничения) Тогда				
				ТипВыражения = "ПланВидовХарактеристик.";				
			ИначеЕсли Метаданные.Перечисления.Содержит(МетаданныеОграничения) Тогда 				
				ТипВыражения = "Перечисление.";					
			КонецЕсли;
			
			Если ТипВыражения <> "" Тогда				
				ТекстСтрокиПоля = "Выразить(" + СтрокаОтбора.ПутьКДанным + " КАК " + ТипВыражения + МетаданныеОграничения.Имя + ")"				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ТекстСтрокиПоля = "" Тогда 			
			ТекстСтрокиПоля = СтрокаОтбора.ПутьКДанным; 			
		КонецЕсли;
			
		ТекстФильтры = ТекстФильтры + " И " + ПолучитьСтрокуОтбора(СтрокаОтбора.ВидСравнения, "&Значение" + Индекс, 
			ТекстСтрокиПоля, "&ЗначениеС" + Индекс, "&ЗначениеПо" + Индекс, СтрокаОтбора.Значение, 
			СтрокаОтбора.ЗначениеС, СтрокаОтбора.ЗначениеПо);
				
	КонецЦикла;
	
	Если ТекстОтбораПоВидамСубконто <> Неопределено Тогда
		ТекстОтбораПоВидамСубконто = УстановитьОтборНаВидыСубконтоПоПостроителюОтчета(ПостроительОтчета, ПостроительОтчета.Параметры.Счет, Запрос);
    КонецЕсли;

	Возврат Сред(ТекстФильтры, 3);
	
КонецФункции // ПолучитьТекстОграниченийПоПостроителюОтчета()

// Процедура формирует строку ограничений для выборки из таблицы оборотов и остатков регистров бухгалтерии.
// 
// Параметры:
//  СтрокаОграничения 		  - Строка.
//  ИмяОграниченияПоРеквизиту - Строка.
//  ОграничениеПоРеквизиту 	  - Строка.
// 
Процедура ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграничения, Знач ИмяОграниченияПоРеквизиту, Знач ОграничениеПоРеквизиту) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ОграничениеПоРеквизиту) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ОграничениеПоРеквизиту) = Тип("Массив") Тогда
		
		СтрокаНовогоОграничения = ИмяОграниченияПоРеквизиту + " В (&" + ИмяОграниченияПоРеквизиту + ") ";
		
	ИначеЕсли ТипЗнч(ОграничениеПоРеквизиту) = Тип("СписокЗначений") Тогда
		
		СтрокаНовогоОграничения = ИмяОграниченияПоРеквизиту + " В (&" + ИмяОграниченияПоРеквизиту + ") ";
		ОграничениеПоРеквизиту = ОграничениеПоРеквизиту.ВыгрузитьЗначения();
		
	Иначе
		
		СтрокаНовогоОграничения = ИмяОграниченияПоРеквизиту + " = &" + ИмяОграниченияПоРеквизиту + " ";
		
	КонецЕсли;
			
	СтрокаОграничения = ОбъединитьОграничения(СтрокаОграничения, СтрокаНовогоОграничения);
    
КонецПроцедуры // ДополнитьСтрокуОграниченийПоРеквизитам()

// Процедура дополняет структуру ограничений по организации.
// 
// Параметры:
//  СтрокаОграниченийПоРеквизитам - Строка.
//  Организация 				  - СправочникСсылка.Организации Или СправочникСсылка.бит_му_ПериметрыКонсолидации.
// 
Процедура ДополнитьСтрокуОграниченийПоОрганизации(СтрокаОграниченийПоРеквизитам, Организация, Знач ОргВидСравнения, ОргИспользование) Экспорт
	
	Если Не ОргИспользование Тогда
		Возврат;
	КонецЕсли;	
	
	// ИмяОгр 	   = "Организация"; 	
	ЭтоОднаОрг = ТипЗнч(Организация) = Тип("СправочникСсылка.Организации") Или Не ЗначениеЗаполнено(Организация);
	
	СтрокаНО = "Организация %Знак%&Организация ";
		
	Если ОргВидСравнения = ВидСравнения.Равно И ЭтоОднаОрг Тогда
		СтрокаНО = СтрЗаменить(СтрокаНО, "%Знак%", "= ");
	ИначеЕсли ОргВидСравнения = ВидСравнения.Равно ИЛИ ОргВидСравнения = ВидСравнения.ВСписке Тогда
		СтрокаНО = СтрЗаменить(СтрокаНО, "%Знак%", "В(") + ") ";
	ИначеЕсли ОргВидСравнения = ВидСравнения.НеРавно И ЭтоОднаОрг Тогда
		СтрокаНО = СтрЗаменить(СтрокаНО, "%Знак%", "<> ");
	ИначеЕсли ОргВидСравнения = ВидСравнения.НеРавно ИЛИ ОргВидСравнения = ВидСравнения.НеВСписке Тогда
		СтрокаНО = СтрЗаменить(СтрокаНО, "%Знак%", "НЕ В(") + ") ";
	КонецЕсли;
			
	СтрокаОграниченийПоРеквизитам = ОбъединитьОграничения(СтрокаОграниченийПоРеквизитам, СтрокаНО);
    
КонецПроцедуры // ДополнитьСтрокуОграниченийПоОрганизации()

// Отборы

// Функция формирует строку представления отборов объекта Отбор
// типового модуля "УправлениеОтчетами".
// 
// Параметры
//  Отбор - Отбор, по которому формируем строку.
// 
// Возвращаемое значение:
//  Строка - представление отбора.
// 
Функция СформироватьСтрокуОтборов(Отбор, Организация = Неопределено, Период = Неопределено) Экспорт

	Если ТипЗнч(Отбор) <> Тип("Отбор") Тогда
		Возврат "";
	КонецЕсли; 
	
	СтрокаОтборов = "";
	
	Для а = 0 По Отбор.Количество() - 1 Цикл
		
		ЭлементОтбора = Отбор[а];
		Если НЕ ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли; 

		Если ЭлементОтбора.Имя = "Периодичность" Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ПустаяСтрока(СтрокаОтборов) Тогда
			СтрокаОтборов = СтрокаОтборов + ", ";
		КонецЕсли; 
		
		ТекВидСравнения = ЭлементОтбора.ВидСравнения;
		ЗначениеОтбора  = ЭлементОтбора.Значение;
			
		Если ЭлементОтбора.Имя = "Организация" И Организация <> Неопределено И Период <> Неопределено Тогда
			Если ТипЗнч(Организация) <> Тип("СправочникСсылка.Организации") Тогда
				МассивОрганизаций = бит_БухгалтерскиеОтчетыСервер.ПолучитьЗначениеПараметраОрганизации(Организация, Период);
				Если ТекВидСравнения = ВидСравнения.Равно Тогда
				 	ТекВидСравнения   =  ВидСравнения.ВСписке;
				ИначеЕсли ТекВидСравнения = ВидСравнения.НеРавно Тогда	
				 	ТекВидСравнения   =  ВидСравнения.НеВСписке;
				КонецЕсли;
				СписокОрганизаций = Новый СписокЗначений;
				СписокОрганизаций.ЗагрузитьЗначения(МассивОрганизаций);
				ЗначениеОтбора = СписокОрганизаций;
			КонецЕсли;
		КонецЕсли;

		Если ТекВидСравнения = ВидСравнения.Равно Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " = "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СокрЛП(Строка(ЗначениеОтбора)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.НеРавно Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " <> "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СокрЛП(Строка(ЗначениеОтбора)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.ВСписке Тогда
			
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЗначениеОтбора Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли; 
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в списке "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СтрокаСписка);
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
			
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЗначениеОтбора Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли; 
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в списке по иерархии "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СтрокаСписка);
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.НеВСписке Тогда
			
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЗначениеОтбора Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли;
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в списке "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СтрокаСписка);
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
			
			СтрокаСписка = "";
			Для каждого ЭлементСписка Из ЗначениеОтбора Цикл
				Если НЕ ПустаяСтрока(СтрокаСписка) Тогда
					СтрокаСписка = СтрокаСписка + "; ";
				КонецЕсли;
				Если НЕ ЗначениеЗаполнено(ЭлементСписка.Представление) Тогда
					СтрокаСписка = СтрокаСписка + СокрЛП(Строка(ЭлементСписка.Значение));
				Иначе
					СтрокаСписка = СтрокаСписка + СокрЛП(ЭлементСписка.Представление);
				КонецЕсли;
			КонецЦикла; 
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в списке по иерархии "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СтрокаСписка);
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.ВИерархии Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " в иерархии "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", ЗначениеОтбора);
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.НеВИерархии Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " не в иерархии "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", ЗначениеОтбора);
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.Больше Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " > "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СокрЛП(Строка(ЗначениеОтбора)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.БольшеИлиРавно Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " >= "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СокрЛП(Строка(ЗначениеОтбора)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.Меньше Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " < "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СокрЛП(Строка(ЗначениеОтбора)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
			
			СтрокаОтборов = СтрокаОтборов + ЭлементОтбора.Представление + " <= "+ ?(НЕ ЗначениеЗаполнено(ЗначениеОтбора), "Пусто", СокрЛП(Строка(ЗначениеОтбора)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.Интервал Тогда
			
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " < " + ЭлементОтбора.Представление + " < "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
			
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " <= " + ЭлементОтбора.Представление + " <= "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
			
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " <= " + ЭлементОтбора.Представление + " < "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
			
			СтрокаОтборов = СтрокаОтборов + ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеС), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеС))) + " < " + ЭлементОтбора.Представление + " <= "+ ?(НЕ ЗначениеЗаполнено(ЭлементОтбора.ЗначениеПо), "...", СокрЛП(Строка(ЭлементОтбора.ЗначениеПо)));
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.Содержит Тогда
			
			СтрокаОтборов = СтрокаОтборов  + ЭлементОтбора.Представление + " содержит '" + ЗначениеОтбора + "'";
			
		ИначеЕсли ТекВидСравнения = ВидСравнения.НеСодержит Тогда
			
			СтрокаОтборов = СтрокаОтборов  + ЭлементОтбора.Представление + " не содержит '" + ЗначениеОтбора + "'";
			
		КонецЕсли; 

	КонецЦикла; 
	
	Возврат СтрокаОтборов;

КонецФункции // СформироватьСтрокуОтборов()

// Функция возвращает Строку Вида отбора для запроса.
// 
// Параметры
//  ВыбВидСравнения  - ВидСравнения.
//  ЗначениеОтбора   - Значение отбора запроса.
//  СтрокаПоляОтбора - Строка, Аргумент запроса, т.е. то что должно быть написано до вида сревнения.
//  ЗначениеОтбораС  - Произвольный, значение отбора для видов сравнения, 
// 						  у которых необходимо указывать два значения, начальное значение.
//  ЗначениеОтбораПо - Произвольный, значение отбора для видов сравнения,
// 						  у которых необходимо указывать два значения, конечное значение.
//  СамоЗначение    - Произвольный.
//  СамоЗначениеС 	- Произвольный.
//  СамоЗначениеПо 	- Произвольный.
// 
// Возвращаемое значение 
//  Строка.
// 
Функция ПолучитьСтрокуОтбора(ВыбВидСравнения, ЗначениеОтбора, СтрокаПоляОтбора, ЗначениеОтбораС = Неопределено, ЗначениеОтбораПо = Неопределено, СамоЗначение = Неопределено, СамоЗначениеС = Неопределено, СамоЗначениеПо = Неопределено) Экспорт

	СтрокаВозврата = "";
	
	Если Типзнч(СамоЗначение) = Тип("Массив") Тогда
		Если ВыбВидСравнения = ВидСравнения.Равно Тогда
	    	ВыбВидСравнения = ВидСравнения.ВСписке;
		ИначеЕсли ВыбВидСравнения = ВидСравнения.НеРавно Тогда
			ВыбВидСравнения = ВидСравнения.НеВСписке;
		КонецЕсли;
	КонецЕсли;
	
	Если ВыбВидСравнения = ВидСравнения.Равно Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" = " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеРавно Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" <> " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ВСписке Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" В (" + ЗначениеОтбора+")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ВСпискеПоИерархии 
		ИЛИ ВыбВидСравнения = ВидСравнения.ВИерархии Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" В ИЕРАРХИИ(" + ЗначениеОтбора + ")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеВСписке Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" НЕ В (" + ЗначениеОтбора + ")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеВСпискеПоИерархии 
		ИЛИ ВыбВидСравнения = ВидСравнения.НеВИерархии Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" НЕ В ИЕРАРХИИ(" + ЗначениеОтбора + ")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Больше Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.БольшеИлиРавно Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Меньше Тогда
		
		Если НЕ (ТипЗнч(СамоЗначение) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначение)) Тогда
			СтрокаВозврата = СтрокаПоляОтбора + Строка(" < " + ЗначениеОтбора);
		КонецЕсли; 
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
		
		Если НЕ (ТипЗнч(СамоЗначение) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначение)) Тогда
			СтрокаВозврата = СтрокаПоляОтбора + Строка(" <= " + ЗначениеОтбора);
		КонецЕсли; 
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Интервал Тогда
		
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" < " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
		
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" <= " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
		
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" < " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
		
		Если ТипЗнч(СамоЗначениеПо) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначениеПо) Тогда
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + ")";
		Иначе
			СтрокаВозврата = "(" + СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбораС) + " И " + СтрокаПоляОтбора + Строка(" <= " + ЗначениеОтбораПо) + ")";
		КонецЕсли;
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.Содержит Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" ПОДОБНО " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравнения.НеСодержит Тогда
		
		СтрокаВозврата = "НЕ (" + СтрокаПоляОтбора + Строка(" ПОДОБНО " + ЗначениеОтбора + ")");
		
	КонецЕсли;

	Возврат СтрокаВозврата;
	
КонецФункции // ПолучитьСтрокуОтбора()

// Функция устанавливает фильтр на виды субконто в параметрах к виртуальной таблице, если это возможно.
// Т.е. установит новый параметр ВидыСубконто и вернет текст для подстановки в текст запроса.
// 
// Параметры:
//  ПостроительОтчета - ПостроительОтчета.
//  Счет 			  - ПланСчетовСсылка.
//  Запрос 			  - Запрос.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция УстановитьОтборНаВидыСубконтоПоПостроителюОтчета(ПостроительОтчета, Счет, Запрос) Экспорт
    
    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
	КолСубкнотоНаСчету 				 = СвСч.КоличествоСубконто;
	Номер 							 = 1;
	ПропущеноИзмерение 				 = Ложь;
	ПропущенОтбор 					 = Ложь;
	НеБылоОтбора 					 = Ложь;
	ИспользоватьОтборПоВидамСубконто = Истина;
	Измерения 						 = Новый Соответствие;
	
	Для каждого Измерение из ПостроительОтчета.ИзмеренияСтроки Цикл
		
		Если Найти(Измерение.ПутьКДанным, ".") <> 0 Тогда
			Измерения.Вставить(Сред(Измерение.ПутьКДанным, 0, Найти(Измерение.ПутьКДанным,".")-1), Истина);
		Иначе
			Измерения.Вставить(Измерение.ПутьКДанным, истина);
		КонецЕсли;
		
	КонецЦикла;
	
	Пока Номер <= КолСубкнотоНаСчету Цикл
		
		ИмяСубконто = "Субконто" + Номер;
		ЕстьИзмерение = Измерения.Получить(ИмяСубконто)<> Неопределено;
		
		Если ПостроительОтчета.Отбор.Найти(ИмяСубконто)<> Неопределено Тогда
			ОтборВключен = ПостроительОтчета.Отбор.Найти(ИмяСубконто).Использование;
		Иначе
			ОтборВключен = Ложь;
		КонецЕсли;	
		
		ПропущенОтбор = (Номер <> 1) И ((ОтборВключен И НеБылоОтбора));
		
		Если (ПропущеноИзмерение и ЕстьИзмерение)
			ИЛИ (ОтборВключен И не ЕстьИзмерение) 
			ИЛИ ((ПропущенОтбор и ОтборВключен) И Не ПропущеноИзмерение)Тогда
			ИспользоватьОтборПоВидамСубконто = Ложь;
			Прервать;
		КонецЕсли;
		
		ПропущеноИзмерение = (Не ЕстьИзмерение) И (Не ПропущеноИзмерение);
		НеБылоОтбора = ((Не ОтборВключен) ИЛИ НеБылоОтбора);
		Номер = Номер + 1;
		
	КонецЦикла;
	
	ТекстОтбораПоВидамСубконто="";
	Если ИспользоватьОтборПоВидамСубконто И Не НеБылоОтбора Тогда
		
		Номер = 1;
		ВидыСубконто = Новый массив;
		
		Пока Номер <= КолСубкнотоНаСчету Цикл
			
			ИмяСубконто = "Субконто" + Номер;
			Если Измерения.Получить(ИмяСубконто) = Неопределено Тогда
				Прервать;
			КонецЕсли;
			
            //ВидыСубконто.Добавить(Счет.ВидыСубконто[номер-1].ВидСубконто);
            ВидыСубконто.Добавить(СвСч["ВидСубконто" + Номер]);
			Номер = Номер + 1;
			
		КонецЦикла;
		
		Запрос.УстановитьПараметр("ВидыСубконто", ВидыСубконто);
		ТекстОтбораПоВидамСубконто = "&ВидыСубконто";
		
	КонецЕсли;	
	
	Возврат ТекстОтбораПоВидамСубконто;
	
КонецФункции // УстановитьОтборНаВидыСубконтоПоПостроителюОтчета()

// Процедура формирует первоначальные строки отбора построителя по субконто.
// 
// Параметры:
//  ПостроительОтчета - ПостроительОтчета.
//  Счет			  - ПланСчетовСсылка.
// 
Процедура СформироватьПервоначальныйОтборПостроителяПоСубконто(ПостроительОтчета, Знач Счет) Экспорт
	
	ПостроительОтчета.ИзмеренияСтроки.Очистить();
	
	Сч = 0;
	Для Каждого СтрокаВидаСубконто Из Счет.ВидыСубконто Цикл
		
		Сч = Сч + 1;
		
		ИмяСубконто = "Субконто" + Сч;
		
		ЭлементОтбора = ПостроительОтчета.Отбор.Найти(ИмяСубконто);
		Если ЭлементОтбора = Неопределено Тогда
			ЭлементОтбора = ПостроительОтчета.Отбор.Добавить(ИмяСубконто);
			ЭлементОтбора.Использование = Ложь;
		КонецЕсли;
					
		ТипИзмерения = ПолучитьТипИзмеренияПоУмолчанию(СтрокаВидаСубконто.ВидСубконто.ТипЗначения);
		ПостроительОтчета.ИзмеренияСтроки.Добавить(ИмяСубконто, , ТипИзмерения);

	КонецЦикла;
	
КонецПроцедуры // СформироватьПервоначальныйОтборПостроителяПоСубконто()

// Процедура формирует текст запроса для таблицы дополнительных отборов.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция СформироватьТекстДопЗапроса() Экспорт

	ТекстДопЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	бит_БюджетированиеОстаткиИОбороты.Сценарий,
	|	бит_БюджетированиеОстаткиИОбороты.ЦФО
	|{ВЫБРАТЬ
	|	Сценарий.*,
	|	ЦФО.*}
	|ИЗ
	|	РегистрБухгалтерии.бит_Бюджетирование.ОстаткиИОбороты КАК бит_БюджетированиеОстаткиИОбороты
	|{ГДЕ
	|	бит_БюджетированиеОстаткиИОбороты.Сценарий.*,
	|	бит_БюджетированиеОстаткиИОбороты.ЦФО.*}
	|";

	Возврат ТекстДопЗапроса;
	
КонецФункции // СформироватьТекстДопЗапроса()

// Счет

// Процедура выводит данные остатков по оборотам в макет.
// 
// Параметры:
//  ЗапросПоОстаткам 	- Запрос.
//  ОбластьМакет 		- Область.
//  Счет 				- ПланСчетовСсылка.
//  ЗапросНаНачало 		- Запрос.
//  ТекущееСальдо 	  	- Число (По умолчанию = 0).
//  ТекущееСальдоКолво  - Число (По умолчанию = 0).
//  СтруктураПараметров - Структура (По умолчанию = Неопределено).
// 
Процедура ВывестиДанныеОстатковКарточкиСчетаВМакет(ЗапросПоОстаткам, Знач ОбластьМакет, Знач Счет, Знач ЗапросНаНачало, 
													ТекущееСальдо = 0, ТекущееСальдоКолво = 0, СтруктураПараметров = Неопределено) Экспорт
       
	Остатки = ЗапросПоОстаткам.Выполнить().Выбрать();
	Остатки.Следующий();
    
    Если ЗапросНаНачало Тогда
        ОбластьМакет.Параметры.ОписательСальдо = Нстр("ru = 'Сальдо на начало'");
    Иначе
        ОбластьМакет.Параметры.ОписательСальдо = Нстр("ru = 'Сальдо на конец'");
    КонецЕсли;
    
    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
    ВыводитьИтогПоКоличеству = СвСч.Количественный;
    
    Если СтруктураПараметров = Неопределено Тогда
        
    	СуммаОстатокДт = ПривестиКЧислу(Остатки.СуммаОстатокДт);
    	СуммаОстатокКт = ПривестиКЧислу(Остатки.СуммаОстатокКт);
    	КоличествоОстатокДт = ПривестиКЧислу(Остатки.КоличествоОстатокДт);
    	КоличествоОстатокКт = ПривестиКЧислу(Остатки.КоличествоОстатокКт);
    	
    	ТекущееСальдо 	   = СуммаОстатокДт - СуммаОстатокКт;
    	ТекущееСальдоКолво = КоличествоОстатокДт - КоличествоОстатокКт;

    	Если СвСч.Вид = ВидСчета.АктивноПассивный Тогда
    		
    		Если СуммаОстатокДт > СуммаОстатокКт Тогда
				
				ОбластьМакет.Параметры.СуммаСальдоДт   = ТекущееСальдо;
    			ОбластьМакет.Параметры.СуммаСальдоКт   = 0;
    			
    			Если ВыводитьИтогПоКоличеству Тогда
    				
    				ОбластьМакет.Параметры.КоличествоСальдоДт = ТекущееСальдоКолво;
    				ОбластьМакет.Параметры.КоличествоСальдоКт = 0;
    				
    			КонецЕсли;
    			
    		Иначе
				
				ОбластьМакет.Параметры.СуммаСальдоКт   = 0;
    			ОбластьМакет.Параметры.СуммаСальдоКт   = -ТекущееСальдо;
    			
    			Если ВыводитьИтогПоКоличеству Тогда
    				
    				ОбластьМакет.Параметры.КоличествоСальдоДт = 0;
    				ОбластьМакет.Параметры.КоличествоСальдоКт = -ТекущееСальдоКолво;
    				
    			КонецЕсли;
    			
    		КонецЕсли;
    		
    	Иначе
    		
    		ОбластьМакет.Параметры.СуммаСальдоДт = СуммаОстатокДт;
    		ОбластьМакет.Параметры.СуммаСальдоКт = СуммаОстатокКт;
    		
    		Если ВыводитьИтогПоКоличеству Тогда
    			
    			ОбластьМакет.Параметры.КоличествоСальдоДт = КоличествоОстатокДт;
    			ОбластьМакет.Параметры.КоличествоСальдоКт = КоличествоОстатокКт;
    			
    		КонецЕсли;
    		
        КонецЕсли;
        
    Иначе
        // Иначе вывод по показателям.
        
        // Получаем массив показателей.
        // ВНИМАНИЕ: Массив показателей не должен содержать "Валютную сумму".
        МассивПоказателей = СтруктураПараметров.МассивПоказателей;
        
        КоличествоОстатокДт = ПривестиКЧислу(Остатки.КоличествоОстатокДт);
    	КоличествоОстатокКт = ПривестиКЧислу(Остатки.КоличествоОстатокКт);
        
    	ТекущееСальдоКолво = КоличествоОстатокДт - КоличествоОстатокКт;
        
        ТекстСальдоДт = "";
        ТекстСальдоКт = "";
        
        ЭтоПерваяСтрока = Истина;
        
        Для Каждого ТекПоказатель Из МассивПоказателей Цикл
            
            ИмяПоказателяДт = ТекПоказатель + "ОстатокДт";
            ИмяПоказателяКт = ТекПоказатель + "ОстатокКт";
            
            СуммаОстатокДт = ПривестиКЧислу(Остатки[ИмяПоказателяДт]);
            СуммаОстатокКт = ПривестиКЧислу(Остатки[ИмяПоказателяКт]);
            
            ТекущееСальдо = СуммаОстатокДт - СуммаОстатокКт;
            
            // Запишем текущее сальдо по текущему показателю.
            СтруктураПараметров.Вставить(ТекПоказатель + "ТекущееСальдо", ТекущееСальдо);
            
            Если СвСч.Вид = ВидСчета.АктивноПассивный Тогда
                
                Если СуммаОстатокДт > СуммаОстатокКт Тогда
                    
                    ТекСуммаСальдоДт = ТекущееСальдо;
                    ТекСуммаСальдоКт = 0;
                    
                    Если ЭтоПерваяСтрока И ВыводитьИтогПоКоличеству Тогда
                        
                        ОбластьМакет.Параметры.КоличествоСальдоДт = ТекущееСальдоКолво;
                        ОбластьМакет.Параметры.КоличествоСальдоКт = 0;
                        
                    КонецЕсли;
                    
                Иначе
                    
                    ТекСуммаСальдоДт = 0;
                    ТекСуммаСальдоКт = -ТекущееСальдо;
                    
                    Если ЭтоПерваяСтрока И ВыводитьИтогПоКоличеству Тогда
                        
                        ОбластьМакет.Параметры.КоличествоСальдоДт = 0;
                        ОбластьМакет.Параметры.КоличествоСальдоКт = -ТекущееСальдоКолво;
                        
                    КонецЕсли;
                    
                КонецЕсли;
                
            Иначе
                
                ТекСуммаСальдоДт = СуммаОстатокДт;
                ТекСуммаСальдоКт = СуммаОстатокКт;
                
                Если ЭтоПерваяСтрока И ВыводитьИтогПоКоличеству Тогда
                    
                    ОбластьМакет.Параметры.КоличествоСальдоДт = КоличествоОстатокДт;
                    ОбластьМакет.Параметры.КоличествоСальдоКт = КоличествоОстатокКт;
                    
                КонецЕсли;
                
            КонецЕсли;
            
            ТекстСальдоДт = ТекстСальдоДт + ?(ПустаяСтрока(ТекстСальдоДт), "", Символы.ПС)
                                          + ?(ТекСуммаСальдоДт <> 0, Формат(ТекСуммаСальдоДт, "ЧЦ=15; ЧДЦ=2"), "0,00");
                                          
            ТекстСальдоКт = ТекстСальдоКт + ?(ПустаяСтрока(ТекстСальдоКт), "", Символы.ПС)
                                          + ?(ТекСуммаСальдоКт <> 0, Формат(ТекСуммаСальдоКт, "ЧЦ=15; ЧДЦ=2"), "0,00");
                                          
            ЭтоПерваяСтрока = Ложь;
                                          
        КонецЦикла;
        
        ОбластьМакет.Параметры.СуммаСальдоДт = ТекстСальдоДт;
        ОбластьМакет.Параметры.СуммаСальдоКт = ТекстСальдоКт;
            
    КонецЕсли; // Если СтруктураПараметров = Неопределено Тогда.
       
КонецПроцедуры // ВывестиДанныеОстатковКарточкиСчетаВМакет()

// Процедура выводит данные остатков по оборотам в макет.
// 
// Параметры:
//  ЗапросПоОстаткам 	- Запрос.
//  ОбластьМакет 		- Область.
//  Счет 				- ПланСчетовСсылка.
//  ЗапросНаНачало 		- Запрос.
//  ТекущееСальдо 	  	- Число (По умолчанию = 0).
//  ТекущееСальдоКолво  - Число (По умолчанию = 0).
//  СтруктураПараметров - Структура (По умолчанию = Неопределено).
// 
Процедура ВывестиДанныеОстатковКарточкиСчетаСВалютойВМакет(ЗапросПоОстаткам, Знач ОбластьМакет, ОбластьВалютная, Знач Счет, Знач ЗапросНаНачало, 
													ТекущееСальдо = 0, ТекущееСальдоКолво = 0, СтруктураПараметров = Неопределено) Экспорт
													
	ОбластьМакет.Параметры.ОписательПериода = ?(ЗапросНаНачало, Нстр("ru = 'Сальдо на начало'"), Нстр("ru = 'Обороты и сальдо на конец'"));
	
	// Получаем массив показателей.
    // ВНИМАНИЕ: Массив показателей не должен содержать "Валютную сумму".
    МассивПоказателей = СтруктураПараметров.МассивПоказателей;
	
	РезультатЗапросаОстатки = ЗапросПоОстаткам.Выполнить();												
	Если РезультатЗапросаОстатки.Пустой() Тогда
		Для Каждого ТекПоказатель Из МассивПоказателей Цикл
       	 	// Запишем текущее сальдо по текущему показателю.
        	СтруктураПараметров.Вставить(ТекПоказатель + "ТекущееСальдо", 0);
		КонецЦикла;
		Возврат;	                           	
	КонецЕсли;
	
	Остатки = РезультатЗапросаОстатки.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	Остатки.Следующий();    	
    
    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
    
    ВыводитьИтогПоКоличеству = СвСч.Количественный;
	ВыводитьИтогПоВалюте	 = СвСч.Валютный;           
    
	КоличествоОстатокДт = Остатки.КоличествоОстатокДт;
	КоличествоОстатокКт = Остатки.КоличествоОстатокКт;
    
	ТекущееСальдоКолво = КоличествоОстатокДт - КоличествоОстатокКт;
	
	ТекстФлаг     = "";
	ТекстСальдо   = "";
	// ТекстСальдоДт = "";
	// ТекстСальдоКт = ""; 	
    
    ЭтоПерваяСтрока = Истина;
    
    Для Каждого ТекПоказатель Из МассивПоказателей Цикл
        
		ТекущееСальдо = Остатки[ТекПоказатель + "Остаток"];
        
        // Запишем текущее сальдо по текущему показателю.
        СтруктураПараметров.Вставить(ТекПоказатель + "ТекущееСальдо", ТекущееСальдо);
        
		ТекстФлаг 	  = ?(ПустаяСтрока(ТекстФлаг), "Д", ТекстФлаг + Символы.ПС + "Д");
		ТекстСальдо   = ТекстСальдо + ?(ПустаяСтрока(ТекстСальдо), "", Символы.ПС)
                                      + ?(ТекущееСальдо <> 0, Формат(ТекущееСальдо, "ЧЦ=15; ЧДЦ=2"), "0,00");
         
        ЭтоПерваяСтрока = Ложь;
                                      
    КонецЦикла;
	
	ОбластьМакет.Параметры.Флаг      		= ТекстФлаг;
	ОбластьМакет.Параметры.СуммаСальдо      = ТекстСальдо;
	Если ВыводитьИтогПоКоличеству Тогда	
		ОбластьМакет.Параметры.КоличествоСальдо = Остатки.КоличествоОстаток;
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Остатки в валюте
	Если Не ВыводитьИтогПоВалюте Тогда
		Возврат;
	КонецЕсли;
	
	ТекстВалюта 	 = "";
	ТекстВалФлаг 	 = "";
	ТекстВалСальдо   = "";
	ТекстВалСальдоДт = "";
    ТекстВалСальдоКт = "";
	
	ОстаткиВал = Остатки.Выбрать();
	Пока ОстаткиВал.Следующий() Цикл
		
		Валюта 					 = ОстаткиВал.Валюта;
		ТекВалютноеСальдо 		 = ОстаткиВал.ВалютнаяСуммаОстаток;// ТекВалютнаяСуммаСальдоДт - ТекВалютнаяСуммаСальдоКт;
		СтруктураПараметров.СоответствиеВалютное.Вставить(Валюта, ТекВалютноеСальдо);
	
		ТекстВалюта 	 = ТекстВалюта + ?(ПустаяСтрока(ТекстВалюта), "", Символы.ПС) + Строка(Валюта); 	                                  									  
		
		ТекстВалФлаг 	 = ?(ПустаяСтрока(ТекстВалФлаг), "Д", ТекстВалФлаг + Символы.ПС + "Д");
		ТекстВалСальдо   = ТекстВалСальдо + ?(ПустаяСтрока(ТекстВалСальдо), "", Символы.ПС)
                                      + ?(ТекВалютноеСальдо <> 0, Формат(ТекВалютноеСальдо, "ЧЦ=15; ЧДЦ=2"), "0,00");
									  
	КонецЦикла;
	
	ОбластьВалютная.Параметры.ОписательСальдо 		= ?(ЗапросНаНачало, Нстр("ru = 'Сальдо на начало'"), Нстр("ru = 'Сальдо на конец'"));;
	ОбластьВалютная.Параметры.Валюта 				= ТекстВалюта;
	ОбластьВалютная.Параметры.Флаг      			= ТекстВалФлаг;
	ОбластьВалютная.Параметры.ВалютнаяСуммаСальдо   = ТекстВалСальдо;
           
КонецПроцедуры // ВывестиДанныеОстатковКарточкиСчетаСВалютойВМакет()

// Проверка соответствия половины проводки установленным отборам пользователя.
// 
// Параметры
//  Выборка  		  - ВыборкаИзРезультатаЗапроса.
//  СторонаПроводки   - Строка - Дт/Кт.
//  ПостроительОтчета - ПостроительОтчета.
// 
// Возвращаемое значение:
//   Булево   - Соответствует или нет сторона проводки установленным отборам.
// 
Функция ЗначениеПоляСоответствуетОтбору(Выборка, Знач СторонаПроводки, ПостроительОтчета) Экспорт

	Результат = Истина;
	ЭтоЗначениеТабличнойЧасти = Ложь;
	
	Для Каждого ЭлементОтбора Из ПостроительОтчета.Отбор Цикл
	
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПоля = СтрЗаменить(ЭлементОтбора.ПутьКДанным, "Субконто", "Субконто" + СторонаПроводки);
		Если ВРЕГ(Лев(ЭлементОтбора.ПутьКДанным, 8)) = "СУБКОНТО" Тогда
			ИмяПоля = "Субконто" + СторонаПроводки + Сред(ЭлементОтбора.ПутьКДанным, 9);
		КонецЕсли;
		Если ВРЕГ(Лев(ЭлементОтбора.ПутьКДанным, 6)) = "ВАЛЮТА" Тогда
			ИмяПоля = "Валюта" + СторонаПроводки + Сред(ЭлементОтбора.ПутьКДанным, 7);
		КонецЕсли;
		Если ВРЕГ(Лев(ЭлементОтбора.ПутьКДанным, 11)) = "ОРГАНИЗАЦИЯ" Тогда
			Продолжить;
		КонецЕсли;
		
		ИндексТочки = Найти(ИмяПоля, ".");
		Если ИндексТочки <> 0 Тогда       			
			
			ИмяЧ1  = Лев(ИмяПоля, ИндексТочки - 1);
			ИмяЧ2  = Сред(ИмяПоля, ИндексТочки);
			ИмяЧ2_ = Сред(ИмяПоля, ИндексТочки + 1);  // Без точки
			       			
			ВремЗначение = Выборка[ИмяЧ1];
			ИндексТочки2  = Найти(ИмяЧ2_, ".");
			
			Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(ВремЗначение)) Тогда
				
				ЗначениеПоля = ВремЗначение;	
				
			ИначеЕсли ИндексТочки2 = 0 Тогда
			
				ЗначениеПоля = Неопределено;
				Выполнить("ЗначениеПоля = ВремЗначение" + ИмяЧ2);
				Если ТипЗнч(ЗначениеПоля) = Тип("Строка") Тогда
					ЗначениеПоля = СокрЛП(ЗначениеПоля);
				КонецЕсли; 
				
			Иначе
				
				ИмяЧ2_1 = Лев(ИмяЧ2_, ИндексТочки2 - 1); // Предположительно имя тч
				ИмяЧ2_2 = Сред(ИмяЧ2_, ИндексТочки2 + 1);

				ОбъектМета    = Метаданные.НайтиПоТипу(ТипЗнч(ВремЗначение));
				ЭтоСправочник = Метаданные.Справочники.Содержит(ОбъектМета);  				
							
				Если ЭтоСправочник И ОбъектМета.ТабличныеЧасти.Найти(ИмяЧ2_1) <> Неопределено Тогда
					
					ЭтоЗначениеТабличнойЧасти = Истина;
					
					Для каждого СтрТч Из ВремЗначение[ИмяЧ2_1] Цикл
						ЗначениеПоля = СтрТч[ИмяЧ2_2];
						Результат = ПроверитьЗначениеПоВидуСравнения(ЭлементОтбора, ЗначениеПоля);
						Если Результат Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
				Иначе
					
					ЗначениеПоля = Неопределено;
					Выполнить("ЗначениеПоля = ВремЗначение" + ИмяЧ2);
					Если ТипЗнч(ЗначениеПоля) = Тип("Строка") Тогда
						ЗначениеПоля = СокрЛП(ЗначениеПоля);
					КонецЕсли; 					
					
				КонецЕсли;
				
			КонецЕсли;
			
		Иначе
			
			ЗначениеПоля = Выборка[ИмяПоля];
			
		КонецЕсли;
		
		Если Не ЭтоЗначениеТабличнойЧасти Тогда
			Результат = ПроверитьЗначениеПоВидуСравнения(ЭлементОтбора, ЗначениеПоля);
		КонецЕсли;     		
		
		Если Не Результат Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;

	Возврат Результат;
	
КонецФункции // ЗначениеПоляСоответствуетОтбору()


// Функция возвращает суммы выборки в виде текста, отделенные
// между собой переносом строки.
// 
// Параметры:
//  МассивРесурсов 	   - Массив, массив ресурсов для которых необходимо получить суммы.
//  Выборка        	   - ВыборкаЗапроса, выборка с суммами.
//  ОкончаниеПараметра - Строка, окончание имени ресурсов с суммами.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьТекстСуммыРесурсов(МассивРесурсов, Выборка, ОкончаниеПараметра) Экспорт
    
    ТекстСумма = "";
    
    Для Каждого ТекРесурс Из МассивРесурсов Цикл
        
        Если ВРег(ТекРесурс) = "ВАЛЮТНАЯСУММА"
            Или ВРег(ТекРесурс) = "КОЛИЧЕСТВО" Тогда
            Продолжить;
        КонецЕсли;
        
        ТекстСумма = ТекстСумма + ?(ПустаяСтрока(ТекстСумма), "", Символы.ПС) 
                     + Формат(Выборка[ТекРесурс + ОкончаниеПараметра], "ЧЦ=15; ЧДЦ=2");
        
    КонецЦикла;
    
    Возврат ТекстСумма;
    
КонецФункции // ПолучитьТекстСуммыРесурсов()

// Функция для счета возвращает количество субконто для него.
// 
// Параметры:
//  Счет 			  - ПланСчетовСсылка.
//  СоответсвиеСчетов - Соответсвие.
// 
// Возвращаемое значение:
//  Число - Количество субконто счета.
// 
Функция ОпределитьДляСчетаКоличествоСубконтоПоСоответствию(Знач Счет, СоответсвиеСчетов) Экспорт
	
	СоответсвиеСчетов = Новый Соответствие;
	
	КоличествоСубконтоСчета = СоответсвиеСчетов[Счет];
	Если КоличествоСубконтоСчета = -1
		ИЛИ КоличествоСубконтоСчета = Неопределено Тогда
        
        СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
	
		КоличествоСубконтоСчета = СвСч.КоличествоСубконто;
		СоответсвиеСчетов[Счет] = КоличествоСубконтоСчета;
		
	КонецЕсли;

	Возврат КоличествоСубконтоСчета;
	
КонецФункции // ОпределитьДляСчетаКоличествоСубконтоПоСоответствию()

// Функция формирует массив субконто по счету.
// 
// Параметры:
//  Счет - ПланСчетовСсылка.
//  
// Возвращаемое значение:
//   Массив.
// 
Функция СформироватьМассивСубконтоПоСчету(Счет) Экспорт

	МассивСубконто = Счет.ВидыСубконто.ВыгрузитьКолонку("ВидСубконто");

	Возврат МассивСубконто;
	
КонецФункции // СформироватьМассивСубконтоПоСчету()

// Функция формирует список субконто по счету.
// 
// Параметры:
//  Счет 			  - ПланСчетовСсылка.
//  ВыбранныеСубконто - СписокЗначений (По умолчанию = Неопределено).
//  
// Возвращаемое значение:
//   СписокЗначений.
// 
Функция СформироватьСписокСубконтоПоСчету(Счет, ВыбранныеСубконто = Неопределено) Экспорт

	СписокСубконто = Новый СписокЗначений;
	
	// Массив выбранных видов субконто
	Если ВыбранныеСубконто = Неопределено Тогда
		МассивВыбранных = Новый Массив;
		ВыбратьВсе      = Истина;
	Иначе	
		МассивВыбранных = ВыбранныеСубконто.ВыгрузитьЗначения();
		ВыбратьВсе      = Ложь;
	КонецЕсли; 	
	
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл
		ИмяСубконто = "Субконто" + Строка(ВидСубконто.НомерСтроки);
		СписокСубконто.Добавить( ИмяСубконто
								, Строка(ВидСубконто.ВидСубконто)            
								, ВыбратьВсе Или МассивВыбранных.Найти(ИмяСубконто) <> Неопределено); 	                                 
	КонецЦикла;

	Возврат СписокСубконто;
	
КонецФункции // СформироватьСписокСубконтоПоСчету()
             
// Процедура заполняет таблицу разворота посубконто и ее представление.
// 
// Параметры:
//  ЭтаФорма			- УправляемаяФорма.
//  Ид   				- Число.
//  СписокСубконтоСчета - СписокЗначений.
//  ИмяТаблицы          - Строка (По умолчанию = "ПравилаВыводаИтогов").
// 
Процедура ЗаполнитьРазворотПоСубконтоПоСписку(ЭтаФорма, Ид, СписокСубконтоСчета, ИмяТаблицы = "ПравилаВыводаИтогов") Экспорт

	Если СписокСубконтоСчета = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекущиеДанные = ЭтаФорма[ИмяТаблицы].НайтиПоИдентификатору(Ид);
	
	ПредставлениеРазворота = "";
	
	ТекущиеДанные.РазворотПоСубконто.Очистить();
	
	Для каждого ЭлСписка Из СписокСубконтоСчета Цикл
		
		Если ЭлСписка.Пометка Тогда
			
			НоваяСтрокаРазворота = ТекущиеДанные.РазворотПоСубконто.Добавить();
			НоваяСтрокаРазворота.Имя 		   = ЭлСписка.Значение;
			НоваяСтрокаРазворота.Представление = ЭлСписка.Представление;
			ПредставлениеРазворота = ?(ПредставлениеРазворота = ""
										, ЭлСписка.Представление
										, ПредставлениеРазворота + ", " + ЭлСписка.Представление);
										
		КонецЕсли;
									
	КонецЦикла;
	
	ТекущиеДанные.ПредставлениеРазворотПоСубконто = ПредставлениеРазворота;	

КонецПроцедуры // ЗаполнитьРазворотПоСубконтоПоСписку()

// Процедура выполняет действия, необходимые при изменении кор счета в таблице правил вывода итогов.
// 
// Параметры:
//  ЭтаФорма   - УправляемаяФорма.
//  Ид   	   - Число.
//  ИмяТаблицы - Строка (По умолчанию = "ПравилаВыводаИтогов").
// 
Процедура ИзменениеСчетаТаблицыПравилВывода(ЭтаФорма, Ид, ИмяТаблицы = "ПравилаВыводаИтогов") Экспорт
	
	ТекущиеДанные = ЭтаФорма[ИмяТаблицы].НайтиПоИдентификатору(Ид);
	ТекСчет 	  = ТекущиеДанные.Счет;
	         	
	// Проверка существования субсчетов счета
	ВыборкаПоСчету = ПланыСчетов[ТекСчет.Метаданные().Имя].Выбрать(ТекСчет);
	ТекущиеДанные.Субсчета = ВыборкаПоСчету.Следующий(); 
	
	// Список видов субконто счета
	СписокСубконтоСчета = СформироватьСписокСубконтоПоСчету(ТекСчет);
	              	
	Если СписокСубконтоСчета.Количество() > 0 Тогда
		
		ЗаполнитьРазворотПоСубконтоПоСписку(ЭтаФорма, Ид, СписокСубконтоСчета, ИмяТаблицы);
		
	ИначеЕсли Не ТекущиеДанные.Субсчета	Тогда
		
		// Если у счета нет ни субсчетов, ни субконто, не дадим его выбрать.
		ТекстРазъяснений = Символы.ПС 
							+ ?(ИмяТаблицы = "ПравилаВыводаИтогов"
							, Нстр("ru = 'Настройка итогов по кор.субсчетам и кор.субконто не имеет смысла!'")
							, Нстр("ru = 'Настройка развернутого сальдо не имеет смысла!'"));
		ТекстСообщения = Нстр("ru = 'Счет ""%1%"" не имеет ни субсчетов, ни субконто.'") + ТекстРазъяснений;
		ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ТекСчет.Код);
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		
		ТекущиеДанные.Счет = Неопределено;
		ТекущиеДанные.РазворотПоСубконто.Очистить();
		ТекущиеДанные.ПредставлениеРазворотПоСубконто = "";
				
	КонецЕсли;
	
КонецПроцедуры // ИзменениеСчетаТаблицыПравилВывода()

// Процедура выводит представления субконто для текущей строки отчета в макет.
// 
// Параметры:
//  ПрефиксНаименованияКолонки - Строка.
//  Проводки 				   - Движения.
//  КоличествоСубконтоСчета    - Число.
//  ОбластьМакет 			   - ОбластьМакета.
//  ДокументРезультат 		   - ТабличныйДокумент.
//  СтруктураРасшифровки 	   - Структура.
// 
Процедура ВывестиПредставленияСубконтоТекущейСтрокиВМакет(Знач ПрефиксНаименованияКолонки, Проводки, Знач КоличествоСубконтоСчета, 
															ОбластьМакет, ДокументРезультат, СтруктураРасшифровки) Экспорт
	
	Для Индекс = 0 По КоличествоСубконтоСчета - 1 Цикл

		ОбластьМакет.Параметры.Содержание = ?(НЕ ЗначениеЗаполнено(Проводки[ПрефиксНаименованияКолонки + Строка(Индекс + 1)])
			, "<...>"
			, Проводки[ПрефиксНаименованияКолонки + Строка(Индекс + 1) + "Представление"]);

		ОбластьМакет.Параметры.Расшифровка = СтруктураРасшифровки;
		ДокументРезультат.Вывести(ОбластьМакет);

	КонецЦикла;
	
КонецПроцедуры // ВывестиПредставленияСубконтоТекущейСтрокиВМакет()
        
// Субконто

// Процедура удаляет строки с пустым субконто из таблицы.
// 
// Параметры:
//  ТабЧастьСубконто - Табличная часть.
// 
Процедура УдалитьПустыеСубконтоИзТабличнойЧасти(ТабЧастьСубконто) Экспорт
	
	СчСубконто = ТабЧастьСубконто.Количество() - 1;
	Пока СчСубконто >= 0 Цикл
						
		Если НЕ ЗначениеЗаполнено(ТабЧастьСубконто[СчСубконто].ВидСубконто) Тогда
			
			ТабЧастьСубконто.Удалить(СчСубконто);
			
		КонецЕсли;
		
		СчСубконто = СчСубконто - 1;
		
	КонецЦикла;
	
КонецПроцедуры // УдалитьПустыеСубконтоИзТабличнойЧасти()

// Процедура изменяет типы у отборов построителя по субконто.
// 
// Параметры:
//  ПостроительОтчета - ПостроительОтчета.
//  МассивСубконто 	  - Массив.
//  ДтКт			  - Строка (По умолчанию = "").
// 
Процедура УстановитьТипыОтборовПостроителяПоСубконто(ПостроительОтчета, МассивСубконто, ДтКт = "") Экспорт
	
	НачалоПредставления = ?(ДтКт = "", "", ДтКт + " ");
	
	Сч = 0;
	
	Для каждого Элемент Из МассивСубконто Цикл
		
		Сч = Сч + 1;
		Поле = ПостроительОтчета.ДоступныеПоля.Найти("Субконто" + ДтКт + Сч);		
		Если Поле <> Неопределено Тогда 			
			Поле.ТипЗначения   = Элемент.ТипЗначения;
			Поле.Представление = НачалоПредставления + Элемент.Наименование; // + " (субконто)"; 			
		КонецЕсли;
	
	КонецЦикла;
	
	// Представления кор субконто
	Для Сч = 1 По 4 Цикл
		
		Поле = ПостроительОтчета.ДоступныеПоля.Найти("КорСубконто" + Сч);
		Если Поле <> Неопределено Тогда
			Поле.Представление = "Кор. Субконто " + Сч;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // УстановитьТипыОтборовПостроителяПоСубконто()

// Функция возвращает строку ограничений по типу субконто.
// 
// Параметры:
//  Запрос 			   	   - Запрос.
//  МассивСубконто  	   - Массив.
//  ИмяРегистраБухгалтерии - Строка.
//  ИмяТаблицыСвязки 	   - Строка.
// 
// Возвращаемое значение:
//  Строка - текущее ограничение.
// 
Функция СформироватьОграниченияПоТипуСубконто(Запрос, Знач МассивСубконто, Знач ИмяРегистраБухгалтерии, Знач ИмяТаблицыСвязки) Экспорт
	
	ТекущееОграничений = "";
	НомерОграничения = 1;
	
	Для Каждого ЭлементМассиваСубконто Из МассивСубконто Цикл
		
		Если Не ПустаяСтрока(ТекущееОграничений) Тогда
			
			ТекущееОграничений = ТекущееОграничений + Символы.ПС + "И" + Символы.ПС;
			
		КонецЕсли;
		
		АлиасТаблицыОграничения = "Суб" + Строка(НомерОграничения);
		ЗначениеТаблицыОграничения =  "Вид" + Строка(НомерОграничения);
		
		ТекущееОграничений = ТекущееОграничений + " 1 В (Выбрать ПЕРВЫЕ 1 1 ИЗ РегистрБухгалтерии." + ИмяРегистраБухгалтерии + ".Субконто КАК " + АлиасТаблицыОграничения + "
			|ГДЕ " + АлиасТаблицыОграничения + ".Регистратор = " + ИмяТаблицыСвязки + ".Регистратор
			|		И " + АлиасТаблицыОграничения + ".НомерСтроки = " + ИмяТаблицыСвязки + ".НомерСтроки
			|		И  " + АлиасТаблицыОграничения + ".Вид = &" + ЗначениеТаблицыОграничения + ")";
			
		Запрос.УстановитьПараметр(ЗначениеТаблицыОграничения + Строка(НомерОграничения), ЭлементМассиваСубконто);	
			
		НомерОграничения = НомерОграничения + 1;
		
	КонецЦикла;
				
	Возврат ТекущееОграничений;			
	
КонецФункции // СформироватьОграниченияПоТипуСубконто()

// Функция возврашает структуру с признаками учета субконто.
// 
// Параметры:
//  ИмяРегистраБухгалтерии - Строка, имя регистра бухгалтерии.
//  МассивВидыСубконто     - Массив, виды субконто для которых необходимо определеить признаки учета.
// 
// Возвращаемое значение:
//  Структура.
// 
Функция ОпределитьПризнакиУчетаСубконтоРегистраБухгалтерии(ИмяРегистраБухгалтерии, МассивВидыСубконто) Экспорт 
    
    ЕстьВалюта     = Ложь;
	ЕстьКоличество = Ложь;
    
    Если МассивВидыСубконто.Количество() <> 0 Тогда
    
        МетаданныеПланСчетов = Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].ПланСчетов;
        
        // Проверим наличие количественного и валютного учета у субконто плана счетов.
        ЕстьКоличественныйИВалютныйПризнакУСубконто = МетаданныеПланСчетов.ПризнакиУчетаСубконто.Найти("Количественный") <> Неопределено
                                                      И МетаданныеПланСчетов.ПризнакиУчетаСубконто.Найти("Валютный") <> Неопределено;
        
    	// Определим признаки учета субконто, которые могут быть использованы.
    	ИмяПланаСчетов = МетаданныеПланСчетов.Имя;
        
        ЗапросСчета = Новый Запрос;
        ЗапросСчета.УстановитьПараметр("ВидСубконто", МассивВидыСубконто);
        
        Если ЕстьКоличественныйИВалютныйПризнакУСубконто Тогда
            
            ЗапросСчета.Текст = 
            "ВЫБРАТЬ
            |   (ВидыСубконто.Валютный
            |       И ВидыСубконто.Ссылка.Валютный) КАК Валютный,
            |   (ВидыСубконто.Количественный
            |       И ВидыСубконто.Ссылка.Количественный) КАК Количественный
            |ПОМЕСТИТЬ ВременнаяТаблица
            |ИЗ
            |   ПланСчетов." + ИмяПланаСчетов + ".ВидыСубконто КАК ВидыСубконто
            |ГДЕ
            |   ВидыСубконто.ВидСубконто В(&ВидСубконто)
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|ВЫБРАТЬ
			|	ЛОЖЬ,
			|	ЛОЖЬ
            |;
            |
            |////////////////////////////////////////////////////////////////////////////////
            |ВЫБРАТЬ
			|   МАКСИМУМ(ЕСТЬNULL(ВременнаяТаблица.Валютный		 , Ложь)) КАК Валютный,
			|   МАКСИМУМ(ЕСТЬNULL(ВременнаяТаблица.Количественный, Ложь)) КАК Количественный
            |ИЗ
            |   ВременнаяТаблица КАК ВременнаяТаблица
            |;
            |
            |////////////////////////////////////////////////////////////////////////////////
            |УНИЧТОЖИТЬ ВременнаяТаблица
			|";
            
        Иначе
            
            ЗапросСчета.Текст =
            "ВЫБРАТЬ
			|	МАКСИМУМ(ЕСТЬNULL(ВидыСубконто.Ссылка.Валютный, ЛОЖЬ)) КАК Валютный,
			|	МАКСИМУМ(ЕСТЬNULL(ВидыСубконто.Ссылка.Количественный, ЛОЖЬ)) КАК Количественный
			|ПОМЕСТИТЬ ВремТабл
			|ИЗ
			|	ПланСчетов." + ИмяПланаСчетов + ".ВидыСубконто КАК ВидыСубконто
			|ГДЕ
			|	ВидыСубконто.ВидСубконто В(&ВидСубконто)
            |
			|ОБЪЕДИНИТЬ ВСЕ
			|ВЫБРАТЬ
			|	ЛОЖЬ,
			|	ЛОЖЬ
			|;
            |
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	МАКСИМУМ(ВремТабл.Валютный) КАК Валютный,
			|	МАКСИМУМ(ВремТабл.Количественный) КАК Количественный
			|ИЗ
			|	ВремТабл КАК ВремТабл
			|;
            |
			|////////////////////////////////////////////////////////////////////////////////
			|УНИЧТОЖИТЬ ВремТабл
			|";
            
        КонецЕсли;
        
        РезультатЗапроса = ЗапросСчета.Выполнить();
        
        Если Не РезультатЗапроса.Пустой() Тогда
            
            ВыборкаЗапроса = РезультатЗапроса.Выбрать();
            
			Если ВыборкаЗапроса.Следующий() Тогда
				ЕстьВалюта     = ВыборкаЗапроса.Валютный;
                ЕстьКоличество = ВыборкаЗапроса.Количественный;
            КонецЕсли;
            
        КонецЕсли;
    
    КонецЕсли; // Если МассивВидыСубконто.Количество() <> 0 Тогда.
    
    СтруктураУчета = Новый Структура;
    СтруктураУчета.Вставить("ЕстьВалюта"    , ЕстьВалюта);
    СтруктураУчета.Вставить("ЕстьКоличество", ЕстьКоличество);
    
    Возврат СтруктураУчета;
    
КонецФункции // ОпределитьПризнакиУчетаСубконтоРегистраБухгалтерии()

// Функция определяет по построителю отчета и имени субконто вести про нему количественный учет или нет.
// 
// Параметры:
//  Счет 	   		  				   - ПланСчетовСсылка.
//  ПостроительОтчета 				   - ПостроительОтчета.
//  Измерение 		  				   - Строка.
//  ЕстьКоличественныйПризнакУСубконто - Булево.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ОпределитьПоСубконтоИПостроителюВестиКоличественныйУчет(Счет, ПостроительОтчета, Знач Измерение,
                                                                ЕстьКоличественныйПризнакУСубконто = Истина) Экспорт
                                                                                                                               
	Если Врег(Измерение) = "СЧЕТ" Тогда  		
		Возврат Ложь;		
	КонецЕсли;
	
	ИзмерениеПостроителя = ПостроительОтчета.ИзмеренияСтроки.Найти(Измерение);
	Если ИзмерениеПостроителя <> Неопределено Тогда  				
		ИмяПоля = ИзмерениеПостроителя.ПутьКДанным;  				
		поз 	= Найти(ИмяПоля, ".");
		ИмяПоля = ?(поз = 0, ИмяПоля, Лев(ИмяПоля, поз - 1)); 			
	Иначе
		ИмяПоля = Измерение; 
	КонецЕсли;
	
	Попытка 		
		ИндСубконто = Число(Сред(ИмяПоля, СтрДлина("Субконто") + 1)); 		
	Исключение 		
		Возврат Ложь;  		
	КонецПопытки;
    
    Если ЕстьКоличественныйПризнакУСубконто Тогда
        ВыводКоличества = Счет.ВидыСубконто[ИндСубконто - 1].Количественный;
    Иначе
        СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
        ВыводКоличества = СвСч.Количественный;
    КонецЕсли;
    	
	Возврат ВыводКоличества;
	
КонецФункции // ОпределитьПоСубконтоИПостроителюВестиКоличественныйУчет()

// Корреспонденции

// Процедура создает колонки для корреспонденции плана счетов.
// 
// Параметры:
//  Корреспонденции - ТаблицаЗначений.
//  ИмяПланаСчетов  - Строка.
// 
Процедура СоздатьКолонкиОграниченийДляКорреспонденцииПланаСчетов(Корреспонденции, Знач ИмяПланаСчетов) Экспорт
	
	ОписаниеТиповПланСчетов 	 = Новый ОписаниеТипов("ПланСчетовСсылка." + ИмяПланаСчетов);
	ОписаниеТиповТаблицаЗначений = Новый ОписаниеТипов("ТаблицаЗначений");
	ОписаниеТиповСтрока 		 = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(200));

	Если Не Корреспонденции.Колонки.Количество() = 0 Тогда
		
		Если Не Корреспонденции.Колонки.Найти("СчетДт") = Неопределено
			И Не Корреспонденции.Колонки.Найти("СчетКт") = Неопределено Тогда
			
			Если Корреспонденции.Колонки.СчетДт.ТипЗначения = ОписаниеТиповПланСчетов Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Корреспонденции.Колонки.Очистить();
	Корреспонденции.Колонки.Добавить("СчетДт"				, ОписаниеТиповПланСчетов, "Дебет");
	Корреспонденции.Колонки.Добавить("СчетКт"				, ОписаниеТиповПланСчетов, "Кредит");
	Корреспонденции.Колонки.Добавить("Субконто"				, ОписаниеТиповТаблицаЗначений);
	Корреспонденции.Колонки.Добавить("ПредставлениеСубконто", ОписаниеТиповСтрока);
	
КонецПроцедуры // СоздатьКолонкиОграниченийДляКорреспонденцииПланаСчетов()

// Функция формирует строку описания корреспонденций для заголовка отчета.
// 
// Параметры:
//  Корреспонденции - ТаблицаЗначений.
// 
// Возвращаемое значение:
//  СтрокаОписания - Строка.
// 
Функция СформироватьОписаниеКорреспондеции(Корреспонденции) Экспорт

	СтрокаОписания = "";

	Для каждого СтрокаТаб Из Корреспонденции Цикл
		
		СчетДтЗаполнен = ЗначениеЗаполнено(СтрокаТаб.СчетДт);
		СчетКтЗаполнен = ЗначениеЗаполнено(СтрокаТаб.СчетКт);
		
		
		СтрокаКор = ?(СчетДтЗаполнен, Строка(СтрокаТаб.СчетДт), "*")
					 + "," 
					 + ?(СчетКтЗаполнен, Строка(СтрокаТаб.СчетКт), "*")
					 + ?(ПустаяСтрока(СтрокаТаб.ПредставлениеСубконто), "", ", " + СтрокаТаб.ПредставлениеСубконто);
		
		СтрокаОписания = СтрокаОписания + ?(ПустаяСтрока(СтрокаОписания), "", "; ") + СтрокаКор;
		
	КонецЦикла;

	Возврат СтрокаОписания;

КонецФункции // СформироватьОписаниеКорреспондеции()

// Обороты счета

// Процедура выводит заголовок для отчета обороты счета.
// 
// Параметры:
//  Выборка 		  		- ВыборкаИзЗапроса.
//  ШиринаТаблицы 	  		- Число.
//  ОбъектОтчет 	 		- ОбъектОтчет.
//  Макет 			  		- Макет.
//  ДокументРезультат 		- ТабличныйДокумент.
//  РезультатЗапроса  		- РезультатЗапроса.
//  ИмяСтроки 		  		- Строка.
//  МассивРесурсов    		- Массив.
//  СписокДт 		  		- СписокЗначений.
//  СписокКт 		  		- СписокЗначений.
//  ДополнениеКУровнюВывода - Число.
//  ВыборкаИтогов 	  		- выборка с суммами.
//  ОбщийИтог 	 	  		- выборка с суммами.
// 
Процедура ВывестиПолныйЗаголовокОтчетаОборотовСчета(Выборка = Неопределено, ШиринаТаблицы, ОбъектОтчет, Макет, ДокументРезультат,
	РезультатЗапроса, Знач ИмяСтроки, МассивРесурсов, СписокДт, СписокКт, Знач ДополнениеКУровнюВывода = 0, Знач ВыборкаИтогов = Неопределено, 
	Знач ОбщийИтог = Неопределено) Экспорт
     
	// Вывод заголовков нач.сальдо
	Если ОбъектОтчет.СальдоНачДт Тогда
		ОблСальдоНачДт = Макет.ПолучитьОбласть(ИмяСтроки + "|СальдоНачДт");
        Если ВыборкаИтогов <> Неопределено Тогда
            ОблСальдоНачДт.Параметры.СуммаНачДт = ПолучитьТекстСуммыРесурсов(МассивРесурсов, ВыборкаИтогов, "НачДт");
            // ОблСальдоНачДт.Параметры.Заполнить(ВыборкаИтогов);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблСальдоНачДт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблСальдоНачДт.ШиринаТаблицы;
	КонецЕсли;
	
	Если ОбъектОтчет.СальдоНачКт Тогда
		ОблСальдоНачКт = Макет.ПолучитьОбласть(ИмяСтроки + "|СальдоНачКт");
        Если ВыборкаИтогов <> Неопределено Тогда
            ОблСальдоНачКт.Параметры.СуммаНачКт = ПолучитьТекстСуммыРесурсов(МассивРесурсов, ВыборкаИтогов, "НачКт");
            // ОблСальдоНачКт.Параметры.Заполнить(ВыборкаИтогов);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблСальдоНачКт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблСальдоНачКт.ШиринаТаблицы;
	КонецЕсли;
	
	// Вывод заголовков оборотов
	Если ОбъектОтчет.ОборотДт Тогда
		ОблОборотДт = Макет.ПолучитьОбласть(ИмяСтроки+"|ОборотДт");
        Если ОбщийИтог <> Неопределено Тогда
            ОблОборотДт.Параметры.СуммаОборотДт = ПолучитьТекстСуммыРесурсов(МассивРесурсов, ОбщийИтог, "ОборотДт");
            // ОблОборотДт.Параметры.Заполнить(ОбщийИтог);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблОборотДт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблОборотДт.ШиринаТаблицы;
	КонецЕсли;
    
	// Вывод кор счетов с дебетовыми оборотами
	Если Выборка = Неопределено Тогда
		Выборка = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "КорСчет", "Все");
	Иначе
		Выборка.Сбросить();
	КонецЕсли;
	
	// Вывод заголовков для корреспондирующих счетов.
	СписокДт = Новый СписокЗначений;
	Если ОбъектОтчет.ОборотДтКорСчета Тогда
		
		ВывестиЗаголовкиОборотовОтчетаОборотыСчета(Макет, ИмяСтроки+"|ОборотДтКорсчет", Выборка,
			ДокументРезультат, ОбъектОтчет.ПоСубсчетамКорСчетов, ВидДвиженияБухгалтерии.Дебет, МассивРесурсов, СписокДт, ДополнениеКУровнюВывода);
						
	КонецЕсли;
	
	// Вывод данных по кредитовому обороту
	Если ОбъектОтчет.ОборотКт Тогда
		ОблОборотКт = Макет.ПолучитьОбласть(ИмяСтроки+"|ОборотКт");
        Если ОбщийИтог <> Неопределено Тогда
            ОблОборотКт.Параметры.СуммаОборотКт = ПолучитьТекстСуммыРесурсов(МассивРесурсов, ОбщийИтог, "ОборотКт");
            // ОблОборотКт.Параметры.Заполнить(ОбщийИтог);
		КонецЕсли;
		ДокументРезультат.Присоединить(ОблОборотКт, 0);
		ШиринаТаблицы = ШиринаТаблицы + ОблОборотКт.ШиринаТаблицы;
	КонецЕсли;
	
	// Вывод кор счетов с кредитовыми оборотами
	СписокКт = Новый СписокЗначений;
	
	Выборка.Сбросить();
	Если ОбъектОтчет.ОборотКтКорСчета Тогда
		
		ВывестиЗаголовкиОборотовОтчетаОборотыСчета(Макет, ИмяСтроки+"|ОборотКтКорсчет", Выборка, 
			ДокументРезультат, ОбъектОтчет.ПоСубсчетамКорСчетов, ВидДвиженияБухгалтерии.Кредит, МассивРесурсов, СписокКт, ДополнениеКУровнюВывода);
			
	КонецЕсли;
	
    
    Если ДополнениеКУровнюВывода <> 0 Тогда
		
		Если ОбъектОтчет.СальдоКонДт Тогда
			ОблСальдоКонДт = Макет.ПолучитьОбласть(ИмяСтроки + "|СальдоКонДт");
			ДокументРезультат.Присоединить(ОблСальдоКонДт, 0);
			ШиринаТаблицы = ШиринаТаблицы + ОблСальдоКонДт.ШиринаТаблицы;
		КонецЕсли;
		
		Если ОбъектОтчет.СальдоКонКт Тогда
			ОблСальдоКонКт = Макет.ПолучитьОбласть(ИмяСтроки + "|СальдоКонКт");
			ДокументРезультат.Присоединить(ОблСальдоКонКт, 0);
			ШиринаТаблицы = ШиринаТаблицы + ОблСальдоКонКт.ШиринаТаблицы;
		КонецЕсли;
		
	КонецЕсли;
       
КонецПроцедуры // ВывестиПолныйЗаголовокОтчетаОборотовСчета()

// Функция возвращает соответствие счетов предков.
// 
// Параметры:
//  ИмяПланаСчетов - Строка.
//  Счет 		   - ПланСчетовСсылка[ИмяПланаСчетов].
// 
// Возвращаемое значение:
//  Соответствие.
// 
Функция ВернутьСоответвиеСчетовПредков(Знач ИмяПланаСчетов = "", Знач Счет) Экспорт
	
	ЗапросСчета = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ПланСчетовРегистра.Ссылка КАК Ссылка
		|ИЗ
		|	ПланСчетов." + ИмяПланаСчетов + " КАК ПланСчетовРегистра
		|
		|ГДЕ
		|	ПланСчетовРегистра.Ссылка = &Ссылка
		|
		|ИТОГИ ПО
		|	Ссылка ИЕРАРХИЯ");
	
	ЗапросСчета.УстановитьПараметр("Ссылка", Счет);
	
	ВыборкаСчета = ЗапросСчета.Выполнить().Выбрать(ОбходРезультатаЗапроса.Прямой);
	
	СоответсвиеСчетов = Новый Соответствие();
	Пока ВыборкаСчета.Следующий() Цикл
		СоответсвиеСчетов.Вставить(ВыборкаСчета.Ссылка, ВыборкаСчета.Ссылка);
	КонецЦикла;

	Возврат СоответсвиеСчетов;
	
КонецФункции // ВернутьСоответвиеСчетовПредков()

// Функция создает структуру таблицы для хранения данных об отборе по субконто каждой корреспонденции.
// 
// Параметры:
//  ДобавлятьКолонкуИспользования - Булево.
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция СоздатьТаблицуДляХраненияОтбора(Знач ДобавлятьКолонкуИспользования = Ложь) Экспорт
	
	ТаблицаОтбора = Новый ТаблицаЗначений();
		
	ТаблицаОтбора.Колонки.Добавить("Имя"		  , Новый ОписаниеТипов("Строка"));
	ТаблицаОтбора.Колонки.Добавить("ПутьКДанным"  , Новый ОписаниеТипов("Строка"));
	ТаблицаОтбора.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	ТаблицаОтбора.Колонки.Добавить("ВидСравнения" , Новый ОписаниеТипов("ВидСравнения"));
	ТаблицаОтбора.Колонки.Добавить("Значение");
	ТаблицаОтбора.Колонки.Добавить("ЗначениеС");
	ТаблицаОтбора.Колонки.Добавить("ЗначениеПо");
	
	Если ДобавлятьКолонкуИспользования Тогда
		ТаблицаОтбора.Колонки.Добавить("Использование");
	КонецЕсли;
	
	Возврат ТаблицаОтбора;
	
КонецФункции // СоздатьТаблицуДляХраненияОтбора()

// Процедура заменяет в структуре отборы на отборы ДТ и КТ.
// 
// Параметры:
//  ОтборДляРасшифровки 	 - ТаблицаЗначений.
//  РасшифровкаОтборПоСчетам - Структура.
//  ВидОборота 			 	 - Строка.
// 
Процедура ЗаменитьОбщиеОтборыНаОтборыДтКт(ОтборДляРасшифровки, РасшифровкаОтборПоСчетам, Знач ВидОборота) Экспорт
	
	Если ОтборДляРасшифровки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ОтборДляРасшифровки) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицы Из ОтборДляРасшифровки Цикл
						
			НовоеИмя = ?(ВидОборота = "ДТ"
						, СтрЗаменить(СтрокаТаблицы.Имя, "Субконто", "СубконтоДт")
						, СтрЗаменить(СтрокаТаблицы.Имя, "Субконто", "СубконтоКт"));
						
			НовоеПутьКданным = ?(ВидОборота = "ДТ"
						, СтрЗаменить(СтрокаТаблицы.ПутьКданным, "Субконто", "СубконтоДт")
						, СтрЗаменить(СтрокаТаблицы.ПутьКданным, "Субконто", "СубконтоКт"));
			
			СтрокаТаблицы.Имя 		  = НовоеИмя;
			СтрокаТаблицы.ПутьКданным = НовоеПутьКданным;
												
		КонецЦикла;
		
	Иначе	
	
		Для каждого соот Из ОтборДляРасшифровки Цикл
			
			Если Найти(соот.Ключ, "Субконто") = 0 Тогда
				Продолжить;
			КонецЕсли;
						
			ИмяКлюча = ?(ВидОборота = "ДТ"
						, СтрЗаменить(соот.Ключ, "Субконто", "СубконтоДт")
						, СтрЗаменить(соот.Ключ, "Субконто", "СубконтоКт"));
						
			РасшифровкаОтборПоСчетам.Вставить(ИмяКлюча, соот.Значение);
									
		КонецЦикла;
	
	КонецЕсли;
		
КонецПроцедуры // ЗаменитьОбщиеОтборыНаОтборыДтКт()

// ОСВ

// Функция дополняет текст часть сформированного запроса по определенным полям.
// 
// Параметры:
//  МассивПоказателей   	   - Массив.
//  ПоляДляВыборки 	  		   - Булево.
//  ИспользоватьАлиасыПолей    - Булево.
//  ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя - Булево.
//  ПолучатьРазвернутыйОстаток - Булево.
// 
// Возвращаемое значение:
//  СтрокаЗапроса - Строка.
// 
Функция ВернутьЧастьЗапросаПоВыборкеПолейОборотноСальдоваяВедомость(МассивПоказателей, Знач ПоляДляВыборки = Истина, 
		Знач ИспользоватьАлиасыПолей = Ложь, Знач ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя = Ложь, ПолучатьРазвернутыйОстаток = Ложь,
        ОчищатьИтоги = Ложь) Экспорт
		
	СтрокаЗапроса = "";	
	РазвернутыйОстаток = ?(ПолучатьРазвернутыйОстаток, "Развернутый", "");
			
	Если ПоляДляВыборки Тогда
		
		Если ИспользоватьАлиасыПолей Тогда
			// Выборка с алиасами
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				СтрокаПрефикса = ?(ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя, ИмяПоказателя, ""); 
							
				СтрокаЗапроса =  СтрокаЗапроса + ",
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт КАК " + СтрокаПрефикса + "НачальныйОстатокДт,
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт КАК " + СтрокаПрефикса + "НачальныйОстатокКт,
				|	" + ИмяПоказателя + "ОборотДт КАК "                                     + СтрокаПрефикса + "ОборотДт,
				|	" + ИмяПоказателя + "ОборотКт КАК "                                     + СтрокаПрефикса + "ОборотКт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт КАК "  + СтрокаПрефикса + "КонечныйОстатокДт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт КАК "  + СтрокаПрефикса + "КонечныйОстатокКт";
					
			КонецЦикла;
			
		Иначе	
			// Выборка без алиасов
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				СтрокаЗапроса =  СтрокаЗапроса + ",
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт,
				|	" + ИмяПоказателя + "ОборотДт,
				|	" + ИмяПоказателя + "ОборотКт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт";
								
			КонецЦикла;
            	

		КонецЕсли;	
		
	Иначе
		// Выборка для суммирования
		Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
            
            Если ОчищатьИтоги 
                И ИмяПоказателя = "СуммаСценарий" Тогда
                
                // Итоги по сценариям не суммируются,
                // т.к. они в разных валютах.
                СтрокаЗапроса = СтрокаЗапроса + ",
    			|	0 КАК СуммаСценарийНачальный" + РазвернутыйОстаток + "ОстатокДт,
    			|	0 КАК СуммаСценарийНачальный" + РазвернутыйОстаток + "ОстатокКт,
    			|	0 КАК СуммаСценарийОборотДт,
    			|	0 КАК СуммаСценарийОборотКт,
    			|	0 КАК СуммаСценарийКонечный" + РазвернутыйОстаток + "ОстатокДт,
    			|	0 КАК СуммаСценарийКонечный" + РазвернутыйОстаток + "ОстатокКт";
                
            Иначе
    			СтрокаЗапроса = СтрокаЗапроса + ",
    			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт),
    			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт),
    			|	СУММА(" + ИмяПоказателя + "ОборотДт),
    			|	СУММА(" + ИмяПоказателя + "ОборотКт),
    			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт),
    			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт)";
            КонецЕсли;
					
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтрокаЗапроса;
	
КонецФункции // ВернутьЧастьЗапросаПоВыборкеПолейОборотноСальдоваяВедомость()

// Функция формирует текст строки запроса для выборки данных оборотов и остатков регистра бухгалтерии.
// 
// Параметры:
//  СтруктураПараметров   - Структура.
//  ИмяАлиасаТаблицы 	  - Строка.
//  ДопОграничениеПоСчету - Строка.
// 
// Возвращаемое значение:
//  СтрокаЧастиЗапроса - Строка.
// 
Функция СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, 
	Знач ИмяАлиасаТаблицы = "ОстаткиИОбороты", Знач ДопОграничениеПоСчету = "", Запрос = Неопределено, 
	//ПостроительОтчета = Неопределено, СтруктураПолейОтбораПостроителя = Неопределено) Экспорт
    ПостроительОтчета = Неопределено, СтруктураПолейОтбораПостроителя = Неопределено, Строка = Неопределено, Данные = Неопределено) Экспорт
    
	СтрокаОграниченийПоРеквизитам = "";
	Если Строка <> неопределено Тогда 
		ДополнитьСтрокуОграниченийПоРеквизитамДоп(СтрокаОграниченийПоРеквизитам, "Организация", Строка.Организация,"Организация"+Данные.Номер);
		 Запрос.УстановитьПараметр("Организация"+Данные.Номер,Строка.Организация);
	Иначе
		Если СтруктураПараметров.СтруктураОграничений.Свойство("Организация") Тогда
			ДополнитьСтрокуОграниченийПоОрганизации(СтрокаОграниченийПоРеквизитам, СтруктураПараметров.СтруктураОграничений.Организация, СтруктураПараметров.СтруктураОграничений.ОрганизацияВидСравнения, СтруктураПараметров.СтруктураОграничений.ОрганизацияИспользование);
		КонецЕсли;
	КонецЕсли;
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "ВидУчета"	, СтруктураПараметров.СтруктураОграничений.ВидУчета);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "ОтражениеВНУ", СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Валюта"		, СтруктураПараметров.СтруктураОграничений.Валюта);
	ДополнитьСтрокуОграниченийПоРеквизитам(СтрокаОграниченийПоРеквизитам, "Сценарий"	, СтруктураПараметров.СтруктураОграничений.Сценарий);
    
    Если ПостроительОтчета = Неопределено Тогда
        ОграниченияПоПостроителюОтчета = "";
    Иначе
        ОграниченияПоПостроителюОтчета = ПолучитьТекстОграниченийПоПостроителюОтчета(ПостроительОтчета, Запрос);
        
        Если Не ПустаяСтрока(ОграниченияПоПостроителюОтчета)
            И Не ПустаяСтрока(СтрокаОграниченийПоРеквизитам) Тогда
            
            ОграниченияПоПостроителюОтчета = " И " + ОграниченияПоПостроителюОтчета;
            
        КонецЕсли;
    КонецЕсли;
    
	СтрокаСвязкиДопОграниченияПоСчету = ?(ПустаяСтрока(ДопОграничениеПоСчету), "", " И ");
	
	// БИТ Avseenkov 20.05.2014 Доработка отчетов по периметру
	
	ДатаКонец = "&КонПериода";
	ДатаНачало = "&НачПериода";
	
	Если Строка <> неопределено Тогда 
		
		Если Строка.ДатаОкончания > Данные.ДатаНач и
			Строка.ДатаОкончания < КонецДня(Данные.ДатаКон) Тогда 
			ДатаКонец = "&ДатаКон"+Данные.Номер;
			Запрос.УстановитьПараметр("ДатаКон"+Данные.Номер, КонецДня(Строка.ДатаОкончания));
		Иначе 
			ДатаКонец = "&КонПериода";
		КонецЕсли;
		
		Если Строка.Период > Данные.ДатаНач Тогда 
			ДатаНачало = "&ДатаНач"+Данные.Номер;
			Запрос.УстановитьПараметр("ДатаНач"+Данные.Номер,Строка.Период);
		Иначе 
			ДатаНачало = "&НачПериода";
		КонецЕсли;
	КонецЕсли;
	//}
	
	СтрокаЧастиЗапроса = "
			|ИЗ
			|	РегистрБухгалтерии." + СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии + ".ОстаткиИОбороты( "
			//+ ?(СтруктураПараметров.СтруктураОграничений.ДатаНач = '00010101000000', "", "&НачПериода") + ", "
			//+ ?(СтруктураПараметров.СтруктураОграничений.ДатаКон = '00010101000000', "", "&КонПериода") 
			+ ?(СтруктураПараметров.СтруктураОграничений.ДатаНач = '00010101000000', "", ДатаНачало) + ", "
			+ ?(СтруктураПараметров.СтруктураОграничений.ДатаКон = '00010101000000', "", ДатаКонец) 
			+ ", , , " + ДопОграничениеПоСчету  
			+ ?(СтруктураПараметров.СтруктураОграничений.ИспользоватьОграниченияПоЗабалансовымСчетам = Ложь 
				ИЛИ СтруктураПараметров.СтруктураОграничений.ПоЗабалансовымСчетам = Истина, "", СтрокаСвязкиДопОграниченияПоСчету + " НЕ Счет.Забалансовый ") + ", "
			+ ", "
            // Добавим в уловие отбора установленный отбор в построителе отчета.
            + СтрокаОграниченийПоРеквизитам + ОграниченияПоПостроителюОтчета + ") КАК " + ИмяАлиасаТаблицы;
            
            Если Не СтруктураПолейОтбораПостроителя = Неопределено Тогда
                
                ПоляОтбораПостроителя = "";
                
                Для Каждого КлючЗначение Из СтруктураПолейОтбораПостроителя Цикл
                    
                    ИмяЭлемента           = КлючЗначение.Ключ;
                    ПредставлениеЭлемента = КлючЗначение.Значение;
                    
                    ПоляОтбораПостроителя = ПоляОтбораПостроителя 
                                            + ?(Найти(ПоляОтбораПостроителя, ".*") = 0, "", "," + Символы.ПС) 
                                            + "ОстаткиИОбороты." + ИмяЭлемента + ".*" 
                                            + ?(ПустаяСтрока(ПредставлениеЭлемента), "" , " КАК " + ПредставлениеЭлемента);
                                            
                    
                КонецЦикла;
                    
                СтрокаЧастиЗапроса = СтрокаЧастиЗапроса + Символы.ПС + "
                   |{ГДЕ
                   |    " + ПоляОтбораПостроителя + "}";
                
            КонецЕсли;
            
	Возврат СтрокаЧастиЗапроса;		
	
КонецФункции // СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии()
            
// Функция возвращает структуру форматов показателей по массиву показателей.
// 
// Параметры:
//  МассивПоказателей 	   - Массив.
//  ИмяРегистраБухгалтерии - Строка.
//                                 
// Возвращаемое значение:
//  Структура.
// 
Функция СформироватьСтруктуруФорматовПоказателей(Знач МассивПоказателей, Знач ИмяРегистраБухгалтерии) Экспорт
	
	ФорматПоказателей = Новый Структура();
	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
		
		Ресурс = Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].Ресурсы.Найти(ИмяПоказателя);
		Если Ресурс <> Неопределено Тогда
			
			ФорматПоказателей.Вставить(ИмяПоказателя, "ЧЦ = " + Ресурс.Тип.КвалификаторыЧисла.Разрядность
			+ " ; ЧДЦ = " + Ресурс.Тип.КвалификаторыЧисла.РазрядностьДробнойЧасти);
			
		Иначе // По умолчанию - сумма
			ФорматПоказателей.Вставить(ИмяПоказателя , "ЧЦ = 15 ; ЧДЦ = 2");
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ФорматПоказателей;
	
КонецФункции // СформироватьСтруктуруФорматовПоказателей()

// Функция возвращает соотвествие подчиненных счетов.
// 
// Параметры:
//  ИмяПланаСчетов 				 - Строка.
//  Счет 		   				 - ПланСчетовСсылка[ИмяПланаСчетов].
//  ДобавлятьСамСчетВСоответсвие - Булево.
// 
// Возвращаемое значение:
//  Соответствие.
// 
Функция ВернутьСоответвиеПодчиненныхСчетов(Знач ИмяПланаСчетов = "", Знач Счет, Знач ДобавлятьСамСчетВСоответсвие = Ложь) Экспорт
	
	СоответсвиеСчетов = Новый Соответствие;
	
	Запрос = Новый Запрос();
	
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПланСчетовРегистра.Ссылка КАК Ссылка
		|ИЗ	ПланСчетов." + ИмяПланаСчетов + " КАК ПланСчетовРегистра
		|ГДЕ	ПланСчетовРегистра.Ссылка В Иерархии(&Ссылка)";
		
	Запрос.УстановитьПараметр("Ссылка", Счет);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если (НЕ ДобавлятьСамСчетВСоответсвие)
			И (Выборка.Ссылка = Счет) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		СоответсвиеСчетов.Вставить(Выборка.Ссылка, Выборка.Ссылка);
		
	КонецЦикла;

	Возврат СоответсвиеСчетов;
	
КонецФункции // ВернутьСоответвиеПодчиненныхСчетов()

// Процедура формирует представление показателя.
// 
// Параметры:
// 	ИмяПоказателя     - Строка.
//  МассивПоказателей - Массив.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьПредставлениеПоказателя(ИмяПоказателя, МассивПоказателей = Неопределено) Экспорт
	
	Если МассивПоказателей = Неопределено ИЛИ МассивПоказателей.Количество() > 0 Тогда
		Если ИмяПоказателя = "ВалютнаяСумма" Тогда
			ПредставлениеПоказателя = "Вал";
		ИначеЕсли ИмяПоказателя = "СуммаСценарий" Тогда
			ПредставлениеПоказателя = "Сц";
		ИначеЕсли ИмяПоказателя = "СуммаУпр" Тогда
			ПредставлениеПоказателя = "Упр";
		ИначеЕсли ИмяПоказателя = "СуммаРегл" Тогда
			ПредставлениеПоказателя = "Рег";
		ИначеЕсли ИмяПоказателя = "СуммаМУ" Тогда
			ПредставлениеПоказателя = "МУ";
		Иначе
			ПредставлениеПоказателя = "";
		КонецЕсли;
	КонецЕсли;

	Возврат ПредставлениеПоказателя;
	
КонецФункции // ПолучитьПредставлениеПоказателя()

// Процедура формирует отчет оборотно сальдовой ведомости.
// 
// Параметры:
// 	ОбъектОтчета		 					    - ОбъектОтчета.
//  ДокументРезультат    					    - ТабличныйДокумент.
//  ПоказыватьЗаголовок  					    - Булево.
//  ВысотаЗаголовка      					    - Число.
// 	ПоВалютам 			 					    - Булево.
// 	ИспользоватьОграниченияПоЗабалансовымСчетам - Булево.
// 	ПоЗабалансовымСчетам 					    - Булево.
// 	ВидУчета 			 					    - ВидУчета.
// 	Валюта 				 					    - СправочникСсылка.Валюты.
// 	ОтражениеВНУ		 					    - Булево.
// 	Сценарий 			 					    - СправочникСсылка.Сценарии/бит_Сценарии.
// 	ВВалютеСценария 						    - Булево.
// 
Процедура СформироватьОтчетОборотноСальдовойВедомости(ОбъектОтчета, ДокументРезультат, ПоказыватьЗаголовок = Истина, ВысотаЗаголовка = 0,
	Знач ПоВалютам, Знач ИспользоватьОграниченияПоЗабалансовымСчетам, Знач ПоЗабалансовымСчетам, 
	Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено, 
	Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено) Экспорт
	
	СформироватьИВывестиЗаголовокОтчета(ОбъектОтчета, ДокументРезультат, ВысотаЗаголовка, ПоказыватьЗаголовок);
	
	Макет = ПолучитьОбщийМакет("бит_ОборотноСальдоваяВедомость");
	
	ЗаголовокОтчета = Макет.ПолучитьОбласть("ЗаголовокОтчета");
	
	ДокументРезультат.Вывести(ЗаголовокОтчета, 1);
	
	ДокументРезультат.НачатьАвтогруппировкуСтрок();
	
	// Используемые области макета
	ОбластьСтрокаСчет           	= Макет.ПолучитьОбласть("Строка|Счет");
	ОбластьСтрокаЧисла 				= Макет.ПолучитьОбласть("Строка|Числа");
	ОбластьСтрокаПоказателяСчет 	= Макет.ПолучитьОбласть("СтрокаПоказателя|Счет");	
	ОбластьСтрокаПоказателяЧисла 	= Макет.ПолучитьОбласть("СтрокаПоказателя|Числа");
	ОбластьСтрокаСчетВал           	= Макет.ПолучитьОбласть("СтрокаВал|Счет");
	ОбластьСтрокаЧислаВал           = Макет.ПолучитьОбласть("СтрокаВал|Числа");
	ОбластьСтрокаПоказателяСчетВал 	= Макет.ПолучитьОбласть("СтрокаПоказателяВал|Счет");	
	ОбластьСтрокаПоказателяЧислаВал = Макет.ПолучитьОбласть("СтрокаПоказателяВал|Числа");
	
	// В этой структуре будут храниться постоянные значения, передаваемые во другие процедуры:
	// - формат, 
	// - области макета.
	СтруктураПараметров = Новый Структура;
	
	// Переменная, содержащая имена показателей отчета (ресурсов) в виде массива.
	МассивПоказателей = ОбъектОтчета.СформироватьМассивПоказателей();
	СтруктураПараметров.Вставить("МассивПоказателей", МассивПоказателей);
	
	// Области для вывода показателей
	СтруктураПараметров.Вставить("ОбластьСтрокаЧисла"		   , ОбластьСтрокаЧисла);
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяСчет" , ОбластьСтрокаПоказателяСчет);	
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяЧисла", ОбластьСтрокаПоказателяЧисла);
	СтруктураПараметров.Вставить("ОбластьСтрокаЧислаВал"		   , ОбластьСтрокаЧислаВал);
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяСчетВал"  , ОбластьСтрокаПоказателяСчетВал);	
	СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяЧислаВал" , ОбластьСтрокаПоказателяЧислаВал);
	
	// Линии, используемые при выводе
	СтруктураПараметров.Вставить("НетЛинии", Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии, 1));
	
	// Формат показателей
	СтруктураФорматовПоказателей = СформироватьСтруктуруФорматовПоказателей(МассивПоказателей, ОбъектОтчета.ИмяРегистраБухгалтерии);
	СтруктураПараметров.Вставить("ФорматПоказателей", СтруктураФорматовПоказателей);
	
	СтруктураПараметровОграничений = СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомости(ОбъектОтчета,
	ПоВалютам, ИспользоватьОграниченияПоЗабалансовымСчетам, ПоЗабалансовымСчетам, ВидУчета, Валюта, ОтражениеВНУ, 
	Сценарий, ВВалютеСценария);
	
	СтруктураПараметров.Вставить("СтруктураОграничений", СтруктураПараметровОграничений);
	
	СтруктураОбщийИтог = Новый Структура;
	ИнициализироватьСтруктуруХраненияИтоговОборотка(МассивПоказателей, СтруктураОбщийИтог);
	
	СоотвПодчСчета = Новый Соответствие;
	
	Запрос = ОбъектОтчета.СформироватьЗапрос(СтруктураПараметров);
	
	// Рассчитаем итоги по счетам, заданным в таблице вывода итогов по счетам
	ОчищатьИтогиПоСценарию = Ложь;// Не ЗначениеЗаполнено(Сценарий);
	ТаблицаРазворотаСчетов = СформироватьТаблицуДанныхРазворотаСчетов(СтруктураПараметров, ОбъектОтчета.ПостроительОтчета, ОбъектОтчета.ПравилаВыводаИтогов, ОчищатьИтогиПоСценарию);
	ТаблицаРазворотаСчетов.Индексы.Добавить("Счет");
	
	// Рассчитаем итоги по счетам, заданным в таблице развернутого сальдо.
	ТаблицаРазвернутогоСальдо = СформироватьТаблицуДанныхРазвернутогоСальдо(СтруктураПараметров, ОбъектОтчета.ПравилаРазвернутогоСальдо); 
	ТаблицаРазвернутогоСальдо.Индексы.Добавить("Счет");
	
	//ижтиси, шадрин, 04.09.2015(
	Попытка
		Если ТипЗнч(Запрос.Параметры.Организация) = Тип("Массив") ИЛИ ТипЗнч(Запрос.Параметры.Организация) = Тип("ТаблицаЗначений") Тогда
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "Организация = &Организация ", "Организация В (&Организация )");
		КонецЕсли;
	Исключение
	КонецПопытки;
	//ижтиси, шадрин, 04.09.2015)
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Выборка = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Счет");
	
	Пока Выборка.Следующий() Цикл
		
		Уровень = Выборка.Уровень();
		
		Если НЕ ОбъектОтчета.ПоСубсчетамИСубконто И Уровень > 0 Тогда						
			Продолжить;                                              			
		КонецЕсли;
		
		// Пропускаем подчиненные счета разворачиваемого счета.
		Если СоотвПодчСчета[Выборка.Счет] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ОбластьСтрокаСчет.Параметры.Заполнить(Выборка);
		
		// Заполнение параметров расшифровки
		ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(ОбъектОтчета.Период.ДатаНачала, ОбъектОтчета.Период.ДатаОкончания, 
		ОбъектОтчета.ИмяРегистраБухгалтерии, ОбластьСтрокаСчет, Выборка, , , ВВалютеСценария);
		
		// Выводим текущую строку отчета
		ДокументРезультат.Вывести(ОбластьСтрокаСчет, Уровень);
		
		// Определим, нужно ли выводить развернутое сальдо по счету и
		// разворачивать счет по субконто.
		Если ОбъектОтчета.ВыводитьРазвернутоеСальдо Тогда
			СтрокаРазвернутогоСальдо = ТаблицаРазвернутогоСальдо.Найти(Выборка.Счет, "Счет");
		Иначе	
			СтрокаРазвернутогоСальдо = Неопределено;
		КонецЕсли;
		
		Если ОбъектОтчета.ПоСубсчетамИСубконто Тогда
			СтрокаРазворотаСчета = ТаблицаРазворотаСчетов.Найти(Выборка.Счет, "Счет");
		Иначе
			СтрокаРазворотаСчета = Неопределено;
		КонецЕсли;
		
		// Перед выводом показателей добавим в структуру параметров расшифровку области счет.
		СтруктураПараметров.Вставить("РасшифровкаОбластиСчет", ОбластьСтрокаСчет.Параметры.Расшифровка);
		
		ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Выборка.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);
		
		ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, 
		ОбластьСтрокаПоказателяСчетВал, 
		Выборка, 
		ДокументРезультат, 
		СтрокаРазвернутогоСальдо, 
		СтруктураОбщийИтог, 
		-1);
		
		// Вывод разворота счета по субконто
		Если СтрокаРазворотаСчета <> Неопределено Тогда
			
			СтрокаРазвернутогоСальдо = Неопределено;
			СоотвПодчСчета 			 = СтрокаРазворотаСчета.СоответсвиеСчетов;
			
			// Сдвиг уровня выводимой группировки отчета относительно группировки запроса.
			СдвигУровня = 0;
			
			// Флаг сброса сдвига уровня при выводе группировки по счету.
			СброситьСдвигУровня = Истина;
			
			ВыборкаПоСчету = СтрокаРазворотаСчета.Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, СтрокаРазворотаСчета.МассивГруппировок[0]);
			
			СтруктураПараметров.Вставить("ОбластьСтрокаСчет"		  , ОбластьСтрокаСчет);
			СтруктураПараметров.Вставить("ОбластьСтрокаПоказателяСчет", ОбластьСтрокаПоказателяСчет);
			СтруктураПараметров.Вставить("ДокументРезультат"		  , ДокументРезультат);
			
			// Вывод детализированных данных
			ВывестиГруппировкуОборотноСальдовойВедомости(ВыборкаПоСчету, 0, СтрокаРазворотаСчета.МассивГруппировок, 
			Уровень, СдвигУровня, СброситьСдвигУровня, 
			Выборка.Счет, СтрокаРазвернутогоСальдо, 
			СтруктураОбщийИтог, СтруктураПараметров, Новый Соответствие);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ДокументРезультат.ЗакончитьАвтогруппировкуСтрок();
	
	// Выведем итоговую строку
	ОбластьИтогиСчет = Макет.ПолучитьОбласть("Итоги|Счет");
	ДокументРезультат.Вывести(ОбластьИтогиСчет, 0);
	
	ОбластьИтогиСтрокаЧисла = Макет.ПолучитьОбласть("ИтогиСтрока|Числа");
	ОбластьИтогиЧисла       = Макет.ПолучитьОбласть("Итоги|Числа");
	ОбластьИтогиСтрокаСчет  = Макет.ПолучитьОбласть("ИтогиСтрока|Счет");
	
	НомерТекущейСтрокиИтога = 0;	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
		
		Если НЕ Метаданные.РегистрыБухгалтерии[ОбъектОтчета.ИмяРегистраБухгалтерии].Ресурсы[ИмяПоказателя].Балансовый Тогда
			Продолжить;
		КонецЕсли;
		
		Если НомерТекущейСтрокиИтога > 0 Тогда
			Область = ОбластьИтогиСтрокаЧисла
		Иначе
			Область = ОбластьИтогиЧисла;
		КонецЕсли;
		
		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);
		
		ЗаполнитьДаннымОблатьВыводаОборотка(Область, ФорматПоказателя, 
		СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"], СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"], 
		СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт"] , СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт"], 
		СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"]			, СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"]);
		
		Если НомерТекущейСтрокиИтога > 0 Тогда
			ДокументРезультат.Вывести(ОбластьИтогиСтрокаСчет, 0);
		КонецЕсли;
		
		ДокументРезультат.Присоединить(Область);
		
		НомерТекущейСтрокиИтога = НомерТекущейСтрокиИтога + 1;
		
	КонецЦикла;
	
	ИтогиПодвал = Макет.ПолучитьОбласть("ИтогиПодвал");
	ДокументРезультат.Вывести(ИтогиПодвал, 0);
	
	
	// Заполним общую расшифровку:
	СтруктураНастроекОтчета = ОбъектОтчета.СформироватьОбщуюСтруктуруДляРасшифровки();
	СтруктураНастроекОтчета.Вставить("ПоказыватьЗаголовок", ПоказыватьЗаголовок);
	
	ДокументРезультат.Область(1, 1).Расшифровка = СтруктураНастроекОтчета;
	
	// Зафиксируем заголовок отчета
	ДокументРезультат.ФиксацияСверху = ВысотаЗаголовка + 3;
	
	// Первую колонку не печатаем
	ДокументРезультат.ОбластьПечати = ДокументРезультат.Область(1, 2, ДокументРезультат.ВысотаТаблицы, ДокументРезультат.ШиринаТаблицы);
	
	// Выводится по ширине листа
	ДокументРезультат.Автомасштаб   = Истина;
	
	УстановитьКолонтитулыПоУмолчанию(ДокументРезультат, ОбъектОтчета.ЗаголовокОтчета(), Строка(ПараметрыСеанса.ТекущийПользователь));
	
КонецПроцедуры // СформироватьОтчетОборотноСальдовойВедомости()

// ОСВ по счету

// Функция создает структуру дополнительных ограничений для расшифровки отчета.
// 
// Параметры:
//  ОтчетОбъект 		   - ОтчетОбъект.
// 	Выборка 			   - ВыборкаИзЗапроса.
// 	МассивГруппировок 	   - Массив.
// 	ВыводитьВсеГруппировки - Булево.
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция СоздатьСтруктуруДопОграниченийДляОборотноСальдовойВедомостиПоСчету(ОтчетОбъект, Выборка, МассивГруппировок, Знач ВыводитьВсеГруппировки = Ложь) Экспорт
	
	ДополнительныеОтборы = СоздатьТаблицуДляХраненияОтбора(Истина);
	
	ИмяГруппировки = Выборка.Группировка();
	Если ВыводитьВсеГруппировки Тогда
		НомерГруппировкиВМассиве = МассивГруппировок.Количество() - 1;
	Иначе	
		НомерГруппировкиВМассиве = бит_РаботаСКоллекциямиКлиентСервер.ВернутьИндексВМассиве(МассивГруппировок, ИмяГруппировки);
	КонецЕсли;
	
	Для Сч = 0 По НомерГруппировкиВМассиве Цикл 
		
		ТекущееИмяГруппировки = Врег(МассивГруппировок[Сч]);
		
		Если ТекущееИмяГруппировки = "СЧЕТ"
			ИЛИ ТекущееИмяГруппировки = "ОБЩИЕ" 
			ИЛИ ТекущееИмяГруппировки = "ВАЛЮТА" Тогда      
			
			Продолжить;
			
		КонецЕсли;
		
		Измерение = ОтчетОбъект.ПостроительОтчета.ИзмеренияСтроки.Найти(ТекущееИмяГруппировки);
		
		СтрокаОтбора = ДополнительныеОтборы.Добавить();
		СтрокаОтбора.Использование = Истина;
		СтрокаОтбора.Имя 		   = Измерение.ПутьКДанным;
		
		// Надо тип отбора определить и по нему можно сказать вид сравнения.
		ВидСравненияДанных = ПолучитьВидОтбораПоТипуЗначения(Выборка[ТекущееИмяГруппировки]);
		
		СтрокаОтбора.ВидСравнения = ВидСравненияДанных;
		СтрокаОтбора.Значение 	  = Выборка[ТекущееИмяГруппировки];
				
		Если Измерение <> Неопределено Тогда
					
			СтрокаОтбора.Имя 		 = Измерение.ПутьКДанным;
			СтрокаОтбора.ПутьКДанным = Измерение.ПутьКДанным;
			
		Иначе
						
			СтрокаОтбора.Имя 		 = ТекущееИмяГруппировки;
			СтрокаОтбора.ПутьКДанным = ТекущееИмяГруппировки;
			
		КонецЕсли;
	
	КонецЦикла;
	
	// BIT AMerkulov 26062014 ++	
	Если ОтчетОбъект.ПоВалютам Тогда
		СтрокаОтбораВалюты = ДополнительныеОтборы.Добавить();
		СтрокаОтбораВалюты.ВидСравнения = ВидСравнения.Равно;
		СтрокаОтбораВалюты.Имя = "Валюта";
		СтрокаОтбораВалюты.Представление = "Валюта";
		СтрокаОтбораВалюты.ПутьКДанным = "Валюта";
		СтрокаОтбораВалюты.Использование = Ложь;		
	КонецЕсли;		
	// BIT AMerkulov 26062014 --	

	Возврат ДополнительныеОтборы;
	
КонецФункции // СоздатьСтруктуруДопОграниченийДляОборотноСальдовойВедомостиПоСчету()

// Функция формирует структуру параметров ограничений для оборотно-сальдовой ведомости.
// 
// Параметры:
// 	ОбъектОтчета	- ОбъектОтчета.
// 	ПоВалютам 		- Булево.
// 	ВидУчета 		- ВидУчета.
// 	Валюта 			- СправочникСсылка.Валюты.
// 	ОтражениеВНУ	- Булево.
// 	Сценарий 		- СправочникСсылка.Сценарии/бит_Сценарии.
// 	ВВалютеСценария - Булево.
// 
// Возвращаемое значение:
//  Структура.
// 
Функция СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомостиПоСчету(ОбъектОтчета,
		Знач ПоВалютам, Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено,
		Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено) Экспорт
	
	Структура = Новый Структура();
	Структура.Вставить("ДатаНач", ОбъектОтчета.Период.ДатаНачала);
	Структура.Вставить("ДатаКон", ОбъектОтчета.Период.ДатаОкончания);
	Попытка
		Структура.Вставить("Организация", ОбъектОтчета.Организация);
	Исключение
		Структура.Вставить("Организация", Неопределено);
	КонецПопытки;
	
	Структура.Вставить("ПоВалютам"			   , ПоВалютам);	
	Структура.Вставить("ВидУчета"			   , ВидУчета);	
	Структура.Вставить("Валюта"				   , Валюта);
	Структура.Вставить("ОтражениеВНУ"		   , ОтражениеВНУ); 	
	Структура.Вставить("Сценарий"			   , Сценарий);      	
	Структура.Вставить("ВВалютеСценария"	   , ВВалютеСценария);	
	Структура.Вставить("ИмяРегистраБухгалтерии", ОбъектОтчета.ИмяРегистраБухгалтерии);
	
	Возврат Структура; 
	
КонецФункции // СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомостиПоСчету()

// Процедура выводит группировку при развороте счета по субсчетам и/или субконто 
// для оборотно сальдовой ведомости по счету.
// 
// Параметры:
// 	ОбъектОтчета		 	 - ОбъектОтчета
// 	Выборка 			 	 - ВыборкаИзЗапроса
// 	ИндексТекущейГруппировки - Число
// 	СтруктураПараметров 	 - Структура.
// 
Процедура ВывестиГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка, Знач ИндексТекущейГруппировки, СтруктураПараметров) Экспорт

	Пока Выборка.Следующий() Цикл
		
		ИмяГруппировки = Выборка.Группировка();
		
		Если СтруктураПараметров.Свойство("РасшифровкаОбластиСчет") Тогда
			СтруктураПараметров.Удалить("РасшифровкаОбластиСчет")
		КонецЕсли;
		
		Если ИмяГруппировки = "Счет" Тогда
			
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаСчет;
			
			ВыводимаяОбласть.Параметры.Заполнить(Выборка);
						
			ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОбъектОтчета, ВыводимаяОбласть, Выборка, СтруктураПараметров);
			
			СтруктураПараметров.Вставить("РасшифровкаОбластиСчет", ВыводимаяОбласть.Параметры.Расшифровка);
			
		ИначеЕсли Лев(ИмяГруппировки, 8) = "Субконто" 
			ИЛИ Лев(ИмяГруппировки, 12) = "Организация" ИЛИ Лев(ИмяГруппировки, 3) = "ЦФО" Тогда
			
			Если Выборка[ИмяГруппировки] = Null Тогда
				Продолжить;
			КонецЕсли;
									
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			ВыводимаяОбласть.Параметры.Заполнить(Выборка);
			
			ВыводимаяОбласть.Параметры.СубконтоПредставление = Выборка[ИмяГруппировки + "Представление"];
			ВыводимаяОбласть.Параметры.Показатель = "";
			
			ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОбъектОтчета, ВыводимаяОбласть, Выборка, СтруктураПараметров);
			
		ИначеЕсли ИмяГруппировки = "Валюта" Тогда
			
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			ВыводимаяОбласть.Параметры.Заполнить(Выборка);
			ВыводимаяОбласть.Параметры.СубконтоПредставление = "Валюта " + Выборка.ВалютаПредставление;
			ВыводимаяОбласть.Параметры.Показатель 
						= ПолучитьПредставлениеПоказателя(СтруктураПараметров.МассивПоказателей[0], СтруктураПараметров.МассивПоказателей);
			
			// Заполнение параметров расшифровки
			ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОбъектОтчета, ВыводимаяОбласть, Выборка, СтруктураПараметров);
			ДобавитьРасшифровкуПоВалюте(Выборка, ВыводимаяОбласть.Параметры.Расшифровка[0].Значение);
					
		Иначе
			
			ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			
			ВыводимаяОбласть.Параметры.Заполнить(Выборка);
			ВыводимаяОбласть.Параметры.СубконтоПредставление = Выборка[ИмяГруппировки];
			
		КонецЕсли;
		
		// При выводе субсчетов не делаем отступы
		Отступ = бит_РаботаСКоллекциямиКлиентСервер.ВернутьИндексВМассиве(СтруктураПараметров.МассивГруппировок, ИмяГруппировки);
						
		// Не выводим счета более высокого уровня
		Если ИмяГруппировки = "Счет" 
			И СтруктураПараметров.СоответствиеСчетовПредков[Выборка.Счет] <> Неопределено Тогда
			
		КонецЕсли;
		
		ДокументРезультат = СтруктураПараметров.ДокументРезультат;
		
		ВыводимаяОбласть.Область("R1C2").Отступ = Отступ;
		
		ДокументРезультат.Вывести(ВыводимаяОбласть, Выборка.Уровень() );
		
		Если Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ИтогПоИерархии 
		   И ИмяГруппировки <> "Счет" Тогда
			
			ДокументРезультат.Область(ДокументРезультат.ВысотаТаблицы, 2).Шрифт = СтруктураПараметров.ШрифтГрупп;
			
		КонецЕсли;
		
		ВывестиПоказателиОборотноСальдовойВедомостиПоСчету(Выборка, СтруктураПараметров, ОбъектОтчета.Счет, , ИмяГруппировки);
		
		 // Если по валютам,
		 Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
		 	
		 	ВыборкаПоВалютам = Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Валюта");
		 	Пока ВыборкаПоВалютам.Следующий() Цикл
		 		
		 		ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчетВал;
		 		
		 		ВыводимаяОбласть.Параметры.Заполнить(Выборка);
		 		ВыводимаяОбласть.Параметры.СубконтоПредставление = "Валюта " + ВыборкаПоВалютам.ВалютаПредставление;
				
				ВыводимаяОбласть.Параметры.Показатель 
						= ПолучитьПредставлениеПоказателя(СтруктураПараметров.МассивПоказателей[0], СтруктураПараметров.МассивПоказателей);
			
		 		ВыводимаяОбласть.Область("R1C2").Отступ = Отступ + 1;
		 		
		 		//  Заполнение параметров расшифровки
		 		ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОбъектОтчета, ВыводимаяОбласть, Выборка, СтруктураПараметров);
		 		ДобавитьРасшифровкуПоВалюте(ВыборкаПоВалютам, ВыводимаяОбласть.Параметры.Расшифровка[0].Значение);
		 		
		 		ДокументРезультат.Вывести(ВыводимаяОбласть, Выборка.Уровень());
		 		
				ВывестиПоказателиОборотноСальдовойВедомостиПоСчету(ВыборкаПоВалютам, СтруктураПараметров, ОбъектОтчета.Счет, , ИмяГруппировки);
		 		
		 	КонецЦикла;
		 	
		 КонецЕсли;

        // Если есть следующая группировка, то выбираем ее.
		ВывестиВложеннуюГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка, ИндексТекущейГруппировки, СтруктураПараметров);
			
	КонецЦикла;

КонецПроцедуры // ВывестиГруппировкуОборотноСальдовойВедомостиПоСчету()

// Процедура заполняет параметры расшифровки.
// 
// Параметры:
// 	ОбъектОтчета		- ОбъектОтчета.
//  Область				- Область.
// 	Выборка 			- ВыборкаИзЗапроса.
// 	СтруктураПараметров - Структура.
// 
Процедура ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету(ОтчетОбъект, Область, Выборка, СтруктураПараметров) Экспорт

	// Если итоги по счету не анализируются, берем общий.
	Если Выборка.Счет = NULL Тогда		
		РасшифровываемыйСчет 			  = ОтчетОбъект.Счет;
		РасшифровываемыйСчетПредставление = Строка(ОтчетОбъект.Счет);  		
	Иначе    		
		РасшифровываемыйСчет 			  = Выборка.Счет;
		РасшифровываемыйСчетПредставление = Выборка.СчетПредставление; 		
	КонецЕсли;
	
	ЗаполнитьРасшифровкуДляСчета(ОтчетОбъект, Область, Выборка, СтруктураПараметров, ОтчетОбъект.ИмяРегистраБухгалтерии,
		РасшифровываемыйСчет, РасшифровываемыйСчетПредставление);
	
КонецПроцедуры // ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету()

// Процедура выводит текущие показатели оборотно сальдовой ведомости по счету.
// 
// Параметры:
// 	Выборка 			 	  - ВыборкаИзЗапроса.
// 	СтруктураПараметров 	  - Структура.
// 	Счет 			 	      - ПланСчетовСсылка.
// 	СтруктураЗамещающихДанных - Структура.
// 
Процедура ВывестиПоказателиОборотноСальдовойВедомостиПоСчету(Выборка, СтруктураПараметров, Знач Счет, 
	Знач СтруктураЗамещающихДанных = Неопределено, ИмяГруппировки = Неопределено) Экспорт

	ВыведеноПоказателей = 0; // Количество выведенных показателей
	Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл

		// Сумму в валюте выводим только по группировке Валюта
		Если ИмяПоказателя = "ВалютнаяСумма" 
			И (Выборка.Группировка() = "Счет" ИЛИ Найти(Выборка.Группировка(), "Субконто") <> 0) Тогда
			Продолжить;
		КонецЕсли;
		
		Если Выборка.Группировка() = "Валюта" Тогда
			Область = ?( ВыведеноПоказателей > 0, СтруктураПараметров.ОбластьСтрокаПоказателяЧислаВал, СтруктураПараметров.ОбластьСтрокаЧислаВал);
		Иначе
			Область = ?( ВыведеноПоказателей > 0, СтруктураПараметров.ОбластьСтрокаПоказателяЧисла, СтруктураПараметров.ОбластьСтрокаЧисла);
		КонецЕсли;
		
		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);
		
		Если СтруктураЗамещающихДанных = Неопределено Тогда
			
			СальдоНачДт = Выборка[ИмяПоказателя + "НачальныйОстатокДт"];
			СальдоНачКт = Выборка[ИмяПоказателя + "НачальныйОстатокКт"];
			СальдоКонДт = Выборка[ИмяПоказателя + "КонечныйОстатокДт"];
			СальдоКонКт = Выборка[ИмяПоказателя + "КонечныйОстатокКт"];
			ОборотДт = Выборка[ИмяПоказателя + "ОборотДт"];
			ОборотКт = Выборка[ИмяПоказателя + "ОборотКт"];
			
		Иначе
			
			СальдоНачДт = СтруктураЗамещающихДанных[ИмяПоказателя + "НачальныйОстатокДт"];
			СальдоНачКт = СтруктураЗамещающихДанных[ИмяПоказателя + "НачальныйОстатокКт"];
			СальдоКонДт = СтруктураЗамещающихДанных[ИмяПоказателя + "КонечныйОстатокДт"];
			СальдоКонКт = СтруктураЗамещающихДанных[ИмяПоказателя + "КонечныйОстатокКт"];
			ОборотДт = СтруктураЗамещающихДанных[ИмяПоказателя + "ОборотДт"];
			ОборотКт = СтруктураЗамещающихДанных[ИмяПоказателя + "ОборотКт"];			
			
	    КонецЕсли;
		
		// Сальдо по счетам нужно привести к традиционному виду, в зависимости от вида выбранного счета:
		// если группировки Счет еще не было, сальдо в выборке рассчитаны как для активно-пассивного счета.
		Если Счет.Вид = ВидСчета.Активный Тогда
			
			СальдоНачДт = СальдоНачДт - СальдоНачКт;
			СальдоНачКт = 0;
			
			СальдоКонДт = СальдоКонДт - СальдоКонКт;
			СальдоКонКт = 0;
			
		ИначеЕсли Счет.Вид = ВидСчета.Пассивный Тогда
			
			СальдоНачКт = СальдоНачКт - СальдоНачДт;
			СальдоНачДт = 0;
			
			СальдоКонКт = СальдоКонКт - СальдоКонДт;
			СальдоКонДт = 0;
			
		КонецЕсли;
		
		Область.Параметры.НачальныйОстатокДт = Формат(СальдоНачДт, ФорматПоказателя);
		Область.Параметры.НачальныйОстатокКт = Формат(СальдоНачКт, ФорматПоказателя);
		Область.Параметры.ОборотДт           = Формат(ОборотДт,    ФорматПоказателя);
		Область.Параметры.ОборотКт           = Формат(ОборотКт,    ФорматПоказателя);
		Область.Параметры.КонечныйОстатокДт  = Формат(СальдоКонДт, ФорматПоказателя);
		Область.Параметры.КонечныйОстатокКт  = Формат(СальдоКонКт, ФорматПоказателя);

		ДокументРезультат = СтруктураПараметров.ДокументРезультат;

		Если ВыведеноПоказателей > 0 Тогда
			
			Если Выборка.Группировка() = "Валюта" Тогда
				ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчетВал;
			Иначе
				ВыводимаяОбласть = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			КонецЕсли;   		
			
			ВыводимаяОбласть.Параметры.СубконтоПредставление = "";
			Если Выборка.Группировка() = "Валюта" Тогда  			
				ВыводимаяОбласть.Параметры.Показатель 
						= ПолучитьПредставлениеПоказателя(ИмяПоказателя, СтруктураПараметров.МассивПоказателей);
			Иначе
				ВыводимаяОбласть.Параметры.Показатель = "";
			КонецЕсли;

			ВыведеннаяОбласть = ДокументРезультат.Вывести(ВыводимаяОбласть);

			ВыведеннаяОбласть.ГраницаСверху = СтруктураПараметров.НетЛинии;
			
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
		
		ВыведеноПоказателей = ВыведеноПоказателей+1;
				
	КонецЦикла;

КонецПроцедуры // ВывестиПоказателиОборотноСальдовойВедомостиПоСчету()

// Процедура заполняет параметры расшифровки для счета по отчету оборотно сальдовая ведомость по счету.
// 
// Параметры:
//  ОтчетОбъект 					  - ОтчетОбъект.
// 	Выборка 			 	  		  - ВыборкаИзЗапроса.
// 	СтруктураПараметров 	  		  - Структура.
// 	ИмяРегистраБухгалтерии 			  - Строка.
// 	РасшифровываемыйСчет 			  - ПланСчетовСсылка.
//  РасшифровываемыйСчетПредставление - Строка.
// 
Процедура ЗаполнитьРасшифровкуДляСчета(ОтчетОбъект, Область, Выборка, СтруктураПараметров, Знач ИмяРегистраБухгалтерии,
	Знач РасшифровываемыйСчет, Знач РасшифровываемыйСчетПредставление) Экспорт
	
	ИмяКарточкаСчета    = Нстр("ru = 'Карточка счета '");
	ИмяКарточкаСубконто = Нстр("ru = 'Карточка субконто '");
	ИмяОткрытьЗначение	= Нстр("ru = 'Открыть '");
	
    // Получим префикс имени отчета расшифровки.
    Префикс = ?(Найти(ИмяРегистраБухгалтерии, "бит") = 0, "", "бит_");
    
    // Удалим из имени регистра бухгалтерии префикс "бит".
    ИмяРегистраБухгалтерии = СтрЗаменить(ИмяРегистраБухгалтерии, "бит", "");
	
	// Если это расшифровка данных дополнительного регистра бухгалтерии, тогда
	Если Найти(ВРег(ИмяРегистраБухгалтерии), "ДОПОЛНИТЕЛЬНЫЙ") > 0 Тогда  		
		ИмяРегистраБухгалтерии = "_Управленческий";   		
	КонецЕсли;
	
	// ПараметрыКарточкиСчета = Новый Соответствие;
	ПараметрыКарточкиСчета = Новый Структура;     
	ПараметрыКарточкиСчета.Вставить("ИмяОбъекта", Префикс + "КарточкаСчета" + ИмяРегистраБухгалтерии); 
	ПараметрыКарточкиСчета.Вставить("Счет", РасшифровываемыйСчет);

	// ПараметрыКарточкиСубконто = Новый Соответствие;
	ПараметрыКарточкиСубконто = Новый Структура;
	ПараметрыКарточкиСубконто.Вставить("ИмяОбъекта"			 , Префикс + "КарточкаСубконто" + ИмяРегистраБухгалтерии);
	ПараметрыКарточкиСубконто.Вставить("ЗаполнитьПоУмолчанию", Истина);
	ПараметрыКарточкиСубконто.Вставить("Счет"				 , РасшифровываемыйСчет);
	
	ПараметрыОткрытьЗначение = Новый Структура;
	ПараметрыОткрытьЗначение.Вставить("СпособРасшифровки", "ОткрытьЗначение");
	         	
	ИмяГруппировки = Выборка.Группировка();

	Если ИмяГруппировки = "Счет" Тогда

		СписокРасшифровки = Новый СписокЗначений;
        СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, ИмяКарточкаСчета + РасшифровываемыйСчетПредставление);
		
	ИначеЕсли Лев(ИмяГруппировки, 12) = "Организация" ИЛИ Лев(ИмяГруппировки, 3) = "ЦФО" Тогда

		// Надо в структуру доп ограничений поместить все группировки более высокого уровня.
		ДополнительныеОтборы = СоздатьСтруктуруДопОграниченийДляОборотноСальдовойВедомостиПоСчету(ОтчетОбъект, Выборка, СтруктураПараметров.МассивГруппировок);
				
		ПараметрыКарточкиСчета.Вставить("ДополнительныеОтборы", Новый ХранилищеЗначения(ДополнительныеОтборы));
		
		СписокРасшифровки = Новый СписокЗначений;
		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, ИмяКарточкаСчета + РасшифровываемыйСчетПредставление);
		
	ИначеЕсли Лев(ИмяГруппировки, 8) = "Субконто" Тогда

		// Надо в структуру доп ограничений поместить все группировки более высокого уровня.
		ДополнительныеОтборы = СоздатьСтруктуруДопОграниченийДляОборотноСальдовойВедомостиПоСчету(ОтчетОбъект, Выборка, СтруктураПараметров.МассивГруппировок);
						
		СписокРасшифровки = Новый СписокЗначений;
		
		//--------------------------------------------------
		// Расшифровка - открыть значение
		ОткрЗначение = Выборка[ИмяГруппировки];
		Если ЗначениеЗаполнено(ОткрЗначение) Тогда
			ПараметрыОткрытьЗначение.Вставить("Значение", ОткрЗначение);
			СписокРасшифровки.Добавить(ПараметрыОткрытьЗначение, ИмяОткрытьЗначение + "'" + Выборка[ИмяГруппировки + "Представление"] + "'");
		КонецЕсли;
		
		//--------------------------------------------------
		// Расшифровка - карточка счета
		ПараметрыКарточкиСчета.Вставить("ДополнительныеОтборы", Новый ХранилищеЗначения(ДополнительныеОтборы));
		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, ИмяКарточкаСчета + РасшифровываемыйСчетПредставление);
		
		//--------------------------------------------------
		// Расшифровка - карточка субконто
		// Изменение кода. Начало. 26.09.2016{{ 09.11.2016{{.
		// ОК Видяйкин В.И. +
		//РасшифровываемоеСубконто = Выборка[ИмяГруппировки];
		Попытка
			РасшифровываемоеСубконто = Выборка[ИмяГруппировки];
	    Исключение
		    РасшифровываемоеСубконто = "";
		КонецПопытки;
		// ОК Видяйкин В.И. -		
		Если РасшифровываемоеСубконто = Неопределено Тогда
			// Ошибка в проводках. Не заполнено субконто. Удаляем отбор.
			НайдСтрТз =ДополнительныеОтборы.НайтиСтроки(Новый Структура("Имя", ИмяГруппировки));
			Если НайдСтрТз.Количество() > 0  Тогда
				СтрокаТз = НайдСтрТз[0];
				СтрокаТз.Использование = Ложь; 			
			КонецЕсли;                                  			
		КонецЕсли;
		// Изменение кода. Конец. 26.09.2016}}
		ВидыСубконто = Новый Массив;
		Для каждого ЭлОтб Из ДополнительныеОтборы Цикл
			ИмяЭл = ЭлОтб.Имя;
			Если Найти(ИмяЭл, "Субконто") <> 0 Тогда
				// Изменение кода. Начало. 29.07.2016{{
				НомерСуб = Число(Сред(ИмяЭл, Найти(ИмяЭл, "Субконто")+8,1))-1;
				// Изменение кода. Конец. 29.07.2016}}
				ВидыСубконто.Добавить(РасшифровываемыйСчет.ВидыСубконто[НомерСуб].ВидСубконто);
				бит_РаботаСКоллекциями.УдалитьПовторяющиесяЭлементыМассива(ВидыСубконто, Истина);
			КонецЕсли;
		КонецЦикла; 
		ПараметрыКарточкиСубконто.Вставить("ВидыСубконто", ВидыСубконто);   		
		// Отбор по счету
		СтрокаОтбора = ДополнительныеОтборы.Добавить();
		СтрокаОтбора.Использование = Истина;
		СтрокаОтбора.Имя 		   = "Счет"; 		
		СтрокаОтбора.ВидСравнения = ПолучитьВидОтбораПоТипуЗначения(Выборка["Счет"]);
		СтрокаОтбора.Значение 	  = Выборка["Счет"]; 				
		СтрокаОтбора.ПутьКДанным   = "Счет";
		СтрокаОтбора.Представление = "Счет";
		// В СписокРасшифровки добавить ПараметрыКарточкиСубконто
		ПараметрыКарточкиСубконто.Вставить("ДополнительныеОтборы", Новый ХранилищеЗначения(ДополнительныеОтборы));
		СписокРасшифровки.Добавить(ПараметрыКарточкиСубконто, ИмяКарточкаСубконто + РасшифровываемоеСубконто);
				
	ИначеЕсли ИмяГруппировки = "Валюта" Тогда
		
		СписокРасшифровки = Новый СписокЗначений;        
		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, ИмяКарточкаСчета + РасшифровываемыйСчетПредставление);
		
	Иначе
		
		СписокРасшифровки = Неопределено;
		
	КонецЕсли;

	Область.Параметры.Расшифровка = СписокРасшифровки;		
	
КонецПроцедуры // ЗаполнитьРасшифровкуДляСчета()

// Процедура выводит итоги отчета оборотно сальдовая ведомость по счету.
// 
// Параметры:
// 	Выборка					  - ВыборкаИзЗапроса.
// 	ИмяРегистраБухгалтерии 	  - Строка.
// 	МассивПоказателей 		  - Массив.
//  Счет 					  - ПланСчетовСсылка.
//  ОбластьИтогиСтрокаЧисла   - Область.
//  ОбластьИтогиЧислаМакет    - Область.
//  ОбластьИтогиСтрокаСчет    - Область.
//  ДокументРезультат 	      - ТабличныйДокумент.
//  ВыводитьРазвернутоеСальдо - Булево.
// 
Процедура ВывестиИтогиОборотноСальдовойВедомостиПоСчету(Знач Выборка, Знач ИмяРегистраБухгалтерии, Знач МассивПоказателей, Знач ФорматПоказателей,
	Знач Счет, Знач ОбластьИтогиСтрокаЧисла, Знач ОбластьИтогиЧислаМакет, Знач ОбластьИтогиСтрокаСчет, Знач ДокументРезультат, ВыводитьРазвернутоеСальдо = Ложь) Экспорт
	
	ЭтоПерваяСтрока = Ложь;

	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл

		Если НЕ Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].Ресурсы[ИмяПоказателя].Балансовый Тогда
			Продолжить;
		КонецЕсли;

		Если ЭтоПерваяСтрока = Истина Тогда
			Область = ОбластьИтогиСтрокаЧисла;
		Иначе
			Область = ОбластьИтогиЧислаМакет;
		КонецЕсли;

		ФорматПоказателя = "";
		ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);

		НачальныйОстатокДт = Выборка[ИмяПоказателя + "НачальныйОстатокДт"];
		НачальныйОстатокКт = Выборка[ИмяПоказателя + "НачальныйОстатокКт"];
		ОборотДт           = Выборка[ИмяПоказателя + "ОборотДт"];
		ОборотКт           = Выборка[ИмяПоказателя + "ОборотКт"];
		КонечныйОстатокДт  = Выборка[ИмяПоказателя + "КонечныйОстатокДт"];
		КонечныйОстатокКт  = Выборка[ИмяПоказателя + "КонечныйОстатокКт"];
		
		Если Счет.Вид = ВидСчета.Активный Тогда 
			
			Если НачальныйОстатокДт = 0 Тогда
				НачальныйОстатокДт = -НачальныйОстатокКт;
				НачальныйОстатокКт = 0;
			КонецЕсли;
			
			Если КонечныйОстатокДт = 0 Тогда
				КонечныйОстатокДт = -КонечныйОстатокКт;
				КонечныйОстатокКт = 0;
			КонецЕсли;
			
		ИначеЕсли Счет.Вид = ВидСчета.Пассивный Тогда
			
			Если НачальныйОстатокКт = 0 Тогда
				НачальныйОстатокКт = -НачальныйОстатокДт;
				НачальныйОстатокДт = 0;
			КонецЕсли;
			
			Если КонечныйОстатокКт = 0 Тогда
				КонечныйОстатокКт = -КонечныйОстатокДт;
				КонечныйОстатокДт = 0;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ВыводитьРазвернутоеСальдо И НачальныйОстатокДт <> Неопределено Тогда
			
			НачальныйОстаток = НачальныйОстатокДт - НачальныйОстатокКт;
			Если НачальныйОстаток > 0 Тогда
				НачальныйСвернутыйОстатокДт = НачальныйОстаток;
				НачальныйСвернутыйОстатокКт = 0;
			Иначе
				НачальныйСвернутыйОстатокДт = 0;
				НачальныйСвернутыйОстатокКт = - НачальныйОстаток;
			КонецЕсли;
			
			КонечныйОстаток = КонечныйОстатокДт - КонечныйОстатокКт;
			Если КонечныйОстаток > 0 Тогда
				КонечныйСвернутыйОстатокДт = КонечныйОстаток;
				КонечныйСвернутыйОстатокКт = 0;
			Иначе
				КонечныйСвернутыйОстатокДт = 0;
				КонечныйСвернутыйОстатокКт = - КонечныйОстаток;
			КонецЕсли;
			
			Область.Параметры.НачальныйРазвернутыйОстатокДт = Формат(НачальныйОстатокДт, ФорматПоказателя);
			Область.Параметры.НачальныйРазвернутыйОстатокКт = Формат(НачальныйОстатокКт, ФорматПоказателя);
			Область.Параметры.НачальныйОстатокДт = Формат(НачальныйСвернутыйОстатокДт, ФорматПоказателя);
			Область.Параметры.НачальныйОстатокКт = Формат(НачальныйСвернутыйОстатокКт, ФорматПоказателя);
			Область.Параметры.ОборотДт           = Формат(ОборотДт, ФорматПоказателя);
			Область.Параметры.ОборотКт           = Формат(ОборотКт, ФорматПоказателя);
			Область.Параметры.КонечныйРазвернутыйОстатокДт  = Формат(КонечныйОстатокДт, ФорматПоказателя);
			Область.Параметры.КонечныйРазвернутыйОстатокКт  = Формат(КонечныйОстатокКт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокДт  = Формат(КонечныйСвернутыйОстатокДт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокКт  = Формат(КонечныйСвернутыйОстатокКт, ФорматПоказателя);
            
		Иначе
			
			Область.Параметры.НачальныйОстатокДт = Формат(НачальныйОстатокДт, ФорматПоказателя);
			Область.Параметры.НачальныйОстатокКт = Формат(НачальныйОстатокКт, ФорматПоказателя);
			Область.Параметры.ОборотДт           = Формат(ОборотДт, ФорматПоказателя);
			Область.Параметры.ОборотКт           = Формат(ОборотКт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокДт  = Формат(КонечныйОстатокДт, ФорматПоказателя);
			Область.Параметры.КонечныйОстатокКт  = Формат(КонечныйОстатокКт, ФорматПоказателя);
			
		КонецЕсли;

		Если ЭтоПерваяСтрока = Истина Тогда
			ДокументРезультат.Вывести(ОбластьИтогиСтрокаСчет, 1);
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
		
		ЭтоПерваяСтрока = Истина;

	КонецЦикла;
	
КонецПроцедуры // ВывестиИтогиОборотноСальдовойВедомостиПоСчету()

#КонецОбласти

#Область Построитель

// Процедура перезаполняет текс тзапроса построителя.
// 
// Параметры:
//  Отчет    - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура ПерезаполнитьТекстЗапроса(Отчет, ЭтаФорма) Экспорт

	// Перезаполнение текста запроса построителя.
	ОтчетОб = ДанныеФормыВЗначение(Отчет, Тип(ЭтаФорма.фКэшЗначений.ИмяТипаОбъекта));
	СинхронизироватьДанныеОтчета(Отчет, ОтчетОб, ЭтаФорма); 	
	ОтчетОб.ПерезаполнитьНачальныеНастройки();  		
	ЭтаФорма.фТекстЗапроса = ОтчетОб.ПостроительОтчета.Текст;	

КонецПроцедуры // ПерезаполнитьТекстЗапроса()

// Процедура обновляет отборы построителя по таблице на форме.
// 
// Параметры:
//  ЭтотОбъект     - Объект.
//  ТаблицаНаФорме - ДанныеФормыКоллекция.
// 
Процедура СинхронизироватьОтборыПостроителяПоТаблицеНаФорме(ЭтотОбъект, ТаблицаНаФорме) Экспорт

	Для каждого СтрокаТаблицы Из ТаблицаНаФорме Цикл
		
		ПутьКДанным = СтрокаТаблицы.ПутьКДанным;
		
		ЭлементОтбораПостроителя = ЭтотОбъект.ПостроительОтчета.Отбор.Найти(ПутьКДанным);
		
		Если ЭлементОтбораПостроителя = Неопределено Тогда
			
			Попытка
				ЭлементОтбораПостроителя = ЭтотОбъект.ПостроительОтчета.Отбор.Добавить(ПутьКДанным);
			Исключение 			
			КонецПопытки;
		КонецЕсли;
		
		Если ЭлементОтбораПостроителя <> Неопределено Тогда 
			
			ЭтоВидСравненияДляСписка = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(СтрокаТаблицы.ВидСравнения);
			Если ЭтоВидСравненияДляСписка И ТипЗнч(СтрокаТаблицы.Значение) <> Тип("СписокЗначений")Тогда 				
				СтрокаТаблицы.ВидСравнения = ВидСравнения.Равно;
			ИначеЕсли Не ЭтоВидСравненияДляСписка И Не ЗначениеЗаполнено(СтрокаТаблицы.Значение) 
						И Не СтрокаТаблицы.Использование Тогда
				СтрокаТаблицы.ВидСравнения = ВидСравнения.Равно;
			КонецЕсли;                                          		
			
			Попытка
				ЗаполнитьЗначенияСвойств(ЭлементОтбораПостроителя, СтрокаТаблицы, , "Значение, ЗначениеПо, ЗначениеС");
			Исключение
				Если СтрокаТаблицы.ВидСравнения = ВидСравнения.ВИерархии Тогда
					СтрокаТаблицы.ВидСравнения = ВидСравнения.Равно;
				ИначеЕсли СтрокаТаблицы.ВидСравнения = ВидСравнения.НеВИерархии Тогда	
					СтрокаТаблицы.ВидСравнения = ВидСравнения.НеРавно;
				ИначеЕсли СтрокаТаблицы.ВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда	
					СтрокаТаблицы.ВидСравнения = ВидСравнения.ВСписке;
				ИначеЕсли СтрокаТаблицы.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда	
					СтрокаТаблицы.ВидСравнения = ВидСравнения.НеВСписке;
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ЭлементОтбораПостроителя, СтрокаТаблицы, , "Значение, ЗначениеПо, ЗначениеС");
			КонецПопытки;
					
			ОписаниеТиповЗначения = ЭлементОтбораПостроителя.ТипЗначения;
			
			СтароеЗначение   = СтрокаТаблицы.Значение;
			СтароеЗначениеС  = СтрокаТаблицы.ЗначениеС;
			СтароеЗначениеПо = СтрокаТаблицы.ЗначениеПо;
						
			Если ТипЗнч(СтрокаТаблицы.Значение) = Тип("СписокЗначений") Тогда
				ЭлементОтбораПостроителя.Значение.ЗагрузитьЗначения(СтрокаТаблицы.Значение.ВыгрузитьЗначения()); 
			Иначе	
				ЭлементОтбораПостроителя.Значение = ОписаниеТиповЗначения.ПривестиЗначение(СтароеЗначение);
			КонецЕсли;
			ЭлементОтбораПостроителя.ЗначениеС  = ОписаниеТиповЗначения.ПривестиЗначение(СтароеЗначениеС);
			ЭлементОтбораПостроителя.ЗначениеПо = ОписаниеТиповЗначения.ПривестиЗначение(СтароеЗначениеПо);
			
		КонецЕсли;
				
	КонецЦикла;	

КонецПроцедуры // СинхронизироватьОтборыПостроителяПоТаблицеНаФорме()

// Процедура обновляет сортировку построителя по таблице на форме.
// 
// Параметры:
//  ЭтотОбъект     - Объект - Текущий объект.
//  ТаблицаНаФорме - ДанныеФормыКоллекция - Таблица.
// 
Процедура СинхронизироватьСортировкуПостроителяПоТаблицеНаФорме(ЭтотОбъект, ТаблицаНаФорме) Экспорт

	ЭтотОбъект.ПостроительОтчета.Порядок.Очистить();
	
	Для каждого СтрокаТаблицы Из ТаблицаНаФорме Цикл
		
		ПутьКДанным = СтрокаТаблицы.ПутьКДанным;
		
		ЭлементСортировкиПостроителя = ЭтотОбъект.ПостроительОтчета.Порядок.Найти(ПутьКДанным);
		
		Если ЭлементСортировкиПостроителя = Неопределено Тогда
			
			ТекНаправление = ?(СтрокаТаблицы.Направление = НаправлениеСортировкиКомпоновкиДанных.Возр
								, НаправлениеСортировки.Возр, НаправлениеСортировки.Убыв);
			Попытка			
				ЭтотОбъект.ПостроительОтчета.Порядок.Добавить(ПутьКДанным
																, СтрокаТаблицы.Имя
																, СтрокаТаблицы.Представление
																, ТекНаправление);
			Исключение 			
			КонецПопытки;
		КонецЕсли;
					
	КонецЦикла;	

КонецПроцедуры // СинхронизироватьСортировкуПостроителяПоТаблицеНаФорме()

// Процедура запоняет данными отбор из таблицы значений.
// 
// Параметры
//  Отбор 							     - Отбор.
//  Таблица 							 - ТаблицаЗначений, структурой колонок полностью повторяющая структуру отбора.
//  ВызыватьИсключениеПриОшибкеУстановки - Булево (По умолчанию = Истина).
// 
Процедура ЗаполнитьОтборИзТаблицыЗначений(Отбор, Таблица, Знач ВызыватьИсключениеПриОшибкеУстановки = Истина) Экспорт

	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицы Из Таблица Цикл
			
			ЭлементОтбора = Неопределено;
			Если НЕ ПустаяСтрока(СтрокаТаблицы.Имя) Тогда
				ЭлементОтбора = Отбор.Найти(СтрокаТаблицы.Имя);
			КонецЕсли;
			
			Попытка
				
				Если ЭлементОтбора = Неопределено Тогда
				
					ЭлементОтбора = Отбор.Добавить(СтрокаТаблицы.ПутьКДанным, СтрокаТаблицы.Имя);
					
				КонецЕсли;
				
				ЭлементОтбора.ВидСравнения = СтрокаТаблицы.ВидСравнения;
				ЭлементОтбора.Использование = СтрокаТаблицы.Использование;
				
				Если СтрокаТаблицы.Значение <> Null Тогда
					ЭлементОтбора.Значение = СтрокаТаблицы.Значение;
				КонецЕсли;
				Если СтрокаТаблицы.ЗначениеС <> Null Тогда
					ЭлементОтбора.ЗначениеС = СтрокаТаблицы.ЗначениеС;
				КонецЕсли;
				Если СтрокаТаблицы.ЗначениеПо <> Null Тогда
					ЭлементОтбора.ЗначениеПо = СтрокаТаблицы.ЗначениеПо;
				КонецЕсли;
				
			Исключение
				
				Если ВызыватьИсключениеПриОшибкеУстановки Тогда
					
					ВызватьИсключение ОписаниеОшибки();
					
				Иначе
					
					Продолжить;
					
				КонецЕсли;
				
			КонецПопытки;
			
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры // ЗаполнитьОтборИзТаблицыЗначений()

// Процедура устанавливает отбор посторителю отчетов по параметрам.
// 
// Параметры:
//  ПостроительОтчета - ПостроительОтчета.
//  СтрокиОтбора 	  - Соответствие/Структура/ТаблицаЗначений.
// 
Процедура ВосстановитьОтборПостроителяОтчетовПоПараметрам(ПостроительОтчета, Знач СтрокиОтбора) Экспорт
	
	Если СтрокиОтбора = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(СтрокиОтбора) = Тип("Соответствие")
		ИЛИ ТипЗнч(СтрокиОтбора) = Тип("Структура") Тогда
		
		Для Каждого Строка Из СтрокиОтбора Цикл
			
			ЭлементОтбора = Неопределено;
			
			// Установим существующие элементы, добавим новые.
			Для Инд = 0 По ПостроительОтчета.Отбор.Количество()-1 Цикл
				
				Если Строка.Ключ = ПостроительОтчета.Отбор[Инд].ПутьКДанным Тогда
					ЭлементОтбора = ПостроительОтчета.Отбор[Инд];
				КонецЕсли;
			
			КонецЦикла;
			
			Попытка
			
				Если ЭлементОтбора = Неопределено Тогда
					ЭлементОтбора = ПостроительОтчета.Отбор.Добавить(Строка.Ключ);
				КонецЕсли;
				
				Если ТипЗнч(Строка.Значение) = Тип("СписокЗначений")
					ИЛИ ТипЗнч(Строка.Значение) = Тип("Массив") ТОгда
					
					ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке;
					ЭлементОтбора.Значение = Строка.Значение;	
					ЭлементОтбора.Использование = Истина;
					
				ИначеЕсли ТипЗнч(Строка.Значение) = Тип("Структура") Тогда
					
					ЭлементОтбора.ВидСравнения  = Строка.Значение.ВидСравнения;
					ЭлементОтбора.Значение      = Строка.Значение.Значение;
					ЭлементОтбора.Использование = Истина;	
					
				Иначе
					ЭлементОтбора.Установить(Строка.Значение);
					
					Если Метаданные.Справочники.Содержит(Строка.Значение.Метаданные())
					   И ЗначениеЗаполнено(Строка.Значение) Тогда
						ЭлементОтбора.ВидСравнения = ВидСравнения.ВИерархии;
					Иначе
						ЭлементОтбора.ВидСравнения = ВидСравнения.Равно;
					КонецЕсли;
				   
				КонецЕсли;	
				
			Исключение
				// Не смогли ограничение установить
				Продолжить;
			КонецПопытки;
			
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(СтрокиОтбора) = Тип("ТаблицаЗначений") Тогда
		
		// Переносим имя отбора из пути к данным
		Для Каждого СтрокаОтбора Из СтрокиОтбора Цикл
			
			СтрокаОтбора.Имя = СтрокаОтбора.ПутьКДанным; 
			
		КонецЦикла;
		
		ЗаполнитьОтборИзТаблицыЗначений(ПостроительОтчета.Отбор, СтрокиОтбора, Ложь);
		
	КонецЕсли;
	
КонецПроцедуры // ВосстановитьОтборПостроителяОтчетовПоПараметрам()

// Процедура устанавливает параметры ограничения запросу из строки ограничений построителя отчета.
// 
// Параметры:
//  Запрос 				- Запрос.
//  СтрокаОтбора 		- СтрокаОтбора.
//  ПостфиксОграничения - Строка.
// 
Процедура УстановитьПараметрыЗапросаПоСтрокеПостроителяОтчета(Запрос, Знач СтрокаОтбора, Знач ПостфиксОграничения) Экспорт
	
	СтрокаПостфикса = Строка(ПостфиксОграничения);
	
	Если СтрокаОтбора.ВидСравнения = ВидСравнения.Содержит
		ИЛИ СтрокаОтбора.ВидСравнения = ВидСравнения.НеСодержит Тогда
		
		// Ограничение на содержит отрабатывается отдельным образом
		// надо из значения ограничения лишние символы преобразовать и дополнить ограничение символами %%.
		
		ИтоговаяСтрокаОграничения = бит_СтрокиКлиентСервер.СформироватьСтрокуДляПоискаВЗапросе(СтрокаОтбора.Значение);
		
		ИтоговаяСтрокаОграничения = "%" + ИтоговаяСтрокаОграничения + "%";
		
		Запрос.УстановитьПараметр("Значение" + СтрокаПостфикса, ИтоговаяСтрокаОграничения);
		
	Иначе	
		
		Запрос.УстановитьПараметр("Значение" + СтрокаПостфикса  , СтрокаОтбора.Значение);
		Запрос.УстановитьПараметр("ЗначениеС" + СтрокаПостфикса , СтрокаОтбора.ЗначениеС);
		Запрос.УстановитьПараметр("ЗначениеПо" + СтрокаПостфикса, СтрокаОтбора.ЗначениеПо);	
	
	КонецЕсли;
	
КонецПроцедуры // УстановитьПараметрыЗапросаПоСтрокеПостроителяОтчета()

// Процедура устанавливает отборы посторителя по субконто счета.
// 
// Параметры:
// 	Счет 			 	   - ПланСчетовСсылка.
// 	ИмяРегистраБухгалтерии - Строка.
// 	ПостроительОтчета 	   - ПостроительОтчета.
// 	ДополнительныеОтборы   - Строка (По умолчанию = "").
// 
Процедура УстановитьЗапросИОтборПостроителяПоСубконтоДляДвижений(Знач Счет, Знач ИмяРегистраБухгалтерии, Знач ПостроительОтчета
																, Знач ДополнительныеОтборы = "") Экспорт
	
	Пока ПостроительОтчета.Отбор.Количество() > 0 Цикл
		ПостроительОтчета.Отбор.Удалить(0);
	КонецЦикла;
		
	ТекстСубконто = "";
	// Если есть субконто, настроим отбор по субконто.
	СтруктураСубконто = Новый Структура;
		
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл  
		СтруктураСубконто.Вставить("Субконто" + ВидСубконто.НомерСтроки, ВидСубконто.ВидСубконто);  				
		ТекстСубконто = ТекстСубконто + ", Субконто" + ВидСубконто.НомерСтроки + ".*";  
	КонецЦикла;
	
	Если Не ПустаяСтрока(ДополнительныеОтборы) Тогда   		
		ТекстСубконто = ТекстСубконто + ", " + ДополнительныеОтборы; 		
	КонецЕсли;
	
	Если Не ПустаяСтрока(ТекстСубконто) Тогда
		СтрокаОграниченийДляПостроителя = "{" + Сред(ТекстСубконто, 3) + "}";
	Иначе
		СтрокаОграниченийДляПостроителя = Сред(ТекстСубконто, 3);
    КонецЕсли;
			
	ПостроительОтчета.Текст = "
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ 1 
		|ИЗ РегистрБухгалтерии." + ИмяРегистраБухгалтерии + ".ДвиженияССубконто(,," + СтрокаОграниченийДляПостроителя + ")";
		
	Для Каждого Элемент Из СтруктураСубконто Цикл
			
		Поле = ПостроительОтчета.ДоступныеПоля.Найти(Элемент.Ключ);
		
		Если Поле <> Неопределено Тогда
		
			Поле.ТипЗначения = Элемент.Значение.ТипЗначения;
			Поле.Представление = Элемент.Значение.Наименование;
				
			Если ПостроительОтчета.Отбор.Найти(Элемент.Ключ) = Неопределено Тогда
				ПостроительОтчета.Отбор.Добавить(Элемент.Ключ);
			КонецЕсли;
		
		КонецЕсли;
			
	КонецЦикла;
	
КонецПроцедуры // УстановитьЗапросИОтборПостроителяПоСубконтоДляДвижений()

// Функция проверяет наличие выбранного показателя,
// если не выбран ни один показатель будет выставлен отказ.
// 
// Параметры:
//  ОтчетОбъект - ОтчетОбъект.
//  МассивПоказателей - Массив показателей (имен реквизитов) типа булево
//                      для проверки активности (По умолчанию = Неопределено).
// 
// Возвращаемое значение:
//  Булево - Нет ошибок.
// 
Функция ПроверитьНаличиеВыбранногоПоказателя(ОтчетОбъект, ЭтоБюджетирование = Истина, ЕстьРесурсСуммаМУ = Ложь) Экспорт 
	
	РезультатПроверки = Ложь;

	МассивПоказателей = Новый Массив;
	МассивПоказателей.Добавить("ВыводитьСуммуРегл");
	МассивПоказателей.Добавить("ВыводитьСуммуУпр");    		
	Если ЭтоБюджетирование Тогда         
		МассивПоказателей.Добавить("ВыводитьСуммуСценарий");          
	ИначеЕсли ЕстьРесурсСуммаМУ Тогда
		МассивПоказателей.Добавить("ВыводитьСуммуМУ");
	КонецЕсли;
       
    Для Каждого ТекПоказатель Из МассивПоказателей Цикл            
        // Если хоть один показатель выбран, тогда выход из цикла.
        Если ОтчетОбъект[ТекПоказатель] Тогда
            РезультатПроверки = Истина;
            Прервать;
        КонецЕсли;           
    КонецЦикла;
    
	Если Не РезультатПроверки Тогда
		// Предупреждение
		ТекстСообщения = Нстр("ru = 'Не выбран ни один числовой показатель для вывода!'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения); 				
    КонецЕсли;
	
	Возврат РезультатПроверки;
	
КонецФункции // ПроверитьНаличиеВыбранногоПоказателя()

// Функция проверяет счет
// 
// Параметры:
// 	Счет - ПланСчетовСсылка.
// 
// Возвращаемое значение:
//  Булево - Нет ошибок.
// 
Функция ПроверитьСчет(Счет) Экспорт
	
	РезультатПроверки = Истина;
	
	// Проверка заполненности счета
	Если Счет.Пустая() Тогда

		// Предупреждение
		ТекстСообщения = Нстр("ru = 'Не выбран счет.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		РезультатПроверки = Ложь;

	КонецЕсли;
	
	Возврат РезультатПроверки;

КонецФункции // ПроверитьСчет()

// Функция проверяет состав табличной части "Субконто".
// 
// Параметры:
//  Субконто - Табличная часть.
//  
// Возвращаемое значение:
//   Булево - Нет ошибок.
// 
Функция ПроверитьКорректностьСубконто(Субконто, КорСубконто = "") Экспорт

	РезультатПроверки = Истина;
	
	Если Субконто.Количество() = 0 Тогда
		
		// Предупреждение
		ТекстСообщения = Нстр("ru = 'Отчет не может быть построен. Не задан ни один вид "+КорСубконто+"субконто.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);			
		РезультатПроверки =  Ложь;
		
	Иначе
	
		Для каждого СтрСубконто Из Субконто Цикл
			
			Если Не ЗначениеЗаполнено(СтрСубконто.ВидСубконто) Тогда
				
				// Предупреждение
				ТекстСообщения = Нстр("ru = 'Отчет не может быть построен. Не задан вид субконто в строке настройки %1%.'");
				ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, СтрСубконто.НомерСтроки);
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
				РезультатПроверки = Ложь;
				
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;

	Возврат РезультатПроверки;
	
КонецФункции // ПроверитьКорректностьСубконто()

// Функция проверяет использование сценария в отборе построителя отчета.
// 
// Параметры:
//  ПостроительОтчета - Построитель отчета.
// 
// Возвращаемое значение:
//  Булево (Истина - если включен отбор по сценарию, Ложь - во всех других случаях).
// 
Функция ПроверитьИспользованиеСценария(ПостроительОтчета) Экспорт
	
	Результат = Ложь;
	
	Если ПостроительОтчета.Отбор.Найти("Сценарий") <> Неопределено Тогда
		Результат = ПостроительОтчета.Отбор.Сценарий.Использование;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПроверитьИспользованиеСценария()
      
#КонецОбласти

#Область ЗаголовокОтчета

// Функция формирует строку ограничений по датам отчета для показа в заголовке формы.
// 
// Параметры:
// 	ДатаНач - Дата.
//  ДатаКон - Дата.
// 
// Возвращаемое значение:
//  Строка - Описание периода.
// 
Функция СформироватьСтрокуВыводаПараметровПоДатам(Знач ДатаНач, Знач ДатаКон) Экспорт

	ТекстПериод         = Нстр("ru = 'Период: '");
	ТекстБезОграничения = Нстр("ru = 'без ограничения'");
	
	Если ДатаНач = '00010101000000' И ДатаКон = '00010101000000' Тогда

		ОписаниеПериода = ТекстПериод + ТекстБезОграничения + ".";

	Иначе

		Если ДатаНач = '00010101000000' ИЛИ ДатаКон = '00010101000000' Тогда

			СтрокаФормата = "ДФ = ""дд.ММ.гггг""; ДП = """ + ТекстБезОграничения + """";
			ОписаниеПериода = ТекстПериод + Формат(ДатаНач, СтрокаФормата) 
							+ " - "      + Формат(ДатаКон, СтрокаФормата) + ".";


		Иначе

			ОписаниеПериода = ТекстПериод + ПредставлениеПериода(НачалоДня(ДатаНач), КонецДня(ДатаКон), "ФП = Истина");

		КонецЕсли;

	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции // СформироватьСтрокуВыводаПараметровПоДатам()

// Формирует строку ограничений по датам отчета для показа в заголовке формы.
// 
// Параметры:
// 	ДатаНач - Дата.
//  ДатаКон - Дата.
// 
// Возвращаемое значение:
//  Строка - Описание периода.
// 
Функция СформироватьСтрокуОграниченийПоДатамДляФормы(Знач ДатаНач, Знач ДатаКон) Экспорт

	// Вывод заголовка, описателя периода и фильтров и заголовка.
	Если ДатаНач = '00010101000000' И ДатаКон = '00010101000000' Тогда

		ОписаниеПериода = Нстр("ru = 'Период не установлен'");
		
	Иначе

		Если ДатаНач = '00010101000000' ИЛИ ДатаКон = '00010101000000' Тогда

			ОписаниеПериода = "" + Формат(ДатаНач, "ДФ = ""дд.ММ.гггг""; ДП = ""...""") 
							+ " - "      + Формат(ДатаКон, "ДФ = ""дд.ММ.гггг""; ДП = ""...""");

		Иначе

			Если ДатаНач <= ДатаКон Тогда
				ОписаниеПериода = "" + ПредставлениеПериода(НачалоДня(ДатаНач), КонецДня(ДатаКон), "ФП = Истина");
			Иначе
				ОписаниеПериода = Нстр("ru = 'Неправильно задан период!'");
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции // СформироватьСтрокуОграниченийПоДатамДляФормы()

// Процедура формирует заголовок отчета.
// 
// Параметры:
//  ОтчетОбъект 		- ОтчетОбъект.
//  ДокументРезультат 	- ТабличныйДокумент.
//  ВысотаЗаголовка 	- Число.
//  ПоказыватьЗаголовок - Булево.
// 
Процедура СформироватьИВывестиЗаголовокОтчета(ОтчетОбъект, ДокументРезультат, ВысотаЗаголовка, ПоказыватьЗаголовок) Экспорт
	
	ОбластьЗаголовка = ОтчетОбъект.СформироватьЗаголовок();
	ВысотаЗаголовка  = ОбластьЗаголовка.ВысотаТаблицы;
	ДокументРезультат.Вывести(ОбластьЗаголовка, 1);
	
	Если ЗначениеЗаполнено(ВысотаЗаголовка) Тогда
		ДокументРезультат.Область("R1:R" + ВысотаЗаголовка).Видимость = ПоказыватьЗаголовок;
	КонецЕсли;
	
КонецПроцедуры // СформироватьИВывестиЗаголовокОтчета()   

// Функция формирует заголовок формы отчета.
// 
// Параметры:
//  Нет
// 
// Возвращаемое значение:
//  Строка
// 
Функция СформироватьЗаголовокФормыОтчета_Бюджетирование(ОтчетОбъект, Период, Организация, СохраненнаяНастройка) Экспорт
    
    ОписаниеПериода = бит_БухгалтерскиеОтчетыСервер.СформироватьСтрокуОграниченийПоДатамДляФормы(Период.ДатаНачала, Период.ДатаОкончания);

	ЗаголовокОтчета = ОтчетОбъект.ЗаголовокОтчета() + " (" + ОписаниеПериода + ") " + ?(ЗначениеЗаполнено(СохраненнаяНастройка), " [" + СохраненнаяНастройка + "]", "");
    
    Возврат ЗаголовокОтчета;
    
КонецФункции // СформироватьЗаголовокФормыОтчета_Бюджетирование()

// Функция формирует заголовок формы отчета.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  ЗаголовокОтчета - Строка.
// 
Функция СформироватьЗаголовокФормыОтчета_Управленческий(ОтчетОбъект, Период, Организация, СохраненнаяНастройка) Экспорт
	
	ОписаниеПериода = бит_БухгалтерскиеОтчетыСервер.СформироватьСтрокуОграниченийПоДатамДляФормы(Период.ДатаНачала, Период.ДатаОкончания);

	Если ЗначениеЗаполнено(Организация) ИЛИ (ТипЗнч(Организация) = Тип("СправочникСсылка.Организации")) Тогда
		
		ЗаголовокОтчета = ОтчетОбъект.ЗаголовокОтчета() +" (" + ОписаниеПериода + ") " + ?(ЗначениеЗаполнено(Организация.НаименованиеПолное), 
																				Организация.НаименованиеПолное, Организация) 
						  + ?(ЗначениеЗаполнено(СохраненнаяНастройка), " [" + СохраненнаяНастройка + "]", "");
	Иначе 
		
		ЗаголовокОтчета = ОтчетОбъект.ЗаголовокОтчета() +" (" + ОписаниеПериода + ") " + Организация 
						  + ?(ЗначениеЗаполнено(СохраненнаяНастройка), " [" + СохраненнаяНастройка + "]", "");
	КонецЕсли;
	
	Возврат ЗаголовокОтчета;
	
КонецФункции // СформироватьЗаголовокФормыОтчета()

// Функция получает полное название организации.
// 
// Параметры:
//  Организация - СправочникСсылка.Организации, СправочникСсылка.бит_му_ПериметрыКонсолидации.
//  
// Возвращаемое значение:
//   Строка, Неопределено.
// 
Функция ПолучитьПолноеНазваниеОрганизации(Организация) Экспорт

	НазваниеОрганизации = ?(ЗначениеЗаполнено(Организация) И ТипЗнч(Организация) = Тип("СправочникСсылка.Организации")
							, Организация.НаименованиеПолное
							, Организация);	

	Если ПустаяСтрока(НазваниеОрганизации) Тогда
		НазваниеОрганизации = Организация;
	КонецЕсли;
	
	Возврат НазваниеОрганизации;
	
КонецФункции // ПолучитьПолноеНазваниеОрганизации()

#КонецОбласти

#Область Колонтитулы

// Установка колонтитулов для отчета
// 
// Параметры
//  ТабличныйДокумент  - ТабличныйДокумент - Отчет, у которого необходимо установить колонтитулы.
//  НазваниеОтчета     - Строка            - Название отчета для вывода в колонтитул.
//  Пользователь       - Строка            - Имя пользователя для вывода в колонтитул.
// 
Процедура УстановитьКолонтитулыПоУмолчанию(ТабличныйДокумент, НазваниеОтчета, Пользователь) Экспорт

	Настройка = ПолучитьНастройкиКолонтитулов();
	
	ТабличныйДокумент.ВерхнийКолонтитул.Выводить          	  = Настройка.ВерхнийКолонтитул.Выводить;
	ТабличныйДокумент.ВерхнийКолонтитул.НачальнаяСтраница 	  = Настройка.ВерхнийКолонтитул.НачальнаяСтраница;
	ТабличныйДокумент.ВерхнийКолонтитул.ВертикальноеПоложение = ВертикальноеПоложение.Низ;
	ТабличныйДокумент.ВерхнийКолонтитул.ТекстСлева   		  = ЗаполнитьТекстКолонтитула(Настройка.ВерхнийКолонтитул.ТекстСлева  , НазваниеОтчета, Пользователь);
	ТабличныйДокумент.ВерхнийКолонтитул.ТекстВЦентре 		  = ЗаполнитьТекстКолонтитула(Настройка.ВерхнийКолонтитул.ТекстВЦентре, НазваниеОтчета, Пользователь);
	ТабличныйДокумент.ВерхнийКолонтитул.ТекстСправа  		  = ЗаполнитьТекстКолонтитула(Настройка.ВерхнийКолонтитул.ТекстСправа , НазваниеОтчета, Пользователь);
	
	ТабличныйДокумент.НижнийКолонтитул.Выводить          	  = Настройка.НижнийКолонтитул.Выводить;
	ТабличныйДокумент.НижнийКолонтитул.НачальнаяСтраница 	  = Настройка.НижнийКолонтитул.НачальнаяСтраница;
	ТабличныйДокумент.НижнийКолонтитул.ВертикальноеПоложение  = ВертикальноеПоложение.Верх;
	ТабличныйДокумент.НижнийКолонтитул.ТекстСлева   		  = ЗаполнитьТекстКолонтитула(Настройка.НижнийКолонтитул.ТекстСлева  , НазваниеОтчета, Пользователь);
	ТабличныйДокумент.НижнийКолонтитул.ТекстВЦентре 		  = ЗаполнитьТекстКолонтитула(Настройка.НижнийКолонтитул.ТекстВЦентре, НазваниеОтчета, Пользователь);
	ТабличныйДокумент.НижнийКолонтитул.ТекстСправа  		  = ЗаполнитьТекстКолонтитула(Настройка.НижнийКолонтитул.ТекстСправа , НазваниеОтчета, Пользователь);
	
КонецПроцедуры // УстановитьКолонтитулыПоУмолчанию()

#КонецОбласти

#Область РасшифровкаОтчетов

// Функция Определяет вид отбора по типу значения объекта.
// 
// Параметры:
//  ЗначениеОтбора - Произвольный.
// 
// Возвращаемое значение:
//   ВидСравнения.
// 
Функция ПолучитьВидОтбораПоТипуЗначения(ЗначениеОтбора) Экспорт
	
	ВидСравненияОтчета = ВидСравнения.Равно;
	
	Если (ЗначениеОтбора = NULL) Или Не ЗначениеЗаполнено(ЗначениеОтбора) Тогда		
		Возврат ВидСравненияОтчета;  		
	КонецЕсли;
	
	// Нужно определить это ссылочный тип или нет.
	Попытка
		
		Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ЗначениеОтбора))
			ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗнч(ЗначениеОтбора)) Тогда
			
			ВидСравненияОтчета = ВидСравнения.ВИерархии;
				                				
		КонецЕсли; 
		
	Исключение
	КонецПопытки;
			
	Возврат ВидСравненияОтчета;
	
КонецФункции // ПолучитьВидОтбораПоТипуЗначения()

// Процедура устанавливает текущую строку в таблице движений для документа - регистратора.
// 
// Параметры:
//  Элементы  - Все элементы формы.
//  Параметры - Структура.
// 
Процедура УстановитьТекущуюСтрокуТаблицыДвиженийДокумента(Элементы, Параметры) Экспорт

	Если Параметры.Свойство("НомерСтрокиДвижения") И Параметры.Свойство("ИмяТабличногоПоля") Тогда
		
		Элементы[Параметры.ИмяТабличногоПоля].ТекущаяСтрока = Параметры.НомерСтрокиДвижения;	
		
	КонецЕсли;

КонецПроцедуры // УстановитьТекущуюСтрокуТаблицыДвиженийДокумента()  

// Процедура перезаполняет отборы по субконто в таблице отборов.
// 
// Параметры:
//  Отчет     	 - ДанныеФормыСтруктура.
//  ЭтаФорма     - УправляемаяФорма.
//  Ид 			 - Строка.
//  ЭтоУдаление  - Булево.
// 
Процедура ОбновитьДанныеФормыПоСубконто(Отчет, ЭтаФорма) Экспорт

	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
				
		// Новый массив субконто
		НовыйМассивСубконто = Новый Массив;
		Для каждого СтрокаСубконто Из Отчет.Субконто Цикл 		
			Если ЗначениеЗаполнено(СтрокаСубконто.ВидСубконто) Тогда
				НовыйМассивСубконто.Добавить(СтрокаСубконто.ВидСубконто);
			КонецЕсли;  			
		КонецЦикла;
		ЭтаФорма.фКэшЗначений.Вставить("МассивСубконто", НовыйМассивСубконто);
		                              		
	ИначеЕсли ЭтаФорма.фКэшЗначений.ЕстьРкСчет Тогда
				
		// Новый массив субконто
		НовыйМассивСубконто = СформироватьМассивСубконтоПоСчету(Отчет.Счет);
									
	КонецЕсли;
	
	ЭтаФорма.фКэшЗначений.Вставить("МассивСубконто", НовыйМассивСубконто);
 	  	
	// ----------------------------------------------------------------------
	// Отборы
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		Для каждого СтрокаТаблицы Из ЭтаФорма.ТаблицаОтбор Цикл
			ОбновитьДанныеСубконтоПоМассиву(СтрокаТаблицы, НовыйМассивСубконто);
		КонецЦикла;
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Отборы корреспонденций
	Если ЭтаФорма.фКэшЗначений.ЕстьРкКорреспонденции Тогда
		Для каждого СтрокаТаблицы Из ЭтаФорма.ТаблицаОтборКорреспонденции Цикл 			
			ДтКт = Сред(СтрЗаменить(СтрокаТаблицы.ПутьКДанным, "Кор", ""), 9, 2);
			Счет = ЭтаФорма.Корреспонденции[СтрокаТаблицы.ИдСтрокиКорреспонденции]["Счет" + ДтКт];
			ОбновитьДанныеСубконтоПоМассиву(СтрокаТаблицы, СформироватьМассивСубконтоПоСчету(Счет), ДтКт);
		КонецЦикла;
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Детализация счета
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаДетализацииСчета Тогда
		ПерезаполнитьТаблицуДетализацииСчета(Отчет, ЭтаФорма);
	КонецЕсли;
		
	// ----------------------------------------------------------------------
	// Перезаполнение текста запроса построителя
	ПерезаполнитьТекстЗапроса(Отчет, ЭтаФорма);	
			
КонецПроцедуры // ОбновитьДанныеФормыПоСубконто()

// Процедура заполняет настройки отчета параметрами расшифровки.
// 
// Параметры:
//  Отчет    			 - ДанныеФормыСтруктура.
//  ЭтаФорма 			 - УправляемаяФорма.
//  ПараметрыРасшифровки - Структура.
// 
Процедура ЗаполнитьОтчетПоПараметрамРасшифровки(Отчет, ЭтаФорма, ПараметрыРасшифровки) Экспорт
	
	ЭтоОтчетПоПроводкам = Найти(ЭтаФорма.фПолноеИмяОтчета, ".бит_ОтчетПоПроводкам") <> 0;
	
	ЗаполнитьЗначенияСвойств(Отчет, ПараметрыРасшифровки);
	                    	
	ЭтаФорма.фПоказыватьЗаголовок = ПараметрыРасшифровки.ПоказыватьЗаголовок;
	
	СтрокаИсключений = "";
	Если ПараметрыРасшифровки.Свойство("Организация") И Отчет.Свойство("Организация") Тогда
		СтрокаИсключений = "Организация, ОрганизацияВидСравнения, ОрганизацияИспользование";	
	КонецЕсли;
	Если ПараметрыРасшифровки.Свойство("ОбщаяРасшифровка") Тогда
		ОбщаяРасшифровка = ПараметрыРасшифровки.ОбщаяРасшифровка;	
		ЗаполнитьЗначенияСвойств(Отчет, ОбщаяРасшифровка, , СтрокаИсключений); 	
	КонецЕсли;
	
	// Субконто
	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
		Для каждого ВидСубконто Из ПараметрыРасшифровки.ВидыСубконто Цикл
			НоваяСтрокаТч = Отчет.Субконто.Добавить();
			НоваяСтрокаТч.ВидСубконто = ВидСубконто;  			
		КонецЦикла;
	КонецЕсли;
	
	// Признаки учета
	ПерезаполнитьПризнакиУчета(Отчет, ЭтаФорма);
		 	
	// Отборы 
	ОтборРасшифровкиСоотв = ?(ПараметрыРасшифровки.Свойство("Отбор")
								, ПараметрыРасшифровки.Отбор, Новый Соответствие);
	ДополнительныеОтборы  = ?(ПараметрыРасшифровки.Свойство("ДополнительныеОтборы")
								, ПараметрыРасшифровки.ДополнительныеОтборы.Получить(), Новый ТаблицаЗначений);
	ОтборРасшифровкиТабл  = ?(ОбщаяРасшифровка.Свойство("Отбор")
								, ОбщаяРасшифровка.Отбор.Получить(), Новый ТаблицаЗначений);
								
	// Исправление 3923
	Если ЭтоОтчетПоПроводкам Тогда
		Для каждого СтрДо Из ДополнительныеОтборы Цикл
			Если Найти(СтрДо.ПутьКДанным, "КорСубконто") <> 0 Тогда
				СтрДо.ПутьКДанным = СтрЗаменить(СтрДо.ПутьКДанным, "КорСубконтоДт", "СубконтоКт");
				СтрДо.ПутьКДанным = СтрЗаменить(СтрДо.ПутьКДанным, "КорСубконтоКт", "СубконтоДт");
				СтрДо.Имя = СтрЗаменить(СтрДо.Имя, "КорСубконтоДт", "СубконтоКт");
				СтрДо.Имя = СтрЗаменить(СтрДо.Имя, "КорСубконтоКт", "СубконтоДт");			
			КонецЕсли;		
		КонецЦикла; 								
	КонецЕсли;
								
	// Таблица отборов
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		
		Если ПараметрыРасшифровки.Свойство("ТаблицаОтборовРасшифровки") Тогда
			
			ТаблицаОтборовРасшифровки = бит_ОбщегоНазначения.РаспаковатьТаблицуЗначений(ПараметрыРасшифровки.ТаблицаОтборовРасшифровки);
			Для каждого СтрТабл Из ТаблицаОтборовРасшифровки Цикл
				СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрТабл);    			
			КонецЦикла;                                             
		
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ОтборРасшифровкиСоотв) Тогда
			
			ЕстьДтКт = ПараметрыРасшифровки.Свойство("СчетДт") 
						ИЛИ ПараметрыРасшифровки.Свойство("СчетКт")
						ИЛИ ПараметрыРасшифровки.Свойство("ВидСчета");
						
			Если Не ЕстьДтКт И ПараметрыРасшифровки.Свойство("Счет") Тогда
			 	ОтборРасшифровкиСоотв.Вставить("Счет", ПараметрыРасшифровки.Счет); 				
			КонецЕсли;
							
			Для каждого КлЗнч Из ОтборРасшифровкиСоотв Цикл  				
				
				Если ЭтоОтчетПоПроводкам Тогда 
					Если ЕстьДтКт И (Найти(КлЗнч.Ключ, "Счет") ИЛИ Найти(КлЗнч.Ключ, "Субконто")) Тогда
						Продолжить;
					КонецЕсли;
					
					НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("ПутьКДанным", КлЗнч.Ключ));
					Если НайденныеСтроки.Количество() > 0 Тогда
						Продолжить;
					КонецЕсли;
					
				КонецЕсли;
				
				// Добавление отборов в таблицу формы
				ОтборПоиска = Новый Структура("ПутьКДанным", КлЗнч.Ключ);
				МассивНайденных = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(ОтборПоиска);
				Если МассивНайденных.Количество() = 0 Тогда
					Если Не ЭтаФорма.фКэшЗначений.ЭтоБюджетирование 
						И КлЗнч.Ключ = "Организация" И Отчет.Свойство("ОрганизацияВидСравнения") Тогда
						Отчет.Организация = КлЗнч.Значение;
						Отчет.ОрганизацияВидСравнения = ВидСравнения.Равно;
						Отчет.ОрганизацияИспользование = Истина;
						Продолжить
					КонецЕсли;
					СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить(); 			
					ЗаполнитьСтрокуОтбораПоКлючуЗначению(СтрокаОтбора, КлЗнч);
				Иначе	
				    ЗаполнитьСтрокуОтбораПоКлючуЗначению(МассивНайденных[0], КлЗнч);
				КонецЕсли;     				
				
				Если СтрокаОтбора.ПутьКДанным = "Сценарий" Тогда
					СтрокаОтбора.Имя = "Сценарий";			
				КонецЕсли;				
				// Изменение кода. Начало. 12.05.2014{{
				Если СтрокаОтбора.ПутьКДанным = "Организация" Тогда
					СтрокаОтбора.Имя = "Организация";
					Если Отчет.Свойство("ОрганизацияВидСравнения") Тогда
						Отчет.Организация = СтрокаОтбора.Значение;
						Отчет.ОрганизацияВидСравнения = СтрокаОтбора.ВидСравнения;
						Отчет.ОрганизацияИспользование = СтрокаОтбора.Использование;					
					КонецЕсли;
				КонецЕсли;
				// Изменение кода. Конец. 12.05.2014}}
				Если СтрокаОтбора.ПутьКДанным = "ЦФО" Тогда
					СтрокаОтбора.Имя = "ЦФО";			
				КонецЕсли;
				
			КонецЦикла;
					
		ИначеЕсли ОтборРасшифровкиТабл.Количество() > 0 Тогда // И Не ЭтоОтчетПоПроводкам Тогда
			
			Для каждого СтрокаОтбораРасш Из ОтборРасшифровкиТабл Цикл
				
				Если ЭтоОтчетПоПроводкам 
					И Найти(СтрокаОтбораРасш.Имя, "Счет") ИЛИ Найти(СтрокаОтбораРасш.Имя, "Субконто") Тогда
					Продолжить;		
				КонецЕсли;
				
				СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить(); 			
				ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаОтбораРасш);
				
				Если ДополнительныеОтборы.Количество() > 0 Тогда
					// + доп отборы
					НайденныеСтрокиДопОтборов = ДополнительныеОтборы.НайтиСтроки(Новый Структура("Имя", СтрокаОтбора.Имя));
					Если НайденныеСтрокиДопОтборов.Количество() > 0 Тогда
						СтрокаДопОтбора = НайденныеСтрокиДопОтборов[0];
						ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаДопОтбора, "ВидСравнения, Значение, ЗначениеПо, ЗначениеС, Использование");				
						ДополнительныеОтборы.Удалить(СтрокаДопОтбора);	
					КонецЕсли;					
				КонецЕсли;
				
			    Если СтрокаОтбора.ПутьКДанным = "Сценарий" Тогда
					СтрокаОтбора.Имя = "Сценарий";			
				КонецЕсли;
				
				// Изменение кода. Начало. 12.05.2014{{
				Если СтрокаОтбора.ПутьКДанным = "Организация" Тогда
					СтрокаОтбора.Имя = "Организация";
					Если Отчет.Свойство("ОрганизацияВидСравнения") Тогда
						Отчет.Организация = СтрокаОтбора.Значение;
						Отчет.ОрганизацияВидСравнения = СтрокаОтбора.ВидСравнения;
						Отчет.ОрганизацияИспользование = СтрокаОтбора.Использование;					
					КонецЕсли;
				КонецЕсли;
				// Изменение кода. Конец. 12.05.2014}}
				
			КонецЦикла;
						
		КонецЕсли;
	
		// + доп отборы
		Если ДополнительныеОтборы.Количество() > 0 Тогда
			Для каждого СтрокаДопОтбора Из ДополнительныеОтборы Цикл
				Если ЭтоОтчетПоПроводкам И Лев(СтрокаДопОтбора.Имя, 8) = "Субконто" Тогда
					Продолжить;				
				КонецЕсли;
				Если Не ЭтаФорма.фКэшЗначений.ЭтоБюджетирование И Лев(СтрокаДопОтбора.Имя, 12) = "Организация" Тогда
				    Отчет.Организация = СтрокаДопОтбора.Значение;
					Отчет.ОрганизацияВидСравнения = ВидСравнения.Равно;
					Отчет.ОрганизацияИспользование = Истина; 					
					Продолжить;
				КонецЕсли;
				СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить(); 			
				ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаДопОтбора);					
				Если СтрокаОтбора.Имя = "Валюта" Тогда
				 	СтрокаОтбора.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.Валюты");				
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
			
		// КонецЕсли;
		
		Если ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда 
			// Сценарий
			УстановитьОтборПоСценарию(Отчет, ЭтаФорма);   
			
			// Изменение кода. Начало. 12.05.2014{{
			// Организация.
			Если бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация() Тогда
				УстановитьОтборПоОрганизации(Отчет, ЭтаФорма);
			КонецЕсли;
			// Изменение кода. Конец. 12.05.2014}}
		КонецЕсли;
	
	КонецЕсли;

	
	// Отчет по проводкам
	Если ЭтоОтчетПоПроводкам Тогда
		
		ЗаполнитьЗначенияСвойств(Отчет, ОтборРасшифровкиСоотв);
		Если ЗначениеЗаполнено(Отчет.Валюта) Тогда
			Отчет.ОтборПоВалюте = Истина;
		КонецЕсли;		
		Если ЗначениеЗаполнено(Отчет.Регистратор) Тогда
			Отчет.ПоРегистратору = Истина;
		КонецЕсли;

		ДтКт = "Дт";
		
		// СтрокаКорр = ЭтаФорма.Корреспонденции.Добавить();
		Если ПараметрыРасшифровки.Свойство("СчетДт") Или ПараметрыРасшифровки.Свойство("СчетКт") Тогда
			СтрокаКорр = ЭтаФорма.Корреспонденции.Добавить();
			ПараметрыРасшифровки.Свойство("СчетДт", СтрокаКорр.СчетДт);
			ПараметрыРасшифровки.Свойство("СчетКт", СтрокаКорр.СчетКт);
			Если ПараметрыРасшифровки.Свойство("Счет") Тогда
				ДтКт = ?(ПараметрыРасшифровки.Счет = СтрокаКорр.СчетДт, "Дт", "Кт");
			ИначеЕсли ПараметрыРасшифровки.Свойство("КорСчет") Тогда	
				ДтКт = ?(ПараметрыРасшифровки.КорСчет = СтрокаКорр.СчетДт, "Кт", "Дт");
			КонецЕсли;
		Иначе
			// Изменение кода. Начало. 28.04.2014{{	
			Если ПараметрыРасшифровки.Свойство("ВидСчета") Тогда
				СтрокаКорр = ЭтаФорма.Корреспонденции.Добавить();
			    Если ПараметрыРасшифровки.ВидСчета = "Дт" Тогда
				    ПараметрыРасшифровки.Свойство("Счет"   , СтрокаКорр.СчетДт);
					ПараметрыРасшифровки.Свойство("КорСчет", СтрокаКорр.СчетКт);
				Иначе
					ДтКт = "Кт";
					ПараметрыРасшифровки.Свойство("Счет"   , СтрокаКорр.СчетКт);
					ПараметрыРасшифровки.Свойство("КорСчет", СтрокаКорр.СчетДт);
				КонецЕсли;
			КонецЕсли;
	     	// Изменение кода. Конец. 28.04.2014}}	
			
		КонецЕсли;
							
		
		Если ДополнительныеОтборы.Количество() > 0 Тогда

			ЗаполнитьДополнительныеОтборыОтчетаПоПроводкам(ЭтаФорма, СтрокаКорр, ДополнительныеОтборы, ДтКт);
			
		ИначеЕсли ОтборРасшифровкиТабл.Количество() > 0 Тогда

			ЗаполнитьДополнительныеОтборыОтчетаПоПроводкам(ЭтаФорма, СтрокаКорр, ОтборРасшифровкиТабл, ДтКт);
		
		Иначе
			
			Если СтрокаКорр <> Неопределено Тогда
			    			
				Для каждого КлЗнч Из ОтборРасшифровкиСоотв Цикл
					Если Лев(КлЗнч.Ключ, 8) = "Субконто" Тогда
						
						СтрокаСубконто = СтрокаКорр.Субконто.Добавить();
						ЗаполнитьСтрокуОтбораПоКлючуЗначению(СтрокаСубконто, КлЗнч, Ложь);
										
						СтрокаОтбора = ЭтаФорма.ТаблицаОтборКорреспонденции.Добавить();
						ЗаполнитьСтрокуОтбораПоКлючуЗначению(СтрокаОтбора, КлЗнч);
						СтрокаОтбора.ИдСтрокиКорреспонденции = 0;
						
					КонецЕсли;				
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
				
	КонецЕсли;
	
	ОбновитьДанныеФормыПоСубконто(Отчет, ЭтаФорма);	
	
	Если Не ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда
		
		ЭтаФорма.фИмяРегистраБухгалтерии = ?(ЗначениеЗаполнено(Отчет.РегистрБухгалтерии)
											, Отчет.РегистрБухгалтерии.ИмяОбъекта
											, "");
											
		// Показатель вывода суммы МУ
		Если бит_ОбщегоНазначения.ЕстьОбъектыМСФО() Тогда		
			
			ЕстьРесурсСуммаМУ = бит_ОбщегоНазначения.ЕстьРесурсСуммаМУРегистраБухгалтерии(ЭтаФорма.фИмяРегистраБухгалтерии);
			ЭтаФорма.Элементы.ВыводитьСуммуМУ.Видимость = ЕстьРесурсСуммаМУ;
			Если Не ЕстьРесурсСуммаМУ Тогда
				Отчет.ВыводитьСуммуМУ = Ложь;
			КонецЕсли;
					
		ИначеЕсли ЭтаФорма.Элементы.Найти("ВыводитьСуммуМУ") <> Неопределено Тогда
			
			ЭтаФорма.Элементы.ВыводитьСуммуМУ.Видимость = Ложь;
			
		КонецЕсли;
		
	КонецЕсли;
			
КонецПроцедуры // ЗаполнитьОтчетПоПараметрамРасшифровки()

#КонецОбласти

#Область КэшЗначений

// Процедура дополняет структуру признаками, относящимися к отчетам по бюджетированию или управленческим.
// 
// Параметры:
//  СтруктураРезультат - Структура.
//  ЭтаФорма  		   - УправляемаяФорма.
//  МетаданныеОбъекта  - Метаданные объекта.
// 
Процедура ЗаполнитьПризнакиПоТипуОтчета(СтруктураРезультат, ЭтаФорма, МетаданныеОбъекта) Экспорт

	ЭтоБюджетирование = Найти(ЭтаФорма.ИмяФормы, "_Бюджетирование") > 0;
	СтруктураРезультат.Вставить("ЭтоБюджетирование", ЭтоБюджетирование);
	
	Если ЭтоБюджетирование Тогда
			
		МетаданныеПланСчетов   = Метаданные.РегистрыБухгалтерии.бит_Бюджетирование.ПланСчетов;
		СтруктураРезультат.Вставить("МаксКоличествоСубконто", МетаданныеПланСчетов.МаксКоличествоСубконто);
		СтруктураРезультат.Вставить("ПустоеСубконто"		, ПланыВидовХарактеристик["бит_ВидыСубконтоБюджетирования"].ПустаяСсылка());
		СтруктураРезультат.Вставить("МассивСубконто"		, Новый Массив);
	
	Иначе
		
		// Переделать начало
		СтруктураРезультат.Вставить("МаксКоличествоСубконто", 4);
		// Переделать конец
		
		СписокВыбораОрганизации = Новый СписокЗначений;
		СписокВыбораОрганизации.ЗагрузитьЗначения(МетаданныеОбъекта.Реквизиты.Организация.Тип.Типы());
		ЭлементСписок = СписокВыбораОрганизации.НайтиПоЗначению(ТипЗнч(Новый СписокЗначений));
		Если ЭлементСписок <> Неопределено Тогда
			СписокВыбораОрганизации.Удалить(ЭлементСписок);		
		КонецЕсли;
		СтруктураРезультат.Вставить("СписокВыбораОрганизации", СписокВыбораОрганизации);
		
		СтруктураРезультат.Вставить("ВидОбъектаРегистрБухгалтерии", Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии);
		СтруктураРезультат.Вставить("СписокДоступныхРегистров"    , СформироватьСписокДоступныхРегистровБухгалтерииДляУправленческихОтчетов());
		
		СтруктураРезультат.Вставить("ПустоеСубконто", Неопределено);
		СтруктураРезультат.Вставить("МассивСубконто", Новый Массив);
		
	КонецЕсли;
		   
КонецПроцедуры // ЗаполнитьПризнакиПоТипуОтчета()

// Процедура дополняет структуру признаками по метаданным объекта.
// 
// Параметры:
//  СтруктураРезультат - Структура.
//  МетаданныеОбъекта  - Метаданные объекта.
// 
Процедура ЗаполнитьПризнакиПоМетаданным(СтруктураРезультат, МетаданныеОбъекта) Экспорт
	
	СтруктураРезультат.Вставить("ЕстьРкПериодичность", МетаданныеОбъекта.Реквизиты.Найти("Периодичность") <> Неопределено);
	
	СтруктураРезультат.Вставить("ЕстьРкСчет"   , МетаданныеОбъекта.Реквизиты.Найти("Счет") <> Неопределено);
	СтруктураРезультат.Вставить("ЕстьРкКорСчет", МетаданныеОбъекта.Реквизиты.Найти("КорСчет") <> Неопределено);
		
	СтруктураРезультат.Вставить("ЕстьРкПоВалютам"	, МетаданныеОбъекта.Реквизиты.Найти("ПоВалютам") <> Неопределено);
	СтруктураРезультат.Вставить("ЕстьРкПоКоличеству", МетаданныеОбъекта.Реквизиты.Найти("ПоКоличеству") <> Неопределено);
	
	СтруктураРезультат.Вставить("ЕстьРкПравилаВыводаИтогов"		 
			, МетаданныеОбъекта.Реквизиты.Найти("ПравилаВыводаИтогов") <> Неопределено);
	СтруктураРезультат.Вставить("ЕстьРкПравилаРазвернутогоСальдо"
			, МетаданныеОбъекта.Реквизиты.Найти("ПравилаРазвернутогоСальдо") <> Неопределено);
	СтруктураРезультат.Вставить("ЕстьРкКорреспонденции"
			, МетаданныеОбъекта.Реквизиты.Найти("Корреспонденции") <> Неопределено);			
			
	СтруктураРезультат.Вставить("ЕстьТчСубконто", МетаданныеОбъекта.ТабличныеЧасти.Найти("Субконто") <> Неопределено);
		
КонецПроцедуры // ЗаполнитьПризнакиПоМетаданным()

// Процедура дополняет структуру признаками по элементам формы.
// 
// Параметры:
//  СтруктураРезультат - Структура.
//  ЭтаФорма  		   - УправляемаяФорма.
// 
Процедура ЗаполнитьПризнакиПоДаннымФормы(СтруктураРезультат, ЭтаФорма) Экспорт

	ИдентификаторИмениОтчета = бит_БухгалтерскиеОтчетыКлиентСервер.ПолучитьИдентификаторИмениОтчета(ЭтаФорма.фПолноеИмяОтчета);
		
	СтруктураРезультат.Вставить("ЕстьТаблицаОтборов"		 , ЭтаФорма.Элементы.Найти("ТаблицаОтбор") <> Неопределено);
		
	СтруктураРезультат.Вставить("ЕстьТаблицаСортировки"		 , ЭтаФорма.Элементы.Найти("ТаблицаСортировки") <> Неопределено);
	
	СтруктураРезультат.Вставить("ЕстьТаблицаДетализацииСчета", ЭтаФорма.Элементы.Найти("ДетализацияСчета") <> Неопределено);
	
	СтруктураРезультат.Вставить("ЕстьТаблицаКорСубконто"     , ЭтаФорма.Элементы.Найти("ТаблицаКорСубконто") <> Неопределено);
	
	СтруктураРезультат.Вставить("ЕстьТаблицаГруппировки"     , ЭтаФорма.Элементы.Найти("ТаблицаГруппировки") <> Неопределено);
	
	Если СтруктураРезультат.ЕстьТаблицаКорСубконто Тогда
             
        // ТипыКорСубконто
        Если СтруктураРезультат.ЭтоБюджетирование Тогда        
            
            СтруктураРезультат.Вставить("ТипыКорСубконто", Метаданные.ПланыВидовХарактеристик.бит_ВидыСубконтоБюджетирования.Тип);   		
    		            
        ИначеЕсли ЗначениеЗаполнено(ЭтаФорма.фИмяРегистраБухгалтерии) Тогда
            
            СтруктураРезультат.Вставить("ТипыКорСубконто", Метаданные.ПланыСчетов[ЭтаФорма.фИмяРегистраБухгалтерии].ВидыСубконто.Тип); 
                        
        КонецЕсли;
        
        // СписокВыбораПредставленияКорСубконто
        СписокВыбораПредставленияКорСубконто = Новый СписокЗначений;
        Для Сч = 1 ПО СтруктураРезультат.МаксКоличествоСубконто Цикл
            СписокВыбораПредставленияКорСубконто.Добавить("КорСубконто" + Строка(Сч), "Кор. субконто " + Строка(Сч));	
        КонецЦикла;            
        СтруктураРезультат.Вставить("СписокВыбораПредставленияКорСубконто", СписокВыбораПредставленияКорСубконто);
        
	КонецЕсли;
	
	Если СтруктураРезультат.ЕстьТаблицаГруппировки Тогда
		
		МассивГруппировок = СформироватьМассивГруппировок(СтруктураРезультат);
		СтруктураРезультат.Вставить("МассивГруппировок", МассивГруппировок);
		
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьПризнакиПоДаннымФормы()

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Процедура заполняет список выбора выда сравнения для сценария.
// 
// Параметры:
//  СписокВыбора - СписокЗначений.
// 
Процедура ЗаполнитьСписокВыбораВидаСравненияДляСценария(СписокВыбора) Экспорт

	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("СправочникСсылка." + бит_ОбщегоНазначения.ПолучитьИмяСправочникаСценарииБюджетирования()));
	ОписаниеТиповСценарий = Новый ОписаниеТипов(МассивТипов);
	
	СписокВыбора.ЗагрузитьЗначения(бит_МеханизмПолученияДанных.СписокВыбораВидаСравнения(ОписаниеТиповСценарий).ВыгрузитьЗначения());	

КонецПроцедуры // ЗаполнитьСписокВыбораВидаСравненияДляСценария()

// Функция получает имя регистра бухгалтерии.
// 
// Параметры:
//  Отчет    - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
//  
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяРегистраБухгалтерии(Отчет, ЭтаФорма) Экспорт

	ИмяРегистраБухгалтерии = ?(ЭтаФорма.фКэшЗначений.ЭтоБюджетирование
								, "бит_Бюджетирование"
								, Отчет.РегистрБухгалтерии.ИмяОбъекта);
	
	Возврат ИмяРегистраБухгалтерии;
	
КонецФункции // ПолучитьИмяРегистраБухгалтерии()

// Функция получает состав периметра консолидации на указанную дату.
// 
// Параметры:
//  ПериметрКонсолидации - СправочникСсылка.бит_му_ПериметрыКонсолидации.
//  Период 				 - Дата.
// 
// Возвращаемое значение:
//  Массив.
// 
Функция ПолучитьСоставПериметраКонсолидации(ПериметрКонсолидации, Период) Экспорт

	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	|ИЗ
	|	РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&Период, ПериметрКонсолидации = &ПериметрКонсолидации) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	|ГДЕ
	|	(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &Период
	|			ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата)
	|";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Запрос.УстановитьПараметр("Период"				, Период);
	Запрос.УстановитьПараметр("ПустаяДата"			, Дата('00010101'));
	Запрос.УстановитьПараметр("ПериметрКонсолидации", ПериметрКонсолидации);
	
	РезультатЗапроса = Запрос.Выполнить();

	Возврат РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("Организация");
	
КонецФункции // ПолучитьСоставПериметраКонсолидации()

// Функция формирует список регистров бухгалтерии, доступных в управленческих отчетах.
// 
// Параметры:
//  ДобавитьБюдж - Булево - добавлять ли регистр Бюджетирование (По умолчанию = Ложь).
//  
// Возвращаемое значение:
//   СписокЗначений.
// 
Функция СформироватьСписокДоступныхРегистровБухгалтерииДляУправленческихОтчетов(ДобавитьБюдж = Ложь) Экспорт

	СписокОбъектовСистемы = Новый СписокЗначений;
	       		
	РегистрыМета = Новый Массив;
	РегистрыМета.Добавить(Метаданные.РегистрыБухгалтерии.бит_Дополнительный_1);
	РегистрыМета.Добавить(Метаданные.РегистрыБухгалтерии.бит_Дополнительный_2);
	РегистрыМета.Добавить(Метаданные.РегистрыБухгалтерии.бит_Дополнительный_3);
	РегистрыМета.Добавить(Метаданные.РегистрыБухгалтерии.бит_Дополнительный_4);
	РегистрыМета.Добавить(Метаданные.РегистрыБухгалтерии.бит_Дополнительный_5);
    
    Если ДобавитьБюдж Тогда
        РегистрыМета.Добавить(Метаданные.РегистрыБухгалтерии.бит_Бюджетирование);
    КонецЕсли;
    
	Для каждого МетаОбъект Из РегистрыМета Цикл
		
		ОбъектСистемы = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(МетаОбъект);
		Если ЗначениеЗаполнено(ОбъектСистемы) Тогда			
			СписокОбъектовСистемы.Добавить(ОбъектСистемы);			
		КонецЕсли; 
		
	КонецЦикла; 
		
	Возврат СписокОбъектовСистемы;
 	
КонецФункции // СформироватьСписокДоступныхРегистровБухгалтерииДляУправленческихОтчетов()

// Функция возвращает соотвествие подчиненных счетов.
// 
// Параметры:
//  ИмяПланаСчетов 				 - Строка (По умолчанию = "").
//  Счет 		   				 - ПланСчетовСсылка[ИмяПланаСчетов].
//  ДобавлятьСамСчетВСоответсвие - Булево (По умолчанию = Ложь).
// 
// Возвращаемое значение:
//  Соответствие.
// 
Функция СформироватьСоответвиеПодчиненныхСчетов(Знач ИмяПланаСчетов = "", Знач Счет, Знач ДобавлятьСамСчетВСоответсвие = Ложь) Экспорт
	
	СоответсвиеСчетов = Новый Соответствие;
	
	Запрос = Новый Запрос();
	
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПланСчетовРегистра.Ссылка КАК Ссылка
		|ИЗ	ПланСчетов." + ИмяПланаСчетов + " КАК ПланСчетовРегистра
		|ГДЕ	ПланСчетовРегистра.Ссылка В Иерархии(&Ссылка)";
		
	Запрос.УстановитьПараметр("Ссылка", Счет);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если (НЕ ДобавлятьСамСчетВСоответсвие)
			И (Выборка.Ссылка = Счет) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		СоответсвиеСчетов.Вставить(Выборка.Ссылка, Выборка.Ссылка);
		
	КонецЦикла;

	Возврат СоответсвиеСчетов;
	
КонецФункции // СформироватьСоответвиеПодчиненныхСчетов()

// Функция приводит значение из выборки к числу.
// 
// Параметры:
//  Значение - Число/NULL.
// 
// Возвращаемое значение:
//   Значение - Число.
// 
Функция ПривестиКЧислу(Значение) Экспорт
	
	Если Значение = NULL Тогда
		Возврат 0;
	Иначе
		Возврат Значение;
	КонецЕсли;
	
КонецФункции // ПривестиКЧислу()

// Процедура перезаполняет таблицу "ТаблицаГруппировки".
// 
// Параметры:
//  Отчет    - ДанныеФормыСтруктура
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура ПерезаполнитьТаблицуГруппировки(Отчет, ЭтаФорма) Экспорт

	КоличествоГрупп = ЭтаФорма.ТаблицаГруппировки.Количество();
	Для Сч = 1 По КоличествоГрупп Цикл
		СтрокаГрупп = ЭтаФорма.ТаблицаГруппировки[КоличествоГрупп-Сч];
	  	Если Найти(СтрокаГрупп.Имя, "Субконто") <> 0 Тогда
	    	ЭтаФорма.ТаблицаГруппировки.Удалить(СтрокаГрупп); 	    
	    КонецЕсли;  	
	КонецЦикла;
	
	КолонкиТз = ДанныеФормыВЗначение(ЭтаФорма.ТаблицаГруппировки, Тип("ТаблицаЗначений")).Колонки;
	
	Если Отчет.Свойство("Субконто") Тогда
		
		Для Каждого СтрСубконто Из Отчет.Субконто Цикл
			
			СтрокаГруппировки = ЭтаФорма.ТаблицаГруппировки.Добавить();
			
			СтрокаГруппировки.Имя           = "Субконто" + СокрЛП(СтрСубконто.НомерСтроки);
			СтрокаГруппировки.Представление = СтрСубконто.ВидСубконто;
			Если КолонкиТз.Найти("Использование") <> Неопределено Тогда
				СтрокаГруппировки.Использование = Истина;
			ИначеЕсли КолонкиТз.Найти("ПутьКДанным") <> Неопределено Тогда	
			 	СтрокаГруппировки.ПутьКДанным  = СтрокаГруппировки.Имя;
				СтрокаГруппировки.ТипИзмерения = ТипИзмеренияПостроителяОтчета.Элементы;
			КонецЕсли;       				
			
		КонецЦикла;
		
	КонецЕсли;
      
КонецПроцедуры // ПерезаполнитьТаблицуГруппировки()

// Функция формирует массив доступных группировок.
// 
// Параметры:
//   фКэшЗначений - Структура.
// 
// Возвращаемое значение:
//   СписокЗначений - Список доступных группировок.
// 
Функция СформироватьМассивГруппировок(фКэшЗначений) Экспорт

	МассивГруппировок = Новый Массив;
	
	Если фКэшЗначений.ЭтоБюджетирование Тогда
		
		Если бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация() Тогда
			МассивГруппировок.Добавить("Организация");
		КонецЕсли;
		
		МассивГруппировок.Добавить("ЦФО");
		
	Иначе
		
		МассивГруппировок.Добавить("Организация");	
		
	КонецЕсли;
	
	Возврат МассивГруппировок;
	
КонецФункции // СформироватьМассивГруппировок()

// Процедура добавляет отбор по организации в расшифровку.
// 
// ОтборГруппировок - Структура.
// ПараметрыРасшифровки.
// 
Процедура ДобавитьОтборПоОрганизацииВРасшифровку(ОтборГруппировок, ПараметрыРасшифровки) Экспорт

	Если ОтборГруппировок <> Неопределено И ОтборГруппировок.Получить("Организация") <> Неопределено Тогда
		ПараметрыРасшифровки.Вставить("Организация"             , ОтборГруппировок.Получить("Организация"));
		ПараметрыРасшифровки.Вставить("ОрганизацияВидСравнения" , ВидСравнения.Равно);
		ПараметрыРасшифровки.Вставить("ОрганизацияИспользование", Истина);
	КонецЕсли;

КонецПроцедуры

// Таблица отборов

// Процедура проверяет наличие отбора по организации
// и если необходимо, удаляет его.
// 
// Параметры:
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура ПроверитьТаблицаОтбор(ЭтаФорма) Экспорт

	Если Не бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация() Тогда
		
		НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("Имя", "Организация"));
		Если НайденныеСтроки.Количество() > 0 Тогда

			ЭтаФорма.ТаблицаОтбор.Удалить(НайденныеСтроки[0]);
			
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры // ПроверитьТаблицаОтбор()

// добавляет отбор по сценарию в таблицу отборов.
// 
// Параметры:
// 	ЭтаФорм      	  - Управляемая форма.
//  СтрокаОтбора 	  - ДанныеФормыЭлементКоллекции.
//  ПодбиратьПериметр - Булево (По умолчанию = Ложь).
// 
Процедура ДобавитьОтборПоОрганизации(ЭтаФорма, СтрокаОтбора = Неопределено, ПодбиратьПериметр = Ложь) Экспорт 
	
	Если Не ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда
		Возврат;	
	КонецЕсли;
	СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить();
		
	СтрокаОтбора.ПутьКДанным   = "Организация";
	СтрокаОтбора.Имя 		   = "Организация";
	СтрокаОтбора.Представление = "Организация";
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("СправочникСсылка.Организации"));
	Если ПодбиратьПериметр И Метаданные.Справочники.Найти("бит_му_ПериметрыКонсолидации") <> Неопределено Тогда
		МассивТипов.Добавить(Тип("СправочникСсылка.бит_му_ПериметрыКонсолидации"));
	КонецЕсли;
	ОписаниеТекущегоТипа = Новый ОписаниеТипов(МассивТипов);
	ПривестиЗначенияЭлементаОтбора(СтрокаОтбора, ОписаниеТекущегоТипа);
		
КонецПроцедуры // ДобавитьОтборПоСценарию()

// Процедура обрабатывает изменение вида сравнения в таблице отбор.
// 
// Параметры:
//  Отчет            - ДанныеФормыСтруктура.
//  ПредВидСравнения - ВидСравнения.
// 
Процедура ИзменениеВидаСравненияОрганизация(Отчет, ПредВидСравнения, ПодбиратьПериметр = Ложь) Экспорт
	
	Если ПредВидСравнения = Отчет.ОрганизацияВидСравнения Тогда
		Возврат;
	КонецЕсли;
		
	флТекВидДляСписка  = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(Отчет.ОрганизацияВидСравнения);
	флПредВидДляСписка = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(ПредВидСравнения);
	
	Если флТекВидДляСписка Тогда
		
		Если НЕ флПредВидДляСписка Тогда
			
			Список             = Новый СписокЗначений;
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(Тип("СправочникСсылка.Организации"));
			Если ПодбиратьПериметр Тогда
				МассивТипов.Добавить(Тип("СправочникСсылка.бит_му_ПериметрыКонсолидации"));
			КонецЕсли;
			Список.ТипЗначения = Новый ОписаниеТипов(МассивТипов);
						
			// Создадим список
			Если ЗначениеЗаполнено(Отчет.Организация) Тогда 				
				Список.Добавить(Отчет.Организация);  				
			КонецЕсли; 
			Отчет.Организация = Список;
									
		КонецЕсли; // НЕ флПредВидДляСписка
		
	Иначе	
		
		Если флПредВидДляСписка Тогда
			
			// Уничтожим список
			Если ТипЗнч(Отчет.Организация) = Тип("СписокЗначений") Тогда
				
				Список = Отчет.Организация;
				Если Список.Количество() > 0 Тогда
					Отчет.Организация = Список[0].Значение;
				Иначе	
					Отчет.Организация = Справочники.Организации.ПустаяСсылка();
				КонецЕсли; 
				
			КонецЕсли; 			
			
		КонецЕсли; // ФлПредВидДляСписка
		
	КонецЕсли; // ФлТекВидДляСписка 
	
КонецПроцедуры // ИзменениеВидаСравненияОрганизация()

// устанавливает отбор по сценарию в таблицу отборов.
// 
// Параметры:
//  Отчет 	 		  - ДанныеФормыСтруктура.
//  ЭтаФорма 		  - УправляемаяФорма.
//  ПредВидСравнения  - ВидСравнения.
//  ПодбиратьПериметр - Булево (По умолчанию = Ложь).
// 
Процедура УстановитьОтборПоОрганизации(Отчет, ЭтаФорма, ПредВидСравнения = Неопределено, ПодбиратьПериметр = Ложь) Экспорт 
	    		
	Если Не ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда 
		ИзменениеВидаСравненияОрганизация(Отчет, ПредВидСравнения, ПодбиратьПериметр);
		Возврат;	
	КонецЕсли;
		
	НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("Имя", "Организация"));
	Если НайденныеСтроки.Количество() > 0 Тогда
		
		СтрокаОтбораПоОрганизации = НайденныеСтроки[0];
		
		ПредВидСравнения = СтрокаОтбораПоОрганизации.ВидСравнения;
		
		СтрокаОтбораПоОрганизации.Использование = Отчет.ОрганизацияИспользование;
		СтрокаОтбораПоОрганизации.ВидСравнения  = Отчет.ОрганизацияВидСравнения;
		СтрокаОтбораПоОрганизации.Значение      = Отчет.Организация;  		   		
		
		Если ПредВидСравнения <> СтрокаОтбораПоОрганизации.ВидСравнения Тогда
			бит_МеханизмПолученияДанных.ИзменениеВидаСравнения(СтрокаОтбораПоОрганизации, ПредВидСравнения);
			Отчет.Организация = СтрокаОтбораПоОрганизации.Значение;
		КонецЕсли;
		
	Иначе
		
		ДобавитьОтборПоОрганизации(ЭтаФорма, СтрокаОтбораПоОрганизации, ПодбиратьПериметр);
		
		СтрокаОтбораПоОрганизации.Использование = Отчет.ОрганизацияИспользование;
		СтрокаОтбораПоОрганизации.ВидСравнения  = Отчет.ОрганизацияВидСравнения;
		СтрокаОтбораПоОрганизации.Значение      = Отчет.Организация;
				
	КонецЕсли;
			
КонецПроцедуры // УстановитьОтборПоОрганизации()

// Функция возвращает Строку Вида отбора для запроса.
// 
// Параметры
//  ВыбВидСравнения  - ВидСравнения.
//  ЗначениеОтбора   - Значение отбора запроса.
//  СтрокаПоляОтбора - Строка, Аргумент запроса, т.е. то что должно быть написано до вида сревнения.
//  ЗначениеОтбораС  - Произвольный, значение отбора для видов сравнения, 
// 						  у которых необходимо указывать два значения, начальное значение.
//  ЗначениеОтбораПо - Произвольный, значение отбора для видов сравнения,
// 						  у которых необходимо указывать два значения, конечное значение.
//  СамоЗначение    - Произвольный.
//  СамоЗначениеС 	- Произвольный.
//  СамоЗначениеПо 	- Произвольный.
// 
// Возвращаемое значение 
//  Строка.
// 
Функция ПолучитьСтрокуОтбораКомповнокиДанных(ВыбВидСравнения, ЗначениеОтбора, СтрокаПоляОтбора, ЗначениеОтбораС = Неопределено, ЗначениеОтбораПо = Неопределено, СамоЗначение = Неопределено, СамоЗначениеС = Неопределено, СамоЗначениеПо = Неопределено) Экспорт

	СтрокаВозврата = "";
	Если ВыбВидСравнения = ВидСравненияКомпоновкиДанных.Равно Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" = " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" <> " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" В (" + ЗначениеОтбора+")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии 
		ИЛИ ВыбВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" В ИЕРАРХИИ(" + ЗначениеОтбора + ")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" НЕ В (" + ЗначениеОтбора + ")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.НеВСпискеПоИерархии 
		ИЛИ ВыбВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" НЕ В ИЕРАРХИИ(" + ЗначениеОтбора + ")");
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.Больше Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" > " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" >= " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.Меньше Тогда
		
		Если НЕ (ТипЗнч(СамоЗначение) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначение)) Тогда
			СтрокаВозврата = СтрокаПоляОтбора + Строка(" < " + ЗначениеОтбора);
		КонецЕсли; 
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно Тогда
		
		Если НЕ (ТипЗнч(СамоЗначение) = Тип("Дата") И НЕ ЗначениеЗаполнено(СамоЗначение)) Тогда
			СтрокаВозврата = СтрокаПоляОтбора + Строка(" <= " + ЗначениеОтбора);
		КонецЕсли; 
						
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.Содержит Тогда
		
		СтрокаВозврата = СтрокаПоляОтбора + Строка(" ПОДОБНО " + ЗначениеОтбора);
		
	ИначеЕсли ВыбВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит Тогда
		
		СтрокаВозврата = "НЕ (" + СтрокаПоляОтбора + Строка(" ПОДОБНО " + ЗначениеОтбора + ")");
		
	КонецЕсли;

	Возврат СтрокаВозврата;
	
КонецФункции // ПолучитьСтрокуОтбора()

// Процедура формирует текст запроса для таблицы дополнительных отборов.
// 
// Параметры:
//  Нет
// 
// Возвращаемое значение:
//  Строка.
// 
Функция СформироватьТекстДопЗапросаДляОтчетаПоПроводкам(ИмяРегистра) Экспорт
	
	ТекстБюдж = ?(ИмяРегистра = "бит_Бюджетирование", " ЦФО.*, Сценарий.*,", " ");

	ТекстДопЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	Проводки.Активность
	|ИЗ
	|	РегистрБухгалтерии." + ИмяРегистра + ".ДвиженияССубконто(, ,
	|							{" + ТекстБюдж + " 
	|							(Счет).* КАК Счет, 
	|							(КорСчет).* КАК КорСчет, 
	|							(Субконто1).* КАК Субконто1, 
	|							(Субконто2).* КАК Субконто2, 
	|							(Субконто3).* КАК Субконто3, 
	|							(Субконто4).* КАК Субконто4,
	|							(КорСубконто1).* КАК КорСубконто1, 
	|							(КорСубконто2).* КАК КорСубконто2, 
	|							(КорСубконто3).* КАК КорСубконто3, 
	|							(КорСубконто4).* КАК КорСубконто4,
	|							(ВидСубконто1) КАК ВидСубконто1, 
	|							(ВидСубконто2) КАК ВидСубконто2, 
	|							(ВидСубконто3) КАК ВидСубконто3, 
	|							(ВидСубконто4) КАК ВидСубконто4, 
	|							(ВидКорСубконто1) КАК ВидКорСубконто1, 
	|							(ВидКорСубконто2) КАК ВидКорСубконто2, 
	|							(ВидКорСубконто3) КАК ВидКорСубконто3, 
	|							(ВидКорСубконто4) КАК ВидКорСубконто4
	|							}, , ) КАК Проводки
	|";
	
	Возврат ТекстДопЗапроса;
	
КонецФункции // СформироватьТекстДопЗапросаДляОтчетаПоПроводкам()

#КонецОбласти

#Область Проверки

// Функция проверяет заполнение регистра бухгалтерии.
// 
// Параметры:
//  РегистрБухгалтерии - СправочникСсылка.бит_ОбъектыСистемы.
// 
Функция  ПроверитьЗаполнениеРегистраБухгалтерии(РегистрБухгалтерии) Экспорт
	
	Результат = Истина;
	
	Если Не ЗначениеЗаполнено(РегистрБухгалтерии) Тогда
		
		ТекстСообщения = Нстр("ru = 'Не выбран регистр бухгалтерии!'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения); 

		Результат = Ложь;
		
	КонецЕсли;
	
	Возврат Результат;

КонецФункции // ПроверитьЗаполнениеРегистраБухгалтерии()

// Процедура заполняет список выбора выда сравнения для организации.
// 
// Параметры:
//  СписокВыбора - СписокЗначений - Список для выбора.
// 
Процедура ЗаполнитьСписокВыбораВидаСравненияДляОрганизации(СписокВыбора) Экспорт

	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("СправочникСсылка.Организации"));
	ОписаниеТиповОрг = Новый ОписаниеТипов(МассивТипов);
	
	СписокВыбора.ЗагрузитьЗначения(бит_МеханизмПолученияДанных.СписокВыбораВидаСравнения(ОписаниеТиповОрг).ВыгрузитьЗначения());	
		
КонецПроцедуры // ЗаполнитьСписокВыбораВидаСравненияДляОрганизации()

#КонецОбласти

#Область РасшифровкаОтчетаОборотыМеждуСубконто

// Процедура заполняет настройки отчета параметрами расшифровки.
// 
// Параметры:
//  Отчет    			 - ДанныеФормыСтруктура.
//  ЭтаФорма 			 - УправляемаяФорма.
//  ПараметрыРасшифровки - Структура.
// 
Процедура ЗаполнитьОтчетПоПроводкамПоПараметрамРасшифровки(Отчет, ЭтаФорма, ПараметрыРасшифровки) Экспорт
	
	ЭтоОтчетПоПроводкам = Найти(ЭтаФорма.фПолноеИмяОтчета, ".бит_ОтчетПоПроводкам") <> 0;
	
	ЗаполнитьЗначенияСвойств(Отчет, ПараметрыРасшифровки);
	                    	
	ЭтаФорма.фПоказыватьЗаголовок = ПараметрыРасшифровки.ПоказыватьЗаголовок;
	
	Если ПараметрыРасшифровки.Свойство("ОбщаяРасшифровка") Тогда
		ОбщаяРасшифровка = ПараметрыРасшифровки.ОбщаяРасшифровка;	
		ЗаполнитьЗначенияСвойств(Отчет, ОбщаяРасшифровка); 	
	КонецЕсли;
	
	// Субконто
	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
		Для каждого ВидСубконто Из ПараметрыРасшифровки.ВидыСубконто Цикл
			НоваяСтрокаТч = Отчет.Субконто.Добавить();
			НоваяСтрокаТч.ВидСубконто = ВидСубконто;  			
		КонецЦикла;
	КонецЕсли;
	
	// Признаки учета
	ПерезаполнитьПризнакиУчета(Отчет, ЭтаФорма);
		 	
	// Отборы 
	ОтборРасшифровкиСоотв = ?(ПараметрыРасшифровки.Свойство("Отбор")
								, ПараметрыРасшифровки.Отбор, Новый Соответствие);
	ДополнительныеОтборы  = ?(ПараметрыРасшифровки.Свойство("ДополнительныеОтборы")
								, ПараметрыРасшифровки.ДополнительныеОтборы.Получить(), Новый ТаблицаЗначений);
	ОтборРасшифровкиТабл  = ?(ОбщаяРасшифровка.Свойство("Отбор")
								, ОбщаяРасшифровка.Отбор.Получить(), Новый ТаблицаЗначений);
										 
	// Таблица отборов
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		
		Если ЗначениеЗаполнено(ОтборРасшифровкиСоотв) Тогда
		 		
			Для каждого КлЗнч Из ОтборРасшифровкиСоотв Цикл  				
				
				Если ЭтоОтчетПоПроводкам Тогда 
					// Изменение кода. Начало. 12.05.2014{{
					Если (КлЗнч.Ключ = "Сценарий" Или КлЗнч.Ключ = "ЦФО" ИЛИ КлЗнч.Ключ = "Организация") Тогда
					// Изменение кода. Конец. 12.05.2014}}
						НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("ПутьКДанным", КлЗнч.Ключ));
						Если НайденныеСтроки.Количество() > 0 Тогда
							Продолжить;
						КонецЕсли;	
					Иначе
						Продолжить;
					КонецЕсли;						
				КонецЕсли;
				
				// Добавление отборов в таблицу формы
				СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить(); 			
				ЗаполнитьСтрокуОтбораПоКлючуЗначению(СтрокаОтбора, КлЗнч);
			    Если СтрокаОтбора.ПутьКДанным = "Сценарий" Тогда
					СтрокаОтбора.Имя = "Сценарий";			
				КонецЕсли;
				
				// Изменение кода. Начало. 12.05.2014{{
				Если СтрокаОтбора.ПутьКДанным = "Организация" Тогда
					СтрокаОтбора.Имя = "Организация";			
				КонецЕсли;
				// Изменение кода. Конец. 12.05.2014}}
				
			КонецЦикла;
		
		ИначеЕсли ОтборРасшифровкиТабл.Количество() > 0 И Не ЭтоОтчетПоПроводкам Тогда
			
			Для каждого СтрокаОтбораРасш Из ОтборРасшифровкиТабл Цикл
				
				СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить(); 			
				ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаОтбораРасш);
				
				Если ДополнительныеОтборы.Количество() > 0 Тогда
					НайденныеСтрокиДопОтборов = ДополнительныеОтборы.НайтиСтроки(Новый Структура("Имя", СтрокаОтбора.Имя));
					Если НайденныеСтрокиДопОтборов.Количество() > 0 Тогда
						СтрокаДопОтбора = НайденныеСтрокиДопОтборов[0];
						ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаДопОтбора, "ВидСравнения, Значение, ЗначениеПо, ЗначениеС, Использование");				
						ДополнительныеОтборы.Удалить(СтрокаДопОтбора);	
					КонецЕсли;					
				КонецЕсли;
				
			    Если СтрокаОтбора.ПутьКДанным = "Сценарий" Тогда
					СтрокаОтбора.Имя = "Сценарий";			
				КонецЕсли;
				
				// Изменение кода. Начало. 12.05.2014{{
				Если СтрокаОтбора.ПутьКДанным = "Организация" Тогда
					СтрокаОтбора.Имя = "Организация";			
				КонецЕсли;
				// Изменение кода. Конец. 12.05.2014}}
				
			КонецЦикла;
						
		КонецЕсли;
		
		Если ДополнительныеОтборы.Количество() > 0 Тогда
			Для каждого СтрокаДопОтбора Из ДополнительныеОтборы Цикл
				СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить(); 			
				ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаДопОтбора);
				Если СтрокаОтбора.Имя = "Валюта" Тогда
				 	СтрокаОтбора.ТипЗначения = Новый ОписаниеТипов("СправочникСсылка.Валюты");				
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если ЭтаФорма.фКэшЗначений.ЭтоБюджетирование Тогда 
			// Сценарий
			УстановитьОтборПоСценарию(Отчет, ЭтаФорма);   
			
			// Изменение кода. Начало. 12.05.2014{{
			Если бит_МеханизмДопИзмерений.ЕстьДопИзмерениеОрганизация() Тогда
				УстановитьОтборПоОрганизации(Отчет, ЭтаФорма);
			КонецЕсли;
			// Изменение кода. Конец. 12.05.2014}}
		КонецЕсли;
	
	КонецЕсли;

	
	// Отчет по проводкам
	Если ЭтоОтчетПоПроводкам Тогда
		
		ЗаполнитьЗначенияСвойств(Отчет, ОтборРасшифровкиСоотв);
		Если ЗначениеЗаполнено(Отчет.Валюта) Тогда
			Отчет.ОтборПоВалюте = Истина;
		КонецЕсли;		
		Если ЗначениеЗаполнено(Отчет.Регистратор) Тогда
			Отчет.ПоРегистратору = Истина;
		КонецЕсли;

		ДтКт = "Дт";
		
		СтрокаКорр = ЭтаФорма.Корреспонденции.Добавить();
		Если ПараметрыРасшифровки.Свойство("СчетДт") Или ПараметрыРасшифровки.Свойство("СчетКт") Тогда
			ПараметрыРасшифровки.Свойство("СчетДт", СтрокаКорр.СчетДт);
			ПараметрыРасшифровки.Свойство("СчетКт", СтрокаКорр.СчетКт);
			Если ПараметрыРасшифровки.Свойство("Счет") Тогда
				ДтКт = ?(ПараметрыРасшифровки.Счет = СтрокаКорр.СчетДт, "Дт", "Кт");
			ИначеЕсли ПараметрыРасшифровки.Свойство("КорСчет") Тогда	
				ДтКт = ?(ПараметрыРасшифровки.КорСчет = СтрокаКорр.СчетДт, "Кт", "Дт");
			КонецЕсли;
		Иначе
			// Изменение кода. Начало. 28.04.2014{{	
			Если ПараметрыРасшифровки.Свойство("ВидСчета") Тогда
				
			    Если ПараметрыРасшифровки.ВидСчета = "Дт" Тогда
				    ПараметрыРасшифровки.Свойство("Счет"   , СтрокаКорр.СчетДт);
					ПараметрыРасшифровки.Свойство("КорСчет", СтрокаКорр.СчетКт);
				Иначе
					ДтКт = "Кт";
					ПараметрыРасшифровки.Свойство("Счет"   , СтрокаКорр.СчетКт);
					ПараметрыРасшифровки.Свойство("КорСчет", СтрокаКорр.СчетДт);
				КонецЕсли;
				
			КонецЕсли;
	     	// Изменение кода. Конец. 28.04.2014}}	
		КонецЕсли;
		
		Ид = ЭтаФорма.Корреспонденции[0].ПолучитьИдентификатор();
		ЗаполнитьТаблицуОтборовПоСчетамСтрокиКорреспонденции(Отчет, ЭтаФорма, Ид);
		
		Если ДополнительныеОтборы.Количество() > 0 Тогда

			ЗаполнитьДополнительныеОтборыОтчетаПоПроводкам(ЭтаФорма, СтрокаКорр, ДополнительныеОтборы, ДтКт);
			
		ИначеЕсли ОтборРасшифровкиТабл.Количество() > 0 Тогда

			ЗаполнитьДополнительныеОтборыОтчетаПоПроводкам(ЭтаФорма, СтрокаКорр, ОтборРасшифровкиТабл, ДтКт);
		
		Иначе
		
			Для каждого КлЗнч Из ОтборРасшифровкиСоотв Цикл
				Если Найти(КлЗнч.Ключ, "Субконто") <> 0 Тогда
					
					СтрокаСубконто = СтрокаКорр.Субконто.Добавить();
					ЗаполнитьСтрокуОтбораПоКлючуЗначению(СтрокаСубконто, КлЗнч, Ложь);
					
					Для Каждого СтрокаОтбора Из ЭтаФорма.ТаблицаОтборКорреспонденции Цикл
						
						МассивТипов = Новый Массив;
						МассивТипов.Добавить(ТипЗнч(КлЗнч.Значение));
						ТипЗначения = Новый ОписаниеТипов(МассивТипов);

						Если СтрокаОтбора.ТипЗначения = ТипЗначения Тогда
							ЗаполнитьСтрокуОтбораПоКлючуЗначению(СтрокаОтбора, КлЗнч, Истина);
						КонецЕсли;
					КонецЦикла;
										
				КонецЕсли;				
			КонецЦикла;
		
		КонецЕсли;
				
	КонецЕсли;
	
	ОбновитьДанныеФормыПоСубконтоОтчетПоПроводкам(Отчет, ЭтаФорма);	
				
КонецПроцедуры // ЗаполнитьОтчетПоПараметрамРасшифровки()

// Процедура перезаполняет отборы по субконто в таблице отборов.
// 
// Параметры:
//  Отчет     	 - ДанныеФормыСтруктура.
//  ЭтаФорма     - УправляемаяФорма.
//  Ид 			 - Строка.
//  ЭтоУдаление  - Булево.
// 
Процедура ОбновитьДанныеФормыПоСубконтоОтчетПоПроводкам(Отчет, ЭтаФорма) Экспорт

	Если ЭтаФорма.фКэшЗначений.ЕстьТчСубконто Тогда
				
		// Новый массив субконто
		НовыйМассивСубконто = Новый Массив;
		Для каждого СтрокаСубконто Из Отчет.Субконто Цикл 		
			Если ЗначениеЗаполнено(СтрокаСубконто.ВидСубконто) Тогда
				НовыйМассивСубконто.Добавить(СтрокаСубконто.ВидСубконто);
			КонецЕсли;  			
		КонецЦикла;
		ЭтаФорма.фКэшЗначений.Вставить("МассивСубконто", НовыйМассивСубконто);
		                              		
	ИначеЕсли ЭтаФорма.фКэшЗначений.ЕстьРкСчет Тогда
				
		// Новый массив субконто
		НовыйМассивСубконто = СформироватьМассивСубконтоПоСчету(Отчет.Счет);
									
	КонецЕсли;
	
	ЭтаФорма.фКэшЗначений.Вставить("МассивСубконто", НовыйМассивСубконто);
 	  	
	// ----------------------------------------------------------------------
	// Отборы
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
		Для каждого СтрокаТаблицы Из ЭтаФорма.ТаблицаОтбор Цикл
			ОбновитьДанныеСубконтоПоМассиву(СтрокаТаблицы, НовыйМассивСубконто);
		КонецЦикла;
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Отборы корреспонденций
	Если ЭтаФорма.фКэшЗначений.ЕстьРкКорреспонденции Тогда
		ЭтаФорма.Корреспонденции[0].Субконто.Очистить();
		
		Для каждого СтрокаТаблицы Из ЭтаФорма.ТаблицаОтборКорреспонденции Цикл 	
			ДтКт = Сред(СтрокаТаблицы.ПутьКДанным, 9, 2);
			
			Счет = ЭтаФорма.Корреспонденции[СтрокаТаблицы.ИдСтрокиКорреспонденции]["Счет" + ДтКт];
			ОбновитьДанныеСубконтоПоМассивуОтчетПоПроводкам(ЭтаФорма, СтрокаТаблицы, СформироватьМассивСубконтоПоСчету(Счет), ДтКт);
		КонецЦикла;
	КонецЕсли;
	
	// ----------------------------------------------------------------------
	// Детализация счета
	Если ЭтаФорма.фКэшЗначений.ЕстьТаблицаДетализацииСчета Тогда
		ПерезаполнитьТаблицуДетализацииСчета(Отчет, ЭтаФорма);
	КонецЕсли;
		
	// ----------------------------------------------------------------------
	// Перезаполнение текста запроса построителя
	ПерезаполнитьТекстЗапроса(Отчет, ЭтаФорма);	
			
КонецПроцедуры // ПерезаполнитьДанныеФормыПоСубконто()

// Процедура заполняет счет по умолчанию.
// 
// Параметры:
//  Счет.
// 
Процедура ЗаполнитьСчетПоУмолчанию_Бюджетирование(Счет) Экспорт

	Если Счет = Неопределено Тогда		
		Счет = ПланыСчетов.бит_Бюджетирование.ПустаяСсылка();
	КонецЕсли;	

КонецПроцедуры // ЗаполнитьСчетПоУмолчанию_Бюджетирование()

// Процедура заполняет таблицу кор субконто по умолчанию.
// 
// Параметры:
//  ТаблицаКорСубконто.
//  МаксКоличествоСубконто - Число.
// 
Процедура ЗаполнитьТаблицуКорСубконтоПоУмолчанию(ТаблицаКорСубконто, МаксКоличествоСубконто) Экспорт

	Если ТаблицаКорСубконто.Количество() = 0 Тогда	
		
		Для Сч = 1 По МаксКоличествоСубконто Цикл
			СтрокаКорСубконто = ТаблицаКорСубконто.Добавить();	
			СтрокаКорСубконто.Имя = "КорСубконто" + Строка(Сч);
		    СтрокаКорСубконто.Представление = "Кор. субконто " + Строка(Сч);
		КонецЦикла;
		
	КонецЕсли;	

КонецПроцедуры // ЗаполнитьТаблицуКорСубконтоПоУмолчанию()

// Процедура обрабатывает изменение вида сравнения в таблице отбор.
// 
// Параметры:
//  Отчет            - ДанныеФормыСтруктура.
// 
Процедура ИзменениеВидаСравненияКорСчета(Отчет, ПредВидСравнения) Экспорт
	
	Если ПредВидСравнения = Отчет.КорСчетВидСравнения Тогда
		Возврат;
	КонецЕсли;
		
	флТекВидДляСписка  = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(Отчет.КорСчетВидСравнения);
	флПредВидДляСписка = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(ПредВидСравнения);
		
	Если флТекВидДляСписка Тогда
		
		Если НЕ флПредВидДляСписка Тогда
			
			ТекТип = ТипЗнч(Отчет.КорСчет);
			
			Список      = Новый СписокЗначений;
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТекТип);
			Список.ТипЗначения = Новый ОписаниеТипов(МассивТипов);
						
			// Создадим список
			Если ЗначениеЗаполнено(Отчет.КорСчет) Тогда 				
				Список.Добавить(Отчет.КорСчет);  				
			КонецЕсли; 
			Отчет.КорСчет = Список;
									
		КонецЕсли; // НЕ флПредВидДляСписка
		
	Иначе	 		
		
		Если флПредВидДляСписка Тогда
			
			// Уничтожим список
			Если ТипЗнч(Отчет.КорСчет) = Тип("СписокЗначений") Тогда
				
				Список = Отчет.КорСчет;
				
				Если Список.Количество() > 0 Тогда
					Отчет.КорСчет = Список[0].Значение;
				Иначе
					ТекТип = ТипЗнч(Отчет.Счет);
					Список      = Новый СписокЗначений;
					МассивТипов = Новый Массив;
					МассивТипов.Добавить(ТекТип);
					ТипСчета = Новый ОписаниеТипов(МассивТипов);
					Отчет.КорСчет = ТипСчета.ПривестиЗначение()
				КонецЕсли; 
				
			КонецЕсли; 			
			
		КонецЕсли; // ФлПредВидДляСписка
		
	КонецЕсли; // ФлТекВидДляСписка 
	
КонецПроцедуры // ИзменениеВидаСравненияКорСчета()

// устанавливает или удаляет отбор по валюте в таблице отборов.
// 
// Параметры:
//  Отчет 	 - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура ПерезаполнитьОтборПоВалюте(Отчет, ЭтаФорма) Экспорт

	ПоВалютам = Ложь;
	Попытка
		ПоВалютам = Отчет.ПоВалютам;	
	Исключение
	    Возврат;
	КонецПопытки;
	
	НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("Имя", "Валюта"));
	
	Если ПоВалютам Тогда
		Если НайденныеСтроки.Количество() = 0 Тогда			
			ДобавитьОтборПоВалюте(ЭтаФорма);  			
		КонецЕсли;
	ИначеЕсли НайденныеСтроки.Количество() <> 0 Тогда
		ЭтаФорма.ТаблицаОтбор.Удалить(НайденныеСтроки[0]);	
	КонецЕсли;

КонецПроцедуры // ПерезаполнитьОтборПоВалюте()

#КонецОбласти

#Область ФормированиеОтчетов

// Функция получает значение параметра организации/периметра.
// 
// Параметры:
//  Организация - СправочникСсылка.Организации, СправочникСсылка.бит_му_ПериметрыКонсолидации.
//  Период		- СтандартныйПериод.
//  
// Возвращаемое значение:
//   Справочник.Организации, Справочник.бит_му_ПериметрыКонсолидации.
// 
//ижтиси, шадрин, 01.09.2015(добавлен параметр СУсловиямиДляОсновногоПараметра)
//Функция ПолучитьЗначениеПараметраОрганизации(Организация, Период) Экспорт
Функция ПолучитьЗначениеПараметраОрганизации(Организация, Период, СУсловиямиДляОсновногоПараметра = Ложь) Экспорт
//ижтиси, шадрин, 01.09.2015(добавлен параметр СУсловиямиДляОсновногоПараметра)

	СтрТипПериметр = "СправочникСсылка.бит_му_ПериметрыКонсолидации";
	
	Если ТипЗнч(Организация) = Тип("СписокЗначений") Тогда
		
		ЗначениеПараметра = Новый Массив;
		
		Для каждого ЭлементСписка Из Организация Цикл
			
			Если бит_ОбщегоНазначенияКлиентСервер.ЭтоУказанныйТип(ТипЗнч(ЭлементСписка.Значение), СтрТипПериметр) Тогда			
				СоставПериметра = бит_БухгалтерскиеОтчетыСервер.ПолучитьСоставПериметраКонсолидации(ЭлементСписка.Значение, Период.ДатаОкончания);
				Для каждого ЭлементСпискаПериметра Из СоставПериметра Цикл
					ЗначениеПараметра.Добавить(ЭлементСпискаПериметра);
				КонецЦикла;
			Иначе      				
				ЗначениеПараметра.Добавить(ЭлементСписка.Значение); 							
			КонецЕсли;      			
		
		КонецЦикла;
				
	ИначеЕсли бит_ОбщегоНазначенияКлиентСервер.ЭтоУказанныйТип(ТипЗнч(Организация), СтрТипПериметр) Тогда		
		
		//ижтиси, шадрин, 01.09.2015(
		//ЗначениеПараметра = бит_БухгалтерскиеОтчетыСервер.ПолучитьСоставПериметраКонсолидации(Организация, Период.ДатаОкончания);
		Если СУсловиямиДляОсновногоПараметра Тогда
			ЗначениеПараметра = бит_БухгалтерскиеОтчетыСервер.ПолучитьСоставПериметраКонсолидацииСУсловиямиДляОсновногоПараметра(Организация,Период.ДатаНачала, Период.ДатаОкончания);
		Иначе
			ЗначениеПараметра = бит_БухгалтерскиеОтчетыСервер.ПолучитьСоставПериметраКонсолидации(Организация, Период.ДатаОкончания);
		КонецЕсли;
		//ижтиси, шадрин, 01.09.2015(
		
	Иначе
		
		ЗначениеПараметра = Организация;
		
	КонецЕсли;	

	Возврат ЗначениеПараметра;
	
КонецФункции // ПолучитьЗначениеПараметраОрганизации()

// Процедура устанавливает параметры запроса КорСубконто.
// 
// Параметры:
//  Запрос.
//  ТаблицаКорСубконто.
// 
Процедура УстановитьПараметрЗапроса_КорСубконто(Запрос, ТаблицаКорСубконто) Экспорт

	Для каждого СтрТабл Из ТаблицаКорСубконто Цикл
		
		Если СтрТабл.Использование Тогда
			Запрос.УстановитьПараметр(СтрТабл.Имя , СтрТабл.Значение);	
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // УстановитьПараметрЗапроса_КорСубконто()

// Процедура дополняет структуру ограничений по счету.
// 
// Параметры:
//  СтрокаОграниченийПоРеквизитам - Строка.
//  Организация 				  - СправочникСсылка.Организации Или СправочникСсылка.бит_му_ПериметрыКонсолидации.
// 
Процедура ДополнитьСтрокуОграниченийПоСчету(СтрокаОграниченийПоРеквизитам, Счет, Знач СчетВидСравнения, СчетИспользование) Экспорт
	
	Если Не СчетИспользование Тогда
		Возврат;
	КонецЕсли;	
	
	Если СчетВидСравнения = ВидСравнения.Равно Тогда
		СтрокаНО = "КорСчет = &КорСчет";
	ИначеЕсли СчетВидСравнения = ВидСравнения.НеРавно Тогда
		СтрокаНО = "КорСчет <> &КорСчет";
		
	ИначеЕсли СчетВидСравнения = ВидСравнения.ВСписке Тогда	
		СтрокаНО = "КорСчет В (&КорСчет)";
	ИначеЕсли СчетВидСравнения = ВидСравнения.НеВСписке Тогда
		СтрокаНО = "КорСчет Не В (&КорСчет)";    		
		
	ИначеЕсли СчетВидСравнения = ВидСравнения.ВИерархии ИЛИ СчетВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
		СтрокаНО = "КорСчет В ИЕРАРХИИ (&КорСчет)";
	ИначеЕсли СчетВидСравнения = ВидСравнения.НеВИерархии ИЛИ СчетВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
		СтрокаНО = "КорСчет НЕ В ИЕРАРХИИ (&КорСчет)";
	КонецЕсли;
				
	СтрокаОграниченийПоРеквизитам = ОбъединитьОграничения(СтрокаОграниченийПоРеквизитам, СтрокаНО);
    
КонецПроцедуры // ДополнитьСтрокуОграниченийПоСчету()

// Процедура дополняет структуру ограничений по субконто.
// 
// Параметры:
//  СтрокаОграниченийПоРеквизитам - Строка.
//  Организация 				  - СправочникСсылка.Организации Или СправочникСсылка.бит_му_ПериметрыКонсолидации.
// 
Процедура ДополнитьСтрокуОграниченийПоСубконто(ТаблицаСубконто, ТекстУсловия) Экспорт
	
	Для каждого СтрСб Из ТаблицаСубконто Цикл
		
		Если Не СтрСб.Использование Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаСубконто  = СтрСб.Имя;
		СтрВидСравнения = СтрСб.ВидСравнения;
		
		Если СтрВидСравнения = ВидСравнения.Равно Тогда
			ТекстУслСб = СтрокаСубконто + " = &" + СтрокаСубконто;
		ИначеЕсли СтрВидСравнения = ВидСравнения.НеРавно Тогда
			ТекстУслСб = СтрокаСубконто + " <> &" + СтрокаСубконто;
			
		ИначеЕсли СтрВидСравнения = ВидСравнения.ВСписке Тогда	
			ТекстУслСб = СтрокаСубконто + " В (&" + СтрокаСубконто + ")";
		ИначеЕсли СтрВидСравнения = ВидСравнения.НеВСписке Тогда
			ТекстУслСб = СтрокаСубконто + " Не В (&" + СтрокаСубконто + ")";
		
		ИначеЕсли СтрВидСравнения = ВидСравнения.ВИерархии ИЛИ СтрВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
			ТекстУслСб = СтрокаСубконто + " В ИЕРАРХИИ (&" + СтрокаСубконто + ")";
		ИначеЕсли СтрВидСравнения = ВидСравнения.НеВИерархии ИЛИ СтрВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
			ТекстУслСб = СтрокаСубконто + " НЕ В ИЕРАРХИИ (&" + СтрокаСубконто + ")";
			
		КонецЕсли;
		
		ТекстУсловия = ОбъединитьОграничения(ТекстУсловия, ТекстУслСб);
		
	КонецЦикла;
	
КонецПроцедуры // ДополнитьСтрокуОграниченийПоСубконто()

// Функция инициализирует таблицу отборов для расшифровки.
// 
// Возвращаемое значение:
// 	ТаблицаЗначений
// 
Функция ИнициализироватьТаблицуОтборовДляРасшифровки() Экспорт

	ТаблицаОтборовРасшифровки = Новый ТаблицаЗначений;
	ТаблицаОтборовРасшифровки.Колонки.Добавить("ПутьКДанным");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("ВидСравнения");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("Значение");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("ЗначениеС");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("ЗначениеПо");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("ТипЗначения");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("Имя");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("Представление");
	ТаблицаОтборовРасшифровки.Колонки.Добавить("Использование");

	Возврат ТаблицаОтборовРасшифровки;
	
КонецФункции // ИнициализироватьТаблицуОтборовДляРасшифровки()

// Функция получает номер субконто счета для известного вида субконто.
// 
// Параметры
//  ВидСубконто  - ПланВидовХарактеристикСсылка - Вид субконто, для которого необходимо определить порядковый номер.
//  Счет         - ПланСчетовСсылка             - Счет, у которого ищется данный вид субконто.
//  ВидыСубконто - Коллекция Видов Суб. счета   - Коллекция видов субконто данного счета, 
// 												  если не указана, то выбирается из базы.
// 
// Возвращаемое значение:
//   Число   - Порядковый номер вида субконто, 0 - если указанный вид субконто не найден у данного счета.
// 
Функция ПолучитьНомерСубконтоСчета(ВидСубконто, Счет, ВидыСубконто = Неопределено) Экспорт

	Если ВидыСубконто = Неопределено Тогда
		ВидыСубконто = Счет.ВидыСубконто;
	КонецЕсли;
	
	НомерСубконто = 0;
	
	СтрокаВидаСубконто = ВидыСубконто.Найти(ВидСубконто, "ВидСубконто");
	
	Если СтрокаВидаСубконто <> Неопределено Тогда
		НомерСубконто = ВидыСубконто.Индекс(СтрокаВидаСубконто)+1;
	КонецЕсли;

	Возврат НомерСубконто;

КонецФункции // ПолучитьНомерСубконтоСчета()

// Функция получает новый путь к субконто
// 
// Параметры
//  СтарыйПутьКСубконто. 
//  Субконто. 
//  тзВидыСубконто. 
// 
// Возвращаемое значение:
//   Строка - новый путь к субконто.
// 
Функция ПолучитьНовыйПутьКСубконто(СтарыйПутьКСубконто, Субконто, Счет, тзВидыСубконто) Экспорт

	НомерСубконто      = Число(Прав(СтарыйПутьКСубконто, СтрДлина(СтарыйПутьКСубконто) - 8)); 				
	НовыйНомерСубконто = ПолучитьНомерСубконтоСчета(Субконто[НомерСубконто - 1].ВидСубконто, Счет, тзВидыСубконто);
	
	НовыйПутьКСубконто = ?(НовыйНомерСубконто = 0, Неопределено, "Субконто" + НовыйНомерСубконто);
	
	Возврат НовыйПутьКСубконто;

КонецФункции // ПолучитьНовыйПутьКСубконто()

// Процедура заполняет список выбора выда сравнения для счета.
// 
// Параметры:
//  СписокВыбора - СписокЗначений.
// 
Процедура ЗаполнитьСписокВыбораВидаСравненияДляСчета(СписокВыбора) Экспорт

	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("ПланСчетовСсылка.бит_Бюджетирование"));
	ОписаниеТиповСчет = Новый ОписаниеТипов(МассивТипов);
	
	СписокВыбора.ЗагрузитьЗначения(бит_МеханизмПолученияДанных.СписокВыбораВидаСравнения(ОписаниеТиповСчет).ВыгрузитьЗначения());	
		
КонецПроцедуры // ЗаполнитьСписокВыбораВидаСравненияДляСчета()

// Процедура заполняет список выбора выда сравнения для субконто.
// 
// Параметры:
//  СписокВыбора - СписокЗначений.
// 
Процедура ЗаполнитьСписокВыбораВидаСравненияДляСубконто(СписокВыбора) Экспорт

	ОписаниеТиповПвх = Метаданные.ПланыВидовХарактеристик.бит_ВидыСубконтоБюджетирования.Тип;
	
	СписокВыбора.ЗагрузитьЗначения(бит_МеханизмПолученияДанных.СписокВыбораВидаСравнения(ОписаниеТиповПвх).ВыгрузитьЗначения());	

КонецПроцедуры // ЗаполнитьСписокВыбораВидаСравненияДляСубконто()

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Процедура перезаполняет таблицу "ДетализацияСчета".
// 
// Параметры:
//  Отчет    - ДанныеФормыСтруктура.
//  ЭтаФорма - УправляемаяФорма.
// 
Процедура ПерезаполнитьТаблицуДетализацииСчета(Отчет, ЭтаФорма)

	ЭтаФорма.ДетализацияСчета.Очистить();
	
	Если Не ЭтаФорма.фКэшЗначений.ЕстьРкСчет Или Не ЗначениеЗаполнено(Отчет.Счет) Тогда
		Возврат;	
	КонецЕсли;
		
	Для Каждого ВидСубконто Из Отчет.Счет.ВидыСубконто Цикл
		
		СтрокаДетализации = ЭтаФорма.ДетализацияСчета.Добавить();
		
		СтрокаДетализации.Имя           = "Субконто" + Строка(ВидСубконто.НомерСтроки);
		СтрокаДетализации.ПутьКДанным   = СтрокаДетализации.Имя;	
		СтрокаДетализации.Представление = Строка(ВидСубконто.ВидСубконто);	
		СтрокаДетализации.ТипИзмерения  = ТипГруппировкиКомпоновкиДанных.Элементы;
		
	КонецЦикла;
      
КонецПроцедуры // ПерезаполнитьДетализациюСчета()

// Заполнение настроек построителя отчетов для указанных счетов.
// 
// Параметры
//  СчетДт  		 - ПланыСчетовСсылка.* - Счет дебета.
//  СчетКт  		 - ПланыСчетовСсылка.* - Счет кредита.
//  ОтборыПоСубконто - ТаблицаЗначений 	   - Таблица отборов. 
// 						Структура полностью повторяет таблицу отборов построителя отчетов.
// 
Процедура ЗаполнитьПостроительОтчетаДляСубконтоКорреспонденции(фИмяРегистраБухгалтерии, ПостроительОтчетаДляСубконто, СчетДт, СчетКт, ОтборыПоСубконто = Неопределено)

	ТекстОтбор       = "";
	ТекстВыбораПолей = "";
	МассивСубконтоДт = Новый Массив;
	МассивСубконтоКт = Новый Массив;
	
	МаксКоличествоСубконто  = Метаданные.ПланыСчетов[фИмяРегистраБухгалтерии].МаксКоличествоСубконто;
	
    Если ЗначениеЗаполнено(СчетДт) Тогда 
        СвСчДт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетДт);	
		КоличествоСубконтоСчета = СвСчДт.КоличествоСубконто;
		Для н = 1 По КоличествоСубконтоСчета Цикл
			ТекстОтбор       = ТекстОтбор + ", СубконтоДт" + н + ".* ";
			ТекстВыбораПолей = ТекстВыбораПолей + ", ОборотыДтКт.СубконтоДт" + н;
		КонецЦикла;
		МассивСубконтоДт = СчетДт.ВидыСубконто.ВыгрузитьКолонку("ВидСубконто");
	КонецЕсли;
	
    Если ЗначениеЗаполнено(СчетКт) Тогда 
        СвСчКт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетКт);	
		КоличествоСубконтоСчета = СвСчКт.КоличествоСубконто;
		Для н = 1 По КоличествоСубконтоСчета Цикл
			ТекстОтбор       = ТекстОтбор + ", СубконтоКт" + н + ".* ";
			ТекстВыбораПолей = ТекстВыбораПолей + ", ОборотыДтКт.СубконтоДт" + н;
		КонецЦикла;
		МассивСубконтоКт = СчетКт.ВидыСубконто.ВыгрузитьКолонку("ВидСубконто");
	КонецЕсли;
	
	ТекстОтбор       = Сред(ТекстОтбор      , 3);
	ТекстВыбораПолей = Сред(ТекстВыбораПолей, 3);
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	0 КАК СуммаОборот
	|" + ?(ЗначениеЗаполнено(ТекстВыбораПолей), "{ВЫБРАТЬ " + ТекстВыбораПолей + "}", "") + "
	|ИЗ
	|	РегистрБухгалтерии." + фИмяРегистраБухгалтерии + ".ОборотыДтКт(, , Запись, , &МассивСубконтоДт, , &МассивСубконтоКт, " 
																+ ?(ЗначениеЗаполнено(ТекстВыбораПолей), "{" + ТекстОтбор + "}", "") + ") КАК ОборотыДтКт";
	
	ПостроительОтчетаДляСубконто.Параметры.Вставить("МассивСубконтоДт", МассивСубконтоДт);
	ПостроительОтчетаДляСубконто.Параметры.Вставить("МассивСубконтоКт", МассивСубконтоКт);
	
	ПостроительОтчетаДляСубконто.Текст = ТекстЗапроса;
	
	// Проставим понятные пользователю имена полей.
	Сч = 0;
	Для каждого Элемент Из МассивСубконтоДт Цикл
		Сч = Сч + 1;
		Поле = ПостроительОтчетаДляСубконто.ДоступныеПоля.Найти("СубконтоДт" + Сч);
		Поле.ТипЗначения = Элемент.ТипЗначения;
		Поле.Представление = "Дт " + Элемент.Наименование;
	КонецЦикла;
	
	Сч = 0;
	Для каждого Элемент Из МассивСубконтоКт Цикл
		Сч = Сч + 1;
		Поле = ПостроительОтчетаДляСубконто.ДоступныеПоля.Найти("СубконтоКт" + Сч);
		Поле.ТипЗначения = Элемент.ТипЗначения;
		Поле.Представление = "Кт " + Элемент.Наименование;
	КонецЦикла;
	
	// Добавим все субконто в поля отборов
	Сч = 0;
	Для каждого Элемент Из МассивСубконтоДт Цикл
		Сч = Сч + 1;
		Поле = ПостроительОтчетаДляСубконто.Отбор.Добавить("СубконтоДт" + Сч);
		Поле.Использование = Ложь;
	КонецЦикла;
	
	Сч = 0;
	Для каждого Элемент Из МассивСубконтоКт Цикл
		Сч = Сч + 1;
		Поле = ПостроительОтчетаДляСубконто.Отбор.Добавить("СубконтоКт" + Сч);
		Поле.Использование = Ложь;
	КонецЦикла;
	
	// Заполним уже имеющиеся отборы
	Если ОтборыПоСубконто <> Неопределено Тогда
		
		Для каждого СтрокаСубконто Из ОтборыПоСубконто Цикл
			
			Попытка
				
				ЭлементОтбора = Неопределено;
				
				Для каждого Элемент Из ПостроительОтчетаДляСубконто.Отбор Цикл
					Если Элемент.ПутьКДанным = СтрокаСубконто.ПутьКДанным Тогда
						ЭлементОтбора = Элемент;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если ЭлементОтбора = Неопределено Тогда
					ЭлементОтбора = ПостроительОтчетаДляСубконто.Отбор.Добавить(СтрокаСубконто.ПутьКДанным);
				КонецЕсли;
				
				ЭлементОтбора.Использование = Истина;
				ЭлементОтбора.ВидСравнения  = СтрокаСубконто.ВидСравнения;
				ЭлементОтбора.Значение      = СтрокаСубконто.Значение;
				ЭлементОтбора.ЗначениеС     = СтрокаСубконто.ЗначениеС;
				ЭлементОтбора.ЗначениеПо    = СтрокаСубконто.ЗначениеПо;
				
			Исключение
			КонецПопытки;
			
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры // ЗаполнитьПостроительОтчетаДляСубконтоКорреспонденции()

// Процедура выводит заголовок отчета обороты счета.
// 
// Параметры:
//  Макет 		  			- Макет.
//  ИмяОбластиВывода 	  	- Строка.
//  Выборка 	  			- ВыборкаИзЗапроса.
//  ДокументРезультат 		- ТабличныйДокумент.
//  ПоСубсчетам  			- Булево.
//  ВидДвижения 			- ВидДвиженияБухгалтерии.
//  МассивРесурсов    		- Массив.
//  СписокСчетов 		    - СписокЗначений.
//  ДополнениеКУровнюВывода - Число.
// 
Процедура ВывестиЗаголовкиОборотовОтчетаОборотыСчета(Макет, Знач ИмяОбластиВывода, Знач Выборка, 
	Знач ДокументРезультат, Знач ПоСубсчетам, Знач ВидДвижения, МассивРесурсов, СписокСчетов, Знач ДополнениеКУровнюВывода = 0)
	
	ВерхнийУровень = 1000;
	
	Обл = Макет.ПолучитьОбласть(ИмяОбластиВывода);
	
	Пока Выборка.Следующий() Цикл
			
		Если НЕ ПоСубсчетам Тогда
				
			// Выводим только верхний уровень
			Если ВерхнийУровень < Выборка.Уровень() Тогда
				Продолжить;
			Иначе
				ВерхнийУровень = Выборка.Уровень();
			КонецЕсли;
				
		КонецЕсли;
			
		ЕстьОборот = Ложь;
		
		ОкончанниеПоля = ?(ВидДвижения = ВидДвиженияБухгалтерии.Дебет, "Дт", "Кт");
		
		Для каждого Ресурс Из МассивРесурсов Цикл
			Если Выборка["Есть" + Ресурс + "Оборот" + ОкончанниеПоля] <> 0 Тогда
				ЕстьОборот = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если ЕстьОборот Тогда
            
            ТекКорСчет = Выборка.КорСчет;
            
            Если СписокСчетов.НайтиПоЗначению(ТекКорСчет) = Неопределено Тогда
                
                СписокСчетов.Добавить(ТекКорСчет);
                
                Обл.Параметры.Заполнить(Выборка);
                
                Если Лев(ИмяОбластиВывода, 4) = "Итог" Тогда
                    Обл.Параметры["СуммаОборот" + ОкончанниеПоля] = ПолучитьТекстСуммыРесурсов(МассивРесурсов, Выборка, "Оборот" + ОкончанниеПоля);
                КонецЕсли;
                
                ДокументРезультат.Присоединить(Обл, Выборка.Уровень() + ДополнениеКУровнюВывода);
                
            КонецЕсли;
                       
		КонецЕсли;
			
	КонецЦикла;
	
КонецПроцедуры // ВывестиЗаголовкиОборотовОтчетаОборотыСчета()

// Функция формирует структуру параметров ограничений для оборотно-сальдовой ведомости.
// 
// Параметры:
// 	ОбъектОтчета		 						- ОбъектОтчета.
// 	ПоВалютам 			 						- Булево.
// 	ИспользоватьОграниченияПоЗабалансовымСчетам - Булево.
// 	ПоЗабалансовымСчетам 						- Булево.
// 	ВидУчета 			 						- ВидУчета.
// 	Валюта 				 						- СправочникСсылка.Валюты.
// 	ОтражениеВНУ		 						- Булево.
// 	Сценарий 			 						- СправочникСсылка.Сценарии/бит_Сценарии.
// 	ВВалютеСценария 	 						- Булево.
// 
// Возвращаемое значение:
//   Структура.
// 
Функция СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомости(ОбъектОтчета,
		Знач ПоВалютам, Знач ИспользоватьОграниченияПоЗабалансовымСчетам, Знач ПоЗабалансовымСчетам = Ложь, 
		Знач ВидУчета = Неопределено, Знач Валюта = Неопределено, Знач ОтражениеВНУ = Неопределено,
		Знач Сценарий = Неопределено, Знач ВВалютеСценария = Неопределено)
	
	Структура = Новый Структура();
	Структура.Вставить("ДатаНач", ОбъектОтчета.Период.ДатаНачала);
	Структура.Вставить("ДатаКон", ОбъектОтчета.Период.ДатаОкончания);
	
	Если ОбъектОтчета.ОрганизацияИспользование Тогда
		Попытка
			Если ТипЗнч(ОбъектОтчета.Организация) = Тип("СправочникСсылка.Организации")
				Или Не ЗначениеЗаполнено(ОбъектОтчета.Организация) Тогда
			 	Структура.Вставить("Организация", ОбъектОтчета.Организация);
			Иначе	
			    Структура.Вставить("Организация", ОбъектОтчета.Организация.ВыгрузитьЗначения());// Новый Массив(1));
			КонецЕсли;
		Исключение
			Структура.Вставить("Организация", Неопределено);
		КонецПопытки;
		Структура.Вставить("ОрганизацияВидСравнения" , ОбъектОтчета.ОрганизацияВидСравнения);
		Структура.Вставить("ОрганизацияИспользование", ОбъектОтчета.ОрганизацияИспользование);
	КонецЕсли;
	
	Структура.Вставить("ПоСубсчетамИСубконто"     , ОбъектОтчета.ПоСубсчетамИСубконто);
	Структура.Вставить("ВыводитьРазвернутоеСальдо", ОбъектОтчета.ВыводитьРазвернутоеСальдо);
	
	Структура.Вставить("ПоВалютам"									, ПоВалютам);
	Структура.Вставить("ИспользоватьОграниченияПоЗабалансовымСчетам", ИспользоватьОграниченияПоЗабалансовымСчетам);
	Структура.Вставить("ПоЗабалансовымСчетам"						, ПоЗабалансовымСчетам);
	
	Структура.Вставить("ВидУчета"	 	, ВидУчета);	
	Структура.Вставить("Валюта"	     	, Валюта);
	Структура.Вставить("ОтражениеВНУ"	, ОтражениеВНУ); 	
	Структура.Вставить("Сценарий"	 	, Сценарий);	
	Структура.Вставить("ВВалютеСценария", ВВалютеСценария);
	
	Структура.Вставить("ИмяРегистраБухгалтерии", ОбъектОтчета.ИмяРегистраБухгалтерии);
	
	Возврат Структура; 
	
КонецФункции // СформироватьСтруктуруОграниченийДляОборотноСальдовойВедомости()

// Процедура инициализирует структуру в которой хранятся итоговые суммы документа.
// 
// Параметры:
//  МассивПоказателей  - Массив.
//  СтруктураОбщийИтог - Структура.
// 
Процедура ИнициализироватьСтруктуруХраненияИтоговОборотка(Знач МассивПоказателей, СтруктураОбщийИтог)
	
	Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
		
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "НачальныйОстатокДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "НачальныйОстатокКт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "КонечныйОстатокДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "КонечныйОстатокКт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "ОборотДт", 0);
		СтруктураОбщийИтог.Вставить(ИмяПоказателя + "ОборотКт", 0);
						
	КонецЦикла;
	
КонецПроцедуры // ИнициализироватьСтруктуруХраненияИтоговОборотка()

// Функция Формирует запросы по каждому счету, указанному в таблице вывода итогов.
// 
// Параметры:
// 	СтруктураПараметров - Структура.
// 	ПравилаВыводаИтогов - ТаблицаЗначений.
// 
// Возвращаемое значение:
// 	ТаблицаЗначений.
// 
Функция СформироватьТаблицуДанныхРазворотаСчетов(СтруктураПараметров, ПостроительОтчета, Знач ПравилаВыводаИтогов, ОчищатьИтоги = Ложь)

	// Результат функции будут укладываться в таблицу.
	ТаблицаРазворотаСчетов = Новый ТаблицаЗначений;
	ТаблицаРазворотаСчетов.Колонки.Добавить("Счет");
	ТаблицаРазворотаСчетов.Колонки.Добавить("Результат");
	ТаблицаРазворотаСчетов.Колонки.Добавить("МассивГруппировок");
	ТаблицаРазворотаСчетов.Колонки.Добавить("СоответсвиеСчетов");
	Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
		ТаблицаРазворотаСчетов.Колонки.Добавить("Валюта");
	КонецЕсли;

	Если НЕ СтруктураПараметров.СтруктураОграничений.ПоСубсчетамИСубконто
		ИЛИ ПравилаВыводаИтогов.Количество() = 0 
		ИЛИ ПравилаВыводаИтогов.Колонки.Количество() = 0
		Тогда
		
		Возврат ТаблицаРазворотаСчетов;
		
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НачПериода"	, НачалоДня(СтруктураПараметров.СтруктураОграничений.ДатаНач));
	Запрос.УстановитьПараметр("КонПериода"	, КонецДня(СтруктураПараметров.СтруктураОграничений.ДатаКон));
	Если СтруктураПараметров.СтруктураОграничений.Свойство("Организация") Тогда
		Запрос.УстановитьПараметр("Организация"	, СтруктураПараметров.СтруктураОграничений.Организация);
	КонецЕсли; 	
	Запрос.УстановитьПараметр("ВидУчета"	, СтруктураПараметров.СтруктураОграничений.ВидУчета);
	Запрос.УстановитьПараметр("Валюта"		, СтруктураПараметров.СтруктураОграничений.Валюта);
	Запрос.УстановитьПараметр("ОтражениеВНУ", СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	Запрос.УстановитьПараметр("Сценарий"	, СтруктураПараметров.СтруктураОграничений.Сценарий);
	
	// Сформируем текст запроса
	Для Каждого ПравилаСчета из ПравилаВыводаИтогов Цикл
		
		Если ПравилаСчета.Счет.Пустая()
			ИЛИ (НЕ ПравилаСчета.Субсчета
				И ПравилаСчета.РазворотПоСубконто.Количество() = 0) Тогда
				
			Продолжить; // Неправильно заполненная строка, не обрабатываем.
				
		КонецЕсли;
		
		ТекстЗапроса 	   = "";
		ТекстИтогов  	   = "";
		ТекстВыбранныеПоля = "";
		ТекстИтогиПо 	   = "";
					
		МассивГруппировок = Новый Массив;
			
		Запрос.УстановитьПараметр("Счет", ПравилаСчета.Счет);

		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	Счет КАК Счет";
			
		ТекстВнеш = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Счет КАК Счет,
		|	Счет.Код КАК СчетКод,
		|	Счет.Наименование КАК СчетНаименование,
		|	Счет.Представление КАК СчетПредставление,
		|	Счет.Забалансовый КАК СчетЗабалансовый";

		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			ТекстЗапроса = ТекстЗапроса + ",
			|	Валюта КАК Валюта";
				
			ТекстВнеш = ТекстВнеш + ",
			|	Валюта КАК Валюта,
			|	Валюта.Представление КАК ВалютаПредставление ";
		КонецЕсли;
		
		МассивГруппировок.Добавить("Счет");
		Если ПравилаСчета.Субсчета Тогда			
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ИЕРАРХИЯ"; 						
		Иначе                                  				
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ";    							
		КонецЕсли;
		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			ТекстИтогиПо = ТекстИтогиПо + ", Валюта";
		КонецЕсли;
		
		// Признак того, что можно использовать вложенный запрос.
		МожноИспользоватьСоставнойЗапрос = ОпределитьМожноИспользоватьСоставнойЗапросПоСубконто(ПравилаСчета);
						
		Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
			
			ВидСубконто = ВернутьСубконтоПоИмени(ПравилаСчета.Счет, СтрокаПоСубконто.Имя);
			
			Если ВидСубконто = Неопределено Тогда
				Продолжить;
			КонецЕсли;
				
			Сч = ВидСубконто.НомерСтроки;
				
			// Определим тип значения поля и в соответствии с этим типом добавим поле запроса.
			ТипыСубконто = ВидСубконто.ВидСубконто.ТипЗначения;
			Выб      = "";
			ВыбИначе = "";
			
			ЕстьПредставление = Истина;
			Для Каждого Элемент Из ТипыСубконто.Типы() Цикл
				
				ОбъектМетаданных = Метаданные.НайтиПоТипу(Элемент);
				
				Если ОбъектМетаданных <> Неопределено Тогда
					
					ИмяТаблицы = ОбъектМетаданных.ПолноеИмя();
					Выб = Выб + "КОГДА #Поле ССЫЛКА " + ИмяТаблицы + " ТОГДА ВЫРАЗИТЬ( #Поле КАК (" + ИмяТаблицы + "))";
						
					Если Метаданные.Перечисления.Найти(ОбъектМетаданных.Имя) <> Неопределено Тогда
						ЕстьПредставление = Ложь;
					КонецЕсли;
					
				Иначе
					// Для примитивных типов придется добавлять само значение.
					ВыбИначе = " #Поле ";
					ЕстьПредставление = Ложь;
					
				КонецЕсли;
					
			КонецЦикла;
			
			// Окончательное формирование строки выбора поля.
			Если НЕ ПустаяСтрока(Выб) Тогда
				
				Если НЕ ПустаяСтрока(ВыбИначе) Тогда
					СтрПоле = "
					|	ВЫБОР " + Выб + " ИНАЧЕ " + ВыбИначе + " КОНЕЦ";
				Иначе
					СтрПоле = "
					|	ВЫБОР " + Выб + " КОНЕЦ";
				КонецЕсли;
				
			Иначе
				
				СтрПоле = ВыбИначе;
				
			КонецЕсли;
				
			ТекстВыбранныеПоля = ТекстВыбранныеПоля + ", " + СтрЗаменить(СтрПоле, "#Поле", " ОстаткиИОбороты.Субконто"  + Сч) + " КАК Субконто" + Сч;
			
			СтрокаТипИзмерения = ПолучитьПоТипуИзмеренияПостроителяОтчетаСтрокуЗапроса(ПолучитьТипИзмеренияПостроителяОтчетаПоУмолчанию());
			ТекстИтогиПо = ТекстИтогиПо + ", " + СтрокаПоСубконто.Имя + СтрокаТипИзмерения;
			
			// Само поле
			ТекстВнеш  = ТекстВнеш + ", " + СтрокаПоСубконто.Имя;
			// Поле представления
			ТекстВнеш  = ТекстВнеш + ", " + СтрокаПоСубконто.Имя;
			
			Если ЕстьПредставление 
				И МожноИспользоватьСоставнойЗапрос Тогда
				
				ТекстВнеш  = ТекстВнеш + ".Представление ";
				
			КонецЕсли;
			
			ТекстВнеш  = ТекстВнеш + " КАК " + СтрокаПоСубконто.Имя + "Представление";
				
			МассивГруппировок.Добавить(СтрокаПоСубконто.Имя);
				
		КонецЦикла; 

		ТекстЗапроса = ТекстЗапроса + ТекстВыбранныеПоля;

			
		// Добавим в текст запроса все выбранные ресурсы.
			
		ТекстЗапроса = ТекстЗапроса + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Истина, 
				Истина, Истина);
			
		ТекстВнеш = ТекстВнеш + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Истина);
        
        ТекстИтогов = ТекстИтогов + ВернутьЧастьЗапросаПоВыборкеПолейОборотносальдоваяВедомость(СтруктураПараметров.МассивПоказателей, Ложь,,,, ОчищатьИтоги);
		
		ДопУсловиеПоСчету = "Счет В ИЕРАРХИИ (&Счет)";
		СтруктураПолейОтбораПостроителя = Новый Структура;
	    СтруктураПолейОтбораПостроителя.Вставить("ЦФО"     , "ЦФО");	
	    
		СтрокаТекстаВыборкиИзТаблицы = СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров
																		, 
																		, ДопУсловиеПоСчету
																		, Запрос
																		, ПостроительОтчета
																		, СтруктураПолейОтбораПостроителя);
		
		Если МожноИспользоватьСоставнойЗапрос Тогда
			
			ТекстЗапроса = ТекстЗапроса + СтрокаТекстаВыборкиИзТаблицы;
							
			ТекстЗапроса = ТекстВнеш + " ИЗ (" + ТекстЗапроса + " ) КАК Подзапрос 
			|	АВТОУПОРЯДОЧИВАНИЕ";
			
		Иначе
				
			ТекстЗапроса = ТекстВнеш + СтрокаТекстаВыборкиИзТаблицы + "
			|	АВТОУПОРЯДОЧИВАНИЕ";
				
		КонецЕсли;

		Если Не ПустаяСтрока(ТекстИтогиПо) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|ИТОГИ ";

			ТекстЗапроса = ТекстЗапроса + Сред(ТекстИтогов, 2);

			ТекстЗапроса = ТекстЗапроса + "
			|ПО " + Сред(ТекстИтогиПо, 2);

			Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
				
				ТекстЗапроса = ТекстЗапроса + ",
				|	Валюта КАК Валюта ";
				
			КонецЕсли;

		КонецЕсли;
			
		Запрос.Текст = ТекстЗапроса;

		НоваяСтрока = ТаблицаРазворотаСчетов.Добавить();
		НоваяСтрока.Счет      		  = ПравилаСчета.Счет;
		НоваяСтрока.Результат 		  = Запрос.Выполнить(); // В таблицу помещается выполненный запрос
		НоваяСтрока.МассивГруппировок = МассивГруппировок;
		
		ИмяПланаСчетов = Метаданные.РегистрыБухгалтерии[СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии].ПланСчетов.Имя;
		
		СооответствиеСчетов 		  = ВернутьСоответвиеПодчиненныхСчетов(ИмяПланаСчетов, ПравилаСчета.Счет);
		НоваяСтрока.СоответсвиеСчетов = СооответствиеСчетов;
							
	КонецЦикла;

	Возврат ТаблицаРазворотаСчетов;
	
КонецФункции // СформироватьТаблицуДанныхРазворотаСчетов()

// Функция Формирует запросы по каждому из счетов, указанному в таблице развернутого сальдо.
// 
// Параметры:
// 	СтруктураПараметров 	  - Структура.
// 	ПравилаРазвернутогоСальдо - ТаблицаЗначений.
// 
// Возвращаемое значение:
// 	ТаблицаЗначений.
// 
Функция СформироватьТаблицуДанныхРазвернутогоСальдо(СтруктураПараметров, ПравилаРазвернутогоСальдо)

	// Результат Каждого запроса будет укладываться в специальную таблицу.
	ТаблицаРазвернутогоСальдо = Новый ТаблицаЗначений;
	ТаблицаРазвернутогоСальдо.Колонки.Добавить("Счет");
	ТаблицаРазвернутогоСальдо.Колонки.Добавить("Результат");
	
	Если НЕ СтруктураПараметров.СтруктураОграничений.ВыводитьРазвернутоеСальдо
		ИЛИ (ПравилаРазвернутогоСальдо.Количество() = 0) Тогда
		
		Возврат ТаблицаРазвернутогоСальдо;
		
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НачПериода"	, НачалоДня(СтруктураПараметров.СтруктураОграничений.ДатаНач));
	Запрос.УстановитьПараметр("КонПериода"	, КонецДня(СтруктураПараметров.СтруктураОграничений.ДатаКон));
	Если СтруктураПараметров.СтруктураОграничений.Свойство("Организация") Тогда
		Запрос.УстановитьПараметр("Организация"	, СтруктураПараметров.СтруктураОграничений.Организация);	
	КонецЕсли;  	
	Запрос.УстановитьПараметр("ВидУчета"	, СтруктураПараметров.СтруктураОграничений.ВидУчета);
	Запрос.УстановитьПараметр("Валюта"		, СтруктураПараметров.СтруктураОграничений.Валюта);
	Запрос.УстановитьПараметр("ОтражениеВНУ", СтруктураПараметров.СтруктураОграничений.ОтражениеВНУ);
	Запрос.УстановитьПараметр("Сценарий"	, СтруктураПараметров.СтруктураОграничений.Сценарий);
	
	// Сформируем текст запроса
	Для Каждого ПравилаСчета из ПравилаРазвернутогоСальдо Цикл
		
		Если ПравилаСчета.Счет.Пустая()
			И НЕ ПравилаСчета.Субсчета
			И ПравилаСчета.РазворотПоСубконто.Количество() = 0 Тогда
				
			Продолжить; // Неправильно заполненная строка, не обрабатываем.
				
		КонецЕсли;
		
		ТекстЗапроса 	   = "";
		ТекстИтогов  	   = "";
		ТекстВыбранныеПоля = "";
			
		ТекстИтогиПо       = "";
			
		МассивГруппировок = Новый Массив;
							
		МассивГруппировок.Добавить("Общие"); // Всегда есть общий итог
			
		Запрос.УстановитьПараметр("Счет", ПравилаСчета.Счет);
			
		ТекстЗапроса =  
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Счет КАК Счет ";
			
		Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
			ТекстЗапроса = ТекстЗапроса + ",
			|	Валюта КАК Валюта,
			|	Валюта.Представление КАК ВалютаПредставление ";
		КонецЕсли;
			
		// Развернутое сальдо может быть подсчитано либо по субсчетам, либо по субконто.
		Если ПравилаСчета.Субсчета Тогда
				
			// ТекстИтогиПо = ТекстИтогиПо + ", Счет ТОЛЬКО ИЕРАРХИЯ";
			ТекстИтогиПо = ТекстИтогиПо + ", Счет ИЕРАРХИЯ";
				
			МассивГруппировок.Добавить("Счет");
			
		Иначе
				
			Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
					
				ТекстВыбранныеПоля = ТекстВыбранныеПоля + ",
				|	" + СтрокаПоСубконто.Имя + " КАК " + СтрокаПоСубконто.Имя;
					
				ТекстИтогиПо = ТекстИтогиПо + ", " + СтрокаПоСубконто.Имя;
					
				МассивГруппировок.Добавить(СтрокаПоСубконто.Имя);
					
			КонецЦикла; 
				
			ТекстЗапроса = ТекстЗапроса + ТекстВыбранныеПоля;
				
		КонецЕсли;

		// Добавим в текст запроса все выбранные ресурсы.
		Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл
				
			ТекстЗапроса = ТекстЗапроса + ",
			|	" + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт КАК " + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт,
			|	" + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт КАК " + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт,
			|	" + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт КАК "  + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт,
			|	" + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт КАК "  + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт";
				
			ТекстИтогов = ТекстИтогов + ",
			|	СУММА(" + ИмяПоказателя + "НачальныйРазвернутыйОстатокДт),
			|	СУММА(" + ИмяПоказателя + "НачальныйРазвернутыйОстатокКт),
			|	СУММА(" + ИмяПоказателя + "КонечныйРазвернутыйОстатокДт),
			|	СУММА(" + ИмяПоказателя + "КонечныйРазвернутыйОстатокКт)";
				
		КонецЦикла;
			
		СтрокаТекстаВыборкиИзТаблицы = СформироватьТекстВыборкиИзТаблицыОборотовИОстатковРегистраБухгалтерии(СтруктураПараметров, ,
			"Счет В ИЕРАРХИИ (&Счет)");
			
		ТекстЗапроса = ТекстЗапроса + СтрокаТекстаВыборкиИзТаблицы;
 			

		Если ПустаяСтрока(ТекстИтогиПо) Тогда
			
			ТекстЗапроса = ТекстЗапроса + "
			|ИТОГИ 
			|" + Сред(ТекстИтогов, 2) + "
			|ПО ОБЩИЕ ";                 
						
		Иначе
			
			ТекстЗапроса = ТекстЗапроса + "
			|ИТОГИ 
			|" + Сред(ТекстИтогов, 2) + "
			|ПО ОБЩИЕ " + ТекстИтогиПо;

			Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда
				ТекстЗапроса = ТекстЗапроса + ",
				|	Валюта КАК Валюта ";
			КонецЕсли;

		КонецЕсли;

		Запрос.Текст = ТекстЗапроса;

		НоваяСтрока = ТаблицаРазвернутогоСальдо.Добавить();
		НоваяСтрока.Счет      = ПравилаСчета.Счет;
		НоваяСтрока.Результат = Запрос.Выполнить(); // В таблицу помещается выполненный запрос
			
	КонецЦикла;

	Возврат ТаблицаРазвернутогоСальдо;

КонецФункции // СформироватьТаблицуДанныхРазвернутогоСальдо()

// Процедура заполняет параметры расшифровки переданной области перед выводом в отчет.
// 
// Параметры:
// 	ДатаНач  	   		   - Дата.
// 	ДатаКон 	   		   - Дата.
// 	ИмяРегистраБухгалтерии - Строка.
// 	Область 	   		   - Область.
// 	Выборка 	   		   - Выборка из результата запроса.
// 	ОтборСубконто  		   - ОтборСубконто (По умолчанию = Неопределено).
// 	ВыведенныйСчет 		   - ПланСчетовСсылка (По умолчанию = Неопределено).
// 	ВыборкаПоВалютам	   - Выборка из результата запроса (По умолчанию = Неопределено).
// 
Процедура ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(Знач ДатаНач, Знач ДатаКон, Знач ИмяРегистраБухгалтерии,
	Область, Выборка, ОтборСубконто = Неопределено, ВыведенныйСчет = Неопределено, Знач ВВалютеСценария = Неопределено,
	Знач ВыборкаПоВалютам = Неопределено)
	             	
	ИмяОсвПоСчету    = Нстр("ru = 'ОСВ по счету '");
	ИмяКарточкаСчета = Нстр("ru = 'Карточка счета '");
	ИмяАнализСчета   = Нстр("ru = 'Анализ счета '");
	ИмяОборотыСчета  = Нстр("ru = 'Обороты счета '");
	
    // Получим префикс имени отчета расшифровки.
    Префикс = ?(Найти(ИмяРегистраБухгалтерии, "бит") = 0, "", "бит_");
    
    // Удалим из имени регистра бухгалтерии префикс "бит".
    ИмяРегистраБухгалтерии = СтрЗаменить(ИмяРегистраБухгалтерии, "бит", "");
	
	// Если это расшифровка данных дополнительного регистра бухгалтерии, тогда
	Если Найти(ВРег(ИмяРегистраБухгалтерии), "ДОПОЛНИТЕЛЬНЫЙ") > 0 Тогда 		
		ИмяРегистраБухгалтерии = "_Управленческий";   		
	КонецЕсли;
	
	// Заполение значений для расшифровки
	СчетДляРасшифровки = ?(Выборка.Счет <> NULL, Выборка.Счет, ВыведенныйСчет);
    
	// Заполнение параметров расшифровки
	ПараметрыОСВПоСчету = Новый Структура;	
	ПараметрыОСВПоСчету.Вставить("ИмяОбъекта"			, Префикс + "ОборотноСальдоваяВедомостьПоСчету" + ИмяРегистраБухгалтерии);
	ПараметрыОСВПоСчету.Вставить("ЗаполнитьПоУмолчанию"	, Истина);
	ПараметрыОСВПоСчету.Вставить("Счет"					, СчетДляРасшифровки);

	// ПараметрыКарточкиСчета = Новый Соответствие;
	ПараметрыКарточкиСчета = Новый Структура;
    ПараметрыКарточкиСчета.Вставить("ИмяОбъекта", Префикс + "КарточкаСчета" + ИмяРегистраБухгалтерии);
	ПараметрыКарточкиСчета.Вставить("Счет"		, СчетДляРасшифровки);
	    
	// ПараметрыАнализСчета = Новый Соответствие;
	ПараметрыАнализСчета = Новый Структура;
    ПараметрыАнализСчета.Вставить("ИмяОбъекта"			, Префикс + "АнализСчета" + ИмяРегистраБухгалтерии);
    ПараметрыАнализСчета.Вставить("ЗаполнитьПоУмолчанию", Истина);
    ПараметрыАнализСчета.Вставить("Счет"				, СчетДляРасшифровки);
   	
	// ПараметрыОборотыСчетаМесяц = Новый Соответствие;
	ПараметрыОборотыСчетаМесяц = Новый Структура;
	ПараметрыОборотыСчетаМесяц.Вставить("ИмяОбъекта"			, Префикс + "ОборотыСчета" + ИмяРегистраБухгалтерии);
	ПараметрыОборотыСчетаМесяц.Вставить("ЗаполнитьПоУмолчанию"	, Истина);
	ПараметрыОборотыСчетаМесяц.Вставить("Счет"					, СчетДляРасшифровки);
	ПараметрыОборотыСчетаМесяц.Вставить("Периодичность"			, "МЕСЯЦ");
	ПараметрыОборотыСчетаМесяц.Вставить("ВсеПериоды",  Истина);
		
	// ПараметрыОборотыСчетаДень = Новый Соответствие;
	ПараметрыОборотыСчетаДень = Новый Структура;
	ПараметрыОборотыСчетаДень.Вставить("ИмяОбъекта"				, Префикс + "ОборотыСчета" + ИмяРегистраБухгалтерии);
	ПараметрыОборотыСчетаДень.Вставить("ЗаполнитьПоУмолчанию"	, Истина);
    ПараметрыОборотыСчетаДень.Вставить("Счет"					, СчетДляРасшифровки);	
	ПараметрыОборотыСчетаДень.Вставить("Периодичность"			, "ДЕНЬ");
	ПараметрыОборотыСчетаДень.Вставить("ВсеПериоды"				, Ложь);
		
	Если ВВалютеСценария <> Неопределено Тогда
		ПараметрыОСВПоСчету.Вставить("ВВалютеСценария"		 , ВВалютеСценария);
		ПараметрыАнализСчета.Вставить("ВВалютеСценария"		 , ВВалютеСценария);
		ПараметрыОборотыСчетаМесяц.Вставить("ВВалютеСценария", ВВалютеСценария);
		ПараметрыОборотыСчетаДень.Вставить("ВВалютеСценария" , ВВалютеСценария);
	КонецЕсли;
	Если ВыборкаПоВалютам <> Неопределено Тогда
	 	ДобавитьРасшифровкуПоВалюте(ВыборкаПоВалютам, ПараметрыОСВПоСчету);
		ДобавитьРасшифровкуПоВалюте(ВыборкаПоВалютам, ПараметрыКарточкиСчета);
		ДобавитьРасшифровкуПоВалюте(ВыборкаПоВалютам, ПараметрыАнализСчета);
		ДобавитьРасшифровкуПоВалюте(ВыборкаПоВалютам, ПараметрыОборотыСчетаМесяц);
		ДобавитьРасшифровкуПоВалюте(ВыборкаПоВалютам, ПараметрыОборотыСчетаДень);
	КонецЕсли;

	СписокРасшифровки = Новый СписокЗначений;
	ИмяГруппировки = Выборка.Группировка();
		
	Если Лев(ИмяГруппировки, СтрДлина(ИмяГруппировки) - 1) = "Субконто" Тогда

		Если ОтборСубконто <> Неопределено Тогда
			
			ОтборСубконто.Вставить(ИмяГруппировки, Выборка[ИмяГруппировки]);
			
			// Область должна содержать свою копию отбора по субконто.
			ОтборРасшифровка = бит_РаботаСКоллекциями.СоздатьКопиюСоответствияСтруктуры(ОтборСубконто);
			
			ПараметрыКарточкиСчета.Вставить("Отбор", ОтборРасшифровка);
			
		КонецЕсли; 		
		
		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, ИмяКарточкаСчета + Выборка.СчетПредставление);
		
	ИначеЕсли ИмяГруппировки = "Счет" Тогда

		СписокРасшифровки.Добавить(ПараметрыОСВПоСчету	 , ИмяОсвПоСчету    + Выборка.СчетПредставление);
		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, ИмяКарточкаСчета + Выборка.СчетПредставление);
		СписокРасшифровки.Добавить(ПараметрыАнализСчета	 , ИмяАнализСчета   + Выборка.СчетПредставление);
		
		Если НЕ (Месяц(ДатаНач) = Месяц(ДатаКон) И Год(ДатаНач) = Год(ДатаКон))
			ИЛИ (ДатаНач = '00010101' И ДатаКон = '00010101') Тогда
			
			ТекстПоМесяцам    = Нстр("ru = ' по месяцам'");
			СписокРасшифровки.Добавить(ПараметрыОборотыСчетаМесяц,  ИмяОборотыСчета + Выборка.СчетПредставление + ТекстПоМесяцам);
			
		КонецЕсли;
		
		ТекстПоДням = Нстр("ru = ' по дням'");
		СписокРасшифровки.Добавить(ПараметрыОборотыСчетаДень,  ИмяОборотыСчета + Выборка.СчетПредставление + ТекстПоДням);
		
	Иначе
		
		СписокРасшифровки = Неопределено;
		
	КонецЕсли;

	Область.Параметры.Расшифровка = СписокРасшифровки;
	
КонецПроцедуры // ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости()

// Процедура добавляет в итоговое хранилище сумм текущие данных.
// 
// Параметры:
// 	ИмяПоказателя	   - Строка.
// 	СтруктураОбщийИтог - Структура.
// 	НачальныйОстатокДт - Число.
// 	НачальныйОстатокКт - Число.
// 	КонечныйОстатокДт  - Число.
// 	КонечныйОстатокКт  - Число.
// 	ОборотДт		   - Число.
// 	ОборотКт 		   - Число.
// 
Процедура ДополнитьСтруктуруХраненияИтоговОборотка(Знач ИмяПоказателя, СтруктураОбщийИтог,
	Знач НачальныйОстатокДт, Знач НачальныйОстатокКт, Знач КонечныйОстатокДт, Знач КонечныйОстатокКт,
	Знач ОборотДт, Знач ОборотКт)
		
	СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"] 
					= СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокДт"] + ?(НачальныйОстатокДт = Null, 0, НачальныйОстатокДт);
	СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"] 
					= СтруктураОбщийИтог[ИмяПоказателя + "НачальныйОстатокКт"] + ?(НачальныйОстатокКт = Null, 0, НачальныйОстатокКт);
	СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт"] 
					=  СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокДт" ] + ?(КонечныйОстатокДт = Null, 0, КонечныйОстатокДт);
	СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт"] 
					=  СтруктураОбщийИтог[ИмяПоказателя + "КонечныйОстатокКт" ] + ?(КонечныйОстатокКт = Null, 0, КонечныйОстатокКт);
	СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"] 
					=  СтруктураОбщийИтог[ИмяПоказателя + "ОборотДт"] + ?(ОборотДт = Null, 0, ОборотДт);
	СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"] 
					=  СтруктураОбщийИтог[ИмяПоказателя + "ОборотКт"] + ?(ОборотКт = Null, 0, ОборотКт);
	
КонецПроцедуры // ДополнитьСтруктуруХраненияИтоговОборотка()

// Процедура выводит показатели.
// 
// Параметры:
// 	ДокументРезультат 		 - таблица отчета.
// 	Макет 					 - используемый макет.
// 	Счет 					 - счет выборки.
// 	ЭтоПерваяСтрока 		 - признак вывода отступов перед субконто.
// 	СтрокаРазвернутогоСальдо - строка с выборкой - развернутым сальдо по счету.
// 	СтруктураОбщийИтог 		 - структура, в которой накапливается общий итог.
// 
Процедура ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, Выборка, Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров)

	ВыведеноПоказателей = 0;	
	
	ИмяГруппировки = Выборка.Группировка();
	
	Для Каждого ИмяПоказателя Из СтруктураПараметров.МассивПоказателей Цикл

		// Сумму в валюте выводим только по группировке Валюта.
		Если ИмяПоказателя = "ВалютнаяСумма" И ИмяГруппировки <> "Валюта" Тогда 
			Продолжить;			
		КонецЕсли;
		
		Если ИмяПоказателя = "НДС" И Счет.НДС = Ложь Тогда
			Продолжить;
		КонецЕсли;

		ФорматПоказателя = "";
		СтруктураПараметров.ФорматПоказателей.Свойство(ИмяПоказателя, ФорматПоказателя);

		ВыведеноПоказателей = ВыведеноПоказателей + 1;
		
		Если ВыведеноПоказателей > 1 Тогда
			// Без подчеркивания вверху
			Область = ?(ИмяГруппировки = "Валюта", 
								СтруктураПараметров.ОбластьСтрокаПоказателяЧислаВал, 
								СтруктураПараметров.ОбластьСтрокаПоказателяЧисла);
		Иначе
			// Есть подчеркивание вверху
			Область = ?(ИмяГруппировки = "Валюта", 
								СтруктураПараметров.ОбластьСтрокаЧислаВал, 
								СтруктураПараметров.ОбластьСтрокаЧисла);
		КонецЕсли;

		ОборотДт = Выборка[ИмяПоказателя + "ОборотДт"];
		ОборотКт = Выборка[ИмяПоказателя + "ОборотКт"];

		Если СтрокаРазвернутогоСальдо = Неопределено Тогда

			НачальныйОстатокДт = Выборка[ИмяПоказателя + "НачальныйОстатокДт"];
			НачальныйОстатокКт = Выборка[ИмяПоказателя + "НачальныйОстатокКт"];
			КонечныйОстатокДт  = Выборка[ИмяПоказателя + "КонечныйОстатокДт"];
			КонечныйОстатокКт  = Выборка[ИмяПоказателя + "КонечныйОстатокКт"];

		Иначе

			// Спозиционируемся на самом верхнем итоге
			ВыборкаОбщиеИтоги = СтрокаРазвернутогоСальдо.Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Если ВыборкаОбщиеИтоги.Следующий() Тогда
				НачальныйОстатокДт = ВыборкаОбщиеИтоги[ИмяПоказателя + "НачальныйРазвернутыйОстатокДт"];
				НачальныйОстатокКт = ВыборкаОбщиеИтоги[ИмяПоказателя + "НачальныйРазвернутыйОстатокКт"];
				КонечныйОстатокДт  = ВыборкаОбщиеИтоги[ИмяПоказателя + "КонечныйРазвернутыйОстатокДт"];
				КонечныйОстатокКт  = ВыборкаОбщиеИтоги[ИмяПоказателя + "КонечныйРазвернутыйОстатокКт"];
			Иначе
				НачальныйОстатокДт = 0;
				НачальныйОстатокКт = 0;
				КонечныйОстатокДт  = 0;
				КонечныйОстатокКт  = 0;
			КонецЕсли;

		КонецЕсли;

		// Накопление итогов по счетам
		НужноДополнятьИтоги = (ИмяГруппировки = "Счет") И (Выборка.Уровень() = 0);
		Если СтруктураПараметров.СтруктураОграничений.ИспользоватьОграниченияПоЗабалансовымСчетам = Истина Тогда 			
			НужноДополнятьИтоги = НужноДополнятьИтоги И	НЕ Выборка.СчетЗабалансовый;			
		КонецЕсли;
			
		Если НужноДополнятьИтоги Тогда 
			ДополнитьСтруктуруХраненияИтоговОборотка(ИмяПоказателя, СтруктураОбщийИтог,
				НачальныйОстатокДт, НачальныйОстатокКт, КонечныйОстатокДт, КонечныйОстатокКт,
				ОборотДт, ОборотКт); 				
		КонецЕсли;

		// Заполняет данными область вывода
		ЗаполнитьДаннымОблатьВыводаОборотка(Область, ФорматПоказателя, 
			НачальныйОстатокДт, НачальныйОстатокКт, КонечныйОстатокДт,
			КонечныйОстатокКт, ОборотДт, ОборотКт);
			
		Если ВыведеноПоказателей > 1 Тогда

			ОбластьСтрокаПоказателяСчет = ?(ИмяГруппировки = "Валюта", 
											СтруктураПараметров.ОбластьСтрокаПоказателяСчетВал, 
											СтруктураПараметров.ОбластьСтрокаПоказателяСчет);
			ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = ""; 			
			Если ИмяГруппировки = "Валюта" Тогда  			
				ОбластьСтрокаПоказателяСчет.Параметры.Показатель 
						= ПолучитьПредставлениеПоказателя(ИмяПоказателя, СтруктураПараметров.МассивПоказателей);
			Иначе
				ОбластьСтрокаПоказателяСчет.Параметры.Показатель = "";
			КонецЕсли;
					
			// Заполним параметры расшифровки для новой строки вывода значений текущего показателя.
			ОбластьСтрокаПоказателяСчет.Параметры.Расшифровка = СтруктураПараметров.РасшифровкаОбластиСчет;
			
            ВыведеннаяОбласть = ДокументРезультат.Вывести(ОбластьСтрокаПоказателяСчет);
			
			ВыведеннаяОбласть.ГраницаСверху = СтруктураПараметров.НетЛинии;
			
		КонецЕсли;

		ДокументРезультат.Присоединить(Область);
				
	КонецЦикла;

КонецПроцедуры // ВывестиПоказателиОборотноСальдовойВедомости()

// Процедура выводит группировку при развороте счета по субсчетам и/или субконто.
// 
// Параметры:
// 	Выборка         		 - выборка из результата запроса по выводимой группировке,
// 	ИндексТекущейГруппировки - индекс выводимой группировки в массиве группировок,
// 	МассивГруппировок 		 - массив, содержащий имена группировок, по которым строится разворот счета,
// 	Уровень 				 - уровень  группировки верхнего уровня
// 	СдвигУровня     		 - сдвиг уровня группировки отчета относительно уровня группировки запроса,
// 	СброситьСдвигУровня 	 - признак сброса сдвига уровня,
// 	СтрокаРазвернутогоСальдо - строка таблицы значений с развернутым сальдо по текущему счету.
// 	СтруктураОбщийИтог 		 - структура, в которой накапливаются общие итоги,
// 	ПоследнийВыведенныйСчет  - последний выведенный счет,
// 	СтруктураПараметров 	 - структура, содержащая неизменные для разворота счета параметры:
// 	                        	Области макета табличного документа, линии, уровень группировки, 
// 	                      		с которой начался вывод отчета.
//  ОтборПоСубконто.
//  ВыборкаПоВалютам.
// 
Процедура ВывестиГруппировкуОборотноСальдовойВедомости(Выборка, Знач ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
	СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, 
	ОтборСубконто, ВыборкаПоВалютам = Неопределено)

	Пока Выборка.Следующий() Цикл
		
		ИмяГруппировки = Выборка.Группировка();
		
		// Итоги более высокого уровня по счету - пропускаем (он уже выведен).
		Если ИмяГруппировки = "Счет" Тогда 

			// При выводе субсчетов не делаем отступы
			Если СброситьСдвигУровня Тогда
				
				СброситьСдвигУровня = Ложь;
				СдвигУровня = 0;
				
			КонецЕсли;
			
			Отступ = 0;
			СдвигУровня = СдвигУровня + 1;

			// Уже выведенные счета не выводим
			Если ИмяГруппировки = "Валюта"
				ИЛИ (ПоследнийВыведенныйСчет = Выборка.Счет 
					ИЛИ ПоследнийВыведенныйСчет.ПринадлежитЭлементу(Выборка.Счет)) Тогда
				
				ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка
						, ИндексТекущейГруппировки
						, МассивГруппировок
						, Уровень
						, СдвигУровня
						, СброситьСдвигУровня
						, ПоследнийВыведенныйСчет
						, СтрокаРазвернутогоСальдо
						, СтруктураОбщийИтог
						, СтруктураПараметров
						, ОтборСубконто
						, ВыборкаПоВалютам);
					
				Продолжить;
				
			КонецЕсли;
			
		Иначе
			
			Отступ = Макс(Выборка.Уровень() - СдвигУровня, 0);
			СброситьСдвигУровня = Истина;
			
		КонецЕсли;
		
		ОбластьСтрокаСчет = СтруктураПараметров.ОбластьСтрокаСчет;
		ОбластьСтрокаСчет.Параметры.Заполнить(Выборка);
		
		ВыводимаяОбласть = ОбластьСтрокаСчет;

		// Заполнение параметров расшифровки
		Если ИмяГруппировки = "Счет" Тогда
			
			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ОбластьСтрокаСчет, Выборка, , , СтруктураПараметров.СтруктураОграничений.ВВалютеСценария);
			
			// Перед выводом показателей добавим в структуру параметров расшифровку области счет.
			СтруктураПараметров.Вставить("РасшифровкаОбластиСчет", ОбластьСтрокаСчет.Параметры.Расшифровка);
			
		КонецЕсли;

		Если Лев(ИмяГруппировки, СтрДлина(ИмяГруппировки) - 1) = "Субконто" тогда

			// Субконто, которых нет, равны NULL
			Если Выборка[ИмяГруппировки] = NULL Тогда
				Продолжить;
			КонецЕсли;

			ОбластьСтрокаПоказателяСчет = СтруктураПараметров.ОбластьСтрокаПоказателяСчет;
			// Добавление кода. Начало. 05.04.2016{{
			ОбластьСтрокаПоказателяСчет.Параметры.Показатель = "";
			// Добавление кода. Конец. 05.04.2016}}   			
			ОбластьСтрокаПоказателяСчет.Параметры.Заполнить(Выборка);
			ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = Выборка[ИмяГруппировки + "Представление"]; 
			
			ВыводимаяОбласть = ОбластьСтрокаПоказателяСчет;

			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(
									СтруктураПараметров.СтруктураОграничений.ДатаНач, 				 // ДатаНач
									СтруктураПараметров.СтруктураОграничений.ДатаКон, 				 // ДатаКон
									СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии, // ИмяРегистраБухгалтерии
									ВыводимаяОбласть, 												 // Область 
									Выборка,  														 // Выборка
									ОтборСубконто,                                                   // ОтборСубконто
									ПоследнийВыведенныйСчет,                                         // ВыведенныйСчет
									СтруктураПараметров.СтруктураОграничений.ВВалютеСценария,        // ВВалютеСценария 
									ВыборкаПоВалютам);                                               // ВыборкаПоВалютам
									
					
			// Перед выводом показателей добавим в структуру параметров расшифровку области счет.
			СтруктураПараметров.Вставить("РасшифровкаОбластиСчет", ВыводимаяОбласть.Параметры.Расшифровка);
			
			// Изменение кода. Начало. 05.04.2016{{
			ВыводимаяОбласть.Область(1, 4).Отступ = Отступ;
			//ВыводимаяОбласть.Область(1, 4).Отступ = Отступ + 1;  			
			// Изменение кода. Конец. 05.04.2016}}.
			
			Если Выборка.ТипЗаписи() = ТипЗаписиЗапроса.ИтогПоИерархии Тогда
				ВыводимаяОбласть.Область(1, 4).Шрифт = Новый Шрифт(ВыводимаяОбласть.Область(1, 4).Шрифт,,,,Истина);
			Иначе
				ВыводимаяОбласть.Область(1, 4).Шрифт = Новый Шрифт(ВыводимаяОбласть.Область(1, 4).Шрифт,,,,Ложь);
			КонецЕсли;

		КонецЕсли;

		ДокументРезультат = СтруктураПараметров.ДокументРезультат;
		ДокументРезультат.Вывести(ВыводимаяОбласть, Выборка.Уровень());
		
		ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат,
														Выборка, 
														Выборка.Счет, 
														СтрокаРазвернутогоСальдо, 
														СтруктураОбщийИтог, 
														СтруктураПараметров);

		// Вывод данных по валютам
		ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, 
															СтруктураПараметров.ОбластьСтрокаПоказателяСчетВал, 
															Выборка,
															ДокументРезультат, 
															СтрокаРазвернутогоСальдо, 
															СтруктураОбщийИтог, 
															Отступ,
															,
															,
															,
															,
															ОтборСубконто);												
														
		ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, 
															  ИндексТекущейГруппировки, 
															  МассивГруппировок, 
															  Уровень, 
															  СдвигУровня, 
															  СброситьСдвигУровня, 
															  ПоследнийВыведенныйСчет, 
															  СтрокаРазвернутогоСальдо, 
															  СтруктураОбщийИтог, 
															  СтруктураПараметров, 
															  ОтборСубконто, 
															  ВыборкаПоВалютам);
											
	КонецЦикла;

КонецПроцедуры // ВывестиГруппировкуОборотноСальдовойВедомости()

// Процедура выводит текущие данные оборотки в область вывода.
// 
// Параметры:
// 	Область	   		   - Область.
// 	ФорматПоказателя   - Строка.
// 	НачальныйОстатокДт - Число.
// 	НачальныйОстатокКт - Число.
// 	КонечныйОстатокДт  - Число.
// 	КонечныйОстатокКт  - Число.
// 	ОборотДт		   - Число.
// 	ОборотКт 		   - Число.
// 
Процедура ЗаполнитьДаннымОблатьВыводаОборотка(Область, Знач ФорматПоказателя, 
	Знач НачальныйОстатокДт, Знач НачальныйОстатокКт, 
	Знач КонечныйОстатокДт, Знач КонечныйОстатокКт, 
	Знач ОборотДт, Знач ОборотКт)
	
	Область.Параметры.НачальныйОстатокДт = Формат(НачальныйОстатокДт, ФорматПоказателя);
	Область.Параметры.НачальныйОстатокКт = Формат(НачальныйОстатокКт, ФорматПоказателя);
	Область.Параметры.КонечныйОстатокДт  = Формат(КонечныйОстатокДт,  ФорматПоказателя);
	Область.Параметры.КонечныйОстатокКт  = Формат(КонечныйОстатокКт,  ФорматПоказателя);
	Область.Параметры.ОборотДт           = Формат(ОборотДт,           ФорматПоказателя);
	Область.Параметры.ОборотКт           = Формат(ОборотКт,           ФорматПоказателя);
	
КонецПроцедуры // ЗаполнитьДаннымОблатьВыводаОборотка()

// Функция возвращает можно ил использовать составной запрос для детализации по субконто.
// 
// Параметры:
//  ПравилаСчета - ПравилаСчета.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ОпределитьМожноИспользоватьСоставнойЗапросПоСубконто(ПравилаСчета)
	
	// Определим признак использования составного запроса.
	Для Каждого СтрокаПоСубконто Из ПравилаСчета.РазворотПоСубконто Цикл
		
		ВидСубконто = ВернутьСубконтоПоИмени(ПравилаСчета.Счет, СтрокаПоСубконто.Имя);
		
		Если (ВидСубконто <> Неопределено)
			 И (ВидСубконто.ВидСубконто.ТипЗначения.Типы().Количество() > 10) Тогда
			 
			Возврат Ложь;
			
		КонецЕсли;
								
	КонецЦикла;

	Возврат Истина;
	
КонецФункции // ОпределитьМожноИспользоватьСоставнойЗапросПоСубконто()

// Функция возвращает видсубконто по имени.
// 
// Параметры:
//  Счет 	    - ПланСчетовСсылка.
//  ИмяСубконто - Строка.
// 
// Возвращаемое значение:
//  ВидСубконто.
// 
Функция ВернутьСубконтоПоИмени(Знач Счет, Знач ИмяСубконто)
	
	// Найдем соответствующий вид субконто
	Для Каждого ВидСубконто Из Счет.ВидыСубконто Цикл
			
		Если "Субконто" + ВидСубконто.НомерСтроки = ИмяСубконто Тогда
				
			Возврат ВидСубконто;
				
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // ВернутьСубконтоПоИмени()

// Процедура выводит вложенную группировку.
// 
// Параметры:
// 	Выборка         		 - выборка из результата запроса по выводимой группировке.
// 	ИндексТекущейГруппировки - индекс выводимой группировки в массиве группировок.
// 	МассивГруппировок 		 - массив, содержащий имена группировок, по которым строится разворот счета.
// 	Уровень 				 - уровень  группировки верхнего уровня.
// 	СдвигУровня     		 - сдвиг уровня группировки отчета относительно уровня группировки запроса.
// 	СброситьСдвигУровня 	 - признак сброса сдвига уровня.
// 	СтрокаРазвернутогоСальдо - строка таблицы значений с развернутым сальдо по текущему счету.
// 	СтруктураОбщийИтог 		 - структура, в которой накапливаются общие итоги.
// 	СтруктураПараметров 	 - структура, содержащая неизменные для разворота счета параметры:
// 	                      		Области макета табличного документа, линии, уровень группировки, 
// 	                      		с которой начался вывод отчета.
//  ОтборСубконто 			 - ОтборСубконто.
//  ВыборкаПоВалютам.
// 
Процедура ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости(Выборка, Знач ИндексТекущейГруппировки, МассивГруппировок, Уровень, СдвигУровня, 
	СброситьСдвигУровня, ПоследнийВыведенныйСчет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров, ОтборСубконто
	, ВыборкаПоВалютам = Неопределено)
	
	Если ИндексТекущейГруппировки + 1 >= МассивГруппировок.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ВывестиГруппировкуОборотноСальдовойВедомости(
						Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, МассивГруппировок[ИндексТекущейГруппировки + 1]), 
						ИндексТекущейГруппировки + 1, 
						МассивГруппировок, 
						Уровень, 
						СдвигУровня, 
						СброситьСдвигУровня, 
						ПоследнийВыведенныйСчет, 
						СтрокаРазвернутогоСальдо, 
						СтруктураОбщийИтог, 
						СтруктураПараметров, 
						бит_РаботаСКоллекциями.СоздатьКопиюСоответствияСтруктуры(ОтборСубконто), 
						ВыборкаПоВалютам);
		
КонецПроцедуры // ВывестиВложеннуюГруппировкуОборотноСальдовойВедомости()

// Процедура выводит вложенную группировку оборотно сальдовой ведомости оп счету.
// 
// Параметры:
// 	ОбъектОтчета		 	 - ОбъектОтчета.
// 	Выборка 			 	 - ВыборкаИзЗапроса.
// 	ИндексТекущейГруппировки - Число.
// 	СтруктураПараметров 	 - Структура.
// 
Процедура ВывестиВложеннуюГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка, Знач ИндексТекущейГруппировки, 
	СтруктураПараметров)
	
	Если ИндексТекущейГруппировки + 1 >= СтруктураПараметров.МассивГруппировок.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ВывестиГруппировкуОборотноСальдовойВедомостиПоСчету(ОбъектОтчета, Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, СтруктураПараметров.МассивГруппировок[ИндексТекущейГруппировки + 1]), 
		ИндексТекущейГруппировки + 1, СтруктураПараметров);
		
КонецПроцедуры // ВывестиВложеннуюГруппировкуОборотноСальдовойВедомостиПоСчету()

// Процедура добавляет доп отбор по валюте в параметры расшифровки.
// 
// Параметры:
//  ВыборкаПоВалюте      - Выборка из результата запроса.
//  ПараметрыРасшифровки - Структура.
// 
Процедура ДобавитьРасшифровкуПоВалюте(ВыборкаПоВалютам, ПараметрыРасшифровки)

	Если ПараметрыРасшифровки.Свойство("ДополнительныеОтборы") Тогда
	 	ДополнительныеОтборы = ПараметрыРасшифровки.ДополнительныеОтборы.Получить();
	Иначе	
	    ДополнительныеОтборы = СоздатьТаблицуДляХраненияОтбора(Истина);
	КонецЕсли;
		
	СтрокаОтбора = ДополнительныеОтборы.Добавить();
	СтрокаОтбора.Использование = Истина;
	СтрокаОтбора.Имя 		   = "Валюта";
	СтрокаОтбора.Представление = "Валюта";
	СтрокаОтбора.ПутьКДанным   = "Валюта";
	СтрокаОтбора.ВидСравнения  = ВидСравнения.Равно;
	СтрокаОтбора.Значение 	   = ВыборкаПоВалютам.Валюта;	
	
	ПараметрыРасшифровки.Вставить("ДополнительныеОтборы", Новый ХранилищеЗначения(ДополнительныеОтборы));

КонецПроцедуры // ДобавитьРасшифровкуПоВалюте()

// Процедура обновляет детализацию счета построителя по таблице на форме.
// 
// Параметры:
//  ЭтотОбъект     - Объект.
//  ТаблицаНаФорме - ДанныеФормыКоллекция.
// 
Процедура СинхронизироватьДетализацииСчетаПоТаблицеНаФорме(ЭтотОбъект, ТаблицаНаФорме)

	ЭтотОбъект.ПостроительОтчета.ИзмеренияСтроки.Очистить();
	
	ТаблицаЗнч = ТаблицаНаФорме.Выгрузить();
	МассивИмен = ТаблицаЗнч.ВыгрузитьКолонку("Имя");
	КоличествоЭлементовМассиваИмен = МассивИмен.Количество();
	МассивИменБезПовторов = бит_РаботаСКоллекциями.УдалитьПовторяющиесяЭлементыМассива(МассивИмен); 
	Если КоличествоЭлементовМассиваИмен <> МассивИменБезПовторов.Количество() Тогда
	 	ТекстСообщения = Нстр("ru = 'Ошибка формирования отчета. В таблице детализации обнаружен повтор строк.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	Для каждого СтрокаТаблицы Из ТаблицаНаФорме Цикл
		
		Если ПустаяСтрока(СтрокаТаблицы.ПутьКДанным) Тогда
			Продолжить;		
		КонецЕсли;
		
		СтрокаТипаИзмерения = ?(СтрокаТаблицы.ТипИзмерения = ТипГруппировкиКомпоновкиДанных.Элементы
									, "Элементы"
									, СтрЗаменить(Трег(СтрокаТаблицы.ТипИзмерения), " ", ""));
		ТипИзмерения = ТипИзмеренияПостроителяОтчета[СтрокаТипаИзмерения];
									
		ЭлементДетализацииСчета = ЭтотОбъект.ПостроительОтчета.ИзмеренияСтроки.Добавить(СтрокаТаблицы.ПутьКДанным
																						, СтрокаТаблицы.Имя
																						, ТипИзмерения);	
		ЭлементДетализацииСчета.Представление = СтрокаТаблицы.Представление;
				
	КонецЦикла;	
	
КонецПроцедуры // СинхронизироватьДетализацииСчетаПоТаблицеНаФорме()

// Процедура обновляет таблицу правил вывода итогов или таблицу развернутого сальдо
// отчета по таблице на форме
// (детализация кор. счетов).
// 
// Параметры:
//  ТаблицаОбъекта - ТаблицаЗначений.
//  ТаблицаНаФорме - ДанныеФормыКоллекция.
// 
Процедура СинхронизироватьТаблицуПравилПоТаблицеНаФорме(ТаблицаОбъекта, ТаблицаНаФорме)
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("Булево"));
	ОписаниеТиповБулево          = Новый ОписаниеТипов(МассивТипов);
	
	ОписаниеТиповСтрока          = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(200));
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("ТаблицаЗначений"));
	ОписаниеТиповТаблицаЗначений = Новый ОписаниеТипов(МассивТипов);


	ТаблицаОбъекта.Очистить();
	ТаблицаОбъекта.Колонки.Очистить();
	ТаблицаОбъекта.Колонки.Добавить("Счет");
	ТаблицаОбъекта.Колонки.Добавить("Субсчета"					     , ОписаниеТиповБулево);
	ТаблицаОбъекта.Колонки.Добавить("ПредставлениеРазворотПоСубконто", ОписаниеТиповСтрока);
	ТаблицаОбъекта.Колонки.Добавить("РазворотПоСубконто"			 , ОписаниеТиповТаблицаЗначений);
	
	Для каждого СтрокаТаблицы Из ТаблицаНаФорме Цикл
		
		СтрокаПравил = ТаблицаОбъекта.Добавить();	
		ЗаполнитьЗначенияСвойств(СтрокаПравил, СтрокаТаблицы, , "РазворотПоСубконто");
		
		СтрокаПравил.РазворотПоСубконто = Новый ТаблицаЗначений;		
		СтрокаПравил.РазворотПоСубконто.Колонки.Добавить("Имя"			, ОписаниеТиповСтрока);
		СтрокаПравил.РазворотПоСубконто.Колонки.Добавить("Представление", ОписаниеТиповСтрока);
		
		Для каждого СтрокаРазворотаИзТаблицы Из СтрокаТаблицы.РазворотПоСубконто Цикл
			
			СтрокаРазворота = СтрокаПравил.РазворотПоСубконто.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаРазворота, СтрокаРазворотаИзТаблицы);			
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // СинхронизироватьТаблицуПравилПоТаблицеНаФорме()

// Процедура обновляет таблицу правил вывода итогов отчета по таблице на форме
// (детализация кор. счетов).
// 
// Параметры:
//  ЭтотОбъект     - Объект.
//  ТаблицаНаФорме - ДанныеФормыКоллекция.
// 
Процедура СинхронизироватьКорреспонденцииПоТаблицеНаФорме(ЭтотОбъект, ТаблицаНаФорме)
	
	ОписаниеТиповСтрока          = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(200));
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("ТаблицаЗначений"));
	ОписаниеТиповТаблицаЗначений = Новый ОписаниеТипов(МассивТипов);

	ЭтотОбъект.Корреспонденции.Очистить();
	ЭтотОбъект.Корреспонденции.Колонки.Очистить();
	ЭтотОбъект.Корреспонденции.Колонки.Добавить("СчетДт");
	ЭтотОбъект.Корреспонденции.Колонки.Добавить("СчетКт");
	ЭтотОбъект.Корреспонденции.Колонки.Добавить("ПредставлениеСубконто", ОписаниеТиповСтрока);
	ЭтотОбъект.Корреспонденции.Колонки.Добавить("Субконто"   		   , ОписаниеТиповТаблицаЗначений);
	
	Для каждого СтрокаТаблицы Из ТаблицаНаФорме Цикл
		
		СтрокаКорреспонденции = ЭтотОбъект.Корреспонденции.Добавить();	
		ЗаполнитьЗначенияСвойств(СтрокаКорреспонденции, СтрокаТаблицы, , "Субконто");
		
		СтрокаКорреспонденции.Субконто = Новый ТаблицаЗначений;		
		СтрокаКорреспонденции.Субконто.Колонки.Добавить("Имя"		   , ОписаниеТиповСтрока);
		СтрокаКорреспонденции.Субконто.Колонки.Добавить("Представление", ОписаниеТиповСтрока);
		СтрокаКорреспонденции.Субконто.Колонки.Добавить("ПутьКДанным"  , ОписаниеТиповСтрока);
		СтрокаКорреспонденции.Субконто.Колонки.Добавить("ВидСравнения");// , ОписаниеТиповВидСравнения);
		СтрокаКорреспонденции.Субконто.Колонки.Добавить("Значение");
		СтрокаКорреспонденции.Субконто.Колонки.Добавить("ЗначениеС");
		СтрокаКорреспонденции.Субконто.Колонки.Добавить("ЗначениеПо");
		
		Для каждого СтрокаСубконтоИзТаблицы Из СтрокаТаблицы.Субконто Цикл
			
			СтрокаСубконто = СтрокаКорреспонденции.Субконто.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСубконто, СтрокаСубконтоИзТаблицы);			
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // СинхронизироватьКорреспонденцииПоТаблицеНаФорме()

// Функция получает тип измерения построителя отчета по умолчанию.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//  Элементы - ТипИзмеренияПостроителяОтчета.
// 
Функция ПолучитьТипИзмеренияПостроителяОтчетаПоУмолчанию()
	
	ТипДетализацииПоУмолчанию = бит_УправлениеПользователямиСервер.ЗначениеПоУмолчаниюТиповой("ТипДетализацииСтандартныхОтчетов");
	
	Возврат ТипИзмеренияПостроителяОтчета.Элементы;
		     		
КонецФункции // ПолучитьТипИзмеренияПостроителяОтчетаПоУмолчанию()

// Чтение настроек колонтитулов из константы. Если константа не заполнена, то формируются пустые настройки.
// 
// Параметры:
//  Нет.
// 
// Возвращаемое значение:
//   Структура   - Настройки колонтитулов.
// 
Функция ПолучитьНастройкиКолонтитулов()

	Если Метаданные.Константы.Найти("НастройкиКолонтитулов") <> Неопределено Тогда
		Настройка = Константы.НастройкиКолонтитулов.Получить().Получить();	
	Иначе
		Настройка = Неопределено;	
	КонецЕсли; 	
	
	Если ТипЗнч(Настройка) <> Тип("Структура") Тогда
		// Если константа не заполнена, то заполним структуру настройками пустых колонтитулов.
		
		Настройка = Новый Структура;
		
		Верхний = Новый Структура;
		Нижний = Новый Структура;
		
		Верхний.Вставить("Выводить"			, Ложь);
		Верхний.Вставить("НачальнаяСтраница", 1);
		Верхний.Вставить("ТекстСлева"		, "");
		Верхний.Вставить("ТекстВЦентре"		, "");
		Верхний.Вставить("ТекстСправа"		, "");
		
		Нижний.Вставить("Выводить"			, Ложь);
		Нижний.Вставить("НачальнаяСтраница"	, 1);
		Нижний.Вставить("ТекстСлева"		, "");
		Нижний.Вставить("ТекстВЦентре"		, "");
		Нижний.Вставить("ТекстСправа"		, "");
		
		Настройка.Вставить("ВерхнийКолонтитул", Верхний);
		Настройка.Вставить("НижнийКолонтитул" ,  Нижний);
		
	Иначе
		// Если константа заполнена, но нет нужных нам полей, то заполним структуру настройками пустых колонтитулов.
	
		Если Не Настройка.Свойство("ВерхнийКолонтитул") Тогда			
			Верхний = Новый Структура;			
			Настройка.Вставить("ВерхнийКолонтитул", Верхний);
			Настройка.Вставить("Выводить"		  , Ложь);
		КонецЕсли;
		
		Если Не Настройка.Свойство("НижнийКолонтитул") Тогда			
			Нижний = Новый Структура;			
			Настройка.Вставить("НижнийКолонтитул", Нижний);
			Настройка.Вставить("Выводить"		 , Ложь);
		КонецЕсли;
		
	КонецЕсли;
	
	ДополнитьНастройкиКолонтитула(Настройка.ВерхнийКолонтитул);
	ДополнитьНастройкиКолонтитула(Настройка.НижнийКолонтитул);
	
	Возврат Настройка;
	
КонецФункции // ПолучитьНастройкиКолонтитулов()

Процедура ДополнитьНастройкиКолонтитула(НастройкиКолонтитула)
	
	// Типовые
	Если Не НастройкиКолонтитула.Свойство("ТекстСлева")
		ИЛИ ТипЗнч(НастройкиКолонтитула.ТекстСлева) <> Тип("Строка") Тогда
		НастройкиКолонтитула.Вставить("ТекстСлева", "");
	КонецЕсли;
	Если Не НастройкиКолонтитула.Свойство("ТекстВЦентре")
		ИЛИ ТипЗнч(НастройкиКолонтитула.ТекстВЦентре) <> Тип("Строка") Тогда
		НастройкиКолонтитула.Вставить("ТекстВЦентре", "");
	КонецЕсли;
	Если Не НастройкиКолонтитула.Свойство("ТекстСправа")
		ИЛИ ТипЗнч(НастройкиКолонтитула.ТекстСправа) <> Тип("Строка") Тогда
		НастройкиКолонтитула.Вставить("ТекстСправа", "");
	КонецЕсли;
	Если Не НастройкиКолонтитула.Свойство("Шрифт")
		ИЛИ ТипЗнч(НастройкиКолонтитула.Шрифт) <> Тип("Шрифт") Тогда
		НастройкиКолонтитула.Вставить("Шрифт", Новый Шрифт);
	КонецЕсли;
	Если Не НастройкиКолонтитула.Свойство("ВертикальноеПоложение")
		ИЛИ ТипЗнч(НастройкиКолонтитула.ВертикальноеПоложение) <> Тип("ВертикальноеПоложение") Тогда
		НастройкиКолонтитула.Вставить("ВертикальноеПоложение", ВертикальноеПоложение.Центр);
	КонецЕсли;
	// Измененные БИТ
	Если Не НастройкиКолонтитула.Свойство("НачальнаяСтраница")
		ИЛИ ТипЗнч(НастройкиКолонтитула.НачальнаяСтраница) <> Тип("Число")
		ИЛИ НастройкиКолонтитула.НачальнаяСтраница < 0 Тогда
		НастройкиКолонтитула.Вставить("НачальнаяСтраница", 1);
	КонецЕсли;
	// Старые БИТ
	Если Не НастройкиКолонтитула.Свойство("Выводить")
		ИЛИ ТипЗнч(НастройкиКолонтитула.НачальнаяСтраница) <> Тип("Булево") Тогда
		НастройкиКолонтитула.Вставить("Выводить", Истина);
	КонецЕсли;
	
КонецПроцедуры // ДополнитьНастройкиКолонтитула()

// Проставление в тексте вместо шаблонов, значений.
// 
// Параметры
//  Текст           - Строка - Исходный текст шаблона.
//  НазваниеОтчета  - Строка - Название отчета.
//  Пользователь    - Строка - Имя пользователя.
// 
// Возвращаемое значение:
//   Строка   - результурующий текст для колонтитула.
// 
Функция ЗаполнитьТекстКолонтитула(Текст, НазваниеОтчета, Пользователь)

	Результат = Текст;
	
	Результат = СтрЗаменить(Результат, "[&НазваниеОтчета]", НазваниеОтчета);
	Результат = СтрЗаменить(Результат, "[&Пользователь]"  , Пользователь);
	
	Возврат Результат;

КонецФункции // ЗаполнитьТекстКолонтитула()

// Процедура обновляет представление по субконто.
// 
// Параметры:
//  СтрокаТаблицы  	    - ДанныеФормыЭлементКоллекции.
//  НовыйМассивСубконто - Массив.
//  
// Возвращаемое значение:
//   Строка.
// 
Процедура ОбновитьДанныеСубконтоПоМассиву(СтрокаТаблицы, НовыйМассивСубконто, ДтКт = "")

	МассивПути     = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(СтрокаТаблицы.ПутьКДанным, ".");
	ИмяСубконто    = МассивПути[0];
	ЭтоСложныйПуть = МассивПути.Количество() > 1;
	ПутьБезИмениСубконто = Прав(СтрокаТаблицы.ПутьКДанным, СтрДлина(СтрокаТаблицы.ПутьКДанным) - СтрДлина(ИмяСубконто));

	Попытка
		ИндексСубконто = Число(СтрЗаменить(ИмяСубконто, "Субконто" + ДтКт, "") - 1);
	Исключение
		Возврат;
	КонецПопытки;
	
	// Изменение кода. Начало. 23.04.2014{{
	Если ТипЗнч(НовыйМассивСубконто) = Тип("Неопределено") Тогда
		Возврат;	
	КонецЕсли;
	// Изменение кода. Конец. 23.04.2014}}
	
	Если НовыйМассивСубконто.Количество() < ИндексСубконто Тогда
		Возврат;	
	КонецЕсли;
	
	ЭлементМассива = НовыйМассивСубконто[ИндексСубконто];
	
	// Представление
	СтрокаТаблицы.Представление = ?(ДтКт = "", "", ДтКт + " ") 
									+ ЭлементМассива.Наименование 
									+ ПутьБезИмениСубконто;	
	
	// Тип значения
	СтрокаТаблицы.ТипЗначения = ЭлементМассива.ТипЗначения;
	Если ЭтоСложныйПуть Тогда
		Для Сч = 1 По МассивПути.Количество() - 1 Цикл
			ЗначениеСубконто = СтрокаТаблицы.ТипЗначения.ПривестиЗначение();
			МассивТипов = Новый Массив;
		    МассивТипов.Добавить(ТипЗнч(ЗначениеСубконто[МассивПути[Сч]]));
			СтрокаТаблицы.ТипЗначения = Новый ОписаниеТипов(МассивТипов);
		КонецЦикла;
	КонецЕсли;	
 	
КонецПроцедуры // ОбновитьПредставлениеСубконтоПоМассиву()

// Процедура заполняет строку отбора по ключу и значению элемента структуры или соответствия.
// 
// Параметры:
//  СтрокаОтбора 	  - ДанныеФормыЭлементКоллекции.
//  КлЗнч  		 	  - Ключ и значение элемента структуры или соответствия.
//  ЕстьИспользование - Булево (По умолчанию = Истина).
// 
Процедура ЗаполнитьСтрокуОтбораПоКлючуЗначению(СтрокаОтбора, КлЗнч, ЕстьИспользование = Истина)

	СтрокаОтбора.ПутьКДанным = КлЗнч.Ключ;
		
	Если ТипЗнч(КлЗнч.Значение) = Тип("Структура") Тогда
	    СтрокаОтбора.Значение      = КлЗнч.Значение.Значение;
		СтрокаОтбора.ВидСравнения  = КлЗнч.Значение.ВидСравнения;
	Иначе	
		
		СтрокаОтбора.Значение = КлЗнч.Значение;
		
		Попытка
			Если КлЗнч.Значение.ЭтоГруппа Тогда
		    	СтрокаОтбора.ВидСравнения = ВидСравнения.ВИерархии;		
			КонецЕсли;		
		Исключение 
			СтрокаОтбора.ВидСравнения = ВидСравнения.Равно;
		КонецПопытки;
		
	КонецЕсли;  

	СтрокаОтбора.Представление = КлЗнч.Ключ;
	Если ЕстьИспользование Тогда
		СтрокаОтбора.Использование = Истина;
	КонецЕсли;   	
	
	Если СтрокаОтбора.Свойство("ТипЗначения") Тогда  	
	
		МасТипов = Новый Массив;
		МасТипов.Добавить(ТипЗнч(КлЗнч.Значение));
		ТипЗначенияТек = Новый ОписаниеТипов(МасТипов);
		
		СтрокаОтбора.ТипЗначения = ТипЗначенияТек;
		
	КонецЕсли;
			
КонецПроцедуры // ЗаполнитьСтрокуОтбораПоКлючуЗначению()

// Процедура заполняет дополнительные отборы и отборы корреспонденции отчета по проводкам 
// (при расшифровке ).
// 
// Параметры:
//  ЭтаФорма  			 - УправляемаяФорма.
//  СтрокаКорр  		 - ДанныеФормыЭлементКоллекции.
//  ДополнительныеОтборы - ТаблицаЗначений.
//  ДтКт - Строка.
// 
Процедура ЗаполнитьДополнительныеОтборыОтчетаПоПроводкам(ЭтаФорма, СтрокаКорр, ДополнительныеОтборы, ДтКт)

	СтрокаОтбораРасш = ДополнительныеОтборы[0];
	Если Найти(СтрокаОтбораРасш.ПутьКДанным , "СубконтоДт") = 0 
		И Найти(СтрокаОтбораРасш.ПутьКДанным, "СубконтоКт") = 0 Тогда
		СтрокаЗамены = "Субконто" + ДтКт;
	Иначе	
		СтрокаЗамены = "Субконто";
	КонецЕсли;
	
	Для каждого СтрокаОтбораРасш Из ДополнительныеОтборы Цикл
		
		Если Не ЭтаФорма.фКэшЗначений.ЭтоБюджетирование И Лев(СтрокаОтбораРасш.Имя, 12) = "Организация" Тогда
			Продолжить;		
		КонецЕсли;
		
		Если Найти(СтрокаОтбораРасш.ПутьКДанным, "Субконто") > 0 Тогда
			
			СтрокаОтбора = ЭтаФорма.ТаблицаОтборКорреспонденции.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаОтбораРасш);
			СтрокаОтбора.ПутьКДанным = СтрЗаменить(СтрокаОтбораРасш.ПутьКДанным, "Субконто", СтрокаЗамены);
			СтрокаОтбора.Имя 	     = СтрЗаменить(СтрокаОтбораРасш.Имя		   , "Субконто", СтрокаЗамены);
			СтрокаОтбора.ИдСтрокиКорреспонденции = 0;
			
			Если СтрокаОтбораРасш.Использование Тогда				
				СтрокаСубконто = СтрокаКорр.Субконто.Добавить();	
				ЗаполнитьЗначенияСвойств(СтрокаСубконто, СтрокаОтбора);			
			КонецЕсли;
			
		ИначеЕсли ЭтаФорма.фКэшЗначений.ЕстьТаблицаОтборов Тогда
			
			// Добавление дополнительных отборов по сценарию и цфо для бит_ОтчетПоПроводкам_Бюджетирование.
			НайденныеСтроки = ЭтаФорма.ТаблицаОтбор.НайтиСтроки(Новый Структура("ПутьКДанным", СтрокаОтбораРасш.ПутьКДанным));
			Если НайденныеСтроки.Количество() = 0 Тогда
				СтрокаОтбора = ЭтаФорма.ТаблицаОтбор.Добавить();
				ЗаполнитьЗначенияСвойств(СтрокаОтбора, СтрокаОтбораРасш);
			КонецЕсли;			
			
		КонецЕсли;
		
	КонецЦикла;     	

КонецПроцедуры // ЗаполнитьДополнительныеОтборыОтчетаПоПроводкам()

// Функция проверяет наличие значений в иерархии.
// 
// Параметры
//  ЛевоеЗначение  - Произвольное.
//  ПравоеЗначение - Произвольное.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ВИерархии(ЛевоеЗначение, ПравоеЗначение)
	
	Если ТипЗнч(ЛевоеЗначение) <> ТипЗнч(ПравоеЗначение) Тогда
		Возврат Ложь;    	
	ИначеЕсли ЛевоеЗначение = ПравоеЗначение Тогда
		Возврат Истина;
	ИначеЕсли ЛевоеЗначение.Пустая() ИЛИ ПравоеЗначение.Пустая() Тогда
		Возврат Ложь;
	ИначеЕсли ЛевоеЗначение.ПринадлежитЭлементу(ПравоеЗначение) Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;

КонецФункции // ВИерархии()

// Процедура Выводит данные по валютам.
//
// Параметры:
//  СтруктураПараметров 		- Структура.
//  ОбластьСтрокаПоказателяСчет - Область.
//  Выборка 					- выборка из результата запроса.
//  ДокументРезультат 			- ТабличныйДокумент.
//  СтрокаРазвернутогоСальдо 	- строка таблицы значений с развернутым сальдо по текущему счету.
//  СтруктураОбщийИтог 			- структура, в которой накапливаются общие итоги.
//  Отступ 						- Число.
//  СтрокаРазворотаСчета
//  ОбластьСтрокаСчет
//  Уровень
//  ВалютаОтбор
//  ОтборСубконто.
//
Процедура ВывестиДанныеПоВалютамОборотноСальдовойВедомости(СтруктураПараметров, ОбластьСтрокаПоказателяСчет, Выборка, 
	ДокументРезультат, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, Знач Отступ
	, СтрокаРазворотаСчета = Неопределено, ОбластьСтрокаСчет = Неопределено, Знач Уровень = 0 
	, ВалютаОтбор = Неопределено, ОтборСубконто = Неопределено)
	
	// Если по валютам,
	Если СтруктураПараметров.СтруктураОграничений.ПоВалютам Тогда

		ВыборкаПоВалютам = Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам, "Валюта");
			
		Пока ВыборкаПоВалютам.Следующий() Цикл
			
			ОбластьСтрокаПоказателяСчет.Параметры.Заполнить(Выборка);
			ОбластьСтрокаПоказателяСчет.Параметры.СубконтоПредставление = "Валюта " + ВыборкаПоВалютам["ВалютаПредставление"];
			
			ОбластьСтрокаПоказателяСчет.Параметры.Показатель 
						= ПолучитьПредставлениеПоказателя(СтруктураПараметров.МассивПоказателей[0], СтруктураПараметров.МассивПоказателей);
			                   
			// Заполнение параметров расшифровки
			ЗаполнитьПараметрыРасшифровкиОборотноСальдовойВедомости(
				СтруктураПараметров.СтруктураОграничений.ДатаНач, 
				СтруктураПараметров.СтруктураОграничений.ДатаКон, 
				СтруктураПараметров.СтруктураОграничений.ИмяРегистраБухгалтерии,
				ОбластьСтрокаПоказателяСчет, 
				Выборка,
				ОтборСубконто,
				, 
				СтруктураПараметров.СтруктураОграничений.ВВалютеСценария,
				ВыборкаПоВалютам);
			
			ОбластьСтрокаПоказателяСчет.Область(1, 4).Отступ = Отступ + 1;

			ДокументРезультат.Вывести(ОбластьСтрокаПоказателяСчет, Уровень + Выборка.Уровень());
			
			// Перед выводом показателей добавим в структуру параметров расшифровку области счет.
			СтруктураПараметров.Вставить("РасшифровкаОбластиСчет", ОбластьСтрокаПоказателяСчет.Параметры.Расшифровка);
			
			ВывестиПоказателиОборотноСальдовойВедомости(ДокументРезультат, ВыборкаПоВалютам, ВыборкаПоВалютам.Счет, СтрокаРазвернутогоСальдо, СтруктураОбщийИтог, СтруктураПараметров);
				
		КонецЦикла;
			
	КонецЕсли;
	
КонецПроцедуры // ВывестиДанныеПоВалютамОборотноСальдовойВедомости()

Функция ПроверитьЗначениеПоВидуСравнения(ЭлементОтбора, ЗначениеПоля)

	Если ЭлементОтбора.ВидСравнения = ВидСравнения.Больше Тогда
			
		Результат = ЗначениеПоля > ЭлементОтбора.Значение;
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.БольшеИлиРавно Тогда	
		
		Результат = ЗначениеПоля >= ЭлементОтбора.Значение;
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВИерархии Тогда 
		
		Результат = ВИерархии(ЗначениеПоля, ЭлементОтбора.Значение);
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСписке Тогда  		
		
		Результат = ЭлементОтбора.Значение.НайтиПоЗначению(ЗначениеПоля) <> Неопределено;
										
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ВСпискеПоИерархии Тогда
	
		ПромРезультат = Ложь;
		
		Для Каждого Элемент Из ЭлементОтбора.Значение Цикл
			
			Если ВИерархии(ЗначениеПоля, Элемент.Значение) Тогда
				ПромРезультат = Истина;
				Прервать;
			КонецЕсли;
		
		КонецЦикла;
		
		Результат = ПромРезультат;
		
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Интервал Тогда
	
		Результат = (ЗначениеПоля > ЭлементОтбора.ЗначениеС) и (ЗначениеПоля < ЭлементОтбора.ЗначениеПо);
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
	
		Результат = (ЗначениеПоля >= ЭлементОтбора.ЗначениеС) и (ЗначениеПоля <= ЭлементОтбора.ЗначениеПо);
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
	
		Результат = (ЗначениеПоля >= ЭлементОтбора.ЗначениеС) и (ЗначениеПоля < ЭлементОтбора.ЗначениеПо);
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
	
		Результат = (ЗначениеПоля > ЭлементОтбора.ЗначениеС) и (ЗначениеПоля <= ЭлементОтбора.ЗначениеПо);
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Меньше Тогда
	
		Результат = ЗначениеПоля < ЭлементОтбора.Значение;
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.МеньшеИлиРавно Тогда
	
		Результат = ЗначениеПоля <= ЭлементОтбора.Значение;
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВИерархии Тогда
	
		Результат = Не ВИерархии(ЗначениеПоля, ЭлементОтбора.Значение);
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСписке Тогда
	
		Результат = ЭлементОтбора.Значение.НайтиПоЗначению(ЗначениеПоля) = Неопределено;
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
	
		ПромРезультат = Ложь;
		
		Для Каждого Элемент Из ЭлементОтбора.Значение Цикл
		
			Если ВИерархии(ЗначениеПоля, Элемент.Значение) Тогда
				ПромРезультат = Истина;
				Прервать;
			КонецЕсли;
		
		КонецЦикла;
		
		Результат = Не ПромРезультат;
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеРавно Тогда
		
		Результат = ЗначениеПоля <> ЭлементОтбора.Значение;	
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.НеСодержит Тогда
		
		ШаблонСтроки = ЭлементОтбора.Значение;
		ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "\%"	, "[|||]");
		ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%"	, "");
		ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "[|||]", "%");
		Результат = Найти(Строка(ЗначениеПоля), ШаблонСтроки) = 0;
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Равно Тогда
		
		Если ТипЗнч(ЭлементОтбора.Значение) = Тип("Строка") Тогда
			Результат = (ЗначениеПоля = СокрЛП(ЭлементОтбора.Значение));
		Иначе
			Результат = (ЗначениеПоля = ЭлементОтбора.Значение);
		КонецЕсли; 			
	
	ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравнения.Содержит Тогда
	
		ШаблонСтроки = ЭлементОтбора.Значение;
		ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "\%"	, "[|||]");
		ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "%"	, "");
		ШаблонСтроки = СтрЗаменить(ШаблонСтроки, "[|||]", "%");
		Результат = Найти(Строка(ЗначениеПоля), ШаблонСтроки) <> 0;
	
	КонецЕсли;
	
	Возврат Результат;

КонецФункции // ПроверитьЗначениеПоВидуСравнения()

// Процедура обновляет представление по субконто.
// 
// Параметры:
//  СтрокаТаблицы  	    - ДанныеФормыЭлементКоллекции.
//  НовыйМассивСубконто - Массив.
//  
// Возвращаемое значение:
//   Строка.
// 
Процедура ОбновитьДанныеСубконтоПоМассивуОтчетПоПроводкам(ЭтаФорма, СтрокаТаблицы, НовыйМассивСубконто, ДтКт = "")

	МассивПути     = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(СтрокаТаблицы.ПутьКДанным, ".");
	ИмяСубконто    = МассивПути[0];
	ЭтоСложныйПуть = МассивПути.Количество() > 1;
	ПутьБезИмениСубконто = Прав(СтрокаТаблицы.ПутьКДанным, СтрДлина(СтрокаТаблицы.ПутьКДанным) - СтрДлина(ИмяСубконто));

	Если Найти(ИмяСубконто, "Субконто") <> 0 Тогда
		ВидСубконто = "Субконто";
	Иначе
		Возврат
	КонецЕсли;
		
	// Изменение кода. Начало. 23.04.2014{{
	Если ТипЗнч(НовыйМассивСубконто) = Тип("Неопределено") Тогда
		Возврат;	
	КонецЕсли;
	// Изменение кода. Конец. 23.04.2014}}
	
	ИндексСубконто = 0;
	Для Инд = 0 По НовыйМассивСубконто.Количество()-1 Цикл
		Если СтрокаТаблицы.ТипЗначения = НовыйМассивСубконто[Инд].ТипЗначения Тогда
			ИндексСубконто = Инд;
			СтрокаТаблицы.ПутьКДанным = Лев(СтрокаТаблицы.ПутьКДанным, 10) + Строка(ИндексСубконто +1); 
		КонецЕсли;
	КонецЦикла;
	
	Если НовыйМассивСубконто.Количество() < ИндексСубконто Тогда
		Возврат;	
	КонецЕсли;

	ЭлементМассива = НовыйМассивСубконто[ИндексСубконто];
	
	// Представление
	СтрокаТаблицы.Представление = ?(ДтКт = "", "", ДтКт + " ") 
									+ ЭлементМассива.Наименование 
									+ ПутьБезИмениСубконто;	
	
	// Тип значения
	СтрокаТаблицы.ТипЗначения = ЭлементМассива.ТипЗначения;
	Если ЭтоСложныйПуть Тогда
		Для Сч = 1 По МассивПути.Количество() - 1 Цикл
			ЗначениеСубконто = СтрокаТаблицы.ТипЗначения.ПривестиЗначение();
			МассивТипов = Новый Массив;
		    МассивТипов.Добавить(ТипЗнч(ЗначениеСубконто[МассивПути[Сч]]));
			СтрокаТаблицы.ТипЗначения = Новый ОписаниеТипов(МассивТипов);
		КонецЦикла;
	КонецЕсли;	
	
	Если СтрокаТаблицы.Использование И ЗначениеЗаполнено(СтрокаТаблицы.ПутьКДанным) Тогда
		НоваяСтрокаСубконто = ЭтаФорма.Корреспонденции[0].Субконто.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрокаСубконто, СтрокаТаблицы);		
	КонецЕсли;

КонецПроцедуры // ОбновитьПредставлениеСубконтоПоМассиву()

Процедура СинхронизироватьТаблицуКорСубконто(ТаблицаОбъекта, ТаблицаНаФорме)

	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип("Булево"));
	ОписаниеТиповБулево = Новый ОписаниеТипов(МассивТипов);
	
	ОписаниеТиповСтрока = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(200));

	ТаблицаОбъекта.Очистить();
	ТаблицаОбъекта.Колонки.Очистить();
	ТаблицаОбъекта.Колонки.Добавить("Использование", ОписаниеТиповБулево);
	ТаблицаОбъекта.Колонки.Добавить("Имя"		   , ОписаниеТиповСтрока);
	ТаблицаОбъекта.Колонки.Добавить("Представление", ОписаниеТиповСтрока);
	ТаблицаОбъекта.Колонки.Добавить("ВидСравнения");
	ТаблицаОбъекта.Колонки.Добавить("Значение");
	
	Для каждого СтрокаТаблицы Из ТаблицаНаФорме Цикл
		
		СтрокаСб = ТаблицаОбъекта.Добавить();	
		ЗаполнитьЗначенияСвойств(СтрокаСб, СтрокаТаблицы);
				
	КонецЦикла;

КонецПроцедуры // СинхронизироватьТаблицуКорСубконто()

Процедура СинхронизироватьТаблицаГруппировки(ТаблицаОбъекта, ТаблицаНаФорме)

	ТаблицаОбъекта = ДанныеФормыВЗначение(ТаблицаНаФорме, Тип("ТаблицаЗначений"));

КонецПроцедуры // СинхронизироватьТаблицаГруппировки()

#КонецОбласти

// BIT
Процедура ЗаполнитьПараметрыРасшифровкиОбороткиПоСчетуВалюта(ОтчетОбъект, Область, Выборка, СтруктураПараметров,Валюта) Экспорт

	// Если итоги по счету не анализируются, берем общий
	Если Выборка.Счет = NULL Тогда
		
		РасшифровываемыйСчет = ОтчетОбъект.Счет;
		РасшифровываемыйСчетПредставление = Строка(ОтчетОбъект.Счет);
		
	Иначе
		
		РасшифровываемыйСчет = Выборка.Счет;
		РасшифровываемыйСчетПредставление = Выборка.СчетПредставление;
		
	КонецЕсли;
	
	ЗаполнитьРасшифровкуДляСчетаВалюта(ОтчетОбъект, Область, Выборка, СтруктураПараметров, ОтчетОбъект.ИмяРегистраБухгалтерии,
		РасшифровываемыйСчет, РасшифровываемыйСчетПредставление, Валюта);
    
КонецПроцедуры // ЗаполнитьПараметрыРасшифровкиОбороткиПоСчету()

Процедура ЗаполнитьРасшифровкуДляСчетаВалюта(ОтчетОбъект, Область, Выборка, СтруктураПараметров, Знач ИмяРегистраБухгалтерии,
	Знач РасшифровываемыйСчет, Знач РасшифровываемыйСчетПредставление, Валюта) Экспорт
    
    // бит_DKravchenko 22.04.2009 Начало добавления... 
    // Получим префикс имени отчета расшифровки.
    Префикс = ?(Найти(ИмяРегистраБухгалтерии, "бит") = 0, "", "бит_");
    
    // Удалим из имени регистра бухгалтерии префикс "бит".
    ИмяРегистраБухгалтерии = СтрЗаменить(ИмяРегистраБухгалтерии, "бит", "");
    // ...бит_DKravchenko 22.04.2009 Конец добавления 
	
	// бит_DKravchenko 16.06.2009 Начало добавления... 
	// Если это расшифровка данных дополнительного регистра бухгалтерии, тогда
	Если Найти(ВРег(ИмяРегистраБухгалтерии), "ДОПОЛНИТЕЛЬНЫЙ") > 0 Тогда
		
		ИмяРегистраБухгалтерии = "_Управленческий";
		
	КонецЕсли;
	// ...бит_DKravchenko 16.06.2009 Конец добавления
	
	ПараметрыКарточкиСчета = Новый Соответствие;
    
	ПараметрыКарточкиСчета.Вставить("ИмяОбъекта", Префикс + "КарточкаСчета" + ИмяРегистраБухгалтерии);

	ПараметрыКарточкиСчета.Вставить("Счет", РасшифровываемыйСчет);

	ИмяГруппировки = Выборка.Группировка();
	
	Если Лев(ИмяГруппировки, 8) = "Субконто" Тогда

		// Надо в структуру доп ограничений поместить все группировки более высокого уровня
		ДополнительныеОтборы = СоздатьСтруктуруДопОграниченийДляОборотноСальдовойВедомостиПоСчету(ОтчетОбъект, Выборка, СтруктураПараметров.МассивГруппировок);
		
		СтрокаОтбора = ДополнительныеОтборы.Найти("Валюта");
		Если СтрокаОтбора <> Неопределено Тогда
			ДополнительныеОтборы.Найти("Валюта").Использование = Истина;
			ДополнительныеОтборы.Найти("Валюта").Значение 		= Валюта;
		КонецЕсли;
		
		
		ПараметрыКарточкиСчета.Вставить("ДополнительныеОтборы", ДополнительныеОтборы);
		
		СписокРасшифровки = Новый СписокЗначений;

		СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + РасшифровываемыйСчетПредставление);
		
	ИначеЕсли ИмяГруппировки = "Счет" Тогда

		СписокРасшифровки = Новый СписокЗначений;
        СписокРасшифровки.Добавить(ПараметрыКарточкиСчета, "Карточка счета " + РасшифровываемыйСчетПредставление);
		
	Иначе
		
		СписокРасшифровки = Неопределено;
		
	КонецЕсли;
		

	Область.Параметры.Расшифровка = СписокРасшифровки;	
	
КонецПроцедуры // ЗаполнитьРасшифровкуДляСчета()
//

// БИТ Avseenkov 20.05.2014 Доработка отчетов по периметру
Функция ПолучитьСоставПериметраКонсолидацииСУсловиями(ПериметрКонсолидации, ПериодНачало, ПериодКонец) Экспорт

	ТекстЗапроса = "ВЫБРАТЬ
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация,
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.Период,
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания
	               |ПОМЕСТИТЬ ВР_Итог
	               |ИЗ
	               |	РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(
	               |			&ПериодКонец,
	               |			ПериметрКонсолидации = &ПериметрКонсолидации
	               |				И НЕ Организация В
	               |						(ВЫБРАТЬ
	               |							бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	               |						ИЗ
	               |							РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&НачалоПериод, ПериметрКонсолидации = &ПериметрКонсолидации) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |						ГДЕ
	               |							(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &ПериодКонец
	               |								ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата))) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |ГДЕ
	               |	(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &НачалоПериод
	               |			ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата)
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания,
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация,
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.Период
	               |
	               |ОБЪЕДИНИТЬ ВСЕ
	               |
	               |ВЫБРАТЬ
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация,
	               |	&ПустаяДата,
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания
	               |ИЗ
	               |	РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(
	               |			&ПериодКонец,
	               |			ПериметрКонсолидации = &ПериметрКонсолидации
	               |				И НЕ Организация В
	               |						(ВЫБРАТЬ
	               |							бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	               |						ИЗ
	               |							РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&ПериодКонец, ПериметрКонсолидации = &ПериметрКонсолидации) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |						ГДЕ
	               |							(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &ПериодКонец
	               |								ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата))) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |ГДЕ
	               |	(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &НачалоПериод
	               |			ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата)
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация,
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ВР_Итог.Организация,
	               |	МИНИМУМ(ВР_Итог.Период) КАК Период,
	               |	МАКСИМУМ(ВР_Итог.ДатаОкончания) КАК ДатаОкончания,
	               |	&НачалоПериод,
	               |	&ПериодКонец
	               |ИЗ
	               |	ВР_Итог КАК ВР_Итог
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	ВР_Итог.Организация";

	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Запрос.УстановитьПараметр("НачалоПериод", 			ПериодНачало);
	Запрос.УстановитьПараметр("ПериодКонец", 	ПериодКонец);
	Запрос.УстановитьПараметр("ПустаяДата",				Дата('00010101'));
	Запрос.УстановитьПараметр("ПериметрКонсолидации", 	ПериметрКонсолидации);

	
	РезультатЗапроса = Запрос.Выполнить();

	Возврат РезультатЗапроса.Выгрузить();
	
КонецФункции

Функция ПолучитьСоставПериметраКонсолидацииСУсловиямиДляОсновногоПараметра(ПериметрКонсолидации, ПериодНачало, ПериодКонец) Экспорт

	ТекстЗапроса = "ВЫБРАТЬ
	               |	бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	               |ИЗ
	               |	РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(
	               |			&ПериодКонец,
	               |			ПериметрКонсолидации = &ПериметрКонсолидации
	               |				И НЕ Организация В
	               |						(ВЫБРАТЬ
	               |							бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	               |						ИЗ
	               |							РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&ПериодКонец, ПериметрКонсолидации = &ПериметрКонсолидации
	               |								И НЕ Организация В
	               |										(ВЫБРАТЬ
	               |											бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	               |										ИЗ
	               |											РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&НачалоПериод, ПериметрКонсолидации = &ПериметрКонсолидации) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |										ГДЕ
	               |											(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &НачалоПериод
	               |												ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата))) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |			
	               |						ОБЪЕДИНИТЬ ВСЕ
	               |			
	               |						ВЫБРАТЬ
	               |							бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	               |						ИЗ
	               |							РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&ПериодКонец, ПериметрКонсолидации = &ПериметрКонсолидации
	               |								И НЕ Организация В
	               |										(ВЫБРАТЬ
	               |											бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
	               |										ИЗ
	               |											РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&ПериодКонец, ПериметрКонсолидации = &ПериметрКонсолидации) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |										ГДЕ
	               |											(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &ПериодКонец
	               |												ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата))) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |						ГДЕ
	               |							НАЧАЛОПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &НачалоПериод)) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
	               |ГДЕ
	               |	(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &ПериодКонец
	               |			ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = &ПустаяДата)";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Запрос.УстановитьПараметр("НачалоПериод", 			ПериодНачало);
	Запрос.УстановитьПараметр("ПериодКонец", 	ПериодКонец);
	Запрос.УстановитьПараметр("ПустаяДата",				Дата('00010101'));
	Запрос.УстановитьПараметр("ПериметрКонсолидации", 	ПериметрКонсолидации);

	
	РезультатЗапроса = Запрос.Выполнить();

	Возврат РезультатЗапроса.Выгрузить();
	
КонецФункции

Функция ВернутьЧастьЗапросаПоВыборкеПолейОборотноСальдоваяВедомостьБИТ(МассивПоказателей, Знач ПоляДляВыборки = Истина, 
		Знач ИспользоватьАлиасыПолей = Ложь, Знач ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя = Ложь, ПолучатьРазвернутыйОстаток = Ложь,
        ОчищатьИтоги = Ложь,ДанныеПоОрганизации =неопределено,ТекстВложенный =  "") Экспорт
		
	СтрокаЗапроса = "";	
	РазвернутыйОстаток = ?(ПолучатьРазвернутыйОстаток, "Развернутый", "");
			
	Если ПоляДляВыборки Тогда
		
		Если ИспользоватьАлиасыПолей Тогда
			// Выборка с алиасами
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				СтрокаПрефикса = ?(ИспользоватьВКачествеПрефиксаАлиасаИмяПоказателя, ИмяПоказателя, ""); 
							
				
					Если ДанныеПоОрганизации <> Неопределено и ДанныеПоОрганизации.Период > ДанныеПоОрганизации.НачалоПериод Тогда 
					    ТекстНачало =  ",
						               |0 КАК" + СтрокаПрефикса + "НачальныйОстатокДт,
						               |0 КАК" + СтрокаПрефикса + "НачальныйОстатокКт";
									   
						ТекстКонец =   ""+ТекстВложенный + ИмяПоказателя + "ОборотДт КАК "                                     + СтрокаПрефикса + "КонечныйОстатокДт,
				                  	|	"+ТекстВложенный + ИмяПоказателя + "ОборотКт КАК "                                     + СтрокаПрефикса + "КонечныйОстатокКт";
			   
					Иначе 
						ТекстНачало = ",
						              |"+ТекстВложенный+ ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт КАК " + СтрокаПрефикса + "НачальныйОстатокДт,
					                  |"+ТекстВложенный+ ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт КАК " + СтрокаПрефикса + "НачальныйОстатокКт";
								   
						ТекстКонец =  ""+ТекстВложенный + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт КАК "  + СтрокаПрефикса + "КонечныйОстатокДт,
					               |   "+ТекстВложенный + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт КАК "  + СтрокаПрефикса + "КонечныйОстатокКт";
	   
 					КонецЕсли;	
					
					СтрокаЗапроса =  СтрокаЗапроса +  ТекстНачало +",
					
					|	" +ТекстВложенный+ ИмяПоказателя + "ОборотДт КАК "                                     + СтрокаПрефикса + "ОборотДт,
					|	" +ТекстВложенный+ ИмяПоказателя + "ОборотКт КАК "                                     + СтрокаПрефикса + "ОборотКт," + ТекстКонец;
				
				КонецЦикла;
			
		Иначе	
			// Выборка без алиасов
			Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
				
				
				
				
				
				
				СтрокаЗапроса =  СтрокаЗапроса + ",
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт,
				|	" + ИмяПоказателя + "ОборотДт,
				|	" + ИмяПоказателя + "ОборотКт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт,
				|	" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт";
								
			КонецЦикла;
            	

		КонецЕсли;	
		
	Иначе
		// Выборка для суммирования
		Для Каждого ИмяПоказателя Из МассивПоказателей Цикл
            
            // бит_DKravchenko 16.04.2009 Начало изменения...
            Если ОчищатьИтоги 
                И ИмяПоказателя = "СуммаСценарий" Тогда
                
                // Итоги по сценариям не суммируются,
                // т.к. они в разных валютах
                СтрокаЗапроса = СтрокаЗапроса + ",
    			|	0 КАК СуммаСценарийНачальный" + РазвернутыйОстаток + "ОстатокДт,
    			|	0 КАК СуммаСценарийНачальный" + РазвернутыйОстаток + "ОстатокКт,
    			|	0 КАК СуммаСценарийОборотДт,
    			|	0 КАК СуммаСценарийОборотКт,
    			|	0 КАК СуммаСценарийКонечный" + РазвернутыйОстаток + "ОстатокДт,
    			|	0 КАК СуммаСценарийКонечный" + РазвернутыйОстаток + "ОстатокКт";
                
            Иначе
    			СтрокаЗапроса = СтрокаЗапроса + ",
    			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокДт),
    			|	СУММА(" + ИмяПоказателя + "Начальный" + РазвернутыйОстаток + "ОстатокКт),
    			|	СУММА(" + ИмяПоказателя + "ОборотДт),
    			|	СУММА(" + ИмяПоказателя + "ОборотКт),
    			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокДт),
    			|	СУММА(" + ИмяПоказателя + "Конечный" + РазвернутыйОстаток + "ОстатокКт)";
            КонецЕсли;
            // ...бит_DKravchenko 16.04.2009 Конец изменения 
					
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтрокаЗапроса;
	
КонецФункции // ВернутьЧастьЗапросаПоВыборкеПолейОборотноСальдоваяВедомость()

Процедура ДополнитьСтрокуОграниченийПоРеквизитамДоп(СтрокаОграничения, Знач ИмяОграниченияПоРеквизиту, Знач ОграничениеПоРеквизиту,Знач ИмяОграниченияПоРеквизитуПараметра) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ОграничениеПоРеквизиту) Тогда
		Возврат;
	КонецЕсли;
	
	// бит_SNovikov изменение кода. Начало. 04.08.2010{{
	Если ТипЗнч(ОграничениеПоРеквизиту) = Тип("Массив") Тогда
		СтрокаНовогоОграничения = ИмяОграниченияПоРеквизиту + " В (&" + ИмяОграниченияПоРеквизитуПараметра + ") ";
	Иначе
		СтрокаНовогоОграничения = ИмяОграниченияПоРеквизиту + " = &" + ИмяОграниченияПоРеквизитуПараметра + " ";
	КонецЕсли;
	// бит_SNovikov изменение кода. Конец. 04.08.2010}}
		
	СтрокаОграничения = ОбъединитьОграничения(СтрокаОграничения, СтрокаНовогоОграничения);
    
КонецПроцедуры
// БИТ Avseenkov 20.05.2014 Доработка отчетов по периметру
