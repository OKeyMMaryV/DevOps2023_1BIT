////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ

#Область ПроцедурыИФункцииРаботыСФайлами



// Составляет полное имя файла из имени каталога и имени файла.
// 
// Параметры 
// 	ИмяКаталога        	 -	Строка                 	 Путь к каталогу файла на диске.
// 	ИмяФайла           	 -	Строка                 	 Имя файла, без имени каталога.                              
// Возвращаемое значение:
// 	Возврат ...        	 -	Строка                 	 Полное имя файла с учетом каталога.
// 
Функция бит_си_ПолучитьИмяФайла(ИмяКаталога, ИмяФайла) Экспорт
	Если Найти(ИмяКаталога,"/")>0 Тогда 
		Слэш="/";		
	Иначе 
		Слэш="\";
	КонецЕсли;
	Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		
		Возврат ""+ИмяКаталога + ?(Прав(ИмяКаталога, 1) = Слэш, "", Слэш) + ИмяФайла;	
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции // бит_си_ПолучитьИмяФайла()

// Процедура полное имя файла разбивает на путь в файлу и имя самого файла.
// 
// Параметры 
// 	ПолноеИмяФайла     	 -	Строка - Полное имя файла на диске.
// 	ИмяКаталога        	 -	Строка - Путь к каталогу файла на диске.
// 	ИмяФайла           	 -	Строка - Имя файла, без имени каталога.
// 
Процедура бит_си_ПолучитьКаталогИИмяФайла(Знач ПолноеИмяФайла, ИмяКаталога, ИмяФайла) Экспорт
	
	// Находим последний с конца "\" все что до него - это путь, после - имя.
	НомерПозиции = СтрДлина(ПолноеИмяФайла);
	Пока НомерПозиции <> 0 Цикл
		
		Если Сред(ПолноеИмяФайла, НомерПозиции, 1) = "\" Тогда
			
			ИмяКаталога = Сред(ПолноеИмяФайла, 1, НомерПозиции - 1);
			ИмяФайла = Сред(ПолноеИмяФайла, НомерПозиции + 1);
			Возврат;
			
		КонецЕсли;
		
		НомерПозиции = НомерПозиции - 1;
		
	КонецЦикла;
	
	// Так и не нашли слешей, значит все- это имя файла.
	ИмяФайла = ПолноеИмяФайла;
	ИмяКаталога = "";
	
КонецПроцедуры // бит_си_ПолучитьКаталогИИмяФайла()

// Процедура меняет расширение имени переданного файла (сам файл не меняется, меняется только строка).
// 
// Параметры 
// 	ИмяФайла           	 -	Строка - Полное имя файла на диске                                        
// 	НовоеРасширениеФайл	 -	Строка - Новое расширение файла.
//
// 
Процедура бит_си_УстановитьРасширениеФайла(ИмяФайла, Знач НовоеРасширениеФайла) Экспорт
	
	// К расширению точку добавляем
	Если Сред(НовоеРасширениеФайла, 1, 1) <> "." Тогда
		ЗначениеНовогоРасширения = "." + НовоеРасширениеФайла;	
	Иначе
		ЗначениеНовогоРасширения = НовоеРасширениеФайла;	
	КонецЕсли;
	// Если не находим точку в текущем имени файла, то просто приписываем к нему новое расширение с конца.
	ПозицияТочки = СтрДлина(ИмяФайла);
	Пока ПозицияТочки >= 1 Цикл
		
		Если Сред(ИмяФайла, ПозицияТочки, 1) = "." Тогда
						
			ИмяФайла = Сред(ИмяФайла, 1, ПозицияТочки - 1) + ЗначениеНовогоРасширения;
			Возврат; 
			
		КонецЕсли;
		
		ПозицияТочки = ПозицияТочки - 1;	
	КонецЦикла;
	
	// Не нашли точку в имени файла
	ИмяФайла = ИмяФайла + ЗначениеНовогоРасширения;	
	
КонецПроцедуры // бит_си_УстановитьРасширениеФайла()


#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РЕДАКТИРОВАНИЯ СТАТЕЙ СПРАВКИ.

#Область ПроцедурыИФункцииРедактированияСтатейСправки



// Получает менеджер по имени
// 
Функция ПолучитьМенеджер(ИмяМенеджера)  Экспорт



	#Если ТолстыйКлиентОбычноеПриложение ИЛИ Сервер ИЛИ ВнешнееСоединение Тогда
	Менеджеры = Новый Соответствие;
	Менеджеры.Вставить("Справочники"   			, Справочники);
	Менеджеры.Вставить("Документы"				, Документы);
	Менеджеры.Вставить("ПланыВидовХарактеристик", ПланыВидовХарактеристик);
	Менеджеры.Вставить("Перечисления"			, Перечисления);
	Менеджеры.Вставить("ПланыСчетов"			, ПланыСчетов);
	Менеджеры.Вставить("ПланыВидовРасчета"		, ПланыВидовРасчета);
	Менеджеры.Вставить("БизнесПроцессы"			, БизнесПроцессы);
	Менеджеры.Вставить("Задачи"					, Задачи);
	Менеджеры.Вставить("ПланыОбмена"			, ПланыОбмена);
	Менеджеры.Вставить("Обработки"				, Обработки);
	Менеджеры.Вставить("Отчеты"					, Отчеты);
	Менеджеры.Вставить("РегистрыСведений"		, РегистрыСведений);
	Менеджеры.Вставить("Справочник"   			, Справочники);
	Менеджеры.Вставить("Документ"				, Документы);
	Менеджеры.Вставить("ПланВидовХарактеристик"	, ПланыВидовХарактеристик);
	Менеджеры.Вставить("Перечисление"			, Перечисления);
	Менеджеры.Вставить("ПланСчетов"				, ПланыСчетов);
	Менеджеры.Вставить("ПланВидовРасчета"		, ПланыВидовРасчета);
	Менеджеры.Вставить("БизнесПроцесс"			, БизнесПроцессы);
	Менеджеры.Вставить("Задача"					, Задачи);
	Менеджеры.Вставить("ПланОбмена"				, ПланыОбмена);
	Менеджеры.Вставить("Обработка"				, Обработки);
	Менеджеры.Вставить("Отчет"					, Отчеты);
	Менеджеры.Вставить("РегистрСведений"		, РегистрыСведений);
    
	Возврат Менеджеры[ИмяМенеджера]
	#Иначе
	Возврат "";
	#КонецЕсли

КонецФункции // ПолучитьМенеджер()

// Помещает текст в поле текстового документ после положения курсора.
// 
// Параметры:
//  ПолеТекстовогоДокумента  - ЭлементУправления.ПолеТекстовогоДокумента.
//  ТекстДляВставки - Строка.
// 
Процедура ВставитьТекстПоКурсору(ПолеТекстовогоДокумента,ТекстДляВставки) Экспорт
	
	НачалоСтроки  = 0;
	НачалоКолонки = 0;
	КонецСтроки   = 0;
	КонецКолонки  = 0;
	
	// Определяем положение курсора
	ПолеТекстовогоДокумента.ПолучитьГраницыВыделения(НачалоСтроки,НачалоКолонки,КонецСтроки,КонецКолонки);
	
	// Заменяем строку
	СтрокаДляЗамены = ПолеТекстовогоДокумента.ПолучитьСтроку(КонецСтроки);
	СтрокаДляЗамены = Лев(СтрокаДляЗамены,КонецКолонки-1)+ТекстДляВставки+Сред(СтрокаДляЗамены,КонецКолонки);
	ПолеТекстовогоДокумента.ЗаменитьСтроку(КонецСтроки,СтрокаДляЗамены);
	
	// И выделяем вставленный фрагмент
	ПолеТекстовогоДокумента.УстановитьГраницыВыделения(НачалоСтроки,
													   КонецКолонки,
													   КонецСтроки,
													   КонецКолонки+СтрДлина(ТекстДляВставки));
КонецПроцедуры // бит_ВставитьТекстПоКурсору()

// Преобразовывает целое десятичное число в HEX-формат.
// 
// Параметры 
// 	ПарамЧисло         	 -	Число -Исходное десятичное число.
// 	ДляWeb             	 -	Булево - Истина - получить представление для Web-строки,
// 									 Ложь - Получить просто HEX-представление.
// Возвращаемое значение:
// 	Возврат ...        	 -	Строка                 	 HEX-представление десятичного числа.
// 
Функция HEXЧисло(ПарамЧисло, ДляWeb = Ложь)
	МодульЧисла=Число(ПарамЧисло);
	
	Если МодульЧисла=0 Тогда
		Возврат "0";
	КонецЕсли;
	флОтрицательное = ?(МодульЧисла < 0, 1, 0);
	МодульЧисла = ?(флОтрицательное = 1, -1 * МодульЧисла, МодульЧисла);

	МодульЧислаЦел=Цел(МодульЧисла);

	ОснованиеРезультата=16;
	
	Пока МодульЧислаЦел > 0 Цикл
		ВремЧисло = МодульЧислаЦел % ОснованиеРезультата;
		ВремЧисло = ?(ВремЧисло = 10, "A", ?(ВремЧисло = 11, "B", ?(ВремЧисло = 12, "C", ?(ВремЧисло = 13, "D", ?(ВремЧисло = 14, "E", ?(ВремЧисло = 15, "F", Строка(ВремЧисло)))))));
		РезЦел = ВремЧисло + РезЦел;
		МодульЧислаЦел = Цел(МодульЧислаЦел / ОснованиеРезультата);
	КонецЦикла;
	Если ДляWeb Тогда
		ВремРез = "";
		Для й = 1 По СтрДлина(РезЦел) / 2 Цикл
			ВремРез = ВремРез + "%" + Сред(РезЦел, й * 2 - 1, 2);
		КонецЦикла;
		РезЦел = ВремРез;
	КонецЕсли;
	Возврат РезЦел;
КонецФункции // HEXЧисло()

// Преобразовывает web-строку в обычную. Преобразует коды символов в исходной строке в символы.
// 
// Параметры 
// 	Строка             	 -	Строка - Исходная строка.
// Возвращаемое значение:
// 	Возврат ...        	 -	Строка - Преобразованная строка.
// 
Функция ПодготовитьСтроку(Строка) Экспорт
	
	Стр = Строка;
	
	ТабЗамены = Новый Соответствие();
	Для й = 1 По 64 Цикл
		ТабЗамены.Вставить(HEXЧисло(й + 53391 + ?(й <= 48, 0, 192), Истина), Символ(1039 + й));
		ТабЗамены.Вставить("&#" + Формат(1039 + й, "ЧРГ=; ЧГ=") + ";", Символ(1039 + й));
	КонецЦикла;
	
	ТабЗамены.Вставить("%D0%81","е");
	ТабЗамены.Вставить("%D1%91","е");
	
	ТабЗамены.Вставить("&#1025;","е");
	ТабЗамены.Вставить("&#1105;","е");
	
	ТабЗамены.Вставить("%20"," ");
	ТабЗамены.Вставить("""","""""");
	
	Для Каждого ТекЗамена Из ТабЗамены Цикл
		Стр = СтрЗаменить(Стр, ТекЗамена.Ключ, ТекЗамена.Значение);
	КонецЦикла;
	
	Возврат Стр;
	
КонецФункции // ПодготовитьСтроку()

#Если ТолстыйКлиентОбычноеПриложение Тогда
// Получает HTML-текст из файла, выполняя преобразование UNICODE строк
// и относительных путей к изображениям в абсолютные.
// 
// Параметры 
// 	ТекстСтатьи			 -	Строка - Преоразованный HTML-текст файла.
// Возвращаемое значение:
// 	Возврат ...        	 -	Булево - Истина - Текст получен; Ложь - в противном случае.
// 
Функция ПолучитьТекстСтатьиИзФайла(ТекстСтатьи) Экспорт
	ДиалогОткрытияФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ДиалогОткрытияФайла.ПолноеИмяФайла = "";
	Фильтр = "Web-страница (*.htm,*.html)|*.htm;*.html";
	ДиалогОткрытияФайла.Фильтр = Фильтр;
	ДиалогОткрытияФайла.МножественныйВыбор = Ложь;
	ДиалогОткрытияФайла.Заголовок = "Выберите файл";
	Если НЕ ДиалогОткрытияФайла.Выбрать() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ВремДок = Новый ТекстовыйДокумент();
	ВремДок.Прочитать(ДиалогОткрытияФайла.ПолноеИмяФайла);
	ТекстСтатьи = ВремДок.ПолучитьТекст();
	
	сзСсылки = Новый СписокЗначений;
	src_Открыт = Ложь;
	ВсегоСтрок = СтрЧислоСтрок(ТекстСтатьи);
	
	IMG_Начало = 0;
	IMG_Продолжение = Ложь;
	Для СчСтрок = 1 По ВсегоСтрок Цикл
		ТекСтрока = СтрПолучитьСтроку(ТекстСтатьи, СчСтрок);
		ВсегоСимволов = СтрДлина(ТекСтрока);
		
		IMG_Начало = ?(IMG_Начало = 0, Найти(ВРег(ТекСтрока),"<IMG"), IMG_Начало);
		
		Если IMG_Начало <> 0 Тогда
			IMG_Начало = IMG_Начало + 4;
			IMG_Путь = "";
			
			Для СчСимвол = ?(IMG_Продолжение, 1, IMG_Начало) По ВсегоСимволов Цикл
				ТекСимвол = Сред(ТекСтрока,СчСимвол,1);
				
				Если ТекСимвол = Символ(34) И src_Открыт Тогда
					ИмяДляЗамены = бит_си_ОбщегоНазначения.ПолучитьПолныйПутьИзОтносительного(ПодготовитьСтроку(IMG_Путь), ДиалогОткрытияФайла.ПолноеИмяФайла);
					
					СчСимвол = СчСимвол - (СтрДлина(IMG_Путь) - СтрДлина(ИмяДляЗамены));
					ТекСтрока = СтрЗаменить(ТекСтрока,IMG_Путь, ИмяДляЗамены);
					
					сзСсылки.Добавить(IMG_Путь, ИмяДляЗамены);
					
					IMG_Путь = "";
					IMG_Начало = 0;
					src_Открыт = Ложь;
				КонецЕсли;
				
				Если НРег(Сред(ТекСтрока,СчСимвол,5)) = ("src=" + Символ(34)) Тогда
					СчСимвол = СчСимвол + 5;
					src_Открыт = Истина;
				КонецЕсли;
				
				Если src_Открыт Тогда
					IMG_Путь = IMG_Путь + Сред(ТекСтрока,СчСимвол,1);
				КонецЕсли;
			КонецЦикла; // По строке, символы
			IMG_Продолжение = НЕ (IMG_Начало = 0);
		КонецЕсли; // Встречается тег
	КонецЦикла;	// по тексту, строки
	
	Для Каждого ТекСсылка Из сзСсылки Цикл
		ТекстСтатьи = СтрЗаменить(ТекстСтатьи,ТекСсылка.Значение,ТекСсылка.Представление);
	КонецЦикла;
	Возврат Истина;
КонецФункции // ПолучитьТекстСтатьиИзФайла()
#КонецЕсли

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАГРУЗКИ СТАТЕЙ СПРАВКИ.

#Область ПроцедурыИФункцииЗагрузкиСтатейСправки

#Если НЕ ВебКлиент Тогда
// Функция определяет возможность чтения очередных данных из объекта ЧтениеXML.
// 
// Параметры:
//  ЧтениеXML - объект чтения XML.
// 
// Возвращаемое значение:
//  Булево - Истина, если возможно чтение очередных данных или Ложь - в противном случае.
// 
Функция ВозможностьЧтенияДанных(ЧтениеXML)
	
	// Получаем тип данных XML, который может быть считан в данный момент.
	ТипXML = ПолучитьXMLТип(ЧтениеXML);
	Если ТипXML = Неопределено Тогда		
		Возврат Ложь;		
	ИначеЕсли ТипXML.ИмяТипа = "CatalogObject.бит_си_Статьи" Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат ВозможностьЧтенияXML(ЧтениеXML);
	
КонецФункции // ВозможностьЧтенияДанных()
#КонецЕсли

// Возвращает полный путь к файлу справочной информации для загрузки
// относительно каталога шаблонов конфигурации.
// 
// Параметры 
// 	ПутьКФайлу		   	 -	Строка - Относительный путь к файлу справочной информации.
// 	МассивНенайденых   	 -	Массив - В параметре возвращается массив имен файлов,
// 								 	 которые не удалось найти в каталогах шаблонов.
// 
// Возвращаемое значение:
// 	Возврат         	 -	Булево - Истина - Массив каталогов получен;
// 									 Ложь - не удалось получить массив каталогов.
// 
Функция ПолучитьФайлСправкиИзКаталогаШаблона(Знач ПутьКФайлу, МассивНенайденых = Неопределено) Экспорт
	#Если ТолстыйКлиентОбычноеПриложение Тогда
	Попытка
		ВремФайл = Новый Файл(ПутьКФайлу);
	Исключение
		Возврат "";
	КонецПопытки;
	Если ВремФайл.Существует() И ВремФайл.ЭтоФайл() Тогда
		Возврат ПутьКФайлу;
	КонецЕсли;
	
	// Изменение кода. Начало. 22.10.2013{{
	ПутьКФайлу = СтрЗаменить(ПутьКФайлу, "##Версия##", бит_ОбщегоНазначения.МетаданныеВерсия());
	// Изменение кода. Конец. 22.10.2013}}
	КаталогиШаблонов = Новый Массив;
	Если НЕ бит_си_ОбщегоНазначения.ПолучитьКаталогиШаблоновКонфигураций(КаталогиШаблонов) Тогда
		Возврат "";
	КонецЕсли;
	Для Каждого ТекКаталог Из КаталогиШаблонов Цикл
		ВремПутьКФайлу = бит_си_ОбщегоНазначения.ПолучитьПолныйПутьИзОтносительного(ПутьКФайлу, ТекКаталог);
		Попытка
			ВремФайл = Новый Файл(ВремПутьКФайлу);
		Исключение
			Продолжить;
		КонецПопытки;
		Если ВремФайл.Существует() И ВремФайл.ЭтоФайл() Тогда
			Возврат ВремПутьКФайлу;
		КонецЕсли;
	КонецЦикла;
	Если НЕ ТипЗнч(МассивНенайденых) = Тип("Массив") Тогда
		МассивНенайденых = Новый Массив();
	КонецЕсли;
	
	ИмяКаталога = "";
	ИмяФайла = "";
	бит_си_ИсточникСправочникСтатьи.бит_си_ПолучитьКаталогИИмяФайла(ПутьКФайлу, ИмяКаталога, ИмяФайла);
	МассивНенайденых.Добавить(ИмяФайла);
	#КонецЕсли
	Возврат "";
КонецФункции // ПолучитьФайлСправкиИзКаталогаШаблона()

// Загружает справочную информацию из текстового макета (xml).
// 
// Параметры 
// 	ИмяМакета          	 -	Строка - Имя макета в конфигурации.
// 	МассивНенайденых   	 -	Массив - В параметре возвращается массив имен файлов,
// 													 на которые обнаружены ссылки в макетах,
// 													 и которые не удалось найти в каталогах шаблонов.
// 
Процедура ЗагрузитьСправочнуюИнформациюИзМакета(ИмяМакета, МассивНенайденых = Неопределено) Экспорт
	#Если ТолстыйКлиентОбычноеПриложение Тогда
	ТекстДляЗагрузки = ПолучитьОбщийМакет(ИмяМакета).ПолучитьТекст();
	Если СокрЛП(ТекстДляЗагрузки)="" Тогда
		Возврат;
	КонецЕсли;
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстДляЗагрузки);
	ЧтениеXML.ПерейтиКСодержимому();
	ВремФайл = ЧтениеXML.ЗначениеАтрибута("Файл");
	Если НЕ ВремФайл = Неопределено Тогда
		ВремФайл = бит_си_ИсточникСправочникСтатьи.ПолучитьФайлСправкиИзКаталогаШаблона(ВремФайл, МассивНенайденых);
		Если НЕ ВремФайл = "" Тогда
			бит_си_ИсточникСправочникСтатьи.ЗагрузитьСправочнуюИнформациюИзФайла(ВремФайл);
		КонецЕсли;
	КонецЕсли;
	ЧтениеXML.Прочитать();
	
	Попытка
		
		Пока ВозможностьЧтенияДанных(ЧтениеXML) Цикл
			
			// Читаем очередное значение
			Данные = ПрочитатьXML(ЧтениеXML);
			
			Если Данные = Неопределено Тогда
				
				Продолжить;
				
			КонецЕсли;
			
            Данные.ОбменДанными.Загрузка = Истина;           

			Данные.Записать();		
			
		КонецЦикла;
		
		ЧтениеXML.Закрыть();
		
	Исключение
		
		ТекстОшибки = ОписаниеОшибки();
		
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстОшибки);
		
		ВызватьИсключение (ТекстОшибки);
		
	КонецПопытки;
	#КонецЕсли
	
КонецПроцедуры // ЗагрузитьСправочнуюИнформациюИзМакета()

// Загружает справочную информацию из файла в формате xml или из архивированного (zip) файла формата xml.
// 
// Параметры 
// 	ФайлДляЗагрузки -	Строка - Путь к файлу, если не задан, то вызывается диалог выбора файла.
// 
Процедура ЗагрузитьСправочнуюИнформациюИзФайла(Знач ФайлДляЗагрузки = Неопределено) Экспорт
	Если ФайлДляЗагрузки = Неопределено Тогда
	#Если Клиент И НЕ ВебКлиент Тогда
		ДиалогОткрытияФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
		ДиалогОткрытияФайла.Фильтр = "Файлы разделов справки(*.xml)|*.xml|Упакованные файлы разделов справки (*.zip)|*.zip";
		ДиалогОткрытияФайла.Расширение = "zip";
		ДиалогОткрытияФайла.МножественныйВыбор = ложь;
			
		Если НЕ ДиалогОткрытияФайла.Выбрать() Тогда
			Возврат;
		КонецЕсли;
		
		ВремФайл = ДиалогОткрытияФайла.ПолноеИмяФайла;
	#Иначе
		Возврат;
	#КонецЕсли
	Иначе
		ВремФайл = ФайлДляЗагрузки;
	КонецЕсли;

	#Если НЕ ВебКлиент Тогда
	Если Прав(ВремФайл,4)=".zip" Тогда
		КаталогДляРаспаковки = КаталогВременныхФайлов();
	
		Попытка
			
			Архиватор = Новый ЧтениеZipФайла(ВремФайл);
		
			Если Архиватор.Элементы.Количество() > 0 Тогда
			
				Архиватор.Извлечь(Архиватор.Элементы[0], КаталогДляРаспаковки, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
				ВремФайл = КаталогДляРаспаковки + ?(Прав(КаталогДляРаспаковки, 1) = "\", "", "\") + Архиватор.Элементы[0].Имя;
			
			Иначе
			
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение("Файлы данных в архиве не найдены");
				Возврат;	
			
			КонецЕсли;

			Архиватор.Закрыть();
	
		Исключение
		
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение("Ошибка распаковки файла разделов справки: "+ОписаниеОшибки());
			Возврат;				
		КонецПопытки;
	
	КонецЕсли;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ВремФайл);
	ЧтениеXML.ПерейтиКСодержимому();
	ЧтениеXML.Прочитать();
	
	Попытка
		
		Пока ВозможностьЧтенияДанных(ЧтениеXML) Цикл
			
			// Читаем очередное значение
			Данные = ПрочитатьXML(ЧтениеXML);
			
			Если Данные = Неопределено Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			Данные.ОбменДанными.Загрузка = Истина;           

			Данные.Записать();		
			
		КонецЦикла;
		
		ЧтениеXML.Закрыть();
		
	Исключение
		
		ТекстОшибки = ОписаниеОшибки();
		
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстОшибки);
		
		ВызватьИсключение (ТекстОшибки);
		
	КонецПопытки;
	#КонецЕсли
	
КонецПроцедуры  // ЗагрузитьСправочнуюИнформациюИзФайла()

// Очищает справочник статей
// 
Процедура ОчиститьСправочнуюИнформацию() Экспорт
	#Если ТолстыйКлиентОбычноеПриложение Или Сервер Тогда
	Запрос = Новый Запрос("ВЫБРАТЬ
						  |	Статьи.Ссылка
						  |ИЗ
						  |	Справочник.бит_си_Статьи КАК Статьи");
	ТабРазделов = Запрос.Выполнить().Выгрузить();
	Для Каждого Раздел Из ТабРазделов  Цикл
		РазделОбъект = Раздел.Ссылка.ПолучитьОбъект();
		Если РазделОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		РазделОбъект.Удалить();
	КонецЦикла;
	#КонецЕсли
КонецПроцедуры // ОчиститьСправочнуюИнформацию()

#КонецОбласти
