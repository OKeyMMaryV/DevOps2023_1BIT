
#Область СлужебныйПрограммныйИнтерфейс

#Область РаботаСПолемТаблицапараметров

// Процедура позволяет получить запросы источника данных либо способа компоновки источников данных.
// Рекурсивный вызов.
// 
// Параметры:
//  Источник  - СправочникСсылка.бит_ИсточникиДанных,СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных
//  МассивЗапросов  - Массив.
// 
Процедура ПолучитьЗапросыИсточников(Источник,МассивЗапросов) Экспорт
	
	Если ТипЗнч(Источник) = Тип("СправочникСсылка.бит_ИсточникиДанных") 
		 ИЛИ ТипЗнч(Источник) = Тип("СправочникОбъект.бит_ИсточникиДанных")  Тогда
		
		Если МассивЗапросов.Найти(Источник.ЗапросБД) = Неопределено Тогда
			
			МассивЗапросов.Добавить(Источник.ЗапросБД);
			
		КонецЕсли; 
		
	ИначеЕсли ТипЗнч(Источник) = Тип("СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных") 
		      ИЛИ ТипЗнч(Источник) = Тип("СправочникОбъект.бит_СпособыКомпоновкиИсточниковДанных") Тогда
		
		Для каждого СтрокаТаблицы Из Источник.ИсточникиДанных Цикл
			
			ПолучитьЗапросыИсточников(СтрокаТаблицы.ИсточникДанных,МассивЗапросов);
			
		КонецЦикла; 
		
	КонецЕсли; 
	
КонецПроцедуры // ПолучитьЗапросыКомпоновки()

// Процедура обновляет таблицу параметров для источника или способа компоновки источников.
// 
// Параметры:
//  Источник          - СправочникСсылка.бит_ИсточникиДанных, СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ТаблицаПараметры  - ТаблицаЗначений.
//  Очищать           - Булево.
//  ПулСоединений     - Неопределено.
// 
Процедура ОбновитьТаблицуПараметров(Источник, ТаблицаПараметры, Очищать = Ложь, ПулСоединений = Неопределено) Экспорт
	
	МассивЗапросов = Новый Массив;
	ПолучитьЗапросыИсточников(Источник,МассивЗапросов);
	
	Исключения  = КонструкторПредопределенныхПараметров();
	// Исключим "технологические параметры"
	ДополнитьСписокИсключений(Источник, Исключения);
	
	СписокПараметров = Справочники.бит_ИсточникиДанных.ПолучитьПараметрыЗапросов(МассивЗапросов, Исключения, ПулСоединений);
		
	Справочники.бит_ИсточникиДанных.ОбновитьТаблицуПараметров(ТаблицаПараметры, СписокПараметров, Очищать);
	
	Если ТипЗнч(Источник) = Тип("СправочникСсылка.бит_ИсточникиДанных") Тогда
	
		 // Заполнение параметров по-умолчанию
		 
		 СохраненнаяНастройка = Источник.НастройкиПостроителя.Получить();
		 Если ТипЗнч(СохраненнаяНастройка) = Тип("Структура") Тогда
			 
			 Если СохраненнаяНастройка.Свойство("ПараметрыПостроителя") Тогда
				 
				  Для каждого СтрокаПараметры Из ТаблицаПараметры Цикл
					  
				  	  Если СохраненнаяНастройка.ПараметрыПостроителя.Свойство(СтрокаПараметры.ИмяПараметра) Тогда
					  
					  	   СтрокаПараметры.ЗначениеПараметра = СохраненнаяНастройка.ПараметрыПостроителя[СтрокаПараметры.ИмяПараметра];
					  
					  КонецЕсли; 
				  
				  КонецЦикла; // ТаблицаПараметры
				 
			 КонецЕсли; 
			 
		 КонецЕсли; 
	
	КонецЕсли;   // Это источник данных
	
КонецПроцедуры // ОбновитьТаблицуПараметров()

// Процедура заполняет таблицу параметров значениями из источников.
// 
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ТаблицаПараметры  - ТаблицаЗначений.
// 
Процедура ЗаполнитьТаблицуПараметров(СпособКомпоновки, ТаблицаПараметры) Экспорт

		
	Для каждого СтрокаТчИсточники Из СпособКомпоновки.ИсточникиДанных Цикл
		
		ИсточникДанных = СтрокаТчИсточники.ИсточникДанных;
		ИсточникОбъект = ИсточникДанных.ПолучитьОбъект();
		
		Если ИсточникОбъект <> Неопределено Тогда
			
			НастройкиИсточника = ИсточникОбъект.ПолучитьНастройкиИсточника();
			Если НастройкиИсточника = Неопределено Тогда
				Продолжить;				
			КонецЕсли;
			СтруктураЗначПарам = НастройкиИсточника.ПараметрыПостроителя;
			
			Для каждого СтрокаТаблицы Из ТаблицаПараметры Цикл
				
				Если Не СтруктураЗначПарам.Свойство(СтрокаТаблицы.ИмяПараметра) 
					ИЛИ ЗначениеЗаполнено(СтрокаТаблицы.ЗначениеПараметра) Тогда
					Продолжить;
				КонецЕсли; 					
				
				// Запись значения в таблицу
				СтрокаТаблицы.ЗначениеПараметра = СтруктураЗначПарам[СтрокаТаблицы.ИмяПараметра];		
				
			КонецЦикла; // По таблице параметров
			
		КонецЕсли;		
	
	КонецЦикла; // По источникам данных
	 
КонецПроцедуры // ЗаполнитьТаблицуПараметров()

// Процедура обрабатывает изменение вида параметра в строке таблицы параметров.
// 
// Параметры:
//  ТекущаяСтрока  - СтрокаТаблицыЗначений.
//  ПредыдущийВидПараметра  - ПеречислениеСсылка.бит_ВидыПараметровЗапроса.
// 
Процедура ИзменениеВидаПараметра(ТекущаяСтрока, ПредыдущийВидПараметра) Экспорт

	Если ТекущаяСтрока = Неопределено Тогда	
		Возврат;	
	КонецЕсли; 
	
	Если ТекущаяСтрока.ВидПараметра = Перечисления.бит_ВидыПараметровЗапроса.Выражение Тогда
		
		ТекущаяСтрока.ЗначениеПараметра = Строка(ТекущаяСтрока.ЗначениеПараметра);
		
	ИначеЕсли ТекущаяСтрока.ВидПараметра = Перечисления.бит_ВидыПараметровЗапроса.Список Тогда	
		
		Список = Новый СписокЗначений();
		
		Если ПредыдущийВидПараметра = Перечисления.бит_ВидыПараметровЗапроса.Значение Тогда
			
			// Создадим список
			ТекЗначение = ТекущаяСтрока.ЗначениеПараметра; 			  			
			Если ЗначениеЗаполнено(ТекЗначение) Тогда 				
				Список.Добавить(ТекЗначение);  				
			КонецЕсли; 
			ТекущаяСтрока.ЗначениеПараметра = Список;
			
		ИначеЕсли ПредыдущийВидПараметра = Перечисления.бит_ВидыПараметровЗапроса.Выражение Тогда
			
			ТекущаяСтрока.ЗначениеПараметра = Список;
						
		КонецЕсли; 
		
		// Ограничим типы значений для списка
		Список.ТипЗначения = ТекущаяСтрока.ДоступныеТипы;
		
	Иначе
		
		Если ПредыдущийВидПараметра = Перечисления.бит_ВидыПараметровЗапроса.Список Тогда
			
			// Уничтожим список
			Если ТипЗнч(ТекущаяСтрока.ЗначениеПараметра) = Тип("СписокЗначений") Тогда
				
				Список = ТекущаяСтрока.ЗначениеПараметра;
				Если Список.Количество() > 0 Тогда
					ТекущаяСтрока.ЗначениеПараметра = Список[0].Значение;
				Иначе	
					ТекущаяСтрока.ЗначениеПараметра = ТекущаяСтрока.ДоступныеТипы.ПривестиЗначение(ТекущаяСтрока.ЗначениеПараметра);
				КонецЕсли; 
				
			КонецЕсли; 			
			
		ИначеЕсли ПредыдущийВидПараметра = Перечисления.бит_ВидыПараметровЗапроса.Выражение Тогда
			
			ТекущаяСтрока.ЗначениеПараметра = ТекущаяСтрока.ДоступныеТипы.ПривестиЗначение(ТекущаяСтрока.ЗначениеПараметра);
			
		КонецЕсли; 
		
	КонецЕсли; 
	

КонецПроцедуры // ИзменениеВидаПараметра()

#КонецОбласти

#Область РаботаСПолемТаблицаотбор

// Функция-конструктор таблицы, используемой для хранения отборов.
// 
// Возвращаемое значение:
//  ТабОтбор - ТаблицаЗначений.
// 
Функция ИнициализироватьТаблицуОтбор() Экспорт

	ТабОтбор = Новый ТаблицаЗначений;
	ТабОтбор.Колонки.Добавить("Использование", Новый ОписаниеТипов("Булево"));
	ТабОтбор.Колонки.Добавить("ПутьКДанным", Новый ОписаниеТипов("Строка"));
	ТабОтбор.Колонки.Добавить("ВидСравнения");
	ТабОтбор.Колонки.Добавить("Значение");
	ТабОтбор.Колонки.Добавить("ЗначениеС");
	ТабОтбор.Колонки.Добавить("ЗначениеПО");
	ТабОтбор.Колонки.Добавить("ТипЗначения");
	ТабОтбор.Колонки.Добавить("ЭтоПериодичность", Новый ОписаниеТипов("Булево"));

	Возврат ТабОтбор;
	
КонецФункции // ИнициализироватьТаблицуОтбор()

// Функция возвращает список доступных видов сравнения в зависимости от типа значения.
// 
// Параметры:
//  ИсточникТипов - ОписаниеТипов ИЛИ ДанныеФормыЭлементКоллекции.
// 
Функция СписокВыбораВидаСравнения(ИсточникТипов) Экспорт
	
	флЕстьПримитивные = Ложь;
	флЕстьСтрока      = Ложь;
	флЕстьСсылочные   = Ложь;
	// Добавление кода. Начало. 12.08.2014{{
	флЕстьИерархия    = Ложь;
	// Добавление кода. Конец. 12.08.2014}}
	
	
	// Определение типов, возможных в данной строке.
	МассивПримитивные = Новый Массив;
	МассивПримитивные.Добавить(Тип("Строка"));
	МассивПримитивные.Добавить(Тип("Число"));
	МассивПримитивные.Добавить(Тип("Дата"));
	МассивПримитивные.Добавить(Тип("Булево"));
	МассивПримитивные.Добавить(Тип("ХранилищеЗначения"));
	
	ОписаниеПримитивные = Новый ОписаниеТипов(МассивПримитивные);
	
	Если ТипЗнч(ИсточникТипов) = Тип("ОписаниеТипов") Тогда
		МассивТипов = ИсточникТипов.Типы();
		флТолькоБулево = ?(ИсточникТипов = Новый ОписаниеТипов("Булево"), Истина, Ложь);
	ИначеЕсли НЕ ИсточникТипов = Неопределено Тогда
		МассивТипов = ИсточникТипов.ТипЗначения.Типы();
	    флТолькоБулево = ?(ИсточникТипов.ТипЗначения = Новый ОписаниеТипов("Булево"), Истина, Ложь);		
	Иначе
		МассивТипов = Новый Массив;
	КонецЕсли;
	
	Для каждого ТекТип Из МассивТипов Цикл
		
		Если ТекТип = Тип("Строка") Тогда 			
			флЕстьСтрока = Истина; 			
		КонецЕсли; 
		
		Если ОписаниеПримитивные.СодержитТип(ТекТип) Тогда			
			флЕстьПримитивные = Истина;  			
		Иначе	                         			
			флЕстьСсылочные   = Истина;
			// Добавление кода. Начало. 12.08.2014{{
			Попытка 		
				ОбъектМета = Метаданные.НайтиПоТипу(ТекТип);
				Если Метаданные.ПланыСчетов.Содержит(ОбъектМета) ИЛИ ОбъектМета.Иерархический Тогда
				 	флЕстьИерархия = Истина;
				КонецЕсли;
			Исключение 			
			КонецПопытки;
			// Добавление кода. Конец. 12.08.2014}}
		КонецЕсли; 
		
	КонецЦикла; 
	
	// Формирование списка доступных видов сравнения.
	СписокВидов = Новый СписокЗначений;
	СписокВидов.Добавить(ВидСравнения.Равно);
	СписокВидов.Добавить(ВидСравнения.НеРавно);
	
	Если НЕ флТолькоБулево Тогда
		
		СписокВидов.Добавить(ВидСравнения.ВСписке);
		СписокВидов.Добавить(ВидСравнения.НеВСписке);
		
	КонецЕсли; 
	
	// Изменение кода. Начало. 12.08.2014{{
	// Если флЕстьСсылочные Тогда
	Если флЕстьИерархия Тогда
	// Изменение кода. Конец. 12.08.2014}}	
		СписокВидов.Добавить(ВидСравнения.ВИерархии);
		СписокВидов.Добавить(ВидСравнения.НеВИерархии);
		СписокВидов.Добавить(ВидСравнения.ВСпискеПоИерархии);
		СписокВидов.Добавить(ВидСравнения.НеВСпискеПоИерархии);
		
	КонецЕсли; 	
	
	Если флЕстьПримитивные И НЕ флТолькоБулево Тогда
		
		СписокВидов.Добавить(ВидСравнения.Больше);
		СписокВидов.Добавить(ВидСравнения.БольшеИлиРавно);
		СписокВидов.Добавить(ВидСравнения.Интервал);
		СписокВидов.Добавить(ВидСравнения.ИнтервалВключаяГраницы);
		СписокВидов.Добавить(ВидСравнения.ИнтервалВключаяНачало);
		СписокВидов.Добавить(ВидСравнения.ИнтервалВключаяОкончание);
		СписокВидов.Добавить(ВидСравнения.Меньше);
		СписокВидов.Добавить(ВидСравнения.МеньшеИлиРавно);
		
	КонецЕсли; 
	
	Если флЕстьСтрока Тогда
		
		СписокВидов.Добавить(ВидСравнения.Содержит);
		СписокВидов.Добавить(ВидСравнения.НеСодержит);
		
	КонецЕсли; 
	
	Возврат СписокВидов;
	
КонецФункции // СписокВыбораВидаСравнения()

// Процедура обрабатывает изменение вида сравнения в таблице отбор.
// 
// Параметры:
//  ИдСтроки         - Строка.
//  ПредВидСравнения - ВидСравнения.
// 
Процедура ИзменениеВидаСравнения(ТекущаяСтрока,ПредВидСравнения) Экспорт
	
	Если НЕ ТекущаяСтрока = Неопределено Тогда
		
		ТекВидСравнения    = ТекущаяСтрока.ВидСравнения;
		флТекВидДляСписка  = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(ТекущаяСтрока.ВидСравнения);
		флПредВидДляСписка = бит_ОбщегоНазначения.ЭтоВидСравненияДляСписка(ПредВидСравнения);
		
		Если флТекВидДляСписка Тогда
			
			Если НЕ флПредВидДляСписка Тогда
				
				Список = Новый СписокЗначений;				
				
				// Создадим список
				ТекЗначение = ТекущаяСтрока.Значение; 			  			
				Если ЗначениеЗаполнено(ТекЗначение) Тогда 				
					Список.Добавить(ТекЗначение);  				
				КонецЕсли; 
				ТекущаяСтрока.Значение = Список;
				
				// Ограничим типы значений для списка
				Список.ТипЗначения = ТекущаяСтрока.ТипЗначения;
				
			КонецЕсли; // НЕ флПредВидДляСписка
			
		Иначе	
			
			Если флПредВидДляСписка Тогда
				
				// Уничтожим список
				Если ТипЗнч(ТекущаяСтрока.Значение) = Тип("СписокЗначений") Тогда
					
					Список = ТекущаяСтрока.Значение;
					Если Список.Количество() > 0 Тогда
						
						ТекущаяСтрока.Значение = Список[0].Значение;
						
					Иначе
						
						Если ТекущаяСтрока.Свойство("ЗначениеПараметра") И ТекущаяСтрока.Свойство("ДоступныеТипы") Тогда
							ТекущаяСтрока.Значение = ТекущаяСтрока.ДоступныеТипы.ПривестиЗначение(ТекущаяСтрока.ЗначениеПараметра);
						ИначеЕсли ТекущаяСтрока.Свойство("Значение") И ТекущаяСтрока.Свойство("ТипЗначения") Тогда
							ТекущаяСтрока.Значение = ТекущаяСтрока.ТипЗначения.ПривестиЗначение(ТекущаяСтрока.Значение);
						Иначе
							ТекущаяСтрока.Значение = Неопределено;
						КонецЕсли;
						
					КонецЕсли; 
					
				КонецЕсли; 			
				
			КонецЕсли; // ФлПредВидДляСписка
			
		КонецЕсли; // ФлТекВидДляСписка 
		
	КонецЕсли; // НЕ ТекущаяСтрока = Неопределено
	
КонецПроцедуры // ИзменениеВидаСравнения()

// Процедура устанавливает УсловноеОформление для полей Значение,ЗначениеС,ЗначениеПо таблицы отбор.
// 
// Параметры:
//  УсловноеОформление      - УсловноеОформлениеКомпоновкиДанных.
//  ИмяТаблицы              - Строка (По умолчанию = "ТаблицаОтбор").
//  ПредставлениеОформления - Строка.
// 
Процедура УстановитьОформлениеТаблицыОтбор(УсловноеОформление, ИмяТаблицы = "ТаблицаОтбор", ПредставлениеОформления = "ОформлениеТаблицаОтбор") Экспорт
		
	// Очистка элементов представления
	бит_РаботаСДиалогамиСервер.УдалитьЭлементыОформленияПоПредставлению(ПредставлениеОформления, УсловноеОформление);
	
	ЦветНеопределено       = Новый Цвет(225, 225, 225);	
	ЦветТекстаНеопределено = Новый Цвет(150, 150, 150);
	
	// Запрет редактировать значение если вид сравнения предполагает использование интервала.
	МассивПолей = Новый Массив;
	МассивПолей.Добавить(ИмяТаблицы + "Значение");
	
	СписокВидовСравнения = Новый СписокЗначений;
	СписокВидовСравнения.Добавить(ВидСравнения.Интервал);
	СписокВидовСравнения.Добавить(ВидСравнения.ИнтервалВключаяГраницы);
	СписокВидовСравнения.Добавить(ВидСравнения.ИнтервалВключаяНачало);
	СписокВидовСравнения.Добавить(ВидСравнения.ИнтервалВключаяОкончание);
	
	СтрУсловия = Новый Структура;
	СтрУсловия.Вставить("УсловиеЛевое" , ИмяТаблицы + ".ВидСравнения");	
	СтрУсловия.Вставить("УсловиеПравое", СписокВидовСравнения);
	СтрУсловия.Вставить("ВидСравнения" , ВидСравненияКомпоновкиДанных.ВСписке);
	
	
	СтрОформления = Новый Структура;
	//СтрОформления.Вставить("ЦветФона"      , ЦветНеопределено);
	//СтрОформления.Вставить("ЦветТекста"    , ЦветТекстаНеопределено);	
	//СтрОформления.Вставить("ТолькоПросмотр", Истина);
	//СтрОформления.Вставить("Текст"         , "недоступно");
	СтрОформления.Вставить("Видимость", Ложь);
	
	СтруктураУО = Новый Структура("СтруктураОформления, СтруктураУсловия, МассивОформляемыхПолей",
	СтрОформления, СтрУсловия, МассивПолей);    								  
	бит_РаботаСДиалогамиСервер.ДобавитьЭлементУсловногоОформления(УсловноеОформление, ПредставлениеОформления, СтруктураУО);				
	
	// Запрет редактировать значенияС, значениеПо если вид сравнения не предполагает использование интервала.
	МассивПолей = Новый Массив;
	МассивПолей.Добавить(ИмяТаблицы + "ЗначениеС");
	МассивПолей.Добавить(ИмяТаблицы + "ЗначениеПо");
	
	СписокВидовСравнения = Новый СписокЗначений;
	СписокВидовСравнения.Добавить(ВидСравнения.Больше);
	СписокВидовСравнения.Добавить(ВидСравнения.БольшеИлиРавно);
	СписокВидовСравнения.Добавить(ВидСравнения.ВИерархии);
	СписокВидовСравнения.Добавить(ВидСравнения.ВСписке);
	СписокВидовСравнения.Добавить(ВидСравнения.ВСпискеПоИерархии);
	СписокВидовСравнения.Добавить(ВидСравнения.Меньше);
	СписокВидовСравнения.Добавить(ВидСравнения.МеньшеИлиРавно);
	СписокВидовСравнения.Добавить(ВидСравнения.НеВИерархии);
	СписокВидовСравнения.Добавить(ВидСравнения.НеВСписке);
	СписокВидовСравнения.Добавить(ВидСравнения.НеВСпискеПоИерархии);
	СписокВидовСравнения.Добавить(ВидСравнения.НеРавно);
	СписокВидовСравнения.Добавить(ВидСравнения.НеСодержит);
	СписокВидовСравнения.Добавить(ВидСравнения.Равно);
	СписокВидовСравнения.Добавить(ВидСравнения.Содержит);
	
	СтрУсловия = Новый Структура;
	СтрУсловия.Вставить("УсловиеЛевое" , ИмяТаблицы + ".ВидСравнения");	
	СтрУсловия.Вставить("УсловиеПравое", СписокВидовСравнения);
	СтрУсловия.Вставить("ВидСравнения" , ВидСравненияКомпоновкиДанных.ВСписке);
	
	СтрОформления = Новый Структура;
	//СтрОформления.Вставить("ЦветФона"      , ЦветНеопределено);
	//СтрОформления.Вставить("ЦветТекста"    , ЦветТекстаНеопределено);	
	//СтрОформления.Вставить("ТолькоПросмотр", Истина);
	//СтрОформления.Вставить("Текст"         , "недоступно");
	СтрОформления.Вставить("Видимость", Ложь);
	
	СтруктураУО = Новый Структура("СтруктураОформления, СтруктураУсловия, МассивОформляемыхПолей",
	СтрОформления, СтрУсловия, МассивПолей);    								  
	бит_РаботаСДиалогамиСервер.ДобавитьЭлементУсловногоОформления(УсловноеОформление, ПредставлениеОформления, СтруктураУО);				
	
	// Вывод текста периодичности
	СписокПериодичность = бит_ОбщегоНазначенияКлиентСервер.ПолучитьПериодичности();
	
	Для каждого Элемент Из СписокПериодичность Цикл
		
		// Новый элемент условного оформления
		ЭлементУО = УсловноеОформление.Элементы.Добавить();
		ЭлементУО.Представление = ПредставлениеОформления;
		ЭлементУО.Использование = Истина;
		
		УсловиеУО 				 = ЭлементУО.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		УсловиеУО.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных(ИмяТаблицы + ".ЭтоПериодичность");
		УсловиеУО.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
		УсловиеУО.ПравоеЗначение = Истина;
		
		УсловиеУО 				 = ЭлементУО.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		УсловиеУО.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных(ИмяТаблицы + ".Значение");
		УсловиеУО.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
		УсловиеУО.ПравоеЗначение = Элемент.Значение;
		
		ЭлементУО.Оформление.УстановитьЗначениеПараметра("Текст", Элемент.Представление);		
		ОформляемоеПоле 	 = ЭлементУО.Поля.Элементы.Добавить();
		ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(ИмяТаблицы + "Значение");
		
	КонецЦикла; 
	
КонецПроцедуры // УстановитьОформлениеТаблицыОтбор()

#КонецОбласти

#Область ПроцедурыФункцииПолученияДанных

// Процедура выполняет проверку текста запроса на наличие синтаксических ошибок.
// 
// Параметры:
//  ТекстЗапроса  -Строка.
//  Отказ         -Булево.
//  Заголовок     -Строка.
//  РежимСообщений-Строка  - "Все","Ошибки","Нет".
// 
// 
Процедура ПроверитьКорректностьТекстаЗапроса(ТекстЗапроса,Отказ,Заголовок="",РежимСообщений="Все")  Экспорт
	
	ВыводитьОшибки     = ?(РежимСообщений="Все" ИЛИ РежимСообщений="Ошибки",Истина,Ложь);
	ВыводитьИнформацию = ?(РежимСообщений="Все",Истина,Ложь);
	
	
	ПостроительЗапроса = Новый ПостроительЗапроса;
	
	Попытка
		ПостроительЗапроса.Текст = ТекстЗапроса;
		Отказ = Ложь;
	Исключение
		Отказ = Истина;
		Если ВыводитьОшибки Тогда
		
			ТекстСообщения = "Текст запроса не корректен. "+ОписаниеОшибки();
			бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
		
		КонецЕсли; 
	КонецПопытки;
	
КонецПроцедуры // ПроверитьКорректностьТекстаЗапроса()

// Процедура устанавливает в построитель отбор, сохраненный в элементе данных.
// 
// Параметры:
//  ПостроительЗапроса   - ПостроительЗапроса.
//  СохраненнаяНастройка - Структура.
// 
Процедура УстановитьОтборЭлементаДанных(ПостроительЗапроса,СохраненнаяНастройка)  Экспорт

	// Отбор заполняем по элементу данных
	Если ТипЗнч(СохраненнаяНастройка)=Тип("Структура") Тогда
		
		Для каждого ЭлементОтбора Из СохраненнаяНастройка.Отбор Цикл
			
			Попытка
				ОписаниеЭлемента = ЭлементОтбора.ПутьКДанным;
				НовыйЭлОтбора    = ПостроительЗапроса.Отбор.Добавить(ОписаниеЭлемента);
				бит_ОбщегоНазначения.ЗаполнитьЭлементОтбора(ЭлементОтбора,НовыйЭлОтбора);
			Исключение
				бит_ОбщегоНазначения.бит_Сообщить(ОписаниеОшибки());
			КонецПопытки;
			
		КонецЦикла; // По элементам отбора
		
	КонецЕсли; // Настройка - структура

КонецПроцедуры // УстановитьОтборЭлементаДанных()

// Процедура устанавливаем в построитель отбор, установленный в отчете в поле Отбор.
// 
// Параметры:
//  ПостроительЗапроса  - Построитель.
//  ОтборВОтчете        - ТаблицаЗначений.
// 
Процедура УстановитьОтборОтчета(ПостроительЗапроса,ОтборВОтчете)  Экспорт

		// Заполним отборы, установленные в форме отчета.
	Если ОтборВОтчете <> Неопределено Тогда
		
		Для каждого СтрокаОтбор Из ОтборВОтчете Цикл
			
			Если СтрокаОтбор.Использование Тогда
				ИмяПоля       = СтрокаОтбор.Имя;
				ПолеНастройки = ПостроительЗапроса.ДоступныеПоля.Найти(ИмяПоля);
				Если ПолеНастройки <> Неопределено И ПолеНастройки.Отбор Тогда
					НовыйЭлОтбора = ПостроительЗапроса.Отбор.Добавить(ИмяПоля);
					НовыйЭлОтбора.ВидСравнения  = СтрокаОтбор.ВидСравнения;
					НовыйЭлОтбора.Значение      = СтрокаОтбор.Значение;
					НовыйЭлОтбора.Использование = Истина;
				КонецЕсли; 
			КонецЕсли; // Использование 
			
		КонецЦикла; // По строкам отборов отчета
		
	КонецЕсли; // Отбор установлен

КонецПроцедуры // УстановитьОтборОтчета()

// Функция упаковывает настройки измерений строк построителя отчета/запроса в структуру.
// 
// Параметры:
//  Построитель  - ПостроительОтчета,ПостроительЗапроса.
// 
// Возвращаемое значение:
//   ИзмеренияСтроки   - Массив.
// 
Функция УпаковатьИзмеренияСтроки(Построитель) Экспорт

	ТипыИзмерений = Новый Соответствие;
	ТипыИзмерений.Вставить(ТипИзмеренияПостроителяЗапроса.Иерархия      ,"Иерархия");
	ТипыИзмерений.Вставить(ТипИзмеренияПостроителяЗапроса.ТолькоИерархия,"ТолькоИерархия");
	ТипыИзмерений.Вставить(ТипИзмеренияПостроителяЗапроса.Элементы      ,"Элементы");
	ТипыИзмерений.Вставить(ТипИзмеренияПостроителяОтчета.Иерархия       ,"Иерархия");
	ТипыИзмерений.Вставить(ТипИзмеренияПостроителяОтчета.ТолькоИерархия ,"ТолькоИерархия");
	ТипыИзмерений.Вставить(ТипИзмеренияПостроителяОтчета.Элементы       ,"Элементы");
	
	
	ИзмеренияСтроки = Новый Массив;
	
	Для каждого ТекИзмерение Из Построитель.ИзмеренияСтроки Цикл
		
		ТипИзмерения = ТипыИзмерений[ТекИзмерение.ТипИзмерения];
		ТипИзмерения = ?(ТипИзмерения = Неопределено,"Элементы",ТипИзмерения);
		НастройкаИзмерения = Новый Структура("ПутьКДанным,Имя,ТипИзмерения",ТекИзмерение.ПутьКДанным,ТекИзмерение.Имя,ТипИзмерения);
		
		ИзмеренияСтроки.Добавить(НастройкаИзмерения);
				
	КонецЦикла; 

	Возврат ИзмеренияСтроки;
	
КонецФункции // УпаковатьИзмеренияСтроки()

// Процедура восстанавливает настройки измерения строк построителя отчета/запроса.
// 
// Параметры:
//  ИзмеренияСтроки  - Массив.
//  Построитель      - ПостроительОтчета,ПостроительЗапроса.
//  Очищать          - Булево.
//  Соединение       - ComObject.
// 
Процедура РаспаковатьИзмеренияСтроки(ИзмеренияСтроки,Построитель,Очищать = Ложь, Соединение = Неопределено) Экспорт
	
	Если Очищать Тогда
		
		Построитель.ИзмеренияСтроки.Очистить();
		
	КонецЕсли; 
	
	Для каждого ТекНастройка Из ИзмеренияСтроки Цикл
		
		Если ТипЗнч(Построитель) = Тип("ПостроительЗапроса") 
			 ИЛИ НЕ Соединение = Неопределено Тогда
			 
			 Если Соединение = Неопределено Тогда
				 ТипИзмерения = ТипИзмеренияПостроителяЗапроса[ТекНастройка.ТипИзмерения];
			 Иначе	
				 ТипИзмерения = Соединение.ТипИзмеренияПостроителяЗапроса[ТекНастройка.ТипИзмерения];
			 КонецЕсли;  
			
			Если Построитель.Измерения.Найти(ТекНастройка.Имя) = Неопределено Тогда
				
				Попытка
					
					Построитель.Измерения.Добавить(ТекНастройка.ПутьКДанным,ТекНастройка.Имя,ТипИзмерения);
					
				Исключение
					
				КонецПопытки;
				
			КонецЕсли; 
			
		Иначе	
			
			ТипИзмерения = ТипИзмеренияПостроителяОтчета[ТекНастройка.ТипИзмерения];
			
			Если Построитель.ИзмеренияСтроки.Найти(ТекНастройка.Имя) = Неопределено Тогда
				
				Попытка
					
					Построитель.ИзмеренияСтроки.Добавить(ТекНастройка.ПутьКДанным,ТекНастройка.Имя,ТипИзмерения);
					
				Исключение
					
				КонецПопытки;
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // РаспаковатьИзмеренияСтроки()

// Процедура восстанавливает настройки измерения строк построителя отчета/запроса.
// 
// Параметры:
//  ИзмеренияСтроки  - Массив.
//  Построитель      - ПостроительОтчета,ПостроительЗапроса.
//  Очищать          - Булево.
//  Соединение       - ComObject.
// 
Процедура УстановитьИзмеренияСтроки(ИзмеренияСтроки,Построитель,Очищать = Ложь, Соединение = Неопределено) Экспорт
	
	Если Очищать Тогда
		
		Построитель.ИзмеренияСтроки.Очистить();
		
	КонецЕсли; 
	
	Для каждого ТекНастройка Из ИзмеренияСтроки Цикл
		
		Если ТипЗнч(Построитель) = Тип("ПостроительЗапроса") 
			 ИЛИ НЕ Соединение = Неопределено Тогда
			 
			 Если Соединение = Неопределено Тогда
				 ТипИзмерения = ТипИзмеренияПостроителяЗапроса.Элементы;
			 Иначе	
				 ТипИзмерения = Соединение.ТипИзмеренияПостроителяЗапроса.Элементы;
			 КонецЕсли;  
			
				
				Попытка
					
					Построитель.Измерения.Добавить(ТекНастройка.ПутьКДанным,,ТипИзмерения);
					
				Исключение
					
					ТекстСообщения = НСтр("ru = 'Не удалось добавить измерение построителя ""%1%""! По причине : %2%.'");
					ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
					                                                                              ,ТекНастройка.ПутьКДанным
																								  ,Строка(ОписаниеОшибки()));
																								  
					бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);																			  
					
				КонецПопытки;
			
		Иначе	
			
			ТипИзмерения = ТипИзмеренияПостроителяОтчета.Элементы;
				
				Попытка
					
					Построитель.ИзмеренияСтроки.Добавить(ТекНастройка.ПутьКДанным,,ТипИзмерения);
					
				Исключение
					
					ТекстСообщения = НСтр("ru = 'Не удалось добавить измерение построителя ""%1%""! По причине : %2%.'");
					ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
					                                                                              ,ТекНастройка.ПутьКДанным
																								  ,Строка(ОписаниеОшибки()));
																								  
					бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);																			  
					
				КонецПопытки;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // РаспаковатьИзмеренияСтроки()

// Функция упаковывает порядок построителя в массив структур, для сохранения в ХранилищеЗначения.
// 
// Параметры:
//  Построитель - ПостроительОтчета, ПостроительЗапроса.
// 
// Возвращаемое значение:
//  Порядок - Массив.
// 
Функция УпаковатьПорядокПостроителя(Построитель) Экспорт

	Порядок = Новый Массив;
	
	Для каждого ЭлементПорядка Из Построитель.Порядок Цикл
	
		СтрПорядок = Новый Структура("Имя,Направление,Представление,ПутьКДанным"
		                              ,ЭлементПорядка.Имя
									  ,ЭлементПорядка.Направление
									  ,ЭлементПорядка.Представление
									  ,ЭлементПорядка.ПутьКДанным);
									  
		Порядок.Добавить(СтрПорядок);							  
	
	КонецЦикла; 
	

	Возврат Порядок;
	
КонецФункции // УпаковатьПорядокПостроителя()

// Процедура добавляет элемент порядка построителя на основании настройки порядка в ИсточникеДанных.
// 
// Параметры:
//  НастройкаПорядка - ТабличнаяЧасть.
//  Построитель      - ПостроительЗапроса, ComObject.
//  НаправленияСортировки - СистемноеПеречисление.НаправленияСортировки, ComObject.
//  Очищать - Булево.
//  ВыводитьСообщения - Булево.
// 
Процедура УстановитьПорядокПостроителя(НастройкаПорядка, Построитель, НаправленияСортировки, Очищать = Ложь, ВыводитьСообщения = Истина) Экспорт

	Если Очищать Тогда
	
		Построитель.Порядок.Очистить();
	
	КонецЕсли; 
	
	Для каждого ТекНастройка Из НастройкаПорядка Цикл
		
		Если ТекНастройка.НаправлениеСортировки = Перечисления.бит_мпд_НаправленияСортировки.Убывание Тогда
			
			ТекНаправление = НаправленияСортировки.Убыв;
			
		Иначе	
			
			ТекНаправление = НаправленияСортировки.Возр;			
			
		КонецЕсли; 
		
		Попытка
			
			Построитель.Порядок.Добавить(ТекНастройка.ПутьКДанным
											,""
											,ТекНастройка.ПутьКДанным
											,ТекНаправление);
			
		Исключение
			
			Если ВыводитьСообщения Тогда
				
				ТекстСообщения = НСтр("ru = 'Не удалось добавить элемент порядка %1! Описание ошибки: %2.'");
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщения
				                                                                            ,ТекНастройка.ПутьКДанным
																							,Строка(ОписаниеОшибки()));
																																								
				
			КонецЕсли; 
			
		КонецПопытки;
		
	КонецЦикла; 
	
КонецПроцедуры // УстановитьПорядокПостроителя()

// Процедура устанавливает обязательные параметры построителя запроса.
// 
// Параметры:
//  ПостроительЗапроса - ПостроительЗапроса,ComObject.
//  ГраницаНач - Дата,Граница,ComObject.
//  ГраницаКон - Дата,Граница,ComObject.
//  флКонецГраница - Булево.
// 
Процедура УстановитьОбязательныеПараметры(ПостроительЗапроса,ГраницаНач,ГраницаКон,флКонецГраница) Экспорт

	ПостроительЗапроса.Параметры.Вставить("НачалоПериода",ГраницаНач);
	ПостроительЗапроса.Параметры.Вставить("КонецПериода" ,ГраницаКон);
	ПостроительЗапроса.Параметры.Вставить("МоментВремени",ГраницаКон);
	
	Если флКонецГраница Тогда
		ПостроительЗапроса.Параметры.Вставить("КонецПериодаДата",ГраницаКон.Значение);
	Иначе	
		ПостроительЗапроса.Параметры.Вставить("КонецПериодаДата",ГраницаКон);
	КонецЕсли; 

	ПостроительЗапроса.Параметры.Вставить("ТекущаяДата", ТекущаяДата());
	ПостроительЗапроса.Параметры.Вставить("ТекущаяДатаСеанса", ТекущаяДатаСеанса());
	
КонецПроцедуры // УстановитьОбязательныеПараметры()

// Функция конструктор структуры параметров для функции получения данных по источнику.
// 
// Параметры:
//  ГраницаНач - Дата, Граница - начало периода извлечения данных.
//  ГраницаКон - Дата, Граница - конец периода извленчения данных.
//  Параметры  - Структура - параметры построителя запроса.
//  Настройка  - Настройка построителя отчета.
//  Поля       - Массив    - выбранные поля построителя.
//  Измерения  - Массив    - измерения, по которым будет производиться расшифровка
//  ОтборВОтчете               - ТаблицаЗначений - Отборы установленные непосредственно в отчете.
//  ВозвращатьРезультатЗапроса - Булево - Используется при в обработке расшифровки.
//  НастройкаПодключения       - СправочникСсылка.бит_мпд_НастройкиВнешнийПодключений.
//  НастройкаПулаПодключений   - СправочникСсылка.бит_мпд_НастройкиПуловПодключенй 
//                               позволяет переопределить настройки подключения для вид ИБ
//  ПулПодключений - Соответствие - Содержит активные подключения, ключ - НастройкаПодключения, значение - ComObject.
// 
// Возвращаемое значение:
//  Результат - СтрПар.
// 
Функция КонструкторПараметры_ПолучитьДанныеПоИсточнику(Параметры    = Неопределено
														,Настройка    = Неопределено
														,Поля         = Неопределено
														,Измерения    = Неопределено
														,ОтборВОтчете = Неопределено
														,ВозвращатьРезультатЗапроса = Ложь
														,НастройкаПодключения       = Неопределено
														,ПулПодключений             = Неопределено 
														,НастройкаПулаПодключений   = Неопределено) Экспорт

	СтрПар = Новый Структура;
	СтрПар.Вставить("Параметры"                 ,Параметры);
	СтрПар.Вставить("Настройка"                 ,Настройка);
	СтрПар.Вставить("Поля"                      ,Поля);
	СтрПар.Вставить("Измерения"                 ,Измерения);
	СтрПар.Вставить("ОтборВОтчете"              ,ОтборВОтчете);
	СтрПар.Вставить("ВозвращатьРезультатЗапроса",ВозвращатьРезультатЗапроса);
	СтрПар.Вставить("НастройкаПодключения"      ,НастройкаПодключения);
	СтрПар.Вставить("НастройкаПулаПодключений"  ,НастройкаПулаПодключений);	
	СтрПар.Вставить("ПулПодключений"            ,ПулПодключений);

	Возврат СтрПар;
	
КонецФункции // КонструкторПараметры_ПолучитьДанныеПоИсточнику()

// Функция конструктор структуры параметров для функции получения данных по источнику.
// 
// Параметры:
//  МассивЭлементов - Массив - Массив элементов данных.
//  Параметры       - Структура - Параметры построителя запроса.
//  ПоказыватьИндикатор - Булево.
//  НастройкаПулаПодключений - СправочникСсылка.бит_мпд_НастройкиПуловПодключений.
// 
// Возвращаемое значение:
//  СтрПар - Структура.
// 
Функция КонструкторПараметры_ПолучитьДанныеПоСпособуКомпоновки(МассивЭлементов = Неопределено
                                                               ,Параметры       = Неопределено															   
									                           ,ОтборВОтчете    = Неопределено
									                           ,ПоказыватьИндикатор = Истина
									                           ,НастройкаПулаПодключений = Неопределено) Экспорт

	СтрПар = Новый Структура;
	СтрПар.Вставить("МассивЭлементов"         ,МассивЭлементов);
	СтрПар.Вставить("Параметры"               ,Параметры);
	СтрПар.Вставить("ОтборВОтчете"            ,ОтборВОтчете);
	СтрПар.Вставить("ПоказыватьИндикатор"     ,ПоказыватьИндикатор);
	СтрПар.Вставить("НастройкаПулаПодключений",НастройкаПулаПодключений);
	СтрПар.Вставить("НастройкаПодключения",	   Неопределено);

	Возврат СтрПар;
	
КонецФункции // КонструкторПараметры_ПолучитьДанныеСпособКомпоновки()

// Процедура получает данные по источнику.
// 
// Параметры:
//  ИсточникДанных  - СправочникСсылка.ИсточникиДанныхДляРасчетовБюджетирования.
//  ГраницаНач      - Дата,Граница.
//  ГраницаКон      - Дата,Граница.
//  СтрПар          - Структура.
// 
// Возвращаемое значение:
//   ТаблицаРезультат  - ТаблицаЗначений.
// 
Функция ПолучитьДанныеПоИсточнику(ИсточникДанных
	                              ,ГраницаНач
								  ,ГраницаКон
								  ,СтрПар) Экспорт

	 
	 НастройкиПодключений = ОпределитьНеобходимыеПодключения(СтрПар.НастройкаПулаПодключений
	                                                           , ИсточникДанных
															   , СтрПар.НастройкаПодключения);
	 
	 // Получим данные по настройкам подключений
	 КолонкиГруппировок  = "";
	 КолонкиСуммирования = "";
	 КоличествоНастроек  = НастройкиПодключений.Количество();
	 Ном = 1;
	 
	 Если СтрПар.ВозвращатьРезультатЗапроса Тогда
	 
	 	ТаблицаРезультат = Новый Соответствие;
	 
	 КонецЕсли; 
	 
	 Для каждого НастройкаПодключения Из НастройкиПодключений Цикл
	 
	 	Если НЕ ЗначениеЗаполнено(НастройкаПодключения) Тогда
			
			
			
	    	 // Текущая информационная база
			СтрПарТек = КонструкторПараметры_ПолучитьДанныеПоИсточнику();
			ЗаполнитьЗначенияСвойств(СтрПарТек, СтрПар);
	    	ТаблицаДанных = ПолучитьДанныеПоИсточникуТекущаяБаза(ИсточникДанных
	    														  ,ГраницаНач
	    														  ,ГраницаКон
	    														  ,СтрПарТек);	    	 
	    	 
	    	
	    Иначе	
	    	
	    	// Внешняя информационная база
			СтрПарВнеш = КонструкторПараметры_ПолучитьДанныеПоИсточнику();
			ЗаполнитьЗначенияСвойств(СтрПарВнеш,СтрПар);
			СтрПарВнеш.НастройкаПодключения = НастройкаПодключения;
			
	    	ТаблицаДанных = бит_мпд_ВнешниеИсточникиСервер.ПолучитьДанныеПоИсточникуВнешняяБаза(ИсточникДанных
	    																						  ,ГраницаНач
	    																						  ,ГраницаКон
	    																						  ,СтрПарВнеш);
	    	
	    	
		КонецЕсли; 
																							  
		Если ТаблицаДанных = Неопределено Тогда
			Возврат Неопределено;		
		КонецЕсли;
		
		Если СтрПар.ВозвращатьРезультатЗапроса Тогда
			
			Если НЕ ЗначениеЗаполнено(НастройкаПодключения) Тогда
				
				ТаблицаРезультат.Вставить(Справочники.бит_мпд_ВидыИнформационныхБаз.ТекущаяИнформационнаяБаза, ТаблицаДанных);
				
			Иначе	
				
				ТаблицаРезультат.Вставить(НастройкаПодключения, ТаблицаДанных);
				
			КонецЕсли; 
			
		Иначе	
			
			
		Если Ном = 1 Тогда
			
			// Инициализация результирующей таблицы
			ТаблицаРезультат = Новый ТаблицаЗначений;
			
			ОписаниеЧисло    = Новый ОписаниеТипов("Число");
	
			Для каждого Колонка Из ТаблицаДанных.Колонки Цикл
				
				Если Колонка.ТипЗначения.СодержитТип(Тип("Число")) Тогда
					
					ТаблицаРезультат.Колонки.Добавить(Колонка.Имя, ОписаниеЧисло);
					
						
						КолонкиСуммирования = бит_СтрокиКлиентСервер.ДобавитьСтрокуСРазделителем(КолонкиСуммирования
																								,Колонка.Имя
																								,",");
						
				Иначе
					
					// Для не числовых колонок тип устанавливать не будем, т.к. если значения не удалось сконвертировать
					// в ссылки текущей базы, то будут записаны элементы списка значений.
					ТаблицаРезультат.Колонки.Добавить(Колонка.Имя);
					
					КолонкиГруппировок = бит_СтрокиКлиентСервер.ДобавитьСтрокуСРазделителем(КолонкиГруппировок
																							,Колонка.Имя
																							,",");
						
					
				КонецЕсли; 
				
			КонецЦикла;  // ТаблицаДанных.Колонки
			
		КонецЕсли;
		
			Для каждого СтрокаТаблицы Из ТаблицаДанных Цикл
				
				// Копируем данные в таблицу-результат
				НоваяСтрока = ТаблицаРезультат.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
				
			КонецЦикла; // ТаблицаДанных
			
		КонецЕсли;  // Количество настроек
		
	    Ном = Ном+1;
	 КонецЦикла; // НастройкиПодключений
	 
	 Если КоличествоНастроек > 1 И НЕ СтрПар.ВозвращатьРезультатЗапроса Тогда
	 
	 	// Необходимо выполнить свертку
		ТаблицаРезультат.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
	 
	 КонецЕсли; 
	 	 
	 // Применение соответствий 
	 Если НЕ СтрПар.ВозвращатьРезультатЗапроса 
		  И (ИсточникДанных.СоотвСтатьиРегл_Применить 
		     ИЛИ ИсточникДанных.СоотвПодразделения_Применить 
			 ИЛИ ИсточникДанных.СоотвНомГруппы_Применить 
			 ИЛИ ИсточникДанных.НастройкиСоответствий.Количество() > 0) Тогда
	 
	 	  ПрименитьСоответствия(ТаблицаРезультат,ИсточникДанных);
	 
	 КонецЕсли; 
	 
	 // Обработчик после получения данных
	 Если НЕ ПустаяСтрока(ИсточникДанных.КодПослеПолученияДанных) Тогда
	 
	 	 Выполнить(ИсточникДанных.КодПослеПолученияДанных);
	 
	 КонецЕсли; 
	 
	Возврат ТаблицаРезультат;
	
КонецФункции // ПолучитьДанные()

// Процедура применяет соответствия к ТаблицеРезультат, полученной источником данных.
// 
// Параметры:
//  ТаблицаРезультат - ТаблицаЗначений.
//  Источник    - СправочникСсылка.бит_ИсточникиДанных.
// 
Процедура ПрименитьСоответствия(ТаблицаРезультат,Источник) Экспорт

	// Подготовим параметры для работы с фиксированными соответствиями.
	СтрСоотв = Новый Структура("СоотвСтатьиРегл,СоотвПодразделения,СоотвНомГруппы");
	
	Для каждого КиЗ Из СтрСоотв Цикл
		
		ВидСоотв         = КиЗ.Ключ;
		ИмяПоляПрименить = ВидСоотв+"_Применить";
		
		Если Источник[ИмяПоляПрименить] Тогда
			
			Если ВидСоотв = "СоотвСтатьиРегл" Тогда
				
				Соотв = бит_МеханизмТрансляции.ПолучитьСоответствиеСтатьиРеглСтатьи();
				
			ИначеЕсли ВидСоотв = "СоотвПодразделения" Тогда
				
				Соотв =  бит_МеханизмТрансляции.ПолучитьСоответствиеПодразделенияЦФО();
				
			ИначеЕсли ВидСоотв = "СоотвНомГруппы" Тогда 	
				
				Соотв = бит_МеханизмТрансляции.ПолучитьСоответствиеНомГруппыСтатьи();
				
			КонецЕсли; 
			
			СтрПар = Новый Структура;
			СтрПар.Вставить("Соотв", Соотв);
			
			ИмяПолеПриемник = ВидСоотв+"_ПолеПриемник";
			СтрПар.Вставить("ПолеПриемник",Источник[ИмяПолеПриемник]);
			
			ИмяПоляИсточники = ВидСоотв+"_ПоляИсточники";
			СтрПоляИсточники = Источник[ИмяПоляИсточники];
			МассивПоляИсточники = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(СтрПоляИсточники,"/");
			СтрПар.Вставить("ПоляИсточники",МассивПоляИсточники);
			
			СтрСоотв[КиЗ.Ключ] = СтрПар;
			
		КонецЕсли; 
	
	КонецЦикла; // По видам фиксированным соответствиям
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	бит_СоответствияАналитик.ЛеваяАналитика_1,
	|	бит_СоответствияАналитик.ЛеваяАналитика_2,
	|	бит_СоответствияАналитик.ЛеваяАналитика_3,
	|	бит_СоответствияАналитик.ПраваяАналитика_1,
	|	бит_СоответствияАналитик.ПраваяАналитика_2,
	|	бит_СоответствияАналитик.ПраваяАналитика_3
	|ИЗ
	|	РегистрСведений.бит_СоответствияАналитик КАК бит_СоответствияАналитик
	|ГДЕ
	|	бит_СоответствияАналитик.ВидСоответствия = &ВидСоответствия";					   
	
	// Подготовка параметров для работы с универсальными соответствиями.
	НастройкиСоотв = Новый Массив;
	МаксКолАналитик = Справочники.бит_ВидыСоответствийАналитик.МаксКоличествоАналитик();
	Для каждого СтрокаСоотв Из Источник.НастройкиСоответствий Цикл
		
		ТекНастройка 	= Новый Структура("ТабСоотв, ПоляИсточники, ПоляПриемники");
		ВидСоответствия = СтрокаСоотв.ВидСоответствия;
		
		Запрос.УстановитьПараметр("ВидСоответствия", ВидСоответствия);
		Результат = Запрос.Выполнить();
		
		ТекНастройка.Вставить("ТабСоотв", Результат.Выгрузить());			   
		
		МассивПолейИсточник = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(СтрокаСоотв.ПоляИсточники, "/");
		МассивПолейПриемник = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(СтрокаСоотв.ПоляПриемники, "/");

		ПоляИсточники = Новый Структура;
		ПоляПриемники = Новый Структура;
		
		Для й = 1 По МаксКолАналитик Цикл
		
			ИмяПоляСоотв = "ЛеваяАналитика_"+й;
			ВидАналитики = ВидСоответствия[ИмяПоляСоотв];
			
			Если ЗначениеЗаполнено(ВидАналитики) Тогда
				
				ИмяАналитики = СокрЛП(ВидАналитики.Код);
				Если НЕ МассивПолейИсточник.Найти(ИмяАналитики) = Неопределено Тогда
					ПоляИсточники.Вставить(ИмяАналитики, ИмяПоляСоотв);
				КонецЕсли; 
			КонецЕсли; 
			
			ИмяПоляСоотв = "ПраваяАналитика_"+й;
			ВидАналитики = ВидСоответствия[ИмяПоляСоотв];
			
			Если ЗначениеЗаполнено(ВидАналитики) Тогда
				
				ИмяАналитики = СокрЛП(ВидАналитики.Код);
				Если НЕ МассивПолейПриемник.Найти(ИмяАналитики) = Неопределено Тогда
					ПоляПриемники.Вставить(ИмяПоляСоотв, ИмяАналитики);
				КонецЕсли; 
			КонецЕсли; 
		КонецЦикла; 
		
		ТекНастройка.Вставить("ПоляИсточники", ПоляИсточники);
		ТекНастройка.Вставить("ПоляПриемники", ПоляПриемники);
		
		НастройкиСоотв.Добавить(ТекНастройка);
		
	КонецЦикла; // По универсальным соответствиям
	
	ЕстьСчетУчетаБУ = ?(ТаблицаРезультат.Колонки.Найти("СчетУчетаБУ") = Неопределено, Ложь, Истина);
	
	// Применим соответствия к ТаблицеРезультат
	Для каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
		
		// Подбор по фиксированным соответствиям
		Для каждого КиЗ Из СтрСоотв Цикл
			
			СтрПар = КиЗ.Значение;
			Если ТипЗнч(СтрПар) = Тип("Структура") Тогда
				
				Если НЕ ЗначениеЗаполнено(СтрПар.ПолеПриемник) Тогда
					Продолжить;
				КонецЕсли; 
				
				Если НЕ ТипЗнч(СтрокаТаблицы[СтрПар.ПолеПриемник]) = Тип("ЭлементСпискаЗначений")
					 И НЕ ЗначениеЗаполнено(СтрокаТаблицы[СтрПар.ПолеПриемник]) Тогда
					
					Для каждого ПолеИсточник Из КиЗ.Значение.ПоляИсточники Цикл
						
						Если ЗначениеЗаполнено(ПолеИсточник) Тогда
							
							ЗначениеПоиска = СтрокаТаблицы[ПолеИсточник];
							СчетПоиска = ?(ЕстьСчетУчетаБУ, СтрокаТаблицы["СчетУчетаБУ"], ПланыСчетов.Хозрасчетный.ПустаяСсылка());
							
							РезЗначение = бит_МеханизмТрансляции.ИзвлечьИзСоответствия(ЗначениеПоиска, СчетПоиска, СтрПар.Соотв);
							// РезЗначение = СтрПар.Соотв[ЗначениеПоиска];
							Если НЕ РезЗначение = Неопределено Тогда
								Прервать;
							КонецЕсли; 
						КонецЕсли; 
					КонецЦикла; // Поля источники
					
					СтрокаТаблицы[СтрПар.ПолеПриемник] = РезЗначение;
					
				КонецЕсли;  // Приемник пустой
			КонецЕсли; // Соответствие применяется
		КонецЦикла; // Фиксированные виды соответствий
		
		// Подбор по универсальным соответствиям		
		Для каждого Настройка Из НастройкиСоотв Цикл
			
			СтрОтбор = Новый Структура;
			
			Для каждого КиЗ Из Настройка.ПоляИсточники Цикл
				
				ИмяПоляСоотв = КиЗ.Значение;
				ИмяАналитики = КиЗ.Ключ;
				СтрОтбор.Вставить(ИмяПоляСоотв, СтрокаТаблицы[ИмяАналитики]);
				
			КонецЦикла; // По полям источникам
			
			// Выполняем поиск в соответствии
			НайденныеСтроки = Настройка.ТабСоотв.НайтиСтроки(СтрОтбор);
			
			Если НайденныеСтроки.Количество() > 0 Тогда
				
				ПерваяСтрока = НайденныеСтроки[0];
				
				Для каждого КиЗ Из Настройка.ПоляПриемники Цикл
					
					ИмяПоляСоотв = КиЗ.Ключ;
					ИмяАналитики = КиЗ.Значение;
					
					Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[ИмяАналитики]) Тогда
						
						СтрокаТаблицы[ИмяАналитики] = ПерваяСтрока[ИмяПоляСоотв];
						
					КонецЕсли; 
					
				КонецЦикла; // По полям приемникам
				
			КонецЕсли;  
			
		КонецЦикла; // По универсальным используемым соответствиям.
		
		
	КонецЦикла; // ТаблицаРезультат

КонецПроцедуры // ПрименитьСоответствия()

// Функция формирует массив подключений, необходимых для получения данных. 
// Учитывается возможность переопределения подключений в настройке пулов.
// 
// Параметры:
//  НастройкаПулаПодключений - СправочникСсылка.бит_мпд_НастройкиПуловПодключений.
//  ИсточникДанных           - СправочникСсылка.бит_ИсточникиДанных.
//  НастройкаПодключения     - СправочникСсылка.бит_мпд_НастройкиПодключений.
// 
// Возвращаемое значение:
//  НастройкиПодключений - Массив.
// 
Функция ОпределитьНеобходимыеПодключения(НастройкаПулаПодключений, ИсточникДанных, НастройкаПодключения) Экспорт

	НастройкиПодключений = Новый Массив;							  
	
	Если ЗначениеЗаполнено(НастройкаПулаПодключений) Тогда
		
		// Подключения для видов ИБ переопределяются в настройке пулов подключений.
		СтрОтбор = Новый Структура("ВидИнформационнойБазы",ИсточникДанных.ВидИнформационнойБазы);
		
		МассивСтрок = НастройкаПулаПодключений.НастройкиПодключений.НайтиСтроки(СтрОтбор);
		
		Для каждого СтрокаТаблицы Из МассивСтрок Цикл
			
			НастройкиПодключений.Добавить(СтрокаТаблицы.НастройкаПодключения);
			
		КонецЦикла; 
		
	КонецЕсли; 							  
	
	Если НастройкиПодключений.Количество() = 0 Тогда
		
		// Подключение передано как параметр или берется из источника.
		Если ЗначениеЗаполнено(НастройкаПодключения) Тогда
			НастройкиПодключений.Добавить(НастройкаПодключения); 
		Иначе	
			НастройкиПодключений.Добавить(ИсточникДанных.НастройкаПодключения); 
		КонецЕсли; 
		
	КонецЕсли;
	
	Возврат НастройкиПодключений;
	
КонецФункции // ОпределитьНеобходимыеПодключения()

// Процедура получает данные по источнику.
// 
// Параметры:
//  ИсточникДанных  - СправочникСсылка.ИсточникиДанныхДляРасчетовБюджетирования.
//  ГраницаНач      - Дата,Граница.
//  ГраницаКон      - Дата,Граница.
//  СтрПар          - Структура.
// 
// Возвращаемое значение:
//   ТаблицаДанных  - ТаблицаЗначений, РезультатЗапроса.
// 
Функция ПолучитьДанныеПоИсточникуТекущаяБаза(ИсточникДанных
				                              ,ГраницаНач
											  ,ГраницаКон
											  ,СтрПар) Экспорт

	Параметры                  = СтрПар.Параметры;
	Настройка                  = СтрПар.Настройка;
	Поля                       = СтрПар.Поля;
	ОтборВОтчете               = СтрПар.ОтборВОтчете;
	ВозвращатьРезультатЗапроса = СтрПар.ВозвращатьРезультатЗапроса;
											  
	ПостроительЗапроса                         = Новый ПостроительЗапроса;
	ПостроительЗапроса.Текст                   = ИсточникДанных.ЗапросБД.ТекстЗапроса;
	ПостроительЗапроса.ДобавлениеПредставлений = ТипДобавленияПредставлений.НеДобавлять;
	Если ИсточникДанных.ЗапросБД.АвтозаполнениеНастроек Тогда
	
		 ПостроительЗапроса.ЗаполнитьНастройки();
	
	КонецЕсли; 
	
	// Сохраненные настройки построителя
	НастройкаИсточника = ИсточникДанных.НастройкиПостроителя.Получить();
	
	Если Настройка = Неопределено Тогда
		СохраненнаяНастройка=НастройкаИсточника;
	Иначе
		СохраненнаяНастройка=Настройка;
	КонецЕсли; 
		
	Если ТипЗнч(НастройкаИсточника) = Тип("Структура") Тогда
	
		Для Каждого Параметр Из НастройкаИсточника.ПараметрыПостроителя Цикл
			ПостроительЗапроса.Параметры.Вставить(Параметр.Ключ,Параметр.Значение);
		КонецЦикла;
	
	КонецЕсли; 
	
	// Заполнение выбранных полей построителя по настройке источника данных.
	ЗаполнитьВыбранныеПоля(ПостроительЗапроса, ИсточникДанных);
	
	// Для каждого Поле Из ИсточникДанных.Поля Цикл.
	// 	
	// 	ДоступноеПоле = ПостроительЗапроса.ДоступныеПоля.Найти(Поле.Имя);
	// 	Если ДоступноеПоле <> Неопределено Тогда 
	// 		
	// 		ИмяПоля = ?(НЕ ПустаяСтрока(Поле.Синоним),Поле.Синоним,Поле.Имя);
	// 		
	// 		ВыбранноеПоле = ПостроительЗапроса.ВыбранныеПоля.Найти(Поле.Имя);
	// 		
	// 		Если Поле.Использование И ВыбранноеПоле = Неопределено Тогда
	// 			
	// 			Попытка
	// 				ВыбранноеПоле = ПостроительЗапроса.ВыбранныеПоля.Добавить(Поле.Имя,ИмяПоля);
	// 				ВыбранноеПоле.Представление = ИмяПоля;
	// 			Исключение
	// 				ТекстСообщения = ОписаниеОшибки();
	// 				бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения);
	// 			КонецПопытки;
	// 		КонецЕсли;
	// 		
	// 	КонецЕсли; 
	// 	
	// КонецЦикла; 
	
	// Заполним параметры построителя
	Если ТипЗнч(Параметры) = Тип("Структура") Тогда
		
		//bit auavseenkov++ Расчет отложенных налогов
		Если НастройкаИсточника.ПараметрыПостроителя.Свойство("СопоставлятьПоОбъекту") 
			Или НастройкаИсточника.ПараметрыПостроителя.Свойство("КонецПериода_РОН") Тогда 
			ИзменитьТекстЗапросаДляРасчетаОтлеженныхНалогов(ПостроительЗапроса,НастройкаИсточника)
		КонецЕсли;
		ИзменитьОтборДляРасчетаОтложенныхНалоговРегистратор(ПостроительЗапроса,НастройкаИсточника);
		//}		
		
		Для каждого КлючИЗначение Из Параметры Цикл
			
			ПостроительЗапроса.Параметры.Вставить(КлючИЗначение.Ключ,КлючИЗначение.Значение);
			
		КонецЦикла; 
		
	КонецЕсли; 
	
	флКонецГраница = ТипЗнч(ГраницаКон) = Тип("Граница");	
	УстановитьОбязательныеПараметры(ПостроительЗапроса, ГраницаНач, ГраницаКон, флКонецГраница);
	
	// Отбор заполняем по элементу данных
	УстановитьОтборЭлементаДанных(ПостроительЗапроса,СохраненнаяНастройка);
	
	// Заполним отборы, установленные в форме отчета.
	УстановитьОтборОтчета(ПостроительЗапроса,ОтборВОтчете);
	
	Если НЕ СтрПар.Измерения = Неопределено Тогда
	
		бит_МеханизмПолученияДанных.УстановитьИзмеренияСтроки(СтрПар.Измерения, ПостроительЗапроса);
	
	КонецЕсли; 
	
	бит_МеханизмПолученияДанных.УстановитьПорядокПостроителя(ИсточникДанных.Порядок, ПостроительЗапроса, НаправлениеСортировки);
	
	// Выполнение запроса
	ПостроительЗапроса.Выполнить();
	Попытка
		Результат = ПостроительЗапроса.Результат;
	Исключение
		ТекстСообщения = Нстр("ru = 'Не удается сформировать произвольный отчет по источнику ""%1"". Описание ошибки: %2.'");
		ТекстСообщения = СтрШаблон(ТекстСообщения, ИсточникДанных.Наименование, Строка(ОписаниеОшибки()));
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		Возврат Неопределено;
	КонецПопытки;
	
	Если ВозвращатьРезультатЗапроса Тогда
		
		ТаблицаДанных = Результат;
		
	Иначе	
		
		// Замена имен на синонимы в результирующей таблице.
		ТаблицаДанных= Результат.Выгрузить();
		ПодставитьСинонимыИсточника(ТаблицаДанных,ИсточникДанных);
		
	КонецЕсли; 
	
	Возврат ТаблицаДанных;
	
КонецФункции // ПолучитьДанныеПоИсточникуТекущаяБаза()

// Процедура добавляет выбранные поля построителя.
// 
// Параметры:
//  Построитель - построитель запроса.
// 
Процедура ЗаполнитьВыбранныеПоля(Построитель, ИсточникДанных, Очищать = Истина)  Экспорт
	
	Если Очищать Тогда
		
		Построитель.ВыбранныеПоля.Очистить();	
		
	КонецЕсли; 
	
	Для каждого Поле Из ИсточникДанных.Поля Цикл
		
		ИмяПоля = ?(НЕ ПустаяСтрока(Поле.Синоним),Поле.Синоним,Поле.Имя);
		ИмяПоля = СтрЗаменить(ИмяПоля,".","");
		
		Если Поле.Использование  Тогда
			//bit auavseenkov++ Расчет отложенных налогов 21.11.2014 
			Если  Поле.Имя ="СчетНУ" или Поле.Имя ="СчетМУ" Тогда 
				Продолжить;
			КонецЕсли;
			//}			
			Попытка
				ВыбранноеПоле = Построитель.ВыбранныеПоля.Добавить(Поле.Имя,ИмяПоля);
				ВыбранноеПоле.Представление = ИмяПоля;
			Исключение
				ТекстСообщения = ОписаниеОшибки();
				бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения);
			КонецПопытки;
		КонецЕсли;
		
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьВыбранныеПоля()

// Процедура заменяет имена колонок на синонимы источника данных.
// 
// Параметры:
//  ТаблицаДанных - ТаблицаЗначений.
//  ИсточникДанных- СправочникСсылка.бит_ИсточникиДанных.
// 
Процедура ПодставитьСинонимыИсточника(ТаблицаДанных,ИсточникДанных) Экспорт

	Для каждого Поле Из ИсточникДанных.Поля Цикл
		
		Если НЕ Поле.Использование Тогда
			
			Продолжить;
			
		КонецЕсли; 
		
		Если ПустаяСтрока(Поле.Синоним) Тогда
			
			Продолжить;
			
		КонецЕсли; 
		
		КолонкаТаблицы = ТаблицаДанных.Колонки.Найти(Поле.Имя);
		КолонкаТаблицыСиноним = ТаблицаДанных.Колонки.Найти(Поле.Синоним);
		Если КолонкаТаблицы <> Неопределено И КолонкаТаблицыСиноним = Неопределено Тогда
			
			КолонкаТаблицы.Имя = Поле.Синоним;
			
		КонецЕсли; 
		
	КонецЦикла;

КонецПроцедуры // ПодставитьСинонимыИсточника()

// Функция получает данные по настройкам, указанным в способе компоновки источников данных.
// 
// Параметры
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ГраницаНач        - Дата,МоментВремени,Граница.
//  ГраницаКон        - Дата,МоментВремени,Граница.
//  СтрПар            - Структура.
// 
// Возвращаемое значение:
//   ТаблицаРезультат   - ТаблицаЗначений.
// 
Функция ПолучитьДанныеПоИсточникам(СпособКомпоновки, ГраницаНач, ГраницаКон, СтрПар) Экспорт
	
	Параметры                = СтрПар.Параметры;
	МассивЭлементов          = СтрПар.МассивЭлементов;
	ОтборВОтчете             = СтрПар.ОтборВОтчете;
	ПоказыватьИндикатор      = СтрПар.ПоказыватьИндикатор;
	НастройкаПулаПодключений = СтрПар.НастройкаПулаПодключений;
	
	// Соответствие для хранения результатов вложенных способов компоновки.
	ВложенныеРезультаты = Новый Соответствие;
	
	СоотвИсточников = СформироватьСоответствияПолейДляСпособа(СпособКомпоновки);
	
	МассивРесурсов = ПолучитьСписокПолейДляСпособаКомпоновки(СпособКомпоновки, "Ресурс");
	Поля           = ПолучитьСписокПолейДляСпособаКомпоновки(СпособКомпоновки, "Поле");
	
	ТаблицаРезультат = ИнициализироватьТаблицуРезультат(СпособКомпоновки,МассивРесурсов);
	
	// Выберем элементы данных
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	бит_ЭлементыДанных.Ссылка КАК ЭлементДанных,
	               |	бит_ЭлементыДанных.Родитель КАК ГруппаЭлементДанных,
				   // ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
				   |	бит_ЭлементыДанных.Кодификатор КАК Кодификатор,
	               |	бит_ЭлементыДанных.ВидГруппы КАК ВидГруппы,
				   // ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)				   
	               |	бит_ЭлементыДанных.ИсточникДанных,
	               |	бит_ЭлементыДанных.НастройкиПостроителя,
	               |	бит_ЭлементыДанных.Коэффициент,
	               |	бит_ЭлементыДанных.ВидСубконто1,
	               |	бит_ЭлементыДанных.ВидСубконто2,
	               |	бит_ЭлементыДанных.ВидСубконто3,
	               |	бит_ЭлементыДанных.ВидСубконто4,
	               |	бит_ЭлементыДанных.Наименование,
	               |	бит_ЭлементыДанных.Родитель.Комментарий КАК Комментарий,
	               |	бит_ЭлементыДанных.ВидИнформационнойБазы,
	               |	бит_ЭлементыДанных.НастройкаПодключения
	               |ИЗ
	               |	Справочник.бит_ЭлементыДанных КАК бит_ЭлементыДанных
	               |ГДЕ
	               |	бит_ЭлементыДанных.Владелец = &СпособКомпоновки
	               |	И бит_ЭлементыДанных.ВидГруппы = ЗНАЧЕНИЕ(Перечисление.бит_ВидыГруппДанных.ВыборкаДанных)
	               |	И ВЫБОР
	               |			КОГДА &ФильтроватьПоМассиву
	               |				ТОГДА бит_ЭлементыДанных.Ссылка В (&МассивЭлементов)
	               |			ИНАЧЕ ИСТИНА
	               |		КОНЕЦ
	               |	И (НЕ бит_ЭлементыДанных.ПометкаУдаления)";
	
	Запрос.УстановитьПараметр("СпособКомпоновки",СпособКомпоновки);				 
	Если МассивЭлементов <> Неопределено Тогда
		Запрос.УстановитьПараметр("МассивЭлементов",МассивЭлементов);
		Запрос.УстановитьПараметр("ФильтроватьПоМассиву",Истина);		
	Иначе
		Запрос.УстановитьПараметр("ФильтроватьПоМассиву",Ложь);
		Запрос.УстановитьПараметр("МассивЭлементов",Новый Массив);		
	КонецЕсли; 
	
	Результат= Запрос.Выполнить();
	
	// При необходимости выполним подключения к информационным базам, из которых следует извлекать данные.
	ТаблицаПодключений = Результат.Выгрузить();
	ТаблицаПодключений.Свернуть("ВидИнформационнойБазы,НастройкаПодключения");
	
	ПулСоединений = Новый Соответствие;
	Для каждого СтрокаТаблицы Из ТаблицаПодключений Цикл
		
		МассивПодключений = ОпределитьНеобходимыеПодключения(НастройкаПулаПодключений, СтрокаТаблицы, Неопределено);
		
		Для каждого ТекНастройкаПодключения Из МассивПодключений Цикл
			
			Если ЗначениеЗаполнено(ТекНастройкаПодключения) Тогда
				
				Если ПулСоединений[ТекНастройкаПодключения] = Неопределено Тогда 
					
					Если  ТекНастройкаПодключения.РасположениеБазы = Перечисления.бит_мпд_ВидыРасположенияИнформационныхБаз.RestСервис Тогда
						
						// HTTP
						ПулСоединений.Вставить(ТекНастройкаПодключения, Неопределено);
						
					Иначе	
						
						// Com
						НовоеПодключение = бит_мпд_ПовтИсп.ПодключитьКОМ(ТекНастройкаПодключения);
						
						Если НЕ НовоеПодключение = Неопределено Тогда
							
							ПулСоединений.Вставить(ТекНастройкаПодключения, НовоеПодключение);
							
						КонецЕсли; 
						
					КонецЕсли; // Расположение базы
					
				КонецЕсли; 
				
			КонецЕсли; 
			
		КонецЦикла; // МассивПодключений
		
	КонецЦикла; // ТаблицаПодключений
	
	Если ПулСоединений.Количество() = 0 Тогда
	
		ПулСоединений = Неопределено;
	
	КонецЕсли; 
	
	ВыборкаЭД = Результат.Выбрать();
	
	КоличествоЭлементовДанных = ВыборкаЭД.Количество();
	
	Если ПоказыватьИндикатор Тогда
		
		ПР = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент; 
		Пр.ОтображатьПроцентВывода=Истина ; 
		Эл = Новый ЭлементРезультатаКомпоновкиДанных; 	
		ПР.НачатьВывод(); 	
		Ном = 1;
		
	КонецЕсли; 
	
	Пока ВыборкаЭД.Следующий() Цикл
		
		Если ПоказыватьИндикатор Тогда
			
			Эл.ПроцентВывода = 100*?(КоличествоЭлементовДанных = 0, 0,Ном/КоличествоЭлементовДанных); 
			ПР.ВывестиЭлемент(Эл); 
			Ном = Ном+1;
			
		КонецЕсли; 
		
		ТаблицаПоИсточнику = Неопределено;
		
		СоотвКолонок = СоотвИсточников[ВыборкаЭД.ИсточникДанных];		
		
		Если ТипЗнч(ВыборкаЭД.ИсточникДанных) = Тип("СправочникСсылка.бит_ИсточникиДанных") Тогда
			
			// Заполним массив субконто для расчета развернутого сальдо.
			МассивСубконто = Новый Массив;
			Для Н=1 По 4 Цикл
				Если ЗначениеЗаполнено(ВыборкаЭД["ВидСубконто"+Н]) Тогда
			       МассивСубконто.Добавить(ВыборкаЭД["ВидСубконто"+Н]);
				КонецЕсли; 
			КонецЦикла; 
			
			Если Параметры = Неопределено Тогда
				Параметры = Новый Структура;
			КонецЕсли;
			
			Если МассивСубконто.Количество()>0 Тогда
			    Параметры.Вставить("МассивСубконто",МассивСубконто);
			КонецЕсли;
			
			// В выбранные поля необходимо добавить субконто по которому идет разворот.
			ВыбранныеПоля = Новый Массив;
			Для Каждого Элемент Из Поля Цикл
				ВыбранныеПоля.Добавить(Элемент);
			КонецЦикла;	
			Для Н=1 По 4 Цикл
				Если ЗначениеЗаполнено(ВыборкаЭД["ВидСубконто"+Н]) Тогда
					ВыбранныеПоля.Добавить("Субконто"+Н);
				КонецЕсли; 
			КонецЦикла; 
			
			Настройка = ВыборкаЭД.НастройкиПостроителя.Получить();
			
			// Получим результат по источнику
			СтрПар = КонструкторПараметры_ПолучитьДанныеПоИсточнику();
			СтрПар.Параметры            = Параметры;
			СтрПар.Настройка            = Настройка;
			СтрПар.Поля                 = ВыбранныеПоля;
			СтрПар.ОтборВОтчете         = ОтборВОтчете;
			СтрПар.НастройкаПодключения = ВыборкаЭД.НастройкаПодключения;
			СтрПар.ПулПодключений       = ПулСоединений;
			СтрПар.НастройкаПулаПодключений = НастройкаПулаПодключений;
			
			ТаблицаПоИсточнику = ПолучитьДанныеПоИсточнику(ВыборкаЭД.ИсточникДанных
															,ГраницаНач
															,ГраницаКон
															,СтрПар);
			
			
		ИначеЕсли ТипЗнч(ВыборкаЭД.ИсточникДанных) = Тип("СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных") Тогда	
			
			// Получаем вложенную таблицу
			ТаблицаВложенная = ВложенныеРезультаты[ВыборкаЭД.ИсточникДанных];
			
			Если ТаблицаВложенная = Неопределено Тогда
			
				 // Вызываем вложенный способ компоновки
				 
				 СтрПарВлож = бит_МеханизмПолученияДанных.КонструкторПараметры_ПолучитьДанныеПоСпособуКомпоновки();
				 СтрПарВлож.Параметры           = Параметры;
				 СтрПарВлож.ОтборВОтчете        = ОтборВОтчете;
				 СтрПарВлож.ПоказыватьИндикатор = Ложь;
				 
				 ТаблицаВложенная = ПолучитьДанныеПоИсточникам(ВыборкаЭД.ИсточникДанных
				                                                ,ГраницаНач
																,ГраницаКон
																,СтрПарВлож);
																
				 ДополнитьРезультатИВыполнитьРасчет(ВыборкаЭД.ИсточникДанных, ТаблицаВложенная);												
																
                 ВложенныеРезультаты.Вставить(ВыборкаЭД.ИсточникДанных,ТаблицаВложенная);																
				 
			КонецЕсли; // Вложенная таблица неопределена
			
			ПостроительЗапроса = Новый ПостроительЗапроса;
			ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(ТаблицаВложенная);
			
			// Применяем ко вложенной таблице отборы элемента данных и отчета.
			Настройка = ВыборкаЭД.НастройкиПостроителя.Получить();			
	        УстановитьОтборЭлементаДанных(ПостроительЗапроса,Настройка);
			УстановитьОтборОтчета(ПостроительЗапроса,ОтборВОтчете);
			
			// Фильтруем данные с помощью построителя
			ПостроительЗапроса.Выполнить();
			
			ТаблицаПоИсточнику = ПостроительЗапроса.Результат.Выгрузить();
			
			
		КонецЕсли; 
		
		Если НЕ ТаблицаПоИсточнику = Неопределено Тогда
			
			КолонкиИсточника = ТаблицаПоИсточнику.Колонки;
			
			// Добавим результат по источнику в результирующую таблицу.
			Для каждого СтрокаПоИсточнику Из ТаблицаПоИсточнику Цикл
				
				НоваяСтрока = ТаблицаРезультат.Добавить();
				// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
				
				//НоваяСтрока.ЭлементДанных       = ВыборкаЭД.ЭлементДанных;
				//НоваяСтрока.ГруппаЭлементДанных = ВыборкаЭД.ГруппаЭлементДанных;
				//НоваяСтрока.Кодификатор         = ВыборкаЭД.ЭлементДанных.Кодификатор;
				//НоваяСтрока.Коэффициент         = ВыборкаЭД.Коэффициент;
				//НоваяСтрока.ВидГруппы           = ВыборкаЭД.ЭлементДанных.ВидГруппы;
				
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ВыборкаЭД, "ЭлементДанных, ГруппаЭлементДанных, Кодификатор, ВидГруппы, Коэффициент");
				// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
				
				Для каждого Колонка Из КолонкиИсточника Цикл
					
					ИмяКолонкиРезультат = СоотвКолонок[Колонка.Имя];
					
					Если ИмяКолонкиРезультат <> Неопределено Тогда
						
						Если МассивРесурсов.Найти(ИмяКолонкиРезультат) <> Неопределено Тогда
							ЗначениеПоИсточнику = СтрокаПоИсточнику[Колонка.Имя];
							Если ТипЗнч(ЗначениеПоИсточнику) <> Тип("Число") Тогда
								ЗначениеПоИсточнику = 0;
							КонецЕсли; 
							НоваяСтрока[ИмяКолонкиРезультат] = ЗначениеПоИсточнику*НоваяСтрока.Коэффициент;
							НоваяСтрока[ИмяКолонкиРезультат+"Исходный"] = ЗначениеПоИсточнику;
						Иначе	
							НоваяСтрока[ИмяКолонкиРезультат] = СтрокаПоИсточнику[Колонка.Имя];
						КонецЕсли;
						
					КонецЕсли; // Нашли колонку-результат
					
				КонецЦикла; // По колонкам таблицы источника
				
			КонецЦикла; // По строкам таблицы источника
			
		КонецЕсли; // Таблица источник есть
		
		
		// ТаблицаПоИсточнику.ВыбратьСтроку();
	КонецЦикла; // по элементам данных
	
	Если ПоказыватьИндикатор Тогда
        ПР.ЗакончитьВывод(); 		
	КонецЕсли;
	
	ПересчитатьРесурсыПоКурсам(СпособКомпоновки
	                                 , ГраницаНач
									 , ГраницаКон
									 , СтрПар
									 , ТаблицаРезультат);
	
	Возврат ТаблицаРезультат;
	
КонецФункции // ПолучитьДанныеПоИсточникам()

// Получает список полей определенного вида для способа компоновки источника данных.
// 
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ВидКолонки        - Строка- "Поле","Ресурс".
//  ТипРезультата    - Строка - "Структура","Массив","СписокЗначений".
// 
// Возвращаемое значение:
//   МассивПолей   - Массив,СписокЗначений,Структура.
// 
Функция ПолучитьСписокПолейДляСпособаКомпоновки(СпособКомпоновки, ВидКолонки, ТипРезультата = "Массив") Экспорт
	
	
	// Определим тип возвращаемого результата
	РезультатМассив    = ?(ВРег(ТипРезультата)="МАССИВ",Истина,Ложь);
	РезультатСписок    = ?(ВРег(ТипРезультата)="СПИСОКЗНАЧЕНИЙ",Истина,Ложь);
	РезультатСтруктура = НЕ РезультатМассив И НЕ РезультатСписок;
	
	Если РезультатСтруктура Тогда
		МассивПолей = Новый Структура;
	КонецЕсли; 
	Если РезультатМассив Тогда
		МассивПолей = Новый Массив;
	КонецЕсли; 
	Если РезультатСписок Тогда
		МассивПолей = Новый СписокЗначений;
	КонецЕсли;  
	
	
	Для каждого СтрокаТаблицы Из СпособКомпоновки.КолонкиТаблицы Цикл
		
		
		Если ВидКолонки = "Все" Тогда
			Если РезультатСтруктура Тогда
				МассивПолей.Вставить(СтрокаТаблицы.ИмяКолонки);
			Иначе	
				МассивПолей.Добавить(СтрокаТаблицы.ИмяКолонки);
			КонецЕсли; 
		Иначе	
			Если СтрокаТаблицы.ВидКолонки = ВидКолонки Тогда
				
				Если РезультатСтруктура Тогда
					МассивПолей.Вставить(СтрокаТаблицы.ИмяКолонки);
				Иначе	
					МассивПолей.Добавить(СтрокаТаблицы.ИмяКолонки);
				КонецЕсли; 
				
			КонецЕсли; 
		КонецЕсли; 
		
	КонецЦикла; 
	
	Возврат МассивПолей;
КонецФункции // БитПолучитьСписокРесурсовДляСпособа()

// Процедура формирует список источников, используемых в данном способе компоновки.
// 
// 
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
// 
// Возвращаемое значение:
//  РезСписок   - СписокЗначений.
// 
Функция СформироватьСписокИсточники(СпособКомпоновки) Экспорт
	
	РезСписок = Новый СписокЗначений;
	
	Для каждого СтрокаТаблицы Из СпособКомпоновки.ИсточникиДанных Цикл
		
		РезСписок.Добавить(СтрокаТаблицы.ИсточникДанных);
		
	КонецЦикла; 
	
	
	Возврат РезСписок;
КонецФункции // СформироватьСписокИсточники()

// Инициализирует таблицу в которой будут собираться результирующие данные.
// 
// 
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  МассивРесурсов    - Массив.
// 
// Возвращаемое значение:
//  ТаблицаЗначений   - ТаблицаРезультат.
// 
Функция ИнициализироватьТаблицуРезультат(СпособКомпоновки,МассивРесурсов)  Экспорт

	ТаблицаРезультат = Новый ТаблицаЗначений;
	 
	ОписаниеЭлементДанных = Новый ОписаниеТипов("СправочникСсылка.бит_ЭлементыДанных");
	ОписаниеЧисло         = Новый ОписаниеТипов("Число");
	ОписаниеСтрока        = Новый ОписаниеТипов("Строка"); 
	ОписаниеЛюбыхТипов    = бит_ОбщегоНазначения.ОписаниеПроизвольногоТипа();
	 
	// МассивДобавляемых = Новый Массив;
	// МассивДобавляемых.Добавить(Тип("ЭлементСпискаЗначений"));
	// ОписаниеЛюбыхТипов    = Новый ОписаниеТипов(ОписаниеЛюбыхТипов,МассивДобавляемых);
	 
	// Обязательные колонки
	ТаблицаРезультат.Колонки.Добавить("ГруппаЭлементДанных", ОписаниеЭлементДанных);	 
	ТаблицаРезультат.Колонки.Добавить("ЭлементДанных"		, ОписаниеЭлементДанных);
	ТаблицаРезультат.Колонки.Добавить("Кодификатор"		, ОписаниеСтрока);
	ТаблицаРезультат.Колонки.Добавить("Коэффициент"		, ОписаниеЧисло);
	ТаблицаРезультат.Колонки.Добавить("ВидГруппы"			, Новый ОписаниеТипов("ПеречислениеСсылка.бит_ВидыГруппДанных"));                                                        	 
	 
	Для каждого СтрокаТаблицы Из СпособКомпоновки.КолонкиТаблицы Цикл
		 
		Если МассивРесурсов.Найти(СтрокаТаблицы.ИмяКолонки)<>Неопределено Тогда
			// Для ресурсов сохраним первоначальное значение и значение с коэффициентом.
			ТаблицаРезультат.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки + "Исходный", ОписаниеЧисло);
			ТаблицаРезультат.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки, ОписаниеЧисло);
		Иначе
		 	// Получим описание типов для колонки
			ТекОписание = Неопределено;
			Если ТипЗнч(СтрокаТаблицы.ОписаниеТипов) = Тип("ХранилищеЗначения") Тогда   				 
				ТекОписание = СтрокаТаблицы.ОписаниеТипов.Получить();                   				 
			КонецЕсли; 
			// Добавим колонку в таблицу значений
			Если ТипЗнч(ТекОписание) <> Тип("ОписаниеТипов") Или ТекОписание.Типы().Количество() = 0 Тогда
				ТаблицаРезультат.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки, ОписаниеЛюбыхТипов);
			Иначе	
				ТаблицаРезультат.Колонки.Добавить(СтрокаТаблицы.ИмяКолонки, ТекОписание);	 
			КонецЕсли; // Для колонки установлено описание
			 
		 КонецЕсли; // Это ресурс 
		 
	 КонецЦикла; // По колонкам таблицы
	 
	 // ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
	 ТаблицаРезультат.Индексы.Добавить("ЭлементДанных");
	 // ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
	 
	 Возврат ТаблицаРезультат;
	 
КонецФункции // ИнициализироватьТаблицуРезультат()

// Функция сворачивает результат по измерениям. 
// Если имена измерений не переданы, то сворачивает только по группе элемента данных и иерархическому коду.
// 
// Параметры
//  ВходящаяТаблица  - ТаблицаЗначений.
//  МассивРесурсов   - Массив.
//  МассивИзмерений  - Массив.
// 
// Возвращаемое значение:
//   ТаблицаРезультат   - ТаблицаЗначений.
// 
// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
//Функция СвернутьРезультат(ВходящаяТаблица,МассивРесурсов,МассивИзмерений=Неопределено) Экспорт
Функция СвернутьРезультат(Знач ТаблицаРезультат,МассивРесурсов,МассивИзмерений=Неопределено) Экспорт

	//ТаблицаРезультат = ВходящаяТаблица.Скопировать();
// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)

	КолонкиТаблицы   = ТаблицаРезультат.Колонки;
	
	ИменаРесурсов = "";
	Для каждого Ресурс Из МассивРесурсов Цикл
		Если НЕ КолонкиТаблицы.Найти(Ресурс) = Неопределено Тогда
			ИменаРесурсов = ИменаРесурсов + ?(ПустаяСтрока(ИменаРесурсов),"",",") + Ресурс;			
		КонецЕсли; 
	КонецЦикла; 
	
	ИменаИзмерений = "ГруппаЭлементДанных,ЭлементДанных,Кодификатор";
	Если МассивИзмерений <> Неопределено Тогда
		Для каждого Измерение Из МассивИзмерений Цикл
			Если НЕ КолонкиТаблицы.Найти(Измерение) = Неопределено Тогда
				ИменаИзмерений = ИменаИзмерений+?(ПустаяСтрока(ИменаИзмерений),"",",")+Измерение;	
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли; 
	
	Попытка
		ТаблицаРезультат.Свернуть(ИменаИзмерений,ИменаРесурсов);	
	Исключение
		ТекстСообщения = Нстр("ru = 'Невозможно сформировать отчет. Измените настройку.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
	КонецПопытки; 	
	
	Возврат ТаблицаРезультат;
	
КонецФункции // СвернутьРезультатПоГруппам()

// Процедура выполняет расчет по формулам для способа компоновки и дополняет результат 
// элементами типа группа.
// 
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ТаблицаРезультат  - ТаблицаЗначений - Содержит данные полученные запросами по элементам данных.
// 
Процедура ДополнитьРезультатИВыполнитьРасчет(СпособКомпоновки,ТаблицаРезультат) Экспорт
	
	Ресурсы        = ПолучитьСписокПолейДляСпособаКомпоновки(СпособКомпоновки,"Ресурс");
	
	ТаблицаРезультат.Колонки.Добавить("Обработана",Новый ОписаниеТипов("Булево"));
	
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	бит_ЭлементыДанных.Ссылка КАК Группа,
	               |	бит_ЭлементыДанных.Кодификатор КАК Кодификатор,
	               |	бит_ЭлементыДанных.ВидГруппы,
	               |	бит_ЭлементыДанных.Коэффициент,
	               |	бит_ЭлементыДанных.Родитель,
	               |	ЛОЖЬ КАК Обработана
	               |ИЗ
	               |	Справочник.бит_ЭлементыДанных КАК бит_ЭлементыДанных
	               |ГДЕ
	               |	(бит_ЭлементыДанных.ВидГруппы = ЗНАЧЕНИЕ(Перечисление.бит_ВидыГруппДанных.Группировка)
	               |			ИЛИ бит_ЭлементыДанных.ВидГруппы = ЗНАЧЕНИЕ(Перечисление.бит_ВидыГруппДанных.Формула))
	               |	И бит_ЭлементыДанных.Владелец = &Владелец
	               |	И (НЕ бит_ЭлементыДанных.ПометкаУдаления)
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Группа ИЕРАРХИЯ,
				   |    Кодификатор";
	
	Запрос.УстановитьПараметр("Владелец",СпособКомпоновки);
	
	Результат = Запрос.Выполнить();
	
	Дерево = Результат.Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	// Дерево.ВыбратьСтроку();
	
	// Выполним расчеты по формулам
	СтрИзмеренияСвертки = "";
	СтрРесурсы          = "";
	СформироватьСтрокиИзмеренияРесурсы(СпособКомпоновки,Ресурсы,СтрИзмеренияСвертки,СтрРесурсы);
	
	// Сворачиваем таблицу
	ТаблицаДляФормул = ТаблицаРезультат.Скопировать();               
	ТаблицаДляФормул.Свернуть(СтрИзмеренияСвертки,СтрРесурсы);
	
	// Вычисляем формулы
	ОбойтиИерархию(Дерево,ТаблицаДляФормул,Ресурсы);
	
	// Добавим результаты расчета в ТаблицуРезультат.
	Для каждого СтрокаРезВычислений Из ТаблицаДляФормул Цикл
		
		Если СтрокаРезВычислений.ВидГруппы = Перечисления.бит_ВидыГруппДанных.Формула Тогда
			
			НоваяСтрока = ТаблицаРезультат.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаРезВычислений);
			
		ИначеЕсли СтрокаРезВычислений.ВидГруппы = Перечисления.бит_ВидыГруппДанных.Группировка Тогда	
			
			СтрокаПоиска = ТаблицаРезультат.Найти(СтрокаРезВычислений.ЭлементДанных,"ЭлементДанных");
			Если СтрокаПоиска = Неопределено Тогда
				
				НоваяСтрока = ТаблицаРезультат.Добавить();			
				ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаРезВычислений);
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	// В случае, когда выводим данные по группировкам с помощью компоновки, то не суммировать по группировкам не нужно.
	Если СпособКомпоновки.НеРассчитыватьИтогиПоГруппам Тогда
		
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("ВидГруппы",Перечисления.бит_ВидыГруппДанных.Группировка);
		
		МассивСтрок = ТаблицаРезультат.НайтиСтроки(СтрОтбор);
		
		Для каждого СтрокаРезультат Из МассивСтрок Цикл
			Для каждого ИмяРесурса Из Ресурсы Цикл
				СтрокаРезультат[ИмяРесурса+"Исходный"] = 0;
				СтрокаРезультат[ИмяРесурса]            = 0;						
			КонецЦикла;
		КонецЦикла; 
		
	КонецЕсли; 
	
	ТаблицаРезультат.Сортировать("Кодификатор, ЭлементДанных");
	
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
	//ТаблицаРезультат.Сортировать("Кодификатор, ЭлементДанных");
	ОбъектСравнения = Новый СравнениеЗначений;
	ТаблицаРезультат.Сортировать("Кодификатор, ЭлементДанных", ОбъектСравнения);
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
	
	// Дерево.ВыбратьСтроку();
	
КонецПроцедуры	

// Процедура дополняет таблицу компоновки элементами данных с видом группировки "Текст".
// 
// Параметры:
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ТаблицаРезультат  - ТаблицаЗначений.
// 
Процедура ДополнитьТаблицуКомпоновкиТекстовымиЭлементами(СпособКомпоновки, ТаблицаРезультат) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Владелец", СпособКомпоновки);
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	бит_ЭлементыДанных.Ссылка 		КАК ЭлементДанных,
	|	бит_ЭлементыДанных.Кодификатор  КАК Кодификатор,
	|	бит_ЭлементыДанных.ВидГруппы,
	|	бит_ЭлементыДанных.Коэффициент,
	|	ЛОЖЬ КАК Обработана
	|ИЗ
	|	Справочник.бит_ЭлементыДанных КАК бит_ЭлементыДанных
	|ГДЕ
	|	бит_ЭлементыДанных.ВидГруппы = ЗНАЧЕНИЕ(Перечисление.бит_ВидыГруппДанных.Текст)
	|	И (НЕ бит_ЭлементыДанных.ПометкаУдаления)
	|	И бит_ЭлементыДанных.Владелец = &Владелец
	|				   
	|	УПОРЯДОЧИТЬ ПО
	|	Кодификатор
	|";
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
	
		НоваяСтрока = ТаблицаРезультат.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
	
	КонецЦикла;	

КонецПроцедуры // ДополнитьТаблицуКомпоновкиТекстовымиЭлементами()

// Функция восстанавливает координаты области по имени области.
// 
// Параметры:
//  ИмяОбласти  - Строка
// 
// Возвращаемое значение:
//   СтрКоординат   - Структура
// 
Функция ВосстановитьКоординатыОбластиПоИмени(ИмяОбласти) Экспорт

	СтрКоординат = КонструкторСтруктурыКоординат();	
	ТекСтр = ИмяОбласти;
	ТекСтр = СтрЗаменить(ТекСтр,":","");
	ТекСтр = СтрЗаменить(ТекСтр," ","");
	
	СтрКоординат.Верх  = ВосстановитьКоординату(ТекСтр,"R","C");
	СтрКоординат.Лево  = ВосстановитьКоординату(ТекСтр,"C","R");
	СтрКоординат.Низ   = ВосстановитьКоординату(ТекСтр,"R","C");
	СтрКоординат.Право = ВосстановитьКоординату(ТекСтр,"C","R");
	
	Возврат СтрКоординат;

КонецФункции // ВосстановитьКоординатыОбластиПоИмени()

// Функция формирует имя области по координатам.
// 
// Параметры:
//  СтрКоординат    - Структура
// 
// Возвращаемое значение:
//   СтрКоординат   - Структура
// 
Функция СформироватьИмяОбластиПоКоординатам(СтрКоординат) Экспорт

	ИмяОбласти = "";
	
	Если СтрКоординат.Верх <> 0 Тогда
	
		ИмяОбласти = ИмяОбласти+"R"+СтрКоординат.Верх;
	
	КонецЕсли; 
	
	Если СтрКоординат.Лево <> 0 Тогда
	
	  ИмяОбласти = ИмяОбласти+"C"+СтрКоординат.Лево;
	
	КонецЕсли; 
	
	Если СтрКоординат.Низ <> 0 Тогда
		
		Если НЕ ПустаяСтрока(ИмяОбласти) Тогда
		
			ИмяОбласти = ИмяОбласти+":";
		
		КонецЕсли; 
		ИмяОбласти = ИмяОбласти+"R"+СтрКоординат.Низ;
	
	КонецЕсли; 
	
	Если СтрКоординат.Право <> 0 Тогда
	
		ИмяОбласти = ИмяОбласти+"C"+СтрКоординат.Право;
	
	КонецЕсли; 
	
	Возврат ИмяОбласти;

КонецФункции // СформироватьИмяОбластиПоКоординатам()

// Функция инициализирует структуру для описания координат области.
// 
// Параметры:
//  Лево  - Число
//  Верх  - Число
//  Право - Число
//  Низ   - Число
// 
// Возвращаемое значение:
//   СтрКоординат   - Структура
// 
Функция КонструкторСтруктурыКоординат(Лево=0,Верх=0,Право=0,Низ=0) Экспорт

	СтрКоординат = Новый Структура("Лево,Верх,Право,Низ",Лево,Верх,Право,Низ);
	
	Возврат СтрКоординат;

КонецФункции // КонструкторСтруктурыКоординат()

// Функция формирует имя области табличного документа.
// 
// Параметры:
//  Префикс      - Строка
//  НомерОбласти - Число
//  Постфикс     - Строка
// 
// Возвращаемое значение:
//   ИмяОбласти   - Строка
// 
Функция СформироватьИмяОбласти(Префикс,НомерОбласти,Длина,Постфикс="")  Экспорт
	
	Длина      = ?(Длина=0,9,Длина);
	СтрФормат  = "ЧЦ="+Длина+"; ЧВН=; ЧГ=";
	ИмяОбласти = Префикс+Формат(НомерОбласти,СтрФормат)+Постфикс;
	
	Возврат ИмяОбласти;
	
КонецФункции // СформироватьИмяОбласти()

// Функция определяет сформировано ли имя области в типовом стиле R<>C<>.
// 
// Параметры:
//  ИмяОбласти  - Строка.
// 
// Возвращаемое значение:
//   флИмяОбластиТиповое   - Булево.
// 
Функция ИмяОбластиТиповое(ИмяОбласти) Экспорт

	флИмяОбластиТиповое = Ложь;
	
	Если Найти(ВРЕГ(ИмяОбласти),"R")>0 ИЛИ Найти(ВРЕГ(ИмяОбласти),"C")>0 Тогда
	
		флИмяОбластиТиповое = Истина;
	
	КонецЕсли; 
	
	Возврат флИмяОбластиТиповое;

КонецФункции // ИмяОбластиТиповое()

// Функция инициализирует структуру настроек расшифровки произвольного отчета.
// 
// Возвращаемое значение:
//  СтруктураНастроек - Структура.
// 
Функция КонструкторНастройкиРасшифровкиПроизвольногоОтчета()  Экспорт

	СтруктураНастроек = Новый Структура("Заголовок
	                                       |,ИмяОбласти
	                                       |,ЭлементДанных
										   |,НастройкаПодключения
										   |,НастройкаПулаПодключений
										   |,ВидИнформационнойБазы
										   |,ИсточникДанных
										   |,ИмяРесурса
										   |,ВидЯчейки
										   |,ВидЭлементаДанных
										   |,Формула
										   |,ФорматЧисел");
	
	

	Возврат СтруктураНастроек;
	
КонецФункции // КонструкторНастройкиРасшифровкиПроизвольногоОтчета()

// Функция формирует настройку расшифровки произвольного отчета.
// 
// Параметры:
//  СтрокаТаблицы  - СтрокаТабличнойЧасти.
// 
// Возвращаемое значение:
//   СтруктураНастроек   - Структура.
// 
Функция СформироватьНастройкуРасшифровкиПроизвольногоОтчета(СтрокаТаблицы, НастройкаПулаПодключений) Экспорт
	
	СтруктураНастроек = КонструкторНастройкиРасшифровкиПроизвольногоОтчета();	
										   
    СтруктураНастроек.Заголовок                = "";										   
	СтруктураНастроек.ИмяОбласти               = СтрокаТаблицы.Код;
	СтруктураНастроек.ЭлементДанных            = СтрокаТаблицы.ЭлементДанных;
	СтруктураНастроек.НастройкаПодключения     = СтрокаТаблицы.ЭлементДанных.НастройкаПодключения;
	СтруктураНастроек.НастройкаПулаПодключений = НастройкаПулаПодключений;
	СтруктураНастроек.ВидИнформационнойБазы= СтрокаТаблицы.ЭлементДанных.ВидИнформационнойБазы;
	СтруктураНастроек.ИсточникДанных       = СтрокаТаблицы.ЭлементДанных.ИсточникДанных;
	СтруктураНастроек.ИмяРесурса           = СтрокаТаблицы.ИмяРесурса;
	СтруктураНастроек.ВидЯчейки            = СтрокаТаблицы.ВидЯчейки;
	СтруктураНастроек.ВидЭлементаДанных    = СтрокаТаблицы.ЭлементДанных.ВидГруппы;
	СтруктураНастроек.Формула              = СтрокаТаблицы.Формула;
	СтруктураНастроек.ФорматЧисел          = СтрокаТаблицы.ФорматЧисел;

	Возврат СтруктураНастроек;
	
КонецФункции // СформироватьНастройкуРасшифровкиПроизвольногоОтчета()

#КонецОбласти

#Область ФормированиеПроизвольногоОтчета

// Функция заполняет структуру параметров из таблицы значений.
// 
// Параметры:
//  ТаблицаПараметров - ТаблицаЗначений.
//  
// Возвращаемое значение:
//   Структура
// 
Функция ЗаполнитьСтруктуруПараметровИзТаблицы(ТаблицаПараметры) Экспорт

	СтруктураПараметров = Новый Структура;
	
	Для каждого СтрокаТаблицы Из ТаблицаПараметры Цикл
		
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.ИмяПараметра) Тогда			
			Продолжить;			
		КонецЕсли;
		
		Попытка
			НайденПараметр = СтруктураПараметров.Свойство(СтрокаТаблицы.ИмяПараметра);		
		Исключение
			Продолжить;
		КонецПопытки;
		
		Если НЕ НайденПараметр Тогда
						
			Если СтрокаТаблицы.ВидПараметра = Перечисления.бит_ВидыПараметровЗапроса.Выражение Тогда
				
				Попытка
					ТекЗначение = Вычислить(СтрокаТаблицы.ЗначениеПараметра);
				Исключение  					
					ТекЗначение = Неопределено;					
				КонецПопытки;	
				
			Иначе
				
				ТекЗначение = СтрокаТаблицы.ЗначениеПараметра
			  
			КонецЕсли; 
			
			СтруктураПараметров.Вставить(СтрокаТаблицы.ИмяПараметра, ТекЗначение); 			
			
		КонецЕсли; // Параметр еще не добавлен
	
	КонецЦикла;  // ТаблицаПараметры
			  

	Возврат СтруктураПараметров;
	
КонецФункции // ЗаполнитьСтруктуруПараметровИзТаблицы()

// Процедура дополняет структуру параметров, параметрами,
// обязательными к использованию в произвольном отчете.
// 
// Параметры:
//  ТекОбъект - ОтчетОбъект.бит_ПроизвольныйОбъект, СправочникСсылка.бит_ЭкземплярыПроизвольныхОтчетов.
//  Параметры - Структура.
// 
Процедура ДобавитьОбязательныеПараметрыПроизвольногоОтчета(ТекОбъект, Параметры) Экспорт

	Если ТипЗнч(ТекОбъект) <> Тип("Структура")
		И ТекОбъект.НастройкаОтчета.ТипОтчета = Перечисления.бит_ТипыПроизвольныхОтчетов.ОтчетностьМСФО Тогда
		
		// Как параметр организация передается только для отчетов МСФО, в остальных случаях можно воспользоваться отборами.
		Параметры.Вставить("Организация", ТекОбъект.Организация);
		
	КонецЕсли; 
	
	Параметры.Вставить("ВалютаОтчета"   , ТекОбъект.ВалютаДокумента);
	Параметры.Вставить("КурсОтчета"     , ТекОбъект.КурсДокумента);
	Параметры.Вставить("КратностьОтчета", ТекОбъект.КратностьДокумента);
	
	КонецПериодаПрошлый 	= ДобавитьМесяц(КонецДня(ТекОбъект.ДатаОкончания), -12);
	КонецПериодаПозапрошлый = ДобавитьМесяц(КонецДня(ТекОбъект.ДатаОкончания), -24);
	
	Параметры.Вставить("КонецПериодаПрошлый"    ,	 Новый Граница(КонецПериодаПрошлый, ВидГраницы.Включая));
	Параметры.Вставить("КонецПериодаПрошлыйДата",	 КонецПериодаПрошлый);
	Параметры.Вставить("КонецПериодаПозапрошлый"    ,Новый Граница(КонецПериодаПозапрошлый, ВидГраницы.Включая));
	Параметры.Вставить("КонецПериодаПозапрошлыйДата",КонецПериодаПозапрошлый);
	Параметры.Вставить("КонецПрошлогоГода",			 Новый Граница(КонецГода(КонецПериодаПрошлый), ВидГраницы.Включая));
	Параметры.Вставить("КонецПрошлогоГодаДата",		 КонецГода(КонецПериодаПрошлый));
	Параметры.Вставить("КонецПозапрошлогоГода",		 Новый Граница(КонецГода(КонецПериодаПозапрошлый), ВидГраницы.Включая));
	Параметры.Вставить("КонецПозапрошлогоГодаДата",	 КонецГода(КонецПериодаПозапрошлый));
	
КонецПроцедуры // ДобавитьОбязательныеПараметрыПроизвольногоОтчета()

// Процедура выполняет формирование произвольного отчета.
// 
// Параметры:
//  ТекОбъект          - СправочникСсылка.бит_НастройкиПроизвольныхОтчетов.
//  ТабличныйДокумент  - ТабличныйДокумент.
//  ОтборВОтчете       - ТаблицаЗначений.
//  ТаблицаПараметры   - ТаблицаЗначений.
//  ТаблицаДанныеОтчета- ТаблицаЗначений.
//  НастройкаПулаПодключений - СправочникСсылка.бит_мпд_НастройкиПуловПодключений.
// 
Процедура СформироватьПроизвольныйОтчет(ТекОбъект, ТабличныйДокумент, ОтборВОтчете, ТаблицаПараметры,
				ТаблицаДанныеОтчета, НастройкаПулаПодключений = Неопределено) Экспорт

	НастройкаОтчета 				   = ТекОбъект.НастройкаОтчета;
	флОтборПоАналитикаПравилЗаполнения = НастройкаОтчета.УстанавливатьОтборПоАналитикеПравилЗаполнения;
	
	Если НЕ ЗначениеЗаполнено(НастройкаОтчета) Тогда
		ТабличныйДокумент.Очистить();
		ТекстСообщения = НСтр("ru = 'Не заполнена настройка отчета.'");
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		Возврат;
		//ВызватьИсключение ТекстСообщения;
	КонецЕсли; 
	
	СписокРеквизитовНастройки = "ТипОтчета, ХранилищеМакета, СпособКомпоновки, ОтображатьПериод";
	РеквизитыНастройки 		  = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(НастройкаОтчета, СписокРеквизитовНастройки); 
	
	// Если отчет предназначен для МСФО принудительно установим дату начала.
	ТекОбъект.ДатаНачала = ОпределитьДатуНачалаДляМСФО(РеквизитыНастройки.ТипОтчета,ТекОбъект.ДатаНачала,ТекОбъект.ДатаОкончания);
	
	// Получим макет отчета
	СохраненныйМакет = РеквизитыНастройки.ХранилищеМакета.Получить();
	
	Если СохраненныйМакет = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ГраницаНач = ТекОбъект.ДатаНачала;
	ГраницаКон = Новый Граница(КонецДня(ТекОбъект.ДатаОкончания), ВидГраницы.Включая);
	
	Параметры = ЗаполнитьСтруктуруПараметровИзТаблицы(ТаблицаПараметры);
	ДобавитьОбязательныеПараметрыПроизвольногоОтчета(ТекОбъект,Параметры);
	
	СпособКомпоновки = РеквизитыНастройки.СпособКомпоновки;
	
	// Получаем результирующую таблицу с данными.
	ПоказыватьИндикатор = Не бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("НеОтображатьИндикаторКомпоновкиИсточников",
								бит_ОбщиеПеременныеСервер.ЗначениеПеременной("глТекущийПользователь"));	
								
	СтрПар = бит_МеханизмПолученияДанных.КонструкторПараметры_ПолучитьДанныеПоСпособуКомпоновки();
	СтрПар.Параметры                = Параметры;
	СтрПар.ОтборВОтчете             = ОтборВОтчете;
	СтрПар.ПоказыватьИндикатор      = ПоказыватьИндикатор;
	СтрПар.НастройкаПулаПодключений = НастройкаПулаПодключений;
	
	мТаблицаРезультат = бит_МеханизмПолученияДанных.ПолучитьДанныеПоИсточникам(СпособКомпоновки
	                                                                           ,ГраницаНач
																			   ,ГраницаКон
																			   ,СтрПар);
																			   
	бит_МеханизмПолученияДанных.ДополнитьРезультатИВыполнитьРасчет(СпособКомпоновки,мТаблицаРезультат);
	
	// Выполняем свертку
	МассивРесурсов  = бит_МеханизмПолученияДанных.ПолучитьСписокПолейДляСпособаКомпоновки(СпособКомпоновки,"Ресурс");
	ПоляАналитики   = Справочники.бит_НастройкиПроизвольныхОтчетов.ПолучитьПоляАналитики(НастройкаОтчета);
	АналитикиПоля	= Новый Соответствие;
	МассивИзмерений = Новый Массив;
	
	Для каждого КиЗ Из ПоляАналитики Цикл
		МассивИзмерений.Добавить(КиЗ.Ключ);
		АналитикиПоля.Вставить(КиЗ.Значение, КиЗ.Ключ);
	КонецЦикла; 
	
	флЕстьПериод = (мТаблицаРезультат.Колонки.Найти("Период")<>Неопределено);
	флЕстьПериод = ФлЕстьПериод И РеквизитыНастройки.ОтображатьПериод;
	
	Если флЕстьПериод Тогда
		МассивИзмерений.Добавить("Период");
	КонецЕсли; 
	
	мТаблицаРезультат = бит_МеханизмПолученияДанных.СвернутьРезультат(мТаблицаРезультат,МассивРесурсов,МассивИзмерений);
	
	// По таблице будет выполнятеся поиск - надо подготовиться.
	Если мТаблицаРезультат.Количество() > 1000 Тогда
	
		мТаблицаРезультат.Индексы.Очистить();
		Поля = "ЭлементДанных";
		Если НЕ мТаблицаРезультат.Колонки.Найти("Период") = Неопределено Тогда
			Поля = Поля + ", Преиод";
		КонецЕсли; 
		мТаблицаРезультат.Индексы.Добавить(Поля);
	КонецЕсли; 
	
	ТабличныйДокумент.Очистить();
    ТабличныйДокумент.Вывести(СохраненныйМакет);
	
	УстановитьПараметрыВДокРезультат(ТекОбъект,ТабличныйДокумент,ОтборВОтчете, ТаблицаПараметры);
	
	// Заполним значения
	ПоказателиПроизвольныхОтчетов = Справочники.бит_НастройкиПроизвольныхОтчетов.ПолучитьПоказателиВида(НастройкаОтчета, 
										Перечисления.бит_ВидыЯчеекПроизвольногоОтчета.Значение);
	ТаблицаДанныеОтчета.Очистить();
	
	Для каждого ПоказательОтчета Из ПоказателиПроизвольныхОтчетов Цикл
		
		// Проверим на тип, т.к. далее будем обращаться к свойствам.
		Если НЕ ТипЗнч(ПоказательОтчета.ЭлементДанных) = Тип("СправочникСсылка.бит_ЭлементыДанных") Тогда
			Продолжить;
		КонецЕсли; 
		
		Фильтр = Новый Структура("ЭлементДанных",ПоказательОтчета.ЭлементДанных);
		Если флОтборПоАналитикаПравилЗаполнения Тогда
			
			// дополнительный отбор по аналитике правил заполнения
			Если НЕ мТаблицаРезультат.Колонки.Найти("Период") = Неопределено Тогда
				Фильтр.Вставить("Период", ПоказательОтчета.ПериодДанных);
			КонецЕсли; 
			
			Если ТипЗнч(ПоказательОтчета.ЗначенияПоУмолчанию) = Тип("ТаблицаЗначений") Тогда
				
				Для каждого СтрокаТаблицы Из ПоказательОтчета.ЗначенияПоУмолчанию Цикл
					ИмяПоля = АналитикиПоля[СтрокаТаблицы.ИмяАналитики];
					
					Если НЕ ИмяПоля = Неопределено И НЕ мТаблицаРезультат.Колонки.Найти(ИмяПоля) = Неопределено Тогда
						Фильтр.Вставить(ИмяПоля, СтрокаТаблицы.ЗначениеАналитики);
					КонецЕсли; 
				КонецЦикла; 
			КонецЕсли; 
		КонецЕсли; // флОтборПоАналитикаПравилЗаполнения
		
		СтрокиРезультат  = мТаблицаРезультат.НайтиСтроки(Фильтр);
		КолонкиРезультат = мТаблицаРезультат.Колонки;
		
		ИтогЗначениеПоказателя = 0;
		Для каждого СтрокаРезультат Из СтрокиРезультат Цикл
			
			ЗначениеКУстановке = СтрокаРезультат[ПоказательОтчета.ИмяРесурса];
			Если ТипЗнч(ЗначениеКУстановке) <> Тип("Число") Тогда
				ЗначениеКУстановке = 0;
			КонецЕсли; 
			
			ИтогЗначениеПоказателя = ИтогЗначениеПоказателя + ЗначениеКУстановке;
			
			СтрокаДанныеОтчета = ТаблицаДанныеОтчета.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаДанныеОтчета, ПоказательОтчета);
			
			СтрокаДанныеОтчета.ЗначениеПоказателя   = ЗначениеКУстановке;
			СтрокаДанныеОтчета.ИД                   = Строка(Новый УникальныйИдентификатор);
			
			Если флЕстьПериод Тогда
				СтрокаДанныеОтчета.ПериодДанных = СтрокаРезультат.Период;
			КонецЕсли; 
			
			// Заполним аналитику
			Для каждого КиЗ Из ПоляАналитики Цикл
				Если НЕ КолонкиРезультат.Найти(КиЗ.Ключ) = Неопределено Тогда
					СтрокаДанныеОтчета[КиЗ.Значение] = СтрокаРезультат[КиЗ.Ключ];
				КонецЕсли; 
			КонецЦикла; 
		КонецЦикла; 
		
		УстановитьЗначениеВТабличныйДокумент(ТабличныйДокумент, ПоказательОтчета.ИмяОбласти, ИтогЗначениеПоказателя);
	КонецЦикла;  // По таблице правил
	
	ВыполнитьРасчет(ТекОбъект.НастройкаОтчета, ТабличныйДокумент, ТаблицаДанныеОтчета);
	УстановитьФорматВывода(НастройкаОтчета,ТабличныйДокумент,ТекОбъект.ФорматЧисел, ТекОбъект.Язык);
	
	Если флЕстьПериод Тогда
		ТаблицаДанныеОтчета.Сортировать("ПериодДанных");
	КонецЕсли; 
	
	ТабличныйДокумент.ТолькоПросмотр = Истина;
	
КонецПроцедуры // СформироватьОтчет()

// Процедура выполняет расчет значений ячеек, рассчитываемых по формулам.
// 
// Параметры:
//  ТабличныйДокумент  - ТабличныйДокумент.
// 
Процедура ВыполнитьРасчет(НастройкаОтчета,ТабличныйДокумент,ТаблицаДанныеОтчета) Экспорт
	
	// Очистим аргументы формулы
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("ВидЯчейки",Перечисления.бит_ВидыЯчеекПроизвольногоОтчета.Формула);
	
	Формулы = ТаблицаДанныеОтчета.НайтиСтроки(СтрОтбор);
	
	// БитФинанас изменения кода. Начало: 16.05.2017 #BF-994 {{. 
	Для каждого СтрокаАргумент Из Формулы Цикл
		ТаблицаДанныеОтчета.Удалить(СтрокаАргумент);
	КонецЦикла; 
	//Для каждого СтрокаАргумент Из Формулы Цикл
	//	СтрокаАргумент.ЗначениеПоказателя = 0;
	//КонецЦикла; 
	// БитФинанас изменения кода. Конец 16.05.2017 #BF-994 }}. 
	
	НастройкиАналитик  = Справочники.бит_НастройкиПроизвольныхОтчетов.ПолучитьНастройкуАналитик(НастройкаОтчета);
	
	Если НастройкаОтчета.ОтображатьПериод Тогда
		
	  СтрНастроек = бит_МеханизмДопИзмерений.КонструкторСтруктураНастроек();
	  СтрНастроек.ТипЗначения = Новый ОписаниеТипов("Дата");
	  
	  НастройкиАналитик.Вставить("ПериодДанных", СтрНастроек);
	
	КонецЕсли; 
	
	// Отбираем из настроек заполнения формулы
	Формулы = Справочники.бит_НастройкиПроизвольныхОтчетов.ПолучитьПоказателиВида(НастройкаОтчета,"Формула");
	
	ПравилаЗаполнения = Справочники.бит_НастройкиПроизвольныхОтчетов.ПолучитьПоказателиОтчета(НастройкаОтчета);
	
	// Выполним расчеты по формулам
	Для каждого СтрокаПравил Из Формулы Цикл
		
		Результат = ВыполнитьРасчетПоФормуле(СтрокаПравил,ПравилаЗаполнения,ТаблицаДанныеОтчета,НастройкиАналитик);
		УстановитьЗначениеВТабличныйДокумент(ТабличныйДокумент,СтрокаПравил.ИмяОбласти,Результат);
		
	КонецЦикла; // По таблице правил 

КонецПроцедуры // ВыполнитьРасчет()

// Функция выделяет из строки формулы имена аргументов.
// 
// Параметры:
//  Формула  - Строка
// 
// Возвращаемое значение:
//   РезМассив   - Массив - значения массива: имена реквизитов.
// 
Функция РазобратьФормулу(Формула) Экспорт 
	
	РезМассив = Новый Массив;
	
	ТекСтрока = Формула;
	
	КоличествоПараметров = СтрЧислоВхождений(ТекСтрока,"[");
	
	Для й = 1 По КоличествоПараметров Цикл
		
		НомерСимволаОткрытие = Найти(ТекСтрока,"[");
		НомерСимволаЗакрытие = Найти(ТекСтрока,"]");
		
		ИмяОбласти = Сред(ТекСтрока,НомерСимволаОткрытие+1,НомерСимволаЗакрытие-НомерСимволаОткрытие-1);
		РезМассив.Добавить(ИмяОбласти);
		
		ТекСтрока = Сред(ТекСтрока,НомерСимволаЗакрытие+1);
		
	КонецЦикла; 
	
	бит_РаботаСКоллекциями.УдалитьПовторяющиесяЭлементыМассива(РезМассив);
	
	Возврат РезМассив;
	
КонецФункции // РазобратьФормулу()

// Процедура принудительно устанавливает дату начала отчета в случае отчета МСФО.
// 
// 
Функция ОпределитьДатуНачалаДляМСФО(ТипОтчета,ДатаНачала,ДатаОкончания) Экспорт
	
	РезДата = ДатаНачала;
	
	Если ТипОтчета = Перечисления.бит_ТипыПроизвольныхОтчетов.ОтчетностьМСФО Тогда
		
		Если ЗначениеЗаполнено(ДатаОкончания) Тогда
			РезДата = НачалоГода(ДатаОкончания)-1;
		Иначе
			РезДата = Дата("00010101");
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат РезДата;
	
КонецФункции // ОпределитьДатуНачалаДляМСФО()

// Процедура устанавливает значение в область табличного документа.
// 
// Параметры:
//  ТабличныйДокумент  - ТабличныйДокумент.
//  ИмяОбласти         - Строка.
//  Значение           - Число.
// 
Процедура УстановитьЗначениеВТабличныйДокумент(ТабличныйДокумент,ИмяОбласти,Значение,Прибавлять = Ложь) Экспорт

	ОблМакета = бит_МеханизмПолученияДанных.ПолучитьОбластьЯчеек(ТабличныйДокумент,ИмяОбласти);
	Если ОблМакета = Неопределено Тогда
		ТекстСообщения = "Не удалось найти область макета по имени: "+ИмяОбласти+"!";
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
	Иначе
		Если НЕ ОблМакета.СодержитЗначение = Неопределено Тогда
			
			Если ОблМакета.СодержитЗначение Тогда
				
				Если Прибавлять Тогда
					
					// Если макет копировался из EXCEL,то зачастую записываются паразитные значения
					// сбросим в ноль.
					Если НЕ ТипЗнч(ОблМакета.Значение) = Тип("Число") Тогда
					
						ОблМакета.Значение = 0;
					
					КонецЕсли; 					
					ОблМакета.Значение = ОблМакета.Значение+Значение;	
				Иначе
					ОблМакета.Значение = Значение;					
				КонецЕсли;
					
			Иначе	
				ОблМакета.Текст    = Значение; 
			КонецЕсли; 
			
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры // УстановитьЗначениеВТабличныйДокумент()

// Процедура устанавливает формат чисел в табличном документе.
// 
// Параметры:
//  ТабличныйДокумент  - ТабличныйДокумент.
// 
Процедура УстановитьФорматВывода(НастройкаОтчета, ТабличныйДокумент, ТекущийФормат, ТекущийЯзык) Экспорт
	
	ПравилаЗаполнения = Справочники.бит_НастройкиПроизвольныхОтчетов.ПолучитьПоказателиОтчета(НастройкаОтчета);	
	
	Для каждого СтрокаПравил Из ПравилаЗаполнения Цикл
		
		СтрФормат = ОпределитьФорматПоСтрокеПравил(СтрокаПравил,ТекущийФормат,ТекущийЯзык);
		
		ОблМакета = бит_МеханизмПолученияДанных.ПолучитьОбластьЯчеек(ТабличныйДокумент,СтрокаПравил.ИмяОбласти);
		Если ОблМакета <> Неопределено Тогда
			
			ОблМакета.Формат = СтрФормат;
			
		КонецЕсли; 
		
	КонецЦикла; 

КонецПроцедуры // УстановитьФорматВывода()

// Функция определяет формат для строки правил. Первый приоритет настройка формата из строки,
// далее из шапки, если формат не задан, то Число(15,2).
// 
// Параметры:
//  СтрокаПравил  - СтрокаТабличнойЧасти.ПравилаЗаполнения.
//  ФорматЧисел   - Строка - Формат по -умолчанию.
// 
// Возвращаемое значение:
//   СтрФормат   - Строка.
// 
Функция ОпределитьФорматПоСтрокеПравил(СтрокаПравил,ФорматЧисел,Язык) Экспорт
	
	// Определим, какую настройку формата применять.
	Если НЕ ПустаяСтрока(СтрокаПравил.ФорматЧисел) Тогда
		
		СтрФормат = СтрокаПравил.ФорматЧисел;
		
	Иначе	
		
		Если НЕ ПустаяСтрока(ФорматЧисел) Тогда
			
			СтрФормат = ФорматЧисел;
			
		Иначе	
			
			СтрФормат = "ЧЦ=15; ЧДЦ=2";
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	// Если язык не установлен установки из шапки отчета.
	Если Найти(СтрокаПравил.ФорматЧисел,"Л=")=0 Тогда
	
		КодСтраны = Справочники.бит_Языки.ПолучитьКодЯзыкСтрана(Язык);
		
		СтрФормат = "Л="+КодСтраны+";"+СтрФормат;
	
	КонецЕсли; 
	
	Возврат СтрФормат;
	
КонецФункции // ОпределитьФорматПоСтрокеПравил()

// Возвращает представление месяца в национальном формате
//
Функция МесяцПрописью(ДатаМесяца,Язык) Экспорт
	
	КодЯзыка = Справочники.бит_Языки.ПолучитьКодЯзыка(Язык);
	КодЯзыкСтрана = Справочники.бит_Языки.ПолучитьКодЯзыкСтрана(Язык);
	
	Если КодЯзыкСтрана = "ru_RU" Тогда
		Результат = Формат(ДатаМесяца, "Л=" + КодЯзыка + "; ДФ='дд.MMMM'");
		Результат = Сред(Результат, 4, СтрДлина(Результат));
	Иначе
		Результат = Формат(ДатаМесяца, "Л=" + КодЯзыка + "; ДФ='MMMM'");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // МесяцПрописью()

// Функция получает массив подстановок
// 
// Параметры: 
//  ПарамСтрока       - Строка                   Строка для получения массива подстановок.
// 
// Возвращаемое значение:
//  Возврат МассивПодстановок - Массив              Массив подстановок.
// 
Функция ПолучитьМассивПодстановок(ПарамСтрока, ОткрывающийТэг = "[", ЗакрывающийТэг = "]") Экспорт
	
	МассивПодстановок = Новый Массив();
	ДлинаОткрывающегоТэга = СтрДлина(ОткрывающийТэг);
	
	ВремСтрока = ПарамСтрока;
	Поз = Найти(ВремСтрока, ОткрывающийТэг);
	Пока НЕ Поз = 0 Цикл
		ВремСтрока = Сред(ВремСтрока, Поз + ДлинаОткрывающегоТэга);
		Поз = Найти(ВремСтрока, ЗакрывающийТэг);
		МассивПодстановок.Добавить(Лев(ВремСтрока, Поз - 1));
		Поз = Найти(ВремСтрока, ОткрывающийТэг);
	КонецЦикла;
	
	Возврат МассивПодстановок;
	
КонецФункции // ПолучитьМассивПодстановок()

// Процедура - фрагмент процедуры "СформироватьОтчет"
// в части заполнения параметров.  
// Применяется для заполнения параметров путого отчета.
// 
Процедура УстановитьПараметрыВДокРезультат(ТекОбъект, ТабличныйДокумент, ОтборВОтчете, ПараметрыЗапроса) Экспорт 
	
	Язык            = ТекОбъект.Язык;
	ФорматЧисел     = ТекОбъект.ФорматЧисел;
	ДатаНачала      = ТекОбъект.ДатаНачала;
	ДатаОкончания   = ТекОбъект.ДатаОкончания;
	Организация     = ТекОбъект.Организация;
	НастройкаОтчета = ТекОбъект.НастройкаОтчета;
	
	
	КодЯзыка = Справочники.бит_Языки.ПолучитьКодЯзыка(Язык);	
	
	// Подготовим структуру параметров отчета
	СтрПараметры = Новый Структура;
	СтрПараметры.Вставить("ДатаНачала"     ,ДатаНачала);
	СтрПараметры.Вставить("ДатаОкончания"  ,ДатаОкончания);	
	
	СтрПараметры.Вставить("ДатаНачалаФормат"      , Формат(ДатаНачала, 		"Л=" + КодЯзыка + "; ДФ='dd MMMM yyyy'"));
	СтрПараметры.Вставить("ДатаОкончанияФормат"   , Формат(ДатаОкончания, 	"Л=" + КодЯзыка + "; ДФ='dd MMMM yyyy'"));
	
	СтрПараметры.Вставить("ДеньНач"     	, Формат(ДатаНачала, 		"Л=" + КодЯзыка + "; ДФ='dd'"));
	СтрПараметры.Вставить("ДеньКон"  		, Формат(ДатаОкончания, 	"Л=" + КодЯзыка + "; ДФ='dd'"));
	
	СтрПараметры.Вставить("МесяцНач"     	, МесяцПрописью(ДатаНачала, Язык));
	СтрПараметры.Вставить("МесяцКон"  		, МесяцПрописью(ДатаОкончания, Язык));
	
	СтрПараметры.Вставить("ГодНач"     		, Формат(ДатаНачала, 		"Л=" + КодЯзыка + "; ДФ='yyyy'"));
	СтрПараметры.Вставить("ГодКон"  		, Формат(ДатаОкончания, 	"Л=" + КодЯзыка + "; ДФ='yyyy'"));
	
	СтрПараметры.Вставить("ОписаниеПериода",ОписаниеПериода(ДатаНачала,ДатаОкончания));
	СтрПараметры.Вставить("ОписаниеПериодаМСФО",ОписаниеПериодаМСФО(ДатаОкончания,Язык));
	
	СтрПараметры.Вставить("КонецПрошлогоГода",	  Формат(КонецГода(ДобавитьМесяц(ДатаОкончания, -12)), 	"Л=" + КодЯзыка + "; ДФ='dd MMMM yyyy'")); 
	СтрПараметры.Вставить("КонецПозапрошлогоГода",Формат(КонецГода(ДобавитьМесяц(ДатаОкончания, -24)), 	"Л=" + КодЯзыка + "; ДФ='dd MMMM yyyy'"));
	
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
	КонецПериодаПрошлый = ДобавитьМесяц(КонецДня(ДатаОкончания), -12);
	СтрПараметры.Вставить("ШаблонДатаКонецПериодаПрошлый"  		, Формат(КонецПериодаПрошлый, 	"Л=" + КодЯзыка + "; ДФ='dd'"));
	СтрПараметры.Вставить("ШаблонМесяцКонецПериодаПрошлый"  		, МесяцПрописью(КонецПериодаПрошлый, Язык));
	СтрПараметры.Вставить("ШаблонГодКонецПериодаПрошлый"  		, Формат(КонецПериодаПрошлый, 	"Л=" + КодЯзыка + "; ДФ='yyyy'"));
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
	
	Если ТипЗнч(Организация) <> Тип("СправочникСсылка.Организации") Тогда
		СтрПараметры.Вставить("КонсолидированныйОтчет", НСтр("ru = ""Консолидированный ""; en = ""CONSOLIDATED """, КодЯзыка));
	Иначе
		СтрПараметры.Вставить("КонсолидированныйОтчет", "");
	КонецЕсли;	
	
	Для каждого СтрокаОтбор Из ОтборВОтчете Цикл
		СтрПараметры.Вставить(СтрокаОтбор.Имя,СтрокаОтбор.Значение);
		СтрПараметры.Вставить(СтрокаОтбор.Имя+"_ВидСравнения",СтрокаОтбор.ВидСравнения);			 
	КонецЦикла; 
	
	Для каждого СтрокаТаблицы Из ПараметрыЗапроса Цикл
		СтрПараметры.Вставить(СтрокаТаблицы.ИмяПараметра,СтрокаТаблицы.ЗначениеПараметра);
	КонецЦикла; 
		
	Для каждого ТекущаяСтрока Из НастройкаОтчета.Параметры Цикл
		Если ТекущаяСтрока.ВидПараметра = Перечисления.бит_ВидыПараметровПроизвольныхОтчетов.ТекстНаРазныхЯзыках 
		 ИЛИ НЕ ЗначениеЗаполнено(ТекущаяСтрока.ВидПараметра) Тогда
			
			СтрПараметры.Вставить(ТекущаяСтрока.Параметр, НСтр(ТекущаяСтрока.Значение, КодЯзыка));
			
		КонецЕсли; 
	КонецЦикла;
	
	// Обработаем шаблоны	
	Шаблоны = Справочники.бит_НастройкиПроизвольныхОтчетов.ПолучитьПоказателиВида(НастройкаОтчета,"Шаблон");
	
	Для каждого СтрокаШаблон Из Шаблоны Цикл
		
		ИмяОбласти   = СтрокаШаблон.ИмяОбласти;
		ОблМакета    = бит_МеханизмПолученияДанных.ПолучитьОбластьЯчеек(ТабличныйДокумент,ИмяОбласти,Истина);
		Если ОблМакета = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
        ТекстШаблона = ОблМакета.Текст;
		
		МассивПодстановок = бит_МеханизмПолученияДанных.ПолучитьМассивПодстановок(ТекстШаблона);
		
		Для Каждого ТекПодстановка Из МассивПодстановок Цикл
			Попытка
				Если СтрПараметры.Свойство(ТекПодстановка) Тогда
					Продолжить;
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			ТекЗначениеПодстановки = "";
			Попытка
				Выполнить("ТекЗначениеПодстановки = " + ТекПодстановка + ";");
			Исключение
				// ТекЗначениеПодстановки = "[" + ТекПодстановка + "]";
				Продолжить;
			КонецПопытки;
			
			ТипЗначения = ТипЗнч(ТекЗначениеПодстановки);
			Если ТипЗначения = Тип("Число") 
				ИЛИ ТипЗначения = Тип("Дата") 
				ИЛИ ТипЗначения = Тип("Булево") Тогда
				
				СтрФормат = ОпределитьФорматПоСтрокеПравил(СтрокаШаблон, ФорматЧисел, Язык); 
				СтрПредставление = Формат(ТекЗначениеПодстановки, СтрФормат);
			Иначе
				СтрПредставление = Строка(ТекЗначениеПодстановки);
			КонецЕсли; 
			
			ТекстШаблона = СтрЗаменить(ТекстШаблона, "[" + ТекПодстановка + "]", СтрПредставление);
			
		КонецЦикла;
		
		Для каждого КлючИЗначение Из СтрПараметры Цикл
			
			ТипЗначения = ТипЗнч(КлючИЗначение.Значение);
			Если ТипЗначения = Тип("Число") 
				 ИЛИ ТипЗначения = Тип("Дата") 
				 ИЛИ ТипЗначения = Тип("Булево") Тогда
				 
				СтрФормат = ОпределитьФорматПоСтрокеПравил(СтрокаШаблон, ФорматЧисел, Язык); 
				СтрПредставление = Формат(КлючИЗначение.Значение,СтрФормат);
			Иначе
				СтрПредставление = Строка(КлючИЗначение.Значение);
			КонецЕсли; 
			ТекстШаблона = СтрЗаменить(ТекстШаблона,"["+КлючИЗначение.Ключ+"]",СтрПредставление);
			
			
		КонецЦикла; // По параметрам
		ОблМакета.Текст  = ТекстШаблона;
		
	КонецЦикла; // По шаблонам
	
КонецПроцедуры // УстановитьПараметрыВДокРезультат() 

// Процедура заполняет строку таблицы данных произвольного отчета значениями по-умолчанию.
// 
// Параметры:
//  ТекущаяСтрока
//  ИмяОбласти
//  ТаблицаДанныеОтчета
//  НастройкаОтчета
//  ФорматЧисел
//  Язык
// 
Процедура ЗаполнитьНовуюСтрокуТаблицыДанных(ТекущаяСтрока
	                                         ,ИмяОбласти
											 ,ТаблицаДанныеОтчета
											 ,НастройкаОтчета
											 ,ФорматЧисел
											 ,Язык) Экспорт

	ТекущаяСтрока.ИД = Строка(Новый  УникальныйИдентификатор);					
	
	СписокСвойств = "ПоказательОтчета, ВидЯчейки, ФорматЧисел, КоличественныйУчет, ИмяОбласти"; 
	
	СтрОтбор    = Новый Структура("ИмяОбласти", ИмяОбласти);
	МассивСтрок = ТаблицаДанныеОтчета.НайтиСтроки(СтрОтбор);
		
	Если МассивСтрок.Количество() > 0 Тогда
		СтрокаЭталон = МассивСтрок[0];
		ЗаполнитьЗначенияСвойств(ТекущаяСтрока, СтрокаЭталон, СписокСвойств);
	Иначе
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПоказателиПроизвольныхОтчетов.Код КАК ИмяОбласти,
		|	ПоказателиПроизвольныхОтчетов.ВидЯчейки КАК ВидЯчейки,
		|	ПоказателиПроизвольныхОтчетов.Ссылка КАК ПоказательОтчета,
		|	ПоказателиПроизвольныхОтчетов.ФорматЧисел КАК ФорматЧисел,
		|	ПоказателиПроизвольныхОтчетов.КоличественныйУчет КАК КоличественныйУчет
		|ИЗ
		|	Справочник.бит_ПоказателиПроизвольныхОтчетов КАК ПоказателиПроизвольныхОтчетов
		|ГДЕ
		|	ПоказателиПроизвольныхОтчетов.Код = &Код
		|	И ПоказателиПроизвольныхОтчетов.Владелец = &Владелец";
		
		Запрос.УстановитьПараметр("Владелец", НастройкаОтчета);
		Запрос.УстановитьПараметр("Код", ИмяОбласти);
		
		РезультатЗапроса = Запрос.Выполнить();
		Выборка		     = РезультатЗапроса.Выбрать();
		Если Выборка.Следующий() Тогда
			ЗаполнитьЗначенияСвойств(ТекущаяСтрока, Выборка, СписокСвойств);
			ТекущаяСтрока.ФорматЧисел = бит_МеханизмПолученияДанных.ОпределитьФорматПоСтрокеПравил(Выборка, ФорматЧисел, Язык);
		КонецЕсли; 
	КонецЕсли; 
	
	// Заполним аналитики по умолчанию в строке
	ЗаполнитьЗначенияПоУмолчаниюСтрокиТаблицыДанных(ТекущаяСтрока); 		

КонецПроцедуры // ЗаполнитьНовуюСтрокуТаблицыДанных()

#КонецОбласти

// Функция создает массив параметров имен "предопределенных" параметров, 
// которые заполняеются при вызове механизма из кода и не должны появляться в списке параметров источника.
// 
// Возвращаемое значение:
//   ПредопределенныеПараметры   - Массив.
// 
Функция КонструкторПредопределенныхПараметров() Экспорт
	
	ПредопределенныеПараметры = Новый Массив;
	ПредопределенныеПараметры.Добавить("НачалоПериода");
	ПредопределенныеПараметры.Добавить("КонецПериода");
	ПредопределенныеПараметры.Добавить("КонецПериодаДата");
	ПредопределенныеПараметры.Добавить("ТекущаяДата");
	ПредопределенныеПараметры.Добавить("ТекущаяДатаСеанса");
	ПредопределенныеПараметры.Добавить("МоментВремени");
	ПредопределенныеПараметры.Добавить("ВалютаОтчета");
	ПредопределенныеПараметры.Добавить("КурсОтчета");
	ПредопределенныеПараметры.Добавить("КратностьОтчета");
	ПредопределенныеПараметры.Добавить("КонецПериодаПрошлый");
	ПредопределенныеПараметры.Добавить("КонецПериодаПрошлыйДата");
	ПредопределенныеПараметры.Добавить("КонецПрошлогоГода");
	ПредопределенныеПараметры.Добавить("КонецПрошлогоГодаДата");
	ПредопределенныеПараметры.Добавить("КонецПозапрошлогоГода");
	ПредопределенныеПараметры.Добавить("КонецПозапрошлогоГодаДата");

	Возврат ПредопределенныеПараметры;
	
КонецФункции // КонструкторМассиваПредопределенныхПараметров()

// Формирует текстовое представление отбора построителя отчета.
// 
// Параметры:
// ПостроительОтчетаОтбор - Отбор.
// 
// ВозвращаемоеЗначение:
// ПредставлениеОтборы - Строка.
// 
Функция СформироватьТекстНастроек(ПостроительОтчетаОтбор)   Экспорт
	// Отборы
	ПредставлениеОтборы = "";
	
	Для каждого Отбор из ПостроительОтчетаОтбор Цикл
		
		Если ТипЗнч(Отбор) = Тип("Структура") Тогда
		
			флВыполнять = ?(Отбор.Использование И Отбор.ПутьКДанным <> "Периодичность",Истина,Ложь);
			
		Иначе	
		
			флВыполнять = ?(Отбор.Использование И Отбор.Имя <> "Периодичность",Истина,Ложь);
			
		КонецЕсли; 
		
		Если флВыполнять Тогда
			
			ПредставлениеОтборы = ПредставлениеОтборы +?(ПустаяСтрока(ПредставлениеОтборы),""," ")+ Отбор.Представление + " ";
			
			Если Отбор.ВидСравнения = ВидСравнения.Интервал Тогда
				
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' > '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеС;
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' И < '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеПо;
				
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
				
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' >= '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеС;
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' И <= '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеПо;
				
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
				
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' >= '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеС;
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' И < '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеПо;
				
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
				
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' > '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеС;
				ПредставлениеОтборы = ПредставлениеОтборы + НСтр("ru=' И <= '");
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ЗначениеПо;
				
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ВСписке ИЛИ Отбор.ВидСравнения = ВидСравнения.ВСпискеПоИерархии ИЛИ Отбор.ВидСравнения = ВидСравнения.НеВСписке ИЛИ Отбор.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
				
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ВидСравнения + " (" + Отбор.Значение + ")";
				
			Иначе
				
				ПредставлениеОтборы = ПредставлениеОтборы + Отбор.ВидСравнения + " " + Отбор.Значение;
				
			КонецЕсли;
			
			ПредставлениеОтборы = ПредставлениеОтборы + ";";
			
		КонецЕсли;
		
	КонецЦикла;
	
	
	
	Возврат ПредставлениеОтборы;		
	
КонецФункции

// Функция получает область ячеек табличного документа по имени.
// 
// Параметры:
// ТабличныйДокумент - ТабличныйДокумент.
// ИмяОбласти        - Строка.
// 
Функция ПолучитьОбластьЯчеек(ТабличныйДокумент,ИмяОбласти,ВыводитьСообщения = Ложь)  Экспорт
	
	Результат = Неопределено;
	
	Попытка
		Область = ТабличныйДокумент.Область(ИмяОбласти);
		Если ТипЗнч(Область) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
			Результат = Область;
		КонецЕсли; 
	Исключение
		Если ВыводитьСообщения Тогда
			ТекстСообщения = "Не удалось найти область макета по имени: "+ИмяОбласти+"!";
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		КонецЕсли; 
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции // ПолучитьОбластьЯчеек()

// Процедура - обработчик события "ПриИзменении" поля ввода "ВидСравнения" 
// табличного поля "ОтборВОтчете".
// 
// Параметры:
//  ТекущийСтрока          - СтрокаТабличнойЧасти.
//  ПредыдущийВидСравнения - ВидСравнения.
// 
Процедура ОтборВОтчетеВидСравненияПриИзменении(ТекущаяСтрока, ПредыдущийВидСравнения)  Экспорт

    флПредСписокДоступен = СписокДоступен(ПредыдущийВидСравнения);
	флТекСписокДоступен  = СписокДоступен(ТекущаяСтрока.ВидСравнения);
	
	Если НЕ флПредСписокДоступен И флТекСписокДоступен Тогда
		
		// Переключились на вид сравнения со списком - создадим список.
		ТекЗначение = ТекущаяСтрока.Значение;
		
		Список = Новый СписокЗначений();
		Если ЗначениеЗаполнено(ТекЗначение) Тогда
			
			Список.Добавить(ТекЗначение);
			
		КонецЕсли; 
		ТекущаяСтрока.Значение = Список;
		
	КонецЕсли; 
	
	Если флПредСписокДоступен И НЕ флТекСписокДоступен Тогда
		
		// Переключились на вид сравнения без списка - уничтожим список.
		Если ТипЗнч(ТекущаяСтрока.Значение) = Тип("СписокЗначений") Тогда
			
			Список = ТекущаяСтрока.Значение;
			Если Список.Количество()>0 Тогда
				ТекущаяСтрока.Значение = Список[0].Значение;
			Иначе	
				ТекущаяСтрока.Значение = Неопределено;
			КонецЕсли; 
			
		КонецЕсли; 	
		
	КонецЕсли; 	

КонецПроцедуры // ОтборВОтчетеВидСравненияПриИзменении()

// Процедура - обработчик события "ПриИзменении" поля ввода "Значение" табличного поля "ОтборВОтчете".
// 
// Параметры:
//  ТекущийСтрока          - СтрокаТабличнойЧасти.
// 
Процедура ОтборВОтчетеЗначениеПриИзменении(ТекущаяСтрока) Экспорт
	
	Если  ТипЗнч(ТекущаяСтрока.Значение) = Тип("СписокЗначений") И НЕ СписокДоступен(ТекущаяСтрока.ВидСравнения)  Тогда
		
		ТекущаяСтрока.Значение = Неопределено;	
		ТекстСообщения = "Для вида сравнения """+ТекущаяСтрока.ВидСравнения+""" список недоступен!";
		бит_ОбщегоНазначения.бит_Сообщить(ТекстСообщения,СтатусСообщения.Важное);
		Возврат;
		
	КонецЕсли; 
	
	Если  НЕ ТипЗнч(ТекущаяСтрока.Значение) = Тип("СписокЗначений") И СписокДоступен(ТекущаяСтрока.ВидСравнения)  Тогда
		
		ТекущаяСтрока.Значение = Новый СписокЗначений();	
		Возврат;
		
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(ТекущаяСтрока.Значение) Тогда
		ТекущаяСтрока.Использование = Истина;
	КонецЕсли; 
	
	
КонецПроцедуры // ОтборВОтчетеЗначениеПриИзменении()

// Процедура заполняет таблицу отбора в отчете, исходя из настроки источника. 
// В источнике имена параметров должны быть указаны на закладке ОтборВОтчете.
// 
// Параметры:
//  ИсточникДанных  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ТаблицаОтбор    - ТаблицаЗначений.
// 
Процедура ЗаполнитьОтборВОтчете(ИсточникДанных,ТаблицаОтбор) Экспорт

	Если НЕ ЗначениеЗаполнено(ИсточникДанных) Тогда
		
		Возврат;
		
	КонецЕсли; 
	
	 ВремТаблица = ТаблицаОтбор.Скопировать();
	
	 ТаблицаОтбор.Очистить();
	
	 Запрос = Новый Запрос;
	 
	 Если ТипЗнч(ИсточникДанных) = Тип("СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных") Тогда
		 
		 Запрос.Текст = "ВЫБРАТЬ
		                |	бит_ИсточникиДанныхОтборВОтчете.Имя,
		                |	бит_ИсточникиДанныхОтборВОтчете.ТипЗначения,
		                |	бит_ИсточникиДанныхОтборВОтчете.ТипЗначенияСтр КАК ТипЗначенияСтр
		                |ИЗ
		                |	Справочник.бит_ИсточникиДанных.ОтборВОтчете КАК бит_ИсточникиДанныхОтборВОтчете
		                |ГДЕ
		                |	бит_ИсточникиДанныхОтборВОтчете.Ссылка В
		                |			(ВЫБРАТЬ
		                |				бит_СпособыКомпоновкиИсточниковДанныхИсточникиДанных.ИсточникДанных
		                |			ИЗ
		                |				Справочник.бит_СпособыКомпоновкиИсточниковДанных.ИсточникиДанных КАК бит_СпособыКомпоновкиИсточниковДанныхИсточникиДанных
		                |			ГДЕ
		                |				бит_СпособыКомпоновкиИсточниковДанныхИсточникиДанных.Ссылка = &ИсточникДанных)";
		 
	 ИначеЕсли ТипЗнч(ИсточникДанных) = Тип("СправочникСсылка.бит_ИсточникиДанных") Тогда
		 
		 Запрос.Текст = "ВЫБРАТЬ
		                |	бит_ИсточникиДанныхОтборВОтчете.Имя,
		                |	бит_ИсточникиДанныхОтборВОтчете.ТипЗначения,
		                |	бит_ИсточникиДанныхОтборВОтчете.ТипЗначенияСтр
		                |ИЗ
		                |	Справочник.бит_ИсточникиДанных.ОтборВОтчете КАК бит_ИсточникиДанныхОтборВОтчете
		                |ГДЕ
		                |	бит_ИсточникиДанныхОтборВОтчете.Ссылка = &ИсточникДанных";
		 
	ИначеЕсли ТипЗнч(ИсточникДанных) = Тип("Массив") Тогда	 
		 
		 Запрос.Текст = "ВЫБРАТЬ
		                |	бит_ИсточникиДанныхОтборВОтчете.Имя,
		                |	бит_ИсточникиДанныхОтборВОтчете.ТипЗначения,
		                |	бит_ИсточникиДанныхОтборВОтчете.ТипЗначенияСтр
		                |ИЗ
		                |	Справочник.бит_ИсточникиДанных.ОтборВОтчете КАК бит_ИсточникиДанныхОтборВОтчете
		                |ГДЕ
		                |	бит_ИсточникиДанныхОтборВОтчете.Ссылка В(&ИсточникДанных)";
		 
	 КонецЕсли; 
	 
					
	Запрос.УстановитьПараметр("ИсточникДанных",ИсточникДанных);
	
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
	
		НайденнаяСтрока = ТаблицаОтбор.Найти(Выборка.Имя,"Имя");
		Если НайденнаяСтрока = Неопределено Тогда
		
			НоваяСтрока     = ТаблицаОтбор.Добавить();
			НоваяСтрока.Использование = Ложь;
			НоваяСтрока.Имя           = Выборка.Имя;
			НоваяСтрока.ВидСравнения  = ВидСравнения.Равно;
			
			Если НЕ ПустаяСтрока(Выборка.ТипЗначенияСтр) Тогда
			
				ОписаниеТипов = бит_ОбщегоНазначенияКлиентСервер.ПолучитьОписаниеИзСтроки(Выборка.ТипЗначенияСтр);
				Если ОписаниеТипов <> Неопределено Тогда
					НоваяСтрока.Значение = ОписаниеТипов.ПривестиЗначение(НоваяСтрока.Значение);
				КонецЕсли;
			
			ИначеЕсли ТипЗнч(Выборка.ТипЗначения) = Тип("ХранилищеЗначения") Тогда
				
				ОписаниеТипов = Выборка.ТипЗначения.Получить();
				Если ОписаниеТипов <> Неопределено Тогда
					НоваяСтрока.Значение = ОписаниеТипов.ПривестиЗначение(НоваяСтрока.Значение);
				КонецЕсли;
				
			КонецЕсли; 
			
		   // Восстановим значения предыдущей настройки, если имя поля совпадает.
		   НайденнаяСтрока = ВремТаблица.Найти(Выборка.Имя,"Имя");
		   Если НайденнаяСтрока <> Неопределено Тогда
			   НоваяСтрока.ВидСравнения = НайденнаяСтрока.ВидСравнения;
			   НоваяСтрока.Значение     = НайденнаяСтрока.Значение;
		   КонецЕсли; 
			
			
		КонецЕсли; 
	
	КонецЦикла; // По выборке

КонецПроцедуры // ЗаполнитьОтборВОтчете()

// Функция формируем список выбора для отбора в отчете.
// 
// Параметры:
//   ТипРезультата - Строка ("СписокЗначений" или "Массив").
// 
// Возвращаемое значение:
//   СписокВыбора   - СписокЗначений.
// 
Функция СформироватьСписокВыбораДляОтборовВОтчете(ТипРезультата = "СписокЗначений") Экспорт

	Если ТипРезультата = "СписокЗначений" Тогда
		СписокВыбора = Новый СписокЗначений;	
	Иначе	
	    СписокВыбора = Новый Массив;
	КонецЕсли;
	
	СписокВыбора.Добавить(ВидСравнения.Равно);
	СписокВыбора.Добавить(ВидСравнения.НеРавно);
	СписокВыбора.Добавить(ВидСравнения.ВИерархии);
	СписокВыбора.Добавить(ВидСравнения.НеВИерархии);
	СписокВыбора.Добавить(ВидСравнения.ВСписке);
	СписокВыбора.Добавить(ВидСравнения.НеВСписке);
	
    Возврат СписокВыбора;
	
КонецФункции // СформироватьСписокВыбораДляОтборовВОтчете()

// Функция определяет доступен ли данному виду сравнения список.
// 
// Параметры:
//  ТекВидСравнения  - ВидСравнения.
// 
// Возвращаемое значение:
//   флСписокДоступен   - Булево.
// 
Функция СписокДоступен(ТекВидСравнения) Экспорт
	
	флСписокДоступен = Ложь;
	
	Если ТекВидСравнения = ВидСравнения.ВСписке ИЛИ ТекВидСравнения = ВидСравнения.НеВСписке Тогда
		
		флСписокДоступен = Истина;	
		
	КонецЕсли; 
	
	Возврат флСписокДоступен;
	
КонецФункции // СписокДоступен()

// Процедура выполняет копирование отбора компоновки данных.
// 
// Параметры:
//  КоллекцияИсточник - КоллекцияЭлементовОтбораКомпоновкиДанных.
//  КоллекцияПриемник - КоллекцияЭлементовОтбораКомпоновкиДанных.
// 
Процедура КопироватьКоллекциюЭлементовОтбора(КоллекцияИсточник, КоллекцияПриемник) Экспорт

	Для каждого ЭлОтбор Из КоллекцияИсточник Цикл
		
		Если ТипЗнч(ЭлОтбор) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			ЭлОтборНовый = КоллекцияПриемник.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(ЭлОтборНовый, ЭлОтбор);
			
		ИначеЕсли ТипЗнч(ЭлОтбор) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда	
			
			ГрОтборНовый = КоллекцияПриемник.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(ГрОтборНовый, ЭлОтбор);
			КопироватьКоллекциюЭлементовОтбора(ЭлОтбор.Элементы, ГрОтборНовый.Элементы);
			
		КонецЕсли; 
		
	КонецЦикла; 

КонецПроцедуры // КопироватьКоллекциюЭлементовОтбора()

// Функция-конструктор структуры, моделирующей элемент отбора.
// 
// Возвращаемое значение:
//  ЭО - Структура.
// 
Функция ЭлементОтбора() Экспорт
	
	ЭО = Новый Структура("ИмяКласса
	                      |, ПутьКДанным
						  |, Использование
						  |, ВидСравнения
						  |, Значение
						  |, ЗначениеС
						  |, ЗначениеПо
						  |, ТипЗначения
						  |, Представление"
						  , "ЭлементОтбора");
	
	Возврат ЭО;
	
КонецФункции // ЭлементОтбора()

// Функция создает схему компоновки данных по тексту запроса.
// 
// Параметры:
// ТекстЗапроса - Строка
// ИмяНабораДанных - Строка
// 
// Возвращаемое значение:
//  СКД - СхемаКомпоновкиДанных.
// 
Функция СоздатьСхемуКомпоновкиПоЗапросу(ТекстЗапроса, ИмяНабораДанных = "НаборДанныхОсновной") Экспорт
	
	СКД = Новый СхемаКомпоновкиДанных;
	
	ИсточникДанных = СКД.ИсточникиДанных.Добавить();
	ИсточникДанных.Имя 				  = "ИсточникДанных";
	ИсточникДанных.ТипИсточникаДанных = "local";
	
	НаборДанных = СКД.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя 						 = ИмяНабораДанных; 
	НаборДанных.ИсточникДанных 				 = "ИсточникДанных";
	НаборДанных.Запрос 						 = ТекстЗапроса;
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;
	
	Построитель = Новый ПостроительЗапроса;
	Построитель.Текст = ТекстЗапроса;
	Построитель.ЗаполнитьНастройки();
	
	Для каждого ПолеПостроителя Из Построитель.ДоступныеПоля Цикл
		
		Если ПолеПостроителя.Отбор Тогда
			
			ВыбранноеПоле = СКД.НастройкиПоУмолчанию.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
			ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных(ПолеПостроителя.Имя);
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	ГруппировкаКомпоновки = СКД.НастройкиПоУмолчанию.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	ВыбранноеПоле         = ГруппировкаКомпоновки.Выбор.Элементы.Добавить(Тип("АвтовыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Использование = Истина;
	
	Возврат СКД
	
КонецФункции // СоздатьСхемуКомпоновкиПоЗапросу()

// Процедура выполняет конвертацию отбора построителя в отбор компоновщика. 
// 
// Параметры:
//  СтрНастроек - Структура.
//  Компоновщик - КомпоновщикНастроекКомпоновкиДанных
//  ТекстЗапроса - Строка - Текст запроса для инициализации построителя.
// 
Процедура КонвертацияОтборПостроителяОтборКомпоновщика(СтрНастроек, Компоновщик, ТекстЗапроса = "") Экспорт

	ОтборПостроителя = Неопределено;
	
	Если СтрНастроек.Свойство("Отбор") Тогда
		
		ОтборПостроителя = СтрНастроек.Отбор;
		
	ИначеЕсли СтрНастроек.Свойство("НастройкиПостроителя") И НЕ ПустаяСтрока(ТекстЗапроса) Тогда	
		
		Построитель = Новый ПостроительОтчета;
		
		Попытка
			
			Построитель.Текст = ТекстЗапроса;
			
		Исключение
			
			ТекстСообщения =  НСтр("ru = 'Не удалось установить текст запроса! Описание ошибки: %1%.'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ОписаниеОшибки());
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецПопытки;
		
		Построитель.УстановитьНастройки(СтрНастроек.НастройкиПостроителя);
		
		ОтборПостроителя = Построитель.Отбор;
		
	КонецЕсли; 
	
	Если НЕ ОтборПостроителя = Неопределено Тогда
		
		Для каждого эо Из ОтборПостроителя Цикл
			
			СтрВид = КонвертацияВидаСравнения(эо.ВидСравнения);
			
			Если СтрВид.Группа = "НЕТ" Тогда
				
				// Виды сравнения построителя для которых есть соотвествующие виды сравнения компоновки.
				эоКомп = Компоновщик.Настройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
				эоКомп.Использование  = эо.Использование;				   
				эоКомп.ВидСравнения   = СтрВид.ВидыСравнения[0];
				эоКомп.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных(эо.ПутьКДанным);
				эоКомп.ПравоеЗначение = эо.Значение;
				
			Иначе	
				
				// Интервальные виды сравнения для которых в компоновке нет соответсвующих видов сравнения
				// для конвертации используем группы элементов отбора компоновки.
				грКомп = Компоновщик.Настройки.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				грКомп.Использование = эо.Использование;
				
				Если СтрВид.Группа = "И" Тогда
					
					грКомп.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
					
				ИначеЕсли СтрВид.Группа = "ИЛИ" Тогда
					
					грКомп.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
					
				ИначеЕсли СтрВид.Группа = "НЕ" Тогда	  
					
					грКомп.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
					
				Иначе	  
					
					грКомп.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
					
				КонецЕсли; 
				
				// ЗначениеС
				эоКомп = грКомп.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
				эоКомп.Использование = эо.Использование;
				эоКомп.ВидСравнения  = СтрВид.ВидыСравнения[0];
				эоКомп.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(эо.ПутьКДанным);
				эоКомп.ПравоеЗначение= эо.ЗначениеС;
				
				// ЗначениеПО
				эоКомп = грКомп.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
				эоКомп.Использование = эо.Использование;
				эоКомп.ВидСравнения  = СтрВид.ВидыСравнения[1];
				эоКомп.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(эо.ПутьКДанным);
				эоКомп.ПравоеЗначение= эо.ЗначениеПО;
				
				
			КонецЕсли; 
			
		КонецЦикла; // СтрНастроек.Отбор 
		
	КонецЕсли;  // Есть отбор построителя
	
КонецПроцедуры // КонвертацияОтборПостроителяОтборКомпоновщика()

// Функция выполняет конвертацию вида сравнения построителя в вид сравнения компоновки данных. 
// 
// Параметры:
//  ВидСравненияПостроителя - ВидСравнения.
// 
// Возвращаемое значение;
//  СтрВид - Структура
// 
Функция КонвертацияВидаСравнения(ВидСравненияПостроителя) Экспорт

	СтрВид = Новый Структура("Группа, ВидыСравнения", "НЕТ", Новый Массив);
	
	Если ВидСравненияПостроителя = ВидСравнения.Больше Тогда
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Больше);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.БольшеИлиРавно Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.БольшеИлиРавно);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.ВИерархии Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.ВИерархии);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.ВСписке Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.ВСписке);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.ВСпискеПоИерархии Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.Интервал Тогда	
		
		СтрВид.Группа = "И";
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Больше);	
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Меньше);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.ИнтервалВключаяГраницы Тогда	
		
		СтрВид.Группа = "И";
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.БольшеИлиРавно);	
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.МеньшеИлиРавно);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.ИнтервалВключаяНачало Тогда	
		
		СтрВид.Группа = "И";
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.БольшеИлиРавно);	
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Меньше);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.ИнтервалВключаяОкончание Тогда	
		
		СтрВид.Группа = "И";
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Больше);	
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.МеньшеИлиРавно);				
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.Меньше Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Меньше);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.МеньшеИлиРавно Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.МеньшеИлиРавно);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.НеВИерархии Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.НеВИерархии);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.НеВСписке Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.НеВСписке);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.НеВСпискеПоИерархии Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.НеВСпискеПоИерархии);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.НеРавно Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.НеРавно);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.НеСодержит Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.НеСодержит);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.Равно Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Равно);		
		
	ИначеЕсли ВидСравненияПостроителя = ВидСравнения.Содержит Тогда	
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Содержит);		
		
	Иначе
		
		СтрВид.ВидыСравнения.Добавить(ВидСравненияКомпоновкиДанных.Равно);
		
	КонецЕсли; 

	Возврат СтрВид;
	
КонецФункции // КонвертацияВидаСравнения()

// Функция выполняет адаптацию текста запроса
// , используемого с построителем запроса для работы с компоновкой данных.
// 
// Параметры:
//  вхТекстЗапроса - Строка
// 
// Возвращаемое значение:
//  ТекстЗапроса - Строка.
// 
Функция АдаптироватьТекстПостроителяДляКомпоновки(вхТекстЗапроса) Экспорт

	ТекстЗапроса = СтрЗаменить(вхТекстЗапроса, "АВТОУПОРЯДОЧИВАНИЕ", "");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса  , "СпрЭлементы.Ссылка.* КАК Ссылка", "Ссылка.*");

	Возврат ТекстЗапроса;
	
КонецФункции // АдаптироватьТекстПостроителяДляКомпоновки()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Процедура дополняет массив параметров - исключений параметрами
// , помеченными флагом "ОграничениеДоступности".
// Рекурсивный вызов.
// 
// Параметры:
//  Источник  - СправочникСсылка.бит_ИсточникиДанных,СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  Исключения  - Массив.
// 
Процедура ДополнитьСписокИсключений(Источник, Исключения)

	Если ТипЗнч(Источник) = Тип("СправочникСсылка.бит_ИсточникиДанных") 
		 ИЛИ ТипЗнч(Источник) = Тип("СправочникОбъект.бит_ИсточникиДанных")  Тогда
		 
		 СохраненнаяНастройка = Источник.НастройкиПостроителя.Получить();
		 Если ТипЗнч(СохраненнаяНастройка) = Тип("Структура") Тогда
			 
			 // Восстанавливаем сохраненные параметры
			 Если СохраненнаяНастройка.Свойство("НастройкиПараметров") Тогда
				 
				 Для Каждого КиЗ Из СохраненнаяНастройка.НастройкиПараметров Цикл

					 ИмяПараметра = КиЗ.Ключ;
					 ОграничениеДоступности = КиЗ.Значение.ОграничениеДоступности;
					 
					 Если ОграничениеДоступности Тогда
						 Если Исключения.Найти(ИмяПараметра) = Неопределено Тогда
						 	Исключения.Добавить(ИмяПараметра);
						 КонецЕсли; 
					 КонецЕсли; // ОграничениеДоступности
				 КонецЦикла; // по параметрам
				 
			 КонецЕсли; 
		 КонецЕсли;
		
	ИначеЕсли ТипЗнч(Источник) = Тип("СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных") 
		      ИЛИ ТипЗнч(Источник) = Тип("СправочникОбъект.бит_СпособыКомпоновкиИсточниковДанных") Тогда
		
		Для каждого СтрокаТаблицы Из Источник.ИсточникиДанных Цикл
			
			ДополнитьСписокИсключений(СтрокаТаблицы.ИсточникДанных, Исключения);
			
		КонецЦикла; 
		
	КонецЕсли; 

КонецПроцедуры // ДополнитьСписокИсключений()

// Процедура устанавливает настройки пересчетов по курсам для элементов данных с учетом иерархии.
// 
// Параметры:
//  СтрокаВерх - СтрокаДереваЗначений.
//  НастройкиПересчета - Соответствие.
//  НастройкаПоУмолчанию - Структура.
// 
Процедура ОпределитьНастройкиПересчетаИерархически(СтрокаВерх, НастройкиПересчета, НастройкаПоУмолчанию)

	 Для каждого СтрокаДерева Из СтрокаВерх.Строки Цикл
		 
		ТекНастройка = НастройкиПересчета[СтрокаДерева.ЭлементДанных];
		Если ТекНастройка = Неопределено Тогда
			
			// Настройка для данного элемента данных не определена
			// применяем настройки по умолчанию.
			ТекНастройка = Новый Структура;
		    ТекНастройкаПоУмолчанию = Новый Структура; 
			
			Для каждого КиЗ Из НастройкаПоУмолчанию Цикл
			
				ТекНастройка.Вставить(КиЗ.Ключ, КиЗ.Значение);
				ТекНастройкаПоУмолчанию.Вставить(КиЗ.Ключ, КиЗ.Значение);
			
			КонецЦикла; 
			
			НастройкиПересчета.Вставить(СтрокаДерева.ЭлементДанных, ТекНастройка);
			
		Иначе	
			
			// Проверяем для всех ли ресурсов заданы настройки, 
			// для ресурсов у которых нет настроек применяем настройки по-умолчанию.
			
			Для каждого КиЗ Из НастройкаПоУмолчанию Цикл
			
				Если НЕ ТекНастройка.Свойство(КиЗ.Ключ) Тогда
				
					ТекНастройка.Вставить(КиЗ.Ключ, КиЗ.Значение);
				
				КонецЕсли; 
			
			КонецЦикла; 
			
			// Для вложенных элементов данных настройкой по умолчанию становится текущая настройка.
			ТекНастройкаПоУмолчанию = Новый Структура;
			Для каждого КиЗ Из ТекНастройка Цикл
			
				ТекНастройкаПоУмолчанию.Вставить(КиЗ.Ключ, КиЗ.Значение);
			
			КонецЦикла; 
			
		КонецЕсли; 
		
		// Устанавливаем настройки для вложенных элементов данных.
	 	ОпределитьНастройкиПересчетаИерархически(СтрокаДерева, НастройкиПересчета, ТекНастройкаПоУмолчанию);
	 
	 КонецЦикла; 

КонецПроцедуры // ОпределитьНастройкиПересчетаИерархически()

// Функция получает структуру ресурсов для пересчетов по курсам.
// В таблицу результата добавляются колонки со способами пересчетов по курсам для ресурсов.
// 
// Параметры:
//  СпособКомпоновки - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ТаблицаРезультат - ТаблицаЗначений.
//  МассивСпособов   - Массив (заполняется возможными способами пересчета ресурсов по курсу).
//  МассивВалют		 - Массив (заполняется возможными валютами).
//  
// Возвращаемое значение:
//   Структура: Ключ - Ресурс, Значение - ИмяВалютыИсходной.
// 
Функция ПолучитьСтруктуруРесурсовДляПересчетовПоКурсам(СпособКомпоновки, ТаблицаРезультат, МассивСпособов, МассивВалют)

	СтруктураРесурсов = Новый Структура;
	
	НастройкиПересчета = Новый Соответствие;
	// Определим установленные способы пересчета по курсам.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СпособКомпоновки", СпособКомпоновки);
	Запрос.Текст = "ВЫБРАТЬ
	               |	СпособыПересчета.Ссылка КАК ЭлементДанных,
	               |	СпособыПересчета.ИмяКолонки,
	               |	СпособыПересчета.СпособПересчетаПоКурсам
	               |ИЗ
	               |	Справочник.бит_ЭлементыДанных.СпособыПересчетаПоКурсам КАК СпособыПересчета
	               |ГДЕ
	               |	СпособыПересчета.Ссылка.Владелец = &СпособКомпоновки
	               |ИТОГИ ПО
	               |	ЭлементДанных
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	бит_ЭлементыДанных.Ссылка КАК ЭлементДанных
	               |ИЗ
	               |	Справочник.бит_ЭлементыДанных КАК бит_ЭлементыДанных
	               |ГДЕ
	               |	бит_ЭлементыДанных.Владелец = &СпособКомпоновки
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ЭлементДанных ИЕРАРХИЯ
	               |АВТОУПОРЯДОЧИВАНИЕ";
				   
	МассивРезультатов = Запрос.ВыполнитьПакет();
	
	// Извлекаем установленные настройки пересчетов по курсам.
	ВыборкаЭД = МассивРезультатов[0].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаЭД.Следующий() Цикл
	
		Выборка = ВыборкаЭД.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		ТекНастройка = Новый Структура;
		Пока Выборка.Следующий() Цикл
		
			  ТекНастройка.Вставить(Выборка.ИмяКолонки, Выборка.СпособПересчетаПоКурсам);
		
		КонецЦикла; 
		
		НастройкиПересчета.Вставить(ВыборкаЭД.ЭлементДанных, ТекНастройка);
		
	КонецЦикла; 
	
	НайденныеСтрокиРесурсов = СпособКомпоновки.КолонкиТаблицы.НайтиСтроки(Новый Структура("ВидКолонки", "Ресурс"));
	
	НастройкаПоУмолчанию = Новый Структура;
	Для каждого СтрокаРесурса Из НайденныеСтрокиРесурсов Цикл
	
		НастройкаПоУмолчанию.Вставить(СтрокаРесурса.ИмяКолонки, СтрокаРесурса.СпособПересчетаПоКурсам);
		// Новая колонка в таблице результата для записи способа пересчета.
		ИмяРесурса = СтрокаРесурса.ИмяКолонки;				
		ИмяКолонкиСпособа = "Ресурс_" + ИмяРесурса + "_СпособПересчетаПоКурсам";
		ТаблицаРезультат.Колонки.Добавить(ИмяКолонкиСпособа);		
		
		// Поиск имени поля - исходной валюты
		ИмяВалюты = "Валюта" + СтрокаРесурса.ИмяКолонки;
		НайденныеСтрокиВалюта = СпособКомпоновки.КолонкиТаблицы.НайтиСтроки(Новый Структура("ИмяКолонки", ИмяВалюты));
		ИмяВалютыИсходной     = ?(НайденныеСтрокиВалюта.Количество() = 0, Неопределено, НайденныеСтрокиВалюта[0].ИмяКолонки);
		
		Если ИмяВалютыИсходной <> Неопределено Тогда 
			
			// Заполнение массива валют
			ТаблицаВалют = ТаблицаРезультат.Скопировать();
			ТаблицаВалют.Свернуть(ИмяВалютыИсходной);
			Для каждого СтрТаб Из ТаблицаВалют Цикл
				ТекВалюта = СтрТаб[ИмяВалютыИсходной];
			 	Если МассивВалют.Найти(ТекВалюта) = Неопределено Тогда
					МассивВалют.Добавить(ТекВалюта);		
				КонецЕсли;			
			КонецЦикла;
			
		КонецЕсли;
		
		// Структура ресурсов
		СтруктураРесурсов.Вставить(ИмяРесурса, ИмяВалютыИсходной);
		
	КонецЦикла; 	
	
	// Определяем способ пересчета по курсам для всех элементов данных.
	ДеревоЭД = МассивРезультатов[1].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	ОпределитьНастройкиПересчетаИерархически(ДеревоЭД, НастройкиПересчета, НастройкаПоУмолчанию);
	
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
	ЗнНеПересчитывается = Перечисления.бит_СпособыПересчетаПоКурсам.НеПересчитывается;
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
	
	// Устанавливаем в таблицу результат способ пересчета по курсам.
	Для каждого СтрокаТаблицы Из ТаблицаРезультат Цикл
		
		ТекЭлементДанных = СтрокаТаблицы.ЭлементДанных;
		ТекНастройка     = НастройкиПересчета[ТекЭлементДанных];
		
		Для каждого СтрокаРесурса Из НайденныеСтрокиРесурсов Цикл
			
			ИмяРесурса = СтрокаРесурса.ИмяКолонки;	
		    ИмяКолонкиСпособа = "Ресурс_" + ИмяРесурса + "_СпособПересчетаПоКурсам";			
			
			Если ТипЗнч(ТекНастройка) = Тип("Структура") Тогда
				
				Если ТекНастройка.Свойство(ИмяРесурса) Тогда
					
					СпособПересчетаПоКурсам = ТекНастройка[ИмяРесурса];
					
				Иначе
					
					// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
					//СпособПересчетаПоКурсам = Перечисления.бит_СпособыПересчетаПоКурсам.НеПересчитывается;
					СпособПересчетаПоКурсам = ЗнНеПересчитывается;
					// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
					
				КонецЕсли; 
				
			Иначе	
				
				// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
				//СпособПересчетаПоКурсам = Перечисления.бит_СпособыПересчетаПоКурсам.НеПересчитывается;
				СпособПересчетаПоКурсам = ЗнНеПересчитывается;
				// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
				
			КонецЕсли; 
			
			// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
			//Если СпособПересчетаПоКурсам = Перечисления.бит_СпособыПересчетаПоКурсам.НеПересчитывается
			Если СпособПересчетаПоКурсам = ЗнНеПересчитывается
			// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)	
				Или Не ЗначениеЗаполнено(СпособПересчетаПоКурсам) Тогда
				// Если ресурс пересчитывать по курсам не нужно, то не записываем его в структуру.
				// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
				//СтрокаТаблицы[ИмяКолонкиСпособа] = Перечисления.бит_СпособыПересчетаПоКурсам.НеПересчитывается;
				СтрокаТаблицы[ИмяКолонкиСпособа] = ЗнНеПересчитывается;
				// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
				Продолжить;
			Иначе
				СтрокаТаблицы[ИмяКолонкиСпособа] = СпособПересчетаПоКурсам;
			КонецЕсли;
			
			Если МассивСпособов.Найти(СпособПересчетаПоКурсам) = Неопределено Тогда
				МассивСпособов.Добавить(СпособПересчетаПоКурсам);			
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла; 	

	Возврат СтруктураРесурсов;
	
КонецФункции // ПолучитьСтруктуруРесурсовДляПересчетовПоКурсам()

// Процедура пересчитывает ресурсы в таблице по курсам.
// 
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  ГраницаНач        - Дата,МоментВремени,Граница.
//  ГраницаКон        - Дата,МоментВремени,Граница.
//  СтрПар            - Структура.
//  ТаблицаРезультат  - ТаблицаЗначений.
// 
Процедура ПересчитатьРесурсыПоКурсам(СпособКомпоновки, ГраницаНач, ГраницаКон, СтрПар, ТаблицаРезультат)

	СпособыПересчета = Перечисления.бит_СпособыПересчетаПоКурсам;
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
	ЗнНеПересчитывается = СпособыПересчета.НеПересчитывается;
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
	
	// Массив способов пересчета по курсам
	МассивСпособов = Новый Массив;
	МассивВалют    = Новый Массив;
	// Структура ресурсов, для которых нужен пересчет (Ключ - Ресурс, Значение - ИмяВалютыИсходной).
	СтруктураРесурсов = ПолучитьСтруктуруРесурсовДляПересчетовПоКурсам(СпособКомпоновки, ТаблицаРезультат, МассивСпособов, МассивВалют);
	Если СтруктураРесурсов.Количество() = 0 Тогда
		// Нет ресурсов, для которых нужно выполнить пересчет.
		Возврат;	
	КонецЕсли;
	
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
	//ВалютаРегл = Константы.ВалютаРегламентированногоУчета.Получить();
	ВалютаРегл = ОбщегоНазначенияБПВызовСервераПовтИсп.ПолучитьВалютуРегламентированногоУчета();
	// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
	СтруктураВалютыРегл = Новый Структура("Валюта, Курс, Кратность", ВалютаРегл, 1, 1);
	
	// Валюта отчета
	Если СтрПар.Параметры.Свойство("ВалютаОтчета") Тогда
		ВалютаОтчета = СтрПар.Параметры.ВалютаОтчета;
		Если Не ЗначениеЗаполнено(ВалютаОтчета) Тогда
			ВалютаОтчета = ВалютаРегл;	
		КонецЕсли;
	Иначе
		ВалютаОтчета = ВалютаРегл;
	КонецЕсли;  	
	
	Если МассивВалют.Найти(ВалютаОтчета) = Неопределено Тогда
		МассивВалют.Добавить(ВалютаОтчета);		
	КонецЕсли;
	
	// Формирование курсов
	ИмяРсКурсовВалют    = "КурсыВалют";
	ИмяРсКурсовВалютОтч = "бит_КурсыВалютОтчетности";
	Для каждого ТекСпособ Из МассивСпособов Цикл
		Если ТекСпособ = СпособыПересчета.СреднийКурсЗаПериод Тогда
			// Средние курсы
			СоответствиеКурсовВалют_С = бит_КурсыВалют.ПолучитьСоответствиеСреднихКурсовВалют(ИмяРсКурсовВалют, МассивВалют, ГраницаНач, ГраницаКон);
		ИначеЕсли ТекСпособ = СпособыПересчета.КурсНаНачалоПериода Тогда
			// Курсы на начало
			СоответствиеКурсовВалют_Н = бит_КурсыВалют.ПолучитьСоответствиеКурсовВалютНаДату(ИмяРсКурсовВалют, МассивВалют, ГраницаНач);
		ИначеЕсли ТекСпособ = СпособыПересчета.КурсНаКонецПериода Тогда
			// Курсы на конец
			СоответствиеКурсовВалют_К = бит_КурсыВалют.ПолучитьСоответствиеКурсовВалютНаДату(ИмяРсКурсовВалют, МассивВалют, ГраницаКон);
		ИначеЕсли ТекСпособ = СпособыПересчета.СреднийКурсОтчетностиЗаПериод Тогда
			// Средние курсы отчетности
			СоответствиеКурсовВалют_Со = бит_КурсыВалют.ПолучитьСоответствиеСреднихКурсовВалют(ИмяРсКурсовВалютОтч, МассивВалют, ГраницаНач, ГраницаКон);
		ИначеЕсли ТекСпособ = СпособыПересчета.КурсОтчетностиНаНачалоПериода Тогда
			// Курсы отчетности на начало
			СоответствиеКурсовВалют_Но = бит_КурсыВалют.ПолучитьСоответствиеКурсовВалютНаДату(ИмяРсКурсовВалютОтч, МассивВалют, ГраницаНач);
		ИначеЕсли ТекСпособ = СпособыПересчета.КурсОтчетностиНаКонецПериода Тогда
			// Курсы отчетности на конец
			СоответствиеКурсовВалют_Ко = бит_КурсыВалют.ПолучитьСоответствиеКурсовВалютНаДату(ИмяРсКурсовВалютОтч, МассивВалют, ГраницаКон);
		Иначе
			Продолжить;
		КонецЕсли;	
	КонецЦикла;
	
	Для каждого КлЗнчРесурс Из СтруктураРесурсов Цикл
		
		ИмяРесурса 		  = КлЗнчРесурс.Ключ;
		ИмяВалютыИсходной = КлЗнчРесурс.Значение;
		
		Для каждого СтрокаТабл Из ТаблицаРезультат Цикл
			
			СпособПересчетаПоКурсам = СтрокаТабл["Ресурс_" + ИмяРесурса + "_СпособПересчетаПоКурсам"];
			// ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-31 (#2954)
			//Если СпособПересчетаПоКурсам = Перечисления.бит_СпособыПересчетаПоКурсам.НеПересчитывается Тогда
			Если СпособПересчетаПоКурсам = ЗнНеПересчитывается Тогда
			// ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-01-31 (#2954)
				// Если способ = "НеПересчитывается", тогда значение не пересчитывается.
				Продолжить;		
			КонецЕсли;
			
			Если СпособПересчетаПоКурсам = СпособыПересчета.СреднийКурсЗаПериод Тогда
				СоответствиеКурсовВалют = СоответствиеКурсовВалют_С;
			ИначеЕсли СпособПересчетаПоКурсам = СпособыПересчета.КурсНаНачалоПериода Тогда
				СоответствиеКурсовВалют = СоответствиеКурсовВалют_Н;
			ИначеЕсли СпособПересчетаПоКурсам = СпособыПересчета.КурсНаКонецПериода Тогда
				СоответствиеКурсовВалют = СоответствиеКурсовВалют_К;
			ИначеЕсли СпособПересчетаПоКурсам = СпособыПересчета.СреднийКурсОтчетностиЗаПериод Тогда
				СоответствиеКурсовВалют = СоответствиеКурсовВалют_Со;
			ИначеЕсли СпособПересчетаПоКурсам = СпособыПересчета.КурсОтчетностиНаНачалоПериода Тогда
				СоответствиеКурсовВалют = СоответствиеКурсовВалют_Но;
			ИначеЕсли СпособПересчетаПоКурсам = СпособыПересчета.КурсОтчетностиНаКонецПериода Тогда
				СоответствиеКурсовВалют = СоответствиеКурсовВалют_Ко;
			Иначе
				Продолжить;
			КонецЕсли;
			
			// Структура валюты исходной
			Если ИмяВалютыИсходной = Неопределено Или СтрокаТабл[ИмяВалютыИсходной] = ВалютаРегл Тогда
				СтруктураВалНачало = СтруктураВалютыРегл;
			Иначе 	
				СтруктураВалНачало = СоответствиеКурсовВалют.Получить(СтрокаТабл[ИмяВалютыИсходной]);
			КонецЕсли;
			// Структура валюты исходной
			Если ВалютаОтчета = ВалютаРегл Тогда
				СтруктураВалКонец = СтруктураВалютыРегл;
			Иначе 	
				СтруктураВалКонец = СоответствиеКурсовВалют.Получить(ВалютаОтчета);
			КонецЕсли;
			
			Если СтруктураВалНачало = Неопределено Или СтруктураВалКонец = Неопределено Тогда
				ТекстСообщения = Нстр("ru = 'Обнаружен нулевой курс'");
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);					
				Продолжить;
			КонецЕсли;
			
			Если ВалютаОтчета = СтруктураВалНачало.Валюта Тогда
				// Если валюты совпадают, то нет смысла пересчитывать.
				Продолжить;
			КонецЕсли; 			
			
			// Пересчет 
			СтрокаТабл[ИмяРесурса] = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(СтрокаТабл[ИмяРесурса]
																			, СтруктураВалНачало.Валюта
																			, СтруктураВалКонец.Валюта 
																			, СтруктураВалНачало.Курс
																			, СтруктураВалКонец.Курс
																			, СтруктураВалНачало.Кратность
																			, СтруктураВалКонец.Кратность);
		КонецЦикла;
																		
	КонецЦикла;																	

КонецПроцедуры // ПересчитатьРесурсыПоКурсам()

//  Процедура формирует соответствие между источниками данных и соответствием колонок 
// источников и таблицы результата.
// 
// Параметры:
//  СпособКомпоновки  - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
// 
// Возвращаемое значение:
//  СоотвИсточников   - Соответствие.
// 
Функция СформироватьСоответствияПолейДляСпособа(СпособКомпоновки)
	
	СоотвИсточников = Новый Соответствие;
	Для каждого СтрокаТаблицы Из СпособКомпоновки.ИсточникиДанных Цикл
		
		СоотвКолонок = СформироватьСоответствиеПолейПоИсточнику(СтрокаТаблицы.ИсточникДанных,СпособКомпоновки.СоответствиеКолонок);
		
		СоотвИсточников.Вставить(СтрокаТаблицы.ИсточникДанных,СоотвКолонок);
		
	КонецЦикла; 
	
	Возврат СоотвИсточников;
КонецФункции // БитСформироватьСоответствияПолейПоИсточникам()

// Процедура формирует соответствие колонок источника и таблицы результата 
// 
// Параметры:
//  ИсточникДанных  - СправочникСсылка.бит_ИсточникиДанныхДляРасчетовБюджетирования.
//  СоответствиеКолонок  - ТабличнаяЧасть.СоответствиеКолонок.
// 
// Возвращаемое значение:
//   СоотвКолонок   - Соответствие.
// 
Функция СформироватьСоответствиеПолейПоИсточнику(ИсточникДанных,СоответствиеКолонок)

	 СоотвКолонок = Новый Соответствие;
	
	 Отбор = Новый Структура;
	 Отбор.Вставить("ИсточникДанных",ИсточникДанных);
	 
	 МассивСтрок = СоответствиеКолонок.НайтиСтроки(Отбор);
	 
	Для каждого СтрокаТаблицы Из МассивСтрок Цикл
	
		СоотвКолонок.Вставить(СтрокаТаблицы.ИмяКолонкиИсточника,СтрокаТаблицы.ИмяКолонки);
	
	КонецЦикла; 

	Возврат СоотвКолонок;
КонецФункции // БитСформироватьСоответствиеПолейПоИсточнику()

// Процедура формирует строки измерений и ресурсов для свертки и вычисления формул.
// 
// Параметры:
//  СпособКомпоновки - СправочникСсылка.бит_СпособыКомпоновкиИсточниковДанных.
//  Ресурсы          - Массив.
//  СтрИзмеренияСвертки - Строка.
//  СтрРесурсы          - Строка.
// 
Процедура СформироватьСтрокиИзмеренияРесурсы(СпособКомпоновки,Ресурсы,СтрИзмеренияСвертки,СтрРесурсы)
	
	// Сформируем массив имен измерений для вычислений.
	ИзмеренияДляВычислений = Новый Массив;
	// Обязательные
	ИзмеренияДляВычислений.Добавить("ЭлементДанных");
	ИзмеренияДляВычислений.Добавить("ГруппаЭлементДанных");
	ИзмеренияДляВычислений.Добавить("ВидГруппы");
	ИзмеренияДляВычислений.Добавить("Кодификатор");
	ИзмеренияДляВычислений.Добавить("Коэффициент");
	ИзмеренияДляВычислений.Добавить("Обработана");
	// Настраиваемые
	Для каждого СтрокаИзмерения Из СпособКомпоновки.КолонкиТаблицы Цикл
		
		Если ВРег(СтрокаИзмерения.ВидКолонки) = ВРег("Ресурс") Тогда
			
			Продолжить;
			
		КонецЕсли; 
		
		Если НЕ СтрокаИзмерения.ИспользоватьВРасчетах Тогда
			
			Продолжить;
			
		КонецЕсли; 
		
		ИзмеренияДляВычислений.Добавить(СтрокаИзмерения.ИмяКолонки);
		
	КонецЦикла; 
	
	// Сформируем строку со списком измерений по которым выполняем свертку.
	СтрИзмеренияСвертки = "";
	Для каждого Элемент Из ИзмеренияДляВычислений Цикл
		
		СтрИзмеренияСвертки = бит_СтрокиКлиентСервер.ДобавитьСтрокуСРазделителем(СтрИзмеренияСвертки,Элемент,",");
		
	КонецЦикла; 
	
	// Строка список ресурсов
	СтрРесурсы = "";
	Для каждого Элемент Из Ресурсы  Цикл
		
		СтрРесурсы = бит_СтрокиКлиентСервер.ДобавитьСтрокуСРазделителем(СтрРесурсы,Элемент,",");
		СтрРесурсы = бит_СтрокиКлиентСервер.ДобавитьСтрокуСРазделителем(СтрРесурсы,Элемент+"Исходный",",");		 
		
	КонецЦикла; 
	
КонецПроцедуры // СформироватьСтрокиИзмеренияРесурсы()

// Процедура выполняет обход по иерархии дерева с группами и формулами.
// 
// Параметры:
//  СтрокаДереваВерх  - СтрокаДереваЗначений.
//  ТаблицаРезультат  - ТаблицаЗначений.
//  Ресурсы           - Массив.
// 
Процедура ОбойтиИерархию(СтрокаДереваВерх,ТаблицаРезультат,Ресурсы)

	Для каждого СтрокаДерева Из СтрокаДереваВерх.Строки Цикл
		
		Если СтрокаДерева.ВидГруппы = Перечисления.бит_ВидыГруппДанных.Группировка Тогда
			ДобавитьГруппуВТаблицуРезультат(СтрокаДерева,ТаблицаРезультат,Ресурсы);
		ИначеЕсли СтрокаДерева.ВидГруппы = Перечисления.бит_ВидыГруппДанных.Формула Тогда	
			ВыполнитьРасчетСтрокиПоФормуле(СтрокаДерева,ТаблицаРезультат,Ресурсы);
		КонецЕсли; 
		
	КонецЦикла; 
	 
КонецПроцедуры // ОбойтиГруппировкуПоИерархии()

// Процедура добавляет в таблицу-результат группы, соответствующие элементам данных вида "Группировка".
// Производится вычисление сумм по иерархии.
// 
// Параметры:
//  СтрокаДереваВерх  - СтрокаДереваЗначений.
//  ТаблицаРезультат  - ТаблицаЗначений.
//  Ресурсы           - Массив.
// 
Процедура ДобавитьГруппуВТаблицуРезультат(СтрокаДереваВерх,ТаблицаРезультат,Ресурсы)

	Если СтрокаДереваВерх = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	Если СтрокаДереваВерх.Обработана Тогда
		Возврат;
	КонецЕсли; 
	
	ТекущаяГруппа = СтрокаДереваВерх.Группа;
	
	СтрокаРезультат = ТаблицаРезультат.Найти(ТекущаяГруппа,"ЭлементДанных");
	
	Если СтрокаРезультат = Неопределено Тогда
		СтрокаРезультат = ТаблицаРезультат.Добавить();
		СтрокаРезультат.ГруппаЭлементДанных = ТекущаяГруппа.Родитель;
		СтрокаРезультат.ЭлементДанных       = ТекущаяГруппа;
		СтрокаРезультат.Кодификатор         = ТекущаяГруппа.Кодификатор;
		СтрокаРезультат.Коэффициент         = ТекущаяГруппа.Коэффициент;
		СтрокаРезультат.ВидГруппы           = ТекущаяГруппа.ВидГруппы;
	КонецЕсли; 
	
	Если СтрокаРезультат.Обработана Тогда
	
		Возврат;
	
	КонецЕсли; 
	
	ОбойтиИерархию(СтрокаДереваВерх,ТаблицаРезультат,Ресурсы);
	
	Итоги          = Новый Структура;
	Для каждого ИмяРесурса Из Ресурсы Цикл
		Итоги.Вставить(ИмяРесурса,0);
	КонецЦикла; 	
	
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("ГруппаЭлементДанных",ТекущаяГруппа);
	
	МассивСтрок = ТаблицаРезультат.НайтиСтроки(СтрОтбор);
	
	
	Для каждого СтрокаТаблицы Из МассивСтрок Цикл
		
		Для каждого ИмяРесурса Из Ресурсы Цикл
			
			Итоги[ИмяРесурса] = Итоги[ИмяРесурса]+СтрокаТаблицы[ИмяРесурса];			
			
		КонецЦикла; 
		
	КонецЦикла; 
	
	Для каждого ИмяРесурса Из Ресурсы Цикл
		СтрокаРезультат[ИмяРесурса+"Исходный"] = Итоги[ИмяРесурса];
		СтрокаРезультат[ИмяРесурса]            = Итоги[ИмяРесурса]*СтрокаРезультат.Коэффициент;		
	КонецЦикла;

	СтрокаРезультат.Обработана  = Истина;
	СтрокаДереваВерх.Обработана = Истина;
	
КонецПроцедуры // ДобавитьГруппу()

// Функция формирует имя колонки аргумента.
// 
// Параметры:
//  КодЭлементаДанных - Строка
// 
// Возвращаемое значение:
//  ИмяКолонки - Строка.
// 
Функция ИмяКолонкиАргумента(КодЭлементаДанных)
	
	ИмяКолонки = "Аргумент_"+СтрЗаменить(КодЭлементаДанных,"-","_");
	
	Возврат ИмяКолонки;
	
КонецФункции // ИмяКолонкиАргумента()

// Выполняет расчет по строке расчета по формуле. Вызывается рекурсивно.
// 
// Параметры:
// 
// СтрокаРасчета - СправочникСсылка.бит_ЭлементыДанных - группа.
// ТаблицаРезультат - ТаблицаЗначений.
// Ресурсы          - Массив - Содержит имена ресурсов способа компоновки .
// 
Процедура ВыполнитьРасчетСтрокиПоФормуле(СтрокаДереваВерх,ТаблицаРезультат,Ресурсы)
	
	Если СтрокаДереваВерх = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	Если СтрокаДереваВерх.Обработана Тогда
		Возврат;
	КонецЕсли; 
	
	СтрокаРасчета = СтрокаДереваВерх.Группа;
	
	ОписаниеТиповЧисла20 = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(20,4));
		
	ТаблицаЗначенийАргументов = Новый ТаблицаЗначений;
	ТаблицаЗначенийАргументов.Колонки.Добавить("ИмяРесурса");
	
	Измерения = Новый Массив;
	
	Для Каждого Колонка ИЗ ТаблицаРезультат.Колонки Цикл
		Если Ресурсы.Найти(Колонка.Имя)=Неопределено
             И Найти(Колонка.Имя,"Исходный")= 0	
			 И Колонка.Имя <> "Обработана" 	
			 И Колонка.Имя <> "ВидГруппы" 			 			 
			 И Колонка.Имя <> "ГруппаЭлементДанных" 
			 И Колонка.Имя <> "ЭлементДанных"
			 И Колонка.Имя <> "Коэффициент"
			 И Колонка.Имя <> "Кодификатор" Тогда
			ТаблицаЗначенийАргументов.Колонки.Добавить(Колонка.Имя);
			Измерения.Добавить(Колонка.Имя);
		КонецЕсли; 
	КонецЦикла;	
	
	// Формируем колонки для хранения агрументов расчета. 
	Для каждого Аргумент Из СтрокаРасчета.СтрокиРасчетаДляФормулы Цикл
		Если Аргумент.СтрокаРасчета.ВидГруппы = Перечисления.бит_ВидыГруппДанных.Формула Тогда
			// Выполняем расчет сначала для строк-аргументов.
			ДеревоДанных = СтрокаДереваВерх.Владелец();
			СтрокаДерева = ДеревоДанных.Строки.Найти(Аргумент.СтрокаРасчета,"Группа",Истина);
			ВыполнитьРасчетСтрокиПоФормуле(СтрокаДерева,ТаблицаРезультат,Ресурсы);
		ИначеЕсли Аргумент.СтрокаРасчета.ВидГруппы = Перечисления.бит_ВидыГруппДанных.Группировка Тогда
			// Добавляем аргументы - группы
			ДеревоДанных = СтрокаДереваВерх.Владелец();
			СтрокаДерева = ДеревоДанных.Строки.Найти(Аргумент.СтрокаРасчета,"Группа",Истина);						
			ДобавитьГруппуВТаблицуРезультат(СтрокаДерева,ТаблицаРезультат,Ресурсы);
		КонецЕсли;
		
			// КодЭД = СтрЗаменить(Аргумент.СтрокаРасчета.Код,"-","_");
			// ИмяКолонки = "Аргумент_"+КодЭД;
			ИмяКолонки = ИмяКолонкиАргумента(Аргумент.СтрокаРасчета.Код);
			
			ТаблицаЗначенийАргументов.Колонки.Добавить(ИмяКолонки,ОписаниеТиповЧисла20);
		
	КонецЦикла;
	
	// Заполним таблицу агрументов
	
	Для каждого Аргумент Из СтрокаРасчета.СтрокиРасчетаДляФормулы Цикл
		
		СтруктураОтбора = Новый Структура;
		СтруктураОтбора.Вставить("ЭлементДанных",Аргумент.СтрокаРасчета);
		
		МассивСтрок = ТаблицаРезультат.НайтиСтроки(СтруктураОтбора);
		
		Для каждого СтрокаДанные Из МассивСтрок Цикл
			
			Для каждого Ресурс Из Ресурсы Цикл
				
				Отбор = Новый Структура;
				Отбор.Вставить("ИмяРесурса",Ресурс);
				Для каждого Измерение Из Измерения Цикл
				
					Отбор.Вставить(Измерение,СтрокаДанные[Измерение]);
				
				КонецЦикла; // По измерениям
				
				МассивСтрокАргументы = ТаблицаЗначенийАргументов.НайтиСтроки(Отбор);
				Если МассивСтрокАргументы.Количество()>0 Тогда
					СтрокаАргумент = МассивСтрокАргументы[0];
				Иначе	
					СтрокаАргумент = ТаблицаЗначенийАргументов.Добавить();
					СтрокаАргумент.ИмяРесурса = Ресурс;
					Для каждого Измерение Из Измерения Цикл
					
						СтрокаАргумент[Измерение] = СтрокаДанные[Измерение];
					
					КонецЦикла; // По измерениям
				КонецЕсли; 
				
				// КодЭД      = СтрЗаменить(Аргумент.СтрокаРасчета.Код,"-","_");				
				// ИмяКолонки = "Аргумент_"+КодЭД;
				ИмяКолонки = ИмяКолонкиАргумента(Аргумент.СтрокаРасчета.Код);
				СтрокаАргумент[ИмяКолонки] = СтрокаАргумент[ИмяКолонки]+СтрокаДанные[Ресурс];
				
			КонецЦикла; 
			
		КонецЦикла; // По строкам данных
		
	КонецЦикла; // По аргументам - группам, которые участвуют в формуле.
	
	
	
	// Выполним вычисления и занесем данные в ТаблицуРезультат.
	Для каждого СтрокаТабл Из ТаблицаЗначенийАргументов Цикл
		Формула   = СтрокаРасчета.Формула;
		
		// На случай, если элементы данных кодируются с префиксами ИБ.
		МассивАрг = РазобратьФормулу(Формула);
		
		Для каждого Арг Из МассивАрг Цикл
			
			АргНов = СтрЗаменить(Арг,"-","_");
			Формула   = СтрЗаменить(Формула,Арг,АргНов);
			
		КонецЦикла; 
		
		Для каждого КолонкаТабл Из ТаблицаЗначенийАргументов.Колонки Цикл
			Если КолонкаТабл.Имя = "ИмяРесурса" Тогда
				Продолжить;
			КонецЕсли;
			Формула = СтрЗаменить(Формула,"["+Сред(КолонкаТабл.Имя,10)+"]",Формат(СтрокаТабл[КолонкаТабл.Имя],"ЧРД=.; ЧН=0; ЧГ=0"));
			
		КонецЦикла;
		Формула = СтрЗаменить(Формула,"@",",");					
		Попытка
			Результат = Вычислить(Формула);
		Исключение
			Результат = 0;
			ТекстСообщения = "Ошибка вычисления выражения """
							+Формула
							+""", до обработки """
							+СтрокаРасчета.Формула
							+""", элемент данных """
							+СтрокаРасчета.Наименование
							+""". Причина: "
							+ОписаниеОшибки()
							+".";
			
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		КонецПопытки;
		
		Отбор = Новый Структура;
		Отбор.Вставить("ЭлементДанных",СтрокаРасчета);
		Для каждого Измерение Из Измерения Цикл
			Отбор.Вставить(Измерение,СтрокаТабл[Измерение]);
		КонецЦикла; // По измерениям
		
		МассивСтрок = ТаблицаРезультат.НайтиСтроки(Отбор);
		Если МассивСтрок.Количество()>0 Тогда
			СтрокаРезультат = МассивСтрок[0];
		Иначе
			СтрокаРезультат = ТаблицаРезультат.Добавить();
			СтрокаРезультат.ГруппаЭлементДанных = СтрокаРасчета.Родитель;
			СтрокаРезультат.Кодификатор         = СтрокаРасчета.Кодификатор;
			СтрокаРезультат.Коэффициент         = СтрокаРасчета.Коэффициент;
			СтрокаРезультат.ЭлементДанных       = СтрокаРасчета;
			СтрокаРезультат.ВидГруппы           = СтрокаРасчета.ВидГруппы;
			Для каждого Измерение Из Измерения Цикл
				
				СтрокаРезультат[Измерение] = СтрокаТабл[Измерение];
				
			КонецЦикла; // По измерениям
		КонецЕсли; 
		
		Если СтрокаРезультат <> Неопределено Тогда
			
			СтрокаРезультат[СтрокаТабл.ИмяРесурса+"Исходный"] = Результат;
			СтрокаРезультат[СтрокаТабл.ИмяРесурса]            = Результат*СтрокаРезультат.Коэффициент;
			СтрокаРезультат.Обработана                        = Истина;
			
		КонецЕсли; 
		
	КонецЦикла;
	
	СтрокаДереваВерх.Обработана = Истина;
	
КонецПроцедуры

// Процедура восстанавливает координату.
// 
// Параметры:
//  ИмяОбласти     - Строка
//  ИмяКоординаты1 - Строка
//  ИмяКоординаты2 - Строка
// 
Функция ВосстановитьКоординату(ИмяОбласти,ИмяКоординаты1,ИмяКоординаты2)
	
	Позиция1   = Найти(ИмяОбласти,ИмяКоординаты1);
	Позиция2   = Найти(ИмяОбласти,ИмяКоординаты2);
	Координата = 0;
	Если Позиция1>0 Тогда
		
		СтрКоордината = Сред(ИмяОбласти,Позиция1+1,Позиция2-Позиция1-1);
		Координата    = СтрокуВЧисло(СтрКоордината);		
		
		Если Позиция2 = 0 Тогда
			ИмяОбласти = "";
		Иначе	
			ИмяОбласти  = Сред(ИмяОбласти,Позиция2);
		КонецЕсли;	
		
	КонецЕсли;	
	
	Возврат Координата;
	
КонецФункции // ВосстановитьКоординату()

// Функция восстанавливает число по строковому представлению.
// 
// Параметры:
//  СтрПредставление  - Строка
// 
// Возвращаемое значение:
//   РезЧисло   - Число
// 
Функция СтрокуВЧисло(СтрПредставление)

	Попытка
	
		РезЧисло = Число(СтрПредставление);
	
	Исключение
	    РезЧисло = 0;
	КонецПопытки;
	
	Возврат РезЧисло;

КонецФункции // СтрокуВЧисло()

// Функция выполняет расчет значения по формуле в произвольном отчете.
// 
// Параметры:
//  СтрокаПравил  - СтрокаТабличнойЧасти.ПравилаЗаполнения.
//  ПравилаЗаполнения - ТабличнаяЧасть.ПравилаЗаполнения.
// 
// ВозвращаемоеЗначение:
//  Результат
// 
Функция ВыполнитьРасчетПоФормуле(СтрокаПравил, ПравилаЗаполнения, ТаблицаДанныеОтчета, НастройкиАналитик, УровеньРекурсии=0)
	
	Заголовок = "Ошибка при вычислении формулы показателя """ + СтрокаПравил.ИмяОбласти + """: ";
	
	СуммаИтог = 0;
	
	// Защита от зацикливания
	Если УровеньРекурсии>1000 Тогда
	
		ТекстСообщения = "Превышен уровень рекурсии! Проверьте настройки формул на зацикливание.";
		бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
	    Возврат СуммаИтог;
		
	КонецЕсли; 
	УровеньРекурсии = УровеньРекурсии+1;
		
	Если СтрокаПравил.ВидЯчейки <> Перечисления.бит_ВидыЯчеекПроизвольногоОтчета.Формула Тогда
		Возврат СуммаИтог;
	КонецЕсли;
	
	// Если значение уже вычислено выходим 
	СтрокаАргумент = Неопределено;
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("ИмяОбласти",СтрокаПравил.ИмяОбласти);
	
	НайденныеСтроки = ТаблицаДанныеОтчета.НайтиСтроки(СтрОтбор);
	Если НайденныеСтроки.Количество()>0 Тогда
		
		Для каждого СтрокаДанные Из НайденныеСтроки Цикл
			СуммаИтог = СуммаИтог+СтрокаДанные.ЗначениеПоказателя;
		КонецЦикла; 		
		
		Возврат СуммаИтог;
	КонецЕсли; 
		
	Формула 			 = СтрокаПравил.Формула; 
	МассивИменАргументов = РазобратьФормулу(Формула);
	
	// Инициализация таблицы аргументов
	ОписаниеЧисло = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(20,4));
	
	// Формирование таблицы аргументов
	ТаблицаАргументы = Новый ТаблицаЗначений;
	Для каждого КиЗ Из НастройкиАналитик Цикл
		ТаблицаАргументы.Колонки.Добавить(КиЗ.Ключ,КиЗ.Значение.ТипЗначения);
	КонецЦикла; 
	
	Для каждого ИмяАргумента Из МассивИменАргументов Цикл
		ИмяКолонки = "Аргумент_" + ИмяАргумента;
		Если ТаблицаАргументы.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			ТаблицаАргументы.Колонки.Добавить(ИмяКолонки,ОписаниеЧисло);
		КонецЕсли;
	КонецЦикла; 
	
	АналитикиПоУмолчанию = Новый Соответствие;
	Для каждого СтрокаАналитики Из СтрокаПравил.Ссылка.ЗначенияПоУмолчанию  Цикл
		АналитикиПоУмолчанию.Вставить(СтрокаАналитики.ИмяАналитики, СтрокаАналитики.ЗначениеАналитики);
	КонецЦикла; 
	
	// Заполняем таблицу аргументов
	Для каждого ИмяАргумента Из МассивИменАргументов Цикл
	
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("ИмяОбласти",ИмяАргумента);
		НайденныеДанные = ТаблицаДанныеОтчета.НайтиСтроки(СтрОтбор);
		
        Если НайденныеДанные.Количество()=0 Тогда
			
			// Не удалось найти агрументы для расчета
			// возможно, аргументом является другая формула, которую нужно вычислить.
			СтрокаПравилФормула = ПравилаЗаполнения.Найти(ИмяАргумента,"ИмяОбласти");
			Если СтрокаПравилФормула <> Неопределено  Тогда
				
				ВыполнитьРасчетПоФормуле(СтрокаПравилФормула
				                                      ,ПравилаЗаполнения
													  ,ТаблицаДанныеОтчета
													  ,НастройкиАналитик
													  ,УровеньРекурсии);
			Иначе
													  
				СуммаИтог = 0;
				ТекстСообщения = "Не найдена строка правил для расчета аргумента """ 
								  + ИмяАргумента 
								  + """, аргументу присвоено значение 0.";
				бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);								  

			КонецЕсли; 

			// После вычисления повторяем поиск аргументов.
		    НайденныеДанные = ТаблицаДанныеОтчета.НайтиСтроки(СтрОтбор);
		КонецЕсли; 
		
		Для каждого СтрокаДанные Из НайденныеДанные Цикл
			// Заполним значения аргумента
			Если ТаблицаАргументы.Количество() = 0 Тогда
				СтрокаАргументы = ТаблицаАргументы.Добавить();
			Иначе	
				СтрокаАргументы = ТаблицаАргументы[0];
			КонецЕсли; 
			СтрокаАргументы["Аргумент_" + ИмяАргумента] = СтрокаАргументы["Аргумент_" + ИмяАргумента] + СтрокаДанные.ЗначениеПоказателя;
		КонецЦикла; // По найденным данным
	КонецЦикла; // По аргументам
		
	// Производим вычисления независимо для каждой комбинации аналитик.
	Для каждого СтрокаАргумент Из ТаблицаАргументы Цикл
		
		ВремФормула = Формула;
		
		Для каждого ИмяАргумента Из МассивИменАргументов Цикл
			ЧтоЗаменить   = "[" + ИмяАргумента + "]";
			НаЧтоЗаменить = Формат(СтрокаАргумент["Аргумент_" + ИмяАргумента],"ЧРД=.; ЧН=0; ЧГ=0");
			ВремФормула   = СтрЗаменить(ВремФормула, ЧтоЗаменить, НаЧтоЗаменить);
		КонецЦикла; 
		
		ВремФормула = СтрЗаменить(ВремФормула,"@",",");
		
		// Вычисляем результат по формуле
		Попытка
			Результат = Вычислить(ВремФормула);
		Исключение
			Результат = 0;

			ТекстСообщения = Нстр("ru= 'Ошибка вычисления выражения - %1, выражение до обработки - %2. По причине: %3'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
															ТекстСообщения,
															ВремФормула,
															СтрокаПравил.Формула,
															КраткоеПредставлениеОшибки(ИнформацияОбОшибке())); 
			ТекстСообщения = Заголовок + ?(ПустаяСтрока(Заголовок),ТекстСообщения,Символы.ПС + ТекстСообщения); 												
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения); 
		КонецПопытки;
		
		
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("ИмяОбласти",СтрокаПравил.ИмяОбласти);
		// Попытка попасть в туже аналитику. Особенно, если раньше удалили
		//Для каждого КиЗ Из НастройкиАналитик Цикл
		//	ИмяАналитики = КиЗ.Ключ;
		//	СтрОтбор.Вставить(ИмяАналитики,СтрокаАргумент[ИмяАналитики]);
		//КонецЦикла; 
		
		НайденныеСтроки = ТаблицаДанныеОтчета.НайтиСтроки(СтрОтбор);
		
		Если НайденныеСтроки.Количество() = 0 Тогда
			
			// Добавим вычисленное значение в таблицу аргументов.
			НоваяСтрока = ТаблицаДанныеОтчета.Добавить();
			НоваяСтрока.ИмяОбласти           = СтрокаПравил.ИмяОбласти;			
			НоваяСтрока.ВидЯчейки            = СтрокаПравил.ВидЯчейки;
			НоваяСтрока.ПоказательОтчета     = СтрокаПравил.Ссылка;
			НоваяСтрока.ЗначениеПоказателя   = Результат;
			НоваяСтрока.ИД                   = Строка(Новый УникальныйИдентификатор);
			
			ЗаполнитьЗначенияПоУмолчаниюСтрокиТаблицыДанных(НоваяСтрока);
			
			Для каждого КиЗ Из НастройкиАналитик Цикл
				ИмяАналитики = КиЗ.Ключ;
				Если НЕ ЗначениеЗаполнено(НоваяСтрока[ИмяАналитики]) Тогда
					НоваяСтрока[ИмяАналитики] = СтрокаАргумент[ИмяАналитики];
				КонецЕсли; 
			КонецЦикла; 
		Иначе
			НайденныеСтроки[0].ЗначениеПоказателя = НайденныеСтроки[0].ЗначениеПоказателя+Результат;
		КонецЕсли; 
		
		СуммаИтог = СуммаИтог+Результат;
	КонецЦикла; // По таблице аргументов
	
	Возврат СуммаИтог;
	
КонецФункции // ВыполнитьРасчетПоФормуле() 

// Получим представление периода отчета.
// 
Функция ОписаниеПериода(ДатаНачала,ДатаОкончания)

	ОписаниеПериода = "";
	
	Если ДатаНачала = '00010101000000' И ДатаОкончания = '00010101000000' Тогда

		ОписаниеПериода = "Период: без ограничения.";

	Иначе

		Если ДатаНачала = '00010101000000' ИЛИ ДатаОкончания = '00010101000000' Тогда
			ОписаниеПериода = "Период: " + Формат(ДатаНачала, "ДФ = ""дд.ММ.гггг""; ДП = ""без ограничения""") 
							+ " - "      + Формат(ДатаОкончания, "ДФ = ""дд.ММ.гггг""; ДП = ""без ограничения""");
		Иначе
			ОписаниеПериода = "Период: " + ПредставлениеПериода(НачалоДня(ДатаНачала), КонецДня(ДатаОкончания), "ФП = Истина");
		КонецЕсли;

	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции // ОписаниеПериода()

// Получим представление периода отчета.
// 
Функция ОписаниеПериодаМСФО(ДатаОкончания,Язык)

	ОписаниеПериода = "";
	
	КодЯзыка = Справочники.бит_Языки.ПолучитьКодЯзыка(Язык);
	
	Если НачалоДня(ДатаОкончания) = Дата(Год(ДатаОкончания), 12, 31) Тогда
		ОписаниеПериода = НСтр("ru = "" год, окончившийся""; en = "" YEAR ENDED""", КодЯзыка);
	ИначеЕсли НачалоДня(ДатаОкончания) = Дата(Год(ДатаОкончания), 03, 31) Тогда
		ОписаниеПериода = НСтр("ru = "" три месяца, окончившихся""; en = "" THREE MONTHS ENDED""", КодЯзыка);
	ИначеЕсли НачалоДня(ДатаОкончания) = Дата(Год(ДатаОкончания), 06, 30) Тогда
		ОписаниеПериода = НСтр("ru = "" шесть месяцев, окончившихся""; en = "" SIX MONTHS ENDED""", КодЯзыка);
	ИначеЕсли НачалоДня(ДатаОкончания) = Дата(Год(ДатаОкончания), 09, 30) Тогда
		ОписаниеПериода = НСтр("ru = "" девять месяцев, окончившихся""; en = "" NINE MONTHS ENDED""", КодЯзыка);
	Иначе
		ОписаниеПериода = Формат(ДатаОкончания,"Л=" + КодЯзыка + "; ДФ=dd.MM.yyyy");;
	КонецЕсли;

	Возврат ОписаниеПериода;

КонецФункции // ОписаниеПериодаМСФО()
	
// Процедура заполняет значения по умолчанию в строке таблицы данных.
// 
// Параметры:
//  ТекущаяСтрока
// 
Процедура ЗаполнитьЗначенияПоУмолчаниюСтрокиТаблицыДанных(ТекущаяСтрока)
	
	Если ЗначениеЗаполнено(ТекущаяСтрока.ПоказательОтчета) Тогда
		
		Показатель = ТекущаяСтрока.ПоказательОтчета;
		
		ТекущаяСтрока.ПериодДанных = Показатель.ПериодДанных;
		
		ТекущаяСтрока.ФормироватьДвиженияПоБюджету = Показатель.ФормироватьДвиженияПоБюджету;
		
		Для каждого СтрокаТаблицы Из Показатель.ЗначенияПоУмолчанию Цикл
			
			ТекущаяСтрока[СтрокаТаблицы.ИмяАналитики] = СтрокаТаблицы.ЗначениеАналитики;
			
		КонецЦикла; // Показатель.ЗначенияПоУмолчанию
		
	КонецЕсли; 
	
КонецПроцедуры // ЗаполнитьЗначенияПоУмолчаниюСтрокиТаблицыДанных()	

//bit auavseenkov++ Расчет отложенных налогов 21.11.2014  
Процедура ИзменитьТекстЗапросаДляРасчетаОтлеженныхНалогов(ПостроительЗапроса,НастройкаИсточника);
	
	ТекстЗапросаДляГруппировкиОбъектов = "
		
		|     ВЫБОР КОГДА ВР_Итог.Объект.Родитель = ЗНАЧЕНИЕ(Справочник.ОбъектыСтроительства.ПустаяСсылка)
		|		ТОГДА ВР_Итог.Объект
		|		ИНАЧЕ
		|		ВЫБОР
		|			 КОГДА ВР_Итог.Объект.Родитель.Родитель = ЗНАЧЕНИЕ(Справочник.ОбъектыСтроительства.ПустаяСсылка)
		|			 ТОГДА ВР_Итог.Объект.Родитель
		|			 ИНАЧЕ
		|			 ВЫБОР
		|					КОГДА ВР_Итог.Объект.Родитель.Родитель.Родитель = ЗНАЧЕНИЕ(Справочник.ОбъектыСтроительства.ПустаяСсылка)
		|					ТОГДА ВР_Итог.Объект.Родитель.Родитель
		|				 	ИНАЧЕ ВР_Итог.Объект.Родитель.Родитель.Родитель
		|			КОНЕЦ
		|		КОНЕЦ
		|		КОНЕЦ";

	ИзменитьТекст = Истина;
	Если НастройкаИсточника.ПараметрыПостроителя.Свойство("СопоставлятьПоОбъекту") Тогда 
		Если НастройкаИсточника.ПараметрыПостроителя.СопоставлятьПоОбъекту тогда
			//Проверим если настойка: Сопоставление по объекту, отбор НУ используется,но не заполнен и не заполнен ТипДанныхНУОбъект
			
			ОтборМассива = НастройкаИсточника.Отбор;
			Для  Каждого Отбор из ОтборМассива Цикл 
				ИмяОтбора = "";
				Если Отбор.Свойство("ПутьКДанным") Тогда 
					Если Отбор.ПутьКДанным = "СчетНУ" Тогда 
						Если Отбор.Использование и не ЗначениеЗаполнено(Отбор.Значение) Тогда 
													
							ПостроительЗапроса.Текст = ТекстЗапросаДляРасчетаОтложенныхНалоговДляМУ();
							ИзменитьТекст = Ложь;
						КонецЕсли;
					ИначеЕсли Отбор.ПутьКДанным = "СчетМУ" Тогда 
						Если Отбор.Использование и не ЗначениеЗаполнено(Отбор.Значение) Тогда 
							
							ПостроительЗапроса.Текст = ТекстЗапросаДляРасчетаОтложенныхНалоговДляНУ();
							ИзменитьТекст = Ложь;
						КонецЕсли;
						
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			
			
			Если  НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхМУОбъект")  Тогда 
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхМУОбъект",НастройкаИсточника.ПараметрыПостроителя.ТипДанныхМУОбъект);
			КонецЕсли;
				
			Если  НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхНУОбъект") Тогда 
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхНУОбъект","НУОстатки."+НастройкаИсточника.ПараметрыПостроителя.ТипДанныхНУОбъект);
			КонецЕсли;
			
			Если НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхОбъект") Тогда  
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхОбъект",НастройкаИсточника.ПараметрыПостроителя.ТипДанныхОбъект);
			КонецЕсли;
			
			Если  НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхБУОбъект") Тогда 
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхБУОбъект","НУОстатки."+НастройкаИсточника.ПараметрыПостроителя.ТипДанныхБУОбъект);
			КонецЕсли;
			
			Если ИзменитьТекст Тогда  
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"""ИзменитьТекстЗапроса""",ТекстЗапросаДляГруппировкиОбъектов);
			КонецЕсли;
		Иначе	
			
			
			Если  НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхМУОбъект") Тогда 
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхМУОбъект ССЫЛКА Справочник.ОбъектыСтроительства","&СопоставлятьПоОбъекту");
			КонецЕсли;
				
			Если  НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхНУОбъект") Тогда 
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхНУОбъект ССЫЛКА Справочник.ОбъектыСтроительства","&СопоставлятьПоОбъекту");
			КонецЕсли;
			
			Если НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхБУОбъект") Тогда  
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхБУОбъект ССЫЛКА Справочник.ОбъектыСтроительства","&СопоставлятьПоОбъекту");
			КонецЕсли;

			Если НастройкаИсточника.ПараметрыПостроителя.Свойство("ТипДанныхОбъект") Тогда  
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"&ТипДанныхОбъект ССЫЛКА Справочник.ОбъектыСтроительства","&СопоставлятьПоОбъекту");
			КонецЕсли;

		КонецЕсли;
	КонецЕсли;
	
	Если НастройкаИсточника.ПараметрыПостроителя.Свойство("КонецПериода_РОН") Тогда   
		Если Не ЗначениеЗаполнено(НастройкаИсточника.ПараметрыПостроителя.КонецПериода_РОН) Тогда 
			ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"КонецПериода_РОН","КонецПериода");
		КонецЕсли;
	КонецЕсли;
	
	Если НастройкаИсточника.ПараметрыПостроителя.Свойство("УровеньРазворотаПоСчетуНУ") Тогда 
		Если НастройкаИсточника.ПараметрыПостроителя.УровеньРазворотаПоСчетуНУ <> Неопределено  Тогда 
			Если НастройкаИсточника.ПараметрыПостроителя.УровеньРазворотаПоСчетуНУ =  1 тогда
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"""НУОстатки.Субконто1""","НУОстатки.Субконто1");
			ИначеЕсли НастройкаИсточника.ПараметрыПостроителя.УровеньРазворотаПоСчетуНУ =  2 тогда
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"""НУОстатки.Субконто1""","НУОстатки.Субконто1");
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"""НУОстатки.Субконто2""","НУОстатки.Субконто2");
			ИначеЕсли НастройкаИсточника.ПараметрыПостроителя.УровеньРазворотаПоСчетуНУ >=  3 тогда
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"""НУОстатки.Субконто1""","НУОстатки.Субконто1");
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"""НУОстатки.Субконто2""","НУОстатки.Субконто2");
				ПостроительЗапроса.Текст  =  СтрЗаменить(ПостроительЗапроса.Текст,"""НУОстатки.Субконто3""","НУОстатки.Субконто3");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	 
КонецПроцедуры

Процедура ИзменитьОтборДляРасчетаОтложенныхНалоговРегистратор(ПостроительЗапроса,НастройкаИсточника)
	
	Для Каждого Строк из НастройкаИсточника.Отбор цикл
		
		//ОКЕЙ Морозов А.В. (СофтЛаб) Начало 2020-08-10 (#3816)
		//Если Строк.Свойство("ПутьКДанным")  Тогда 
		Если ТипЗнч(Строк) = Тип("ЭлементОтбора") Тогда
			Если Строк.Имя = "ПутьКДанным" Тогда
				ЕстьСвойствоПутьКДанным = Истина;
			Иначе
				ЕстьСвойствоПутьКДанным = Ложь;
			КонецЕсли;	
		ИначеЕсли Строк.Свойство("ПутьКДанным") Тогда
			ЕстьСвойствоПутьКДанным = Истина;
		Иначе
			ЕстьСвойствоПутьКДанным = Ложь;
		КонецЕсли;
		Если ЕстьСвойствоПутьКДанным Тогда 
		//ОКЕЙ Морозов А.В. (СофтЛаб) Конец  2020-08-10 (#3816)
			Если Строк.ПутьКДанным = "ТипРегистратора" Тогда 
			Если Строк.Использование Тогда 
				МассивПараметров = Новый Массив ;   
				Если Строк.ВидСравнения = ВидСравнения.Равно Или 
					Строк.ВидСравнения = ВидСравнения.НеРавно Тогда 
					Для Каждого док из Метаданные.Документы Цикл 
						Если док.ПредставлениеОбъекта = Строк.Значение 
							или док.Синоним  = Строк.Значение Тогда 
							МассивПараметров.Добавить(ТипЗнч((Документы[док.Имя].ПолучитьСсылку())));
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
				ИначеЕсли Строк.ВидСравнения = ВидСравнения.ВСписке Или 
					Строк.ВидСравнения = ВидСравнения.НеВСписке Тогда 
					
					Для Каждого СтрокаЗначения из Строк.Значение  Цикл 
						Для Каждого док из Метаданные.Документы Цикл 
							Если док.Синоним = СтрокаЗначения.Значение Или 
								док.ПредставлениеОбъекта = Строк.Значение Тогда 
								МассивПараметров.Добавить(ТипЗнч((Документы[док.Имя].ПолучитьСсылку())));
								Прервать;
							КонецЕсли;
						КонецЦикла;
					КонецЦикла;
				КонецЕсли;
				
				ПостроительЗапроса.Параметры.Вставить("ТипыЗначения_РОН",МассивПараметров);
				Если Строк.ВидСравнения = ВидСравнения.Равно Или 
					Строк.ВидСравнения = ВидСравнения.ВСписке Тогда 
					ПостроительЗапроса.Текст=СтрЗаменить(ПостроительЗапроса.Текст,"//ГДЕ","ГДЕ")
				Иначе 
					ПостроительЗапроса.Текст=СтрЗаменить(ПостроительЗапроса.Текст,"//ГДЕ","ГДЕ НЕ")
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	КонецЦикла;
КонецПроцедуры

Функция ТекстЗапросаДляРасчетаОтложенныхНалоговДляМУ()
	Текст = "
			// agoncharenko #1886 05102015 начало
			|ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация КАК Организация,
			|МАКСИМУМ(бит_му_СоставПериметровКонсолидацииСрезПоследних.ТипКонсолидации) КАК ТипКонсолидации,
			|СУММА(1) КАК ПризнакКонсолидации
			|ПОМЕСТИТЬ ВтКонсолидация
			|ИЗ
			|	РегистрСведений.бит_му_СоставПериметровКонсолидации.СрезПоследних(&КонецПериода, ТипКонсолидации = ЗНАЧЕНИЕ(Перечисление.бит_му_ТипыКонсолидации.Консолидирующая) {(Организация).*}) КАК бит_му_СоставПериметровКонсолидацииСрезПоследних
			|ГДЕ
			|	(КОНЕЦПЕРИОДА(бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания, ДЕНЬ) >= &КонецПериодаДата
			|			ИЛИ бит_му_СоставПериметровКонсолидацииСрезПоследних.ДатаОкончания = ДАТАВРЕМЯ(1, 1, 1))
			|
			|СГРУППИРОВАТЬ ПО
			|	бит_му_СоставПериметровКонсолидацииСрезПоследних.Организация
			|;
	        |////////////////////////////////////////////////////////////////////////////////
			|	
			|	ВЫБРАТЬ
			|СУММА(ВЫБОР
			|		КОГДА ЕСТЬNULL(ВтКонсолидация.ПризнакКонсолидации, 0) > 0
			|			ТОГДА МУОстатки.СуммаУпрОстаток
			|		ИНАЧЕ МУОстатки.СуммаМУОстаток
			|	КОНЕЦ) КАК СуммаМУОстаток,
			|СУММА(ВЫБОР
			|		КОГДА ЕСТЬNULL(ВтКонсолидация.ПризнакКонсолидации, 0) > 0
			|			ТОГДА МУОстатки.СуммаУпрОстатокДт
			|		ИНАЧЕ МУОстатки.СуммаМУОстатокДт
			|	КОНЕЦ) КАК СуммаМУОстатокДт,
			|СУММА(ВЫБОР
			|		КОГДА ЕСТЬNULL(ВтКонсолидация.ПризнакКонсолидации, 0) > 0
			|			ТОГДА МУОстатки.СуммаУпрОстатокКт
			|		ИНАЧЕ МУОстатки.СуммаМУОстатокКт
			|	КОНЕЦ) КАК СуммаМУОстатокКт,
			//|	СУММА(МУОстатки.СуммаМУОстаток) КАК СуммаМУОстаток,
			//|	СУММА(МУОстатки.СуммаМУОстатокДт) КАК СуммаМУОстатокДт,
			//|	СУММА(МУОстатки.СуммаМУОстатокКт) КАК СуммаМУОстатокКт,
			// agoncharenko #1886 конец
	        |	МУОстатки.Субконто1,
	        |	МУОстатки.Субконто2,
	        |	МУОстатки.Субконто3,
	        |	МУОстатки.Организация,
	        |	МУОстатки.Счет,
	        |	ВЫБОР
	        |		КОГДА &СопоставлятьПоОбъекту
	        |			ТОГДА ВЫБОР
	        |					КОГДА &ТипДанныхМУОбъект ССЫЛКА Справочник.ОбъектыСтроительства
	        |						ТОГДА &ТипДанныхМУОбъект
	        |					ИНАЧЕ NULL
	        |				КОНЕЦ
	        |		ИНАЧЕ NULL
	        |	КОНЕЦ КАК Объект
	        |ПОМЕСТИТЬ МУОстатки
	        |{ВЫБРАТЬ
	        |	СуммаМУОстаток,
	        |	СуммаМУОстатокДт,
	        |	СуммаМУОстатокКт,
	        |	МУОстатки.Счет.* КАК СчетМУ}
	        |ИЗ
	        |	РегистрБухгалтерии.бит_Дополнительный_2.Остатки(&КонецПериода, , , {(Организация).*, (Субконто1).* КАК СубконтоМУ1, (Субконто2).* КАК СубконтоМУ2, (Субконто3).* КАК СубконтоМУ3, (Субконто4).* КАК СубконтоМУ4}) КАК МУОстатки
			// agoncharenko #1886 05102015 начало
			|		ЛЕВОЕ СОЕДИНЕНИЕ ВтКонсолидация КАК ВтКонсолидация
			|		ПО МУОстатки.Организация = ВтКонсолидация.Организация
			// agoncharenko #1886 конец
	        |{ГДЕ
	        |	МУОстатки.Счет.* КАК СчетМУ}
	        |
	        |СГРУППИРОВАТЬ ПО
	        |	МУОстатки.Субконто1,
	        |	МУОстатки.Субконто2,
	        |	МУОстатки.Субконто3,
	        |	МУОстатки.Организация,
	        |	МУОстатки.Счет,
			|ВЫБОР
			|	КОГДА &СопоставлятьПоОбъекту
			|		ТОГДА ВЫБОР
			|				КОГДА &ТипДанныхМУОбъект ССЫЛКА Справочник.ОбъектыСтроительства
			|					ТОГДА &ТипДанныхМУОбъект
			|				ИНАЧЕ NULL
			|			КОНЕЦ
			|	ИНАЧЕ NULL
			|КОНЕЦ 

	        |;
	        |
	        |////////////////////////////////////////////////////////////////////////////////
	        |ВЫБРАТЬ
	        |	СУММА(МУОстатки.СуммаМУОстаток) КАК СуммаМУОстаток,
	        |	СУММА(МУОстатки.СуммаМУОстатокДт) КАК СуммаМУОстатокДт,
	        |	СУММА(МУОстатки.СуммаМУОстатокКт) КАК СуммаМУОстатокКт,
	        |	СУММА(0) КАК СуммаНУОстатокДт,
	        |	СУММА(0) КАК СуммаНУОстатокКт,
	        |	МУОстатки.Организация КАК Организация,
	        |	МУОстатки.Субконто1 КАК Субконто1,
	        |	МУОстатки.Субконто2 КАК Субконто2,
	        |	МУОстатки.Субконто3 КАК Субконто3,
	        |	СУММА(0) КАК СуммаПРОстаток,
	        |	СУММА(0) КАК СуммаПРОстатокДт,
	        |	СУММА(0) КАК СуммаПРОстатокКт,
	        |	СУММА(0) КАК СуммаНУОстаток,
	        |	ВЫБОР
	        |		КОГДА &СопоставлятьПоОбъекту
	        |			ТОГДА МУОстатки.Объект
	        |	КОНЕЦ КАК Объект
	        |{ВЫБРАТЬ
	        |	СуммаМУОстаток,
	        |	СуммаМУОстатокДт,
	        |	СуммаМУОстатокКт,
	        |	СуммаНУОстатокДт,
	        |	СуммаНУОстатокКт,
	        |	Организация.*,
	        |	МУОстатки.Счет.* КАК СчетМУ,
	        |	СуммаПРОстаток,
	        |	СуммаПРОстатокДт,
	        |	СуммаПРОстатокКт,
	        |	Субконто1.*,
	        |	Субконто2.*,
	        |	Субконто3.*,
	        |	СуммаНУОстаток,
	        |	Объект}
	        |ИЗ
	        |	МУОстатки КАК МУОстатки
	        |
	        |СГРУППИРОВАТЬ ПО
	        |	МУОстатки.Организация,
	        |	МУОстатки.Субконто1,
	        |	МУОстатки.Субконто2,
	        |	МУОстатки.Субконто3,
	        |	ВЫБОР
	        |		КОГДА &СопоставлятьПоОбъекту
	        |			ТОГДА МУОстатки.Объект
	        |	КОНЕЦ" ;
	Возврат   Текст; 
КонецФункции

Функция ТекстЗапросаДляРасчетаОтложенныхНалоговДляНУ()
	Текст = "ВЫБРАТЬ
	        |	0 КАК СуммаМУОстаток,
	        |	0 КАК СуммаМУОстатокДт,
	        |	0 КАК СуммаМУОстатокКт,
	        |	НУОстатки.Организация КАК Организация,
	        |	ЕСТЬNULL(НУОстатки.СуммаНУОстатокДт, 0) КАК СуммаНУОстатокДт,
	        |	ЕСТЬNULL(НУОстатки.СуммаНУОстатокКт, 0) КАК СуммаНУОстатокКт,
	        |	ЕСТЬNULL(НУОстатки.СуммаПРОстаток, 0) КАК СуммаПРОстаток,
	        |	ЕСТЬNULL(НУОстатки.СуммаПРОстатокДт, 0) КАК СуммаПРОстатокДт,
	        |	ЕСТЬNULL(НУОстатки.СуммаПРОстатокКт, 0) КАК СуммаПРОстатокКт,
	        |	НУОстатки.Объект КАК Объект,
	        |	ЕСТЬNULL(НУОстатки.СуммаНУОстаток, 0) КАК СуммаНУОстаток
	        |{ВЫБРАТЬ
	        |	СуммаМУОстаток,
	        |	СуммаМУОстатокДт,
	        |	СуммаМУОстатокКт,
	        |	Организация.* КАК Организация,
	        |	СуммаНУОстатокДт,
	        |	СуммаНУОстатокКт,
	        |	СуммаПРОстаток,
	        |	НУОстатки.Счет.* КАК СчетНУ,
	        |	Объект,
	        |	СуммаНУОстаток,
	        |	СуммаПРОстатокДт,
	        |	СуммаПРОстатокКт}
	        |ИЗ
	        |	(ВЫБРАТЬ
	        |		НУОстатки.Счет КАК Счет,
	        |		НУОстатки.Организация КАК Организация,
	        |		СУММА(НУОстатки.СуммаНУОстатокДт) КАК СуммаНУОстатокДт,
	        |		СУММА(НУОстатки.СуммаНУОстатокКт) КАК СуммаНУОстатокКт,
	        |		СУММА(НУОстатки.СуммаНУОстаток) КАК СуммаНУОстаток,
	        |		СУММА(НУОстатки.СуммаПРОстаток) КАК СуммаПРОстаток,
	        |		НУОстатки.Объект КАК Объект,
	        |		СУММА(НУОстатки.СуммаПРОстатокДт) КАК СуммаПРОстатокДт,
	        |		СУММА(НУОстатки.СуммаПРОстатокКт) КАК СуммаПРОстатокКт
	        |	{ВЫБРАТЬ
	        |		Счет.* КАК СчетНУ,
	        |		Организация.*,
	        |		СуммаНУОстатокДт,
	        |		СуммаНУОстатокКт,
	        |		СуммаНУОстаток,
	        |		СуммаПРОстаток,
	        |		Объект,
	        |		СуммаПРОстатокДт,
	        |		СуммаПРОстатокКт}
	        |	ИЗ
	        |		(ВЫБРАТЬ
	        |			ГруппировкаПоСубконто.Счет КАК Счет,
	        |			ГруппировкаПоСубконто.Организация КАК Организация,
	        |			ЕСТЬNULL(ГруппировкаПоСубконто.СуммаНУОстатокДт, 0) - ЕСТЬNULL(ГруппировкаПоСубконто.СуммаВРРазвернутыйОстатокДт, 0) КАК СуммаНУОстатокДт,
	        |			ЕСТЬNULL(ГруппировкаПоСубконто.СуммаНУОстатокКт, 0) - ЕСТЬNULL(ГруппировкаПоСубконто.СуммаВРРазвернутыйОстатокКт, 0) КАК СуммаНУОстатокКт,
	        |			ЕСТЬNULL(ГруппировкаПоСубконто.СуммаОстаток, 0) - ЕСТЬNULL(ГруппировкаПоСубконто.СуммаВРОстаток, 0) КАК СуммаНУОстаток,
	        |			ГруппировкаПоСубконто.СуммаПРОстаток КАК СуммаПРОстаток,
	        |			ГруппировкаПоСубконто.Объект КАК Объект,
	        |			ГруппировкаПоСубконто.СуммаПРОстатокДт КАК СуммаПРОстатокДт,
	        |			ГруппировкаПоСубконто.СуммаПРОстатокКт КАК СуммаПРОстатокКт
	        |		{ВЫБРАТЬ
	        |			Счет.* КАК СчетНУ,
	        |			Организация.*,
	        |			СуммаНУОстатокДт,
	        |			СуммаНУОстатокКт,
	        |			СуммаНУОстаток,
	        |			СуммаПРОстаток,
	        |			Объект,
	        |			СуммаПРОстатокДт,
	        |			СуммаПРОстатокКт}
	        |		ИЗ
	        |			(ВЫБРАТЬ
	        |				ВРазворотеПоСубкотно.Счет КАК Счет,
	        |				ВРазворотеПоСубкотно.Организация КАК Организация,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаНУОстатокДт) КАК СуммаНУОстатокДт,
	        |				-СУММА(ВРазворотеПоСубкотно.СуммаНУОстатокКт) КАК СуммаНУОстатокКт,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаОстаток) КАК СуммаОстаток,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаПРОстаток) КАК СуммаПРОстаток,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаВРРазвернутыйОстатокДт) КАК СуммаВРРазвернутыйОстатокДт,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаВРРазвернутыйОстатокКт) КАК СуммаВРРазвернутыйОстатокКт,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаВРОстаток) КАК СуммаВРОстаток,
	        |				ВРазворотеПоСубкотно.Объект КАК Объект,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаПРОстатокДт) КАК СуммаПРОстатокДт,
	        |				СУММА(ВРазворотеПоСубкотно.СуммаПРОстатокКт) КАК СуммаПРОстатокКт
	        |			ИЗ
	        |				(ВЫБРАТЬ
	        |					НУОстатки.Счет КАК Счет,
	        |					НУОстатки.Организация КАК Организация,
	        |					СУММА(НУОстатки.СуммаРазвернутыйОстатокДт) КАК СуммаНУОстатокДт,
	        |					СУММА(НУОстатки.СуммаРазвернутыйОстатокКт) КАК СуммаНУОстатокКт,
	        |					""НУОстатки.Субконто1"" КАК Субконто1,
	        |					""НУОстатки.Субконто2"" КАК Субконто2,
	        |					""НУОстатки.Субконто3"" КАК Субконто3,
	        |					СУММА(НУОстатки.СуммаОстаток) КАК СуммаОстаток,
	        |					СУММА(НУОстатки.СуммаПРОстаток) КАК СуммаПРОстаток,
	        |					СУММА(НУОстатки.СуммаВРРазвернутыйОстатокДт) КАК СуммаВРРазвернутыйОстатокДт,
	        |					СУММА(НУОстатки.СуммаВРРазвернутыйОстатокКт) КАК СуммаВРРазвернутыйОстатокКт,
	        |					СУММА(НУОстатки.СуммаВРОстаток) КАК СуммаВРОстаток,
	        |					ВЫБОР
	        |						КОГДА &СопоставлятьПоОбъекту
	        |							ТОГДА ВЫБОР
	        |									КОГДА &ТипДанныхНУОбъект ССЫЛКА Справочник.ОбъектыСтроительства
	        |										ТОГДА &ТипДанныхНУОбъект
	        |									ИНАЧЕ NULL
	        |								КОНЕЦ
	        |						ИНАЧЕ NULL
	        |					КОНЕЦ КАК Объект,
	        |					СУММА(НУОстатки.СуммаПРОстатокДт) КАК СуммаПРОстатокДт,
	        |					СУММА(НУОстатки.СуммаПРОстатокКт) КАК СуммаПРОстатокКт
	        |				ИЗ
	        |					РегистрБухгалтерии.Хозрасчетный.Остатки(&КонецПериода, , , {(Организация).*, (Субконто1).* КАК СубконтоНУ1, (Субконто2).* КАК СубконтоНУ2, (Субконто3).* КАК СубконтоНУ3, (Подразделение).* КАК Подразделение}) КАК НУОстатки
	        |				{ГДЕ
	        |					НУОстатки.Счет.* КАК СчетНУ}
	        |				
	        |				СГРУППИРОВАТЬ ПО
	        |					НУОстатки.Организация,
	        |					НУОстатки.Счет,
			|                    ВЫБОР
	        |						КОГДА &СопоставлятьПоОбъекту
	        |							ТОГДА ВЫБОР
	        |									КОГДА &ТипДанныхНУОбъект ССЫЛКА Справочник.ОбъектыСтроительства
	        |										ТОГДА &ТипДанныхНУОбъект
	        |									ИНАЧЕ NULL
	        |								КОНЕЦ
	        |						ИНАЧЕ NULL
	        |					КОНЕЦ,
			|                   ""НУОстатки.Субконто1"" ,
	        |					""НУОстатки.Субконто2"" ,
	        |					""НУОстатки.Субконто3"" ) КАК ВРазворотеПоСубкотно
	        |			
	        |			СГРУППИРОВАТЬ ПО
	        |				ВРазворотеПоСубкотно.Счет,
	        |				ВРазворотеПоСубкотно.Организация,
	        |				ВРазворотеПоСубкотно.Объект) КАК ГруппировкаПоСубконто) КАК НУОстатки
	        |	
	        |	СГРУППИРОВАТЬ ПО
	        |		НУОстатки.Организация,
	        |		НУОстатки.Объект,
	        |		НУОстатки.Счет) КАК НУОстатки" ;
	Возврат   Текст; 
КонецФункции
//bit auavseenkov-- Расчет отложенных налогов 21.11.2014  

#КонецОбласти
