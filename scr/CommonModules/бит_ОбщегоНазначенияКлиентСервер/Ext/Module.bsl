
#Область ПрограммныйИнтерфейс

// Процедура выводит сообщение пользователю.
//
// Параметры:
//  ТекстСообщения	 - Строка	 - Текст сообщения.
//  ТекущийОбъект	 - Произвольный	 - Объект для которого выводим сообщение.
//  ТекущееПоле		 - Строка		 - Поле для которого выводим сообщение.
//  Отказ			 - Булево		 - Выходной параметр.
//
Процедура ВывестиСообщение(ТекстСообщения, Знач ТекущийОбъект = Неопределено, ТекущееПоле = "",Отказ = Ложь) Экспорт

	Если ТипЗнч(ТекущийОбъект) = Тип("ДанныеФормыСтруктура")
		И ТекущийОбъект.Свойство("Ссылка") Тогда
		
		Объект = ТекущийОбъект.Ссылка;
		
	Иначе
		Объект = ТекущийОбъект;
	КонецЕсли; 
    
    СообщитьПользователю(ТекстСообщения, Объект, ТекущееПоле,,Отказ);
   
КонецПроцедуры // ВывестиСообщение()

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область ИнтерфейсыКМетодамТиповыхКонфигураций

// Получает номер документа для вывода на печать; из номера удаляются префиксы и лидирующие нули
// Функция:
// отбрасывает префикс организации,
// отбрасывает префикс информационной базы (опционально),
// отбрасывает пользовательские префиксы (опционально),
// удаляет лидирующие нули в номере объекта.
//
// Параметры:
//  Документ.
//  МассивПрефиксов.
//  УдалитьПрефиксИнформационнойБазы.
//  УдалитьПользовательскийПрефикс.
// 
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено, УдалитьПрефиксИнформационнойБазы = Ложь, УдалитьПользовательскийПрефикс = Ложь) Экспорт
	
	Результат = "";
	
	Если бит_ОбщегоНазначения.ЭтоСемействоБП() ИЛИ бит_ОбщегоНазначения.ЭтоСемействоERP() Тогда		
		НомерОбъекта = СокрЛП(Документ.Номер);
		Результат = ПрефиксацияОбъектовКлиентСервер.НомерНаПечать(НомерОбъекта, УдалитьПрефиксИнформационнойБазы, УдалитьПользовательскийПрефикс);                
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам().
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	
	Результат = ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(ИсхСумма, МассивКоэф, Точность);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СообщенияПользователю

// Процедура выводит сообщение пользователю.
//
// Параметры:
//  Представление - Строка - представление объекта.
//  Отказ         - Булево - признак отказа.
//
Процедура СообщитьОбОтказеОткрытияОбработкиСамостоятельно(Представление, Отказ = Ложь) Экспорт

	Отказ = Истина;
	
	ТекстСообщения = Нстр("ru = 'Обработка ""%1"" не предназначена для самостоятельного использования.'");
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщения, Представление); 		
	ВывестиСообщение(ТекстСообщения);

КонецПроцедуры // СообщитьОбОтказеОткрытияОбработкиСамостоятельно()

// Функция заполняет параметры в строке по Структуре. 
// Параметры в строке следует задавать в формате %ИмяПараметра%. Значение подстановки должно быть строковое.
// 
// Параметры:
//  СтрокаИсходная      - Строка.
//  СтруктураПараметров - Структура 
//                          Ключ     - Строка - Имя параметра
//                          Значение - Строка - Значение для подстановки.
// 
// Возвращаемое значение:
//   Строка.
// 
Функция ЗаполнитьПараметрыСтроки(СтрокаИсходная,СтруктураПараметров)  Экспорт

	СтрокаРезультат = СтрокаИсходная;
	
	Для каждого КиЗ Из СтруктураПараметров Цикл
	
		СтрокаРезультат = СтрЗаменить(СтрокаРезультат,"%"+КиЗ.Ключ+"%",КиЗ.Значение);
	
	КонецЦикла; 

	Возврат СтрокаРезультат;
	
КонецФункции // ЗаполнитьПараметрыСтроки()

// Функция заполняет параметры в строке по переданным параметрам в функцию. 
// Параметры в строке следует задавать в формате %ИмяПараметра%. Значение подстановки должно быть строковое.
// 
// Параметры:
//  СтрокаИсходная  - Строка.
//  П1              - Строка.
//  П2              - Строка.
//  П3              - Строка.
//  П4              - Строка.
//  П5              - Строка.
// 
// Возвращаемое значение:
//   СтрокаРезультат - СтрокаРезультат.
// 
Функция ПодставитьПараметрыСтроки(Знач СтрокаИсходная,
                                   Знач П1,
                                   Знач П2 = Неопределено,
                                   Знач П3 = Неопределено,
                                   Знач П4 = Неопределено,
                                   Знач П5 = Неопределено) Экспорт
	
	СтрокаРезультат = СтрокаИсходная;
	
	СтрокаРезультат    = СтрЗаменить(СтрокаРезультат, "%1%", П1);
	
	Если П2 <> Неопределено Тогда
		СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "%2%", П2);
	КонецЕсли;
	
	Если П3 <> Неопределено Тогда
		СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "%3%", П3);
	КонецЕсли;
	
	Если П4 <> Неопределено Тогда
		СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "%4%", П4);
	КонецЕсли;
	
	Если П5 <> Неопределено Тогда
		СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "%5%", П5);
	КонецЕсли;
	
	Возврат СтрокаРезультат;
	
КонецФункции

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//  Параметры
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - на объект информационной базы.
//                               Ссылка на объект информационной базы, к которому это сообщение относится,
//                               или ключ записи.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - Выходной параметр.
//                               Всегда устанавливается в значение Истина.
//
//	Пример:
//
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения связанного с объектом информационной базы.
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
// 4. Для вывода сообщения по ссылке на объект информационной базы.
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
// Случаи некорректного использования:
//  1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//  2. Передача в параметре КлючДанных значения типа отличного от допустимых.
//  3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ ТонкийКлиент И НЕ ВебКлиент Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры // СообщитьПользователю()

#КонецОбласти

#Область РасчетыНдс

// Процедура расчитывает суммму НДС в строке.
// 
// Параметры:
//  ТекущиеДанные - Объект, Строка табличной части.
//  СтавкиНДС     - Структура, Перечисление.СтавкиНДС.
// 
Процедура РассчитатьДляСтрокиСуммуНДС(ТекущиеДанные, СтавкиНДС) Экспорт
	
	Если ТекущиеДанные = Неопределено Тогда
		Возврат;
	КонецЕсли; 

	СтавкаНДСЧисло = бит_БухгалтерияКлиентСервер.ПолучитьСтавкуНДС(ТекущиеДанные.СтавкаНДС, 
												СтавкиНДС);
	
	ТекущиеДанные.НДС = бит_БухгалтерияКлиентСервер.РассчитатьСуммуНДС(ТекущиеДанные.Сумма, 
												Истина, 
												Истина, 
												СтавкаНДСЧисло);
																							
КонецПроцедуры // РассчитатьДляСтрокиСуммуНДС()

#КонецОбласти

#Область ПроцедурыИФункцииПоРаботеСЕдиницамиИзмеренияСумм

// Функция пересчитывает сумму из размерности РазмерностьНач в РазмерностьКон.
// 
// Параметры:      
// 	Сумма		   - Число, сумма которую следует пересчитать.
// 	РазмерностьНач - Число, размерность из которой надо пересчитать.
// 	РазмерностьКон - Число, размерность в которую надо пересчитать.
// 
// Возвращаемое значение: 
//  СуммаРез - Число, пересчитанная в другую размерность.
// 
Функция ПересчитатьИзРазмерностиВРазмерность(Сумма, РазмерностьНач, РазмерностьКон) Экспорт

	Если РазмерностьНач = РазмерностьКон Тогда
		
		// Считаем, что пересчет не нужен.
		СуммаРез = Сумма;
		
	Иначе

		Если РазмерностьНач = 0 ИЛИ РазмерностьКон = 0 Тогда
			
			ТекстСообщения = "Процедура ""ПересчитатьИзРазмерностиВРазмерность()"": при пересчете обнаружена нулевая размерность.";
			бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения);
			Возврат 0;
			
		КонецЕсли;

		СуммаРез = (Сумма * РазмерностьНач / РазмерностьКон);
		
	КонецЕсли;
	
	Возврат СуммаРез;

КонецФункции // ПересчитатьИзРазмерностиВРазмерность()

#КонецОбласти

#Область СистемнаяИнформация

// Функция определяет, используется ли Windows.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоВинОС() Экспорт
	
	флВин = Ложь;
	
	СисИнфо = Новый СистемнаяИнформация;
	
	Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 
		ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
	
		флВин = Истина;
	
	КонецЕсли; 
	
	Возврат флВин;
	
КонецФункции // ЭтоВинОС()

// Функция получает из системной информации текущую редакцию платформы.
// 
// Возвращаемое значение:
//  ТекущаяРедакцияПлатформы - Строка.
// 
Функция РедакцияПлатформы() Экспорт

	СисИнфо = Новый СистемнаяИнформация;
	ТекущаяРедакцияПлатформы = Лев(СисИнфо.ВерсияПриложения,3);
	
	Возврат ТекущаяРедакцияПлатформы;
	
КонецФункции // РедакцияПлатформы()

// Функция получает из системной информации текущую версию платформы.
// 
// Возвращаемое значение:
//  ВерсияПриложения - Строка.
// 
Функция ВерсияПлатформы() Экспорт

	СисИнфо = Новый СистемнаяИнформация;
	
	Возврат СисИнфо.ВерсияПриложения;
	
КонецФункции // ВерсияПлатформы()

#КонецОбласти

#Область ФункцииРаботыСоЗначениямиТипаДата

// Функция вычисляет исходя из количества минут количество дней, часов и минут.
// 
// Параметры:
//  КоличествоМинут - Число.
// 
// Возвращаемое значение:
//  Структура.
// 
Функция МинутыВоВремя(КоличествоМинут) Экспорт
	
	РезСтруктура = Новый Структура("Дни,Часы,Минуты",0,0,0);
	
	ТекВремя = КоличествоМинут;
	
	РезСтруктура.Дни = Цел(ТекВремя/1440);
	
	ТекВремя = ТекВремя-РезСтруктура.Дни*1440;
	
	РезСтруктура.Часы = Цел(ТекВремя/60);
	
	РезСтруктура.Минуты = ТекВремя-РезСтруктура.Часы*60;
	
	Возврат РезСтруктура;
	
КонецФункции // МинутыВСтрокуВремя()

// Функция вычисляет исходя из количества секунд количество дней, часов, минут и секунд.
// 
// Параметры:
//  КоличествоМинут - Число.
// 
// Возвращаемое значение:
//  Структура.
// 
Функция СекундыВоВремя(КоличествоМинут) Экспорт
	
	РезСтруктура = Новый Структура("Дни,Часы,Минуты,Секунды",0,0,0,0);
	
	ТекВремя = КоличествоМинут;
	
	РезСтруктура.Дни = Цел(ТекВремя/86400);
	
	ТекВремя = ТекВремя-РезСтруктура.Дни*86400;
	
	РезСтруктура.Часы    = Цел(ТекВремя/3600);
	
	ТекВремя = ТекВремя-РезСтруктура.Часы*3600;
	
	РезСтруктура.Минуты  = Цел(ТекВремя/60);
	
	РезСтруктура.Секунды =  ТекВремя-РезСтруктура.Минуты*60; 
	
	Возврат РезСтруктура;
	
КонецФункции // МинутыВСтрокуВремя()

// Функция формирует строку представления времени исходя из заданного количества минут.
// 
// Параметры:
//  КоличествоМинут - Число.
// 
// Возвращаемое значение:
//   Число.
// 
Функция ВремяВМинуты(СтрВремя) Экспорт
	
	КоличествоМинут = СтрВремя.Дни*1440+СтрВремя.Часы*60+СтрВремя.Минуты;
	
	Возврат КоличествоМинут;
	
КонецФункции // ВремяВМинуты()	

// Функция формирует строковое представление времени.
// 
// Параметры:
//  ВходящееВремя - Структура, Число.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПредставлениеВремени(ВходящееВремя, ДоСекунд = Ложь) Экспорт
	
	РезСтрока = "";
    
	Если ТипЗнч(ВходящееВремя) = Тип("Структура") ИЛИ ТипЗнч(ВходящееВремя) = Тип("Число")  Тогда
		
		Если ТипЗнч(ВходящееВремя) = Тип("Структура") Тогда
			
			СтрВремя = ВходящееВремя;
			
		Иначе
			
			Если ДоСекунд Тогда
				СтрВремя = СекундыВоВремя(ВходящееВремя);
			Иначе	
				СтрВремя = МинутыВоВремя(ВходящееВремя);
			КонецЕсли; 
			
		КонецЕсли; 
		
		СтрФормат = "ЧЦ=2; ЧН=; ЧВН=";
		СтрДень   = НСтр("ru=' д. '");
		
		Если СтрВремя.Дни > 0 Тогда
			РезСтрока = Строка(СтрВремя.Дни) + СтрДень + Формат(СтрВремя.Часы, СтрФормат) + ":" + Формат(СтрВремя.Минуты, СтрФормат);
		Иначе	
			РезСтрока = Формат(СтрВремя.Часы, СтрФормат) + ":" + Формат(СтрВремя.Минуты, СтрФормат);
		КонецЕсли; 
		
		Если  СтрВремя.Свойство("Секунды") Тогда		
			РезСтрока = РезСтрока+":"+Формат(СтрВремя.Секунды,СтрФормат);		
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат РезСтрока;
	
КонецФункции // ПредставлениеВремени()

// Функция возвращает склонения периодов.
// 
// Параметры:
//   ЧислоПериодов - Число.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПрописьПериода(ЧислоПериодов, Периодичность) Экспорт

	РезСтр = "";
	
	Если Периодичность = "Минута" Тогда
		
		СтрСклонения = "Минута, Минуты, Минут,,,,,,0";
	
	ИначеЕсли Периодичность = "Час" Тогда
		
		СтрСклонения = "Час, Часа, Часов,,,,,,0";
	
	ИначеЕсли Периодичность = "День" Тогда	
		
		СтрСклонения = "День, Дня, Дней,,,,,,0";
		
	Иначе
		
		СтрСклонения = "";
	
	КонецЕсли; 
	
	СтрЧисла = НРег(ЧислоПрописью(ЧислоПериодов, "НП = Ложь; НД = Ложь; ДП = Ложь"  , СтрСклонения));
	РезСтр   = НРег(ЧислоПрописью(ЧислоПериодов, "НП = Истина; НД = Ложь; ДП = Ложь", СтрСклонения));

	РезСтр = СтрЗаменить(РезСтр, СтрЧисла, "");
	
	Возврат РезСтр;
	
КонецФункции // ПрописьПериода()

// Функция формирует представление периода в зависимости от периодичности планирования.
// 
// Параметры:
//  ТекущийПериод  - Дата
//  Периодичность  - ПеречислениеСсылка.бит_ПериодичностьПланирования
// 
// Возвращаемое значение:
//   Представление   - Строка
// 
Функция СформироватьПредставлениеПериода(ТекущийПериод, Периодичность) Экспорт

	ТекКодЯзыка = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("КодЯзыка");
	
	СтрЯзык = "Л=" + ТекКодЯзыка + ";";
	
	Если ТипЗнч(Периодичность) <> Тип("Строка") Тогда
		ПериодичностьСтр = Строка(Периодичность);
	Иначе
		ПериодичностьСтр = Периодичность;
	КонецЕсли; 

	Если СтрСравнить(ПериодичностьСтр, "День") = 0 Тогда
		Представление =  НСтр("ru = 'День'")+" ("+Формат(ТекущийПериод, СтрЯзык+"ДФ=dd.MM.yyyy")+")";
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Неделя") = 0 Тогда
		Представление =  НСтр("ru = 'Неделя'")+" ("+Формат(ТекущийПериод,СтрЯзык+"ДФ=dd.MM.yyyy")+" - "+Формат(КонецНедели(ТекущийПериод),СтрЯзык+"ДФ=dd.MM.yyyy")+")";
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Декада") = 0 Тогда
		Представление =  НСтр("ru = 'Декада'")+" ("+Формат(ТекущийПериод,СтрЯзык+"ДФ=dd.MM.yyyy")+" - "+Формат(ПолучитьКонецПериода(ТекущийПериод,Периодичность),СтрЯзык+"ДФ=dd.MM.yyyy")+")";		
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Месяц") = 0 Тогда	
		Представление = Формат(ТекущийПериод,СтрЯзык+"ДФ='MMMM yyyy'");
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Квартал") = 0 Тогда
		Представление = Формат(ТекущийПериод,СтрЯзык+"ДФ='q ""кв"" yyyy'");
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Полугодие") = 0 Тогда
		
		Если Формат(ТекущийПериод, СтрЯзык+"ДФ=q") = "3" 
			Или Формат(ТекущийПериод, СтрЯзык+"ДФ=q") = "4" Тогда
			
			Представление =  НСтр("ru = '2-ое полугодие'")+ " " + Формат(ТекущийПериод, СтрЯзык+"ДФ=yyyy") + " "+ НСтр("ru = 'г.'");
			
		Иначе
			Представление =  НСтр("ru = '1-ое полугодие'")+" " + Формат(ТекущийПериод, СтрЯзык+"ДФ=yyyy") + " "+ НСтр("ru = 'г.'");
		КонецЕсли;
		
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Год") = 0 Тогда	
		Представление = Формат(ТекущийПериод,СтрЯзык+"ДФ=yyyy");
	КонецЕсли; 

   Возврат Представление;
   
КонецФункции // СформироватьСинонимДляПериодичности()

// Функция получает период по сдвигу исходя из текущего периода и периодичности.
// 
// Параметры:
//  ДатаНачала  	   - Дата
//  Сдвиг       	   - Число
//  Периодичность      - ПеречислениеСсылка.бит_ПериодичностьПланирования
//  НеприводитьКНачалу - Булево, по умолчанию Ложь
// 
// Возвращаемое значение:
//  ТекущийПериод   - Дата
// 
Функция ПолучитьПериодПоСдвигу(ДатаНачала,Сдвиг,Периодичность,НеприводитьКНачалу = Ложь) Экспорт
	
	Если Не НеприводитьКНачалу Тогда
		ТекущийПериод = ПолучитьНачалоПериода(ДатаНачала,Периодичность);
	Иначе
		ТекущийПериод = ДатаНачала;
	КонецЕсли;
	
	Если Сдвиг >=0 Тогда
		Для й = 1 По Сдвиг Цикл
			КонецПериода  = ПолучитьКонецПериода(ТекущийПериод  ,Периодичность);
			ТекущийПериод = ПолучитьНачалоПериода(КонецПериода+1,Периодичность);
		КонецЦикла;	
	Иначе
		КоличествоПериодов = МодульЧисла(Сдвиг);
		Для й = 1 По КоличествоПериодов Цикл
			НачалоПериода = ПолучитьНачалоПериода(ТекущийПериод  ,Периодичность);
			ТекущийПериод = ПолучитьНачалоПериода(ТекущийПериод-1,Периодичность);
		КонецЦикла; 
	КонецЕсли; 
	
   Возврат ТекущийПериод;
   
КонецФункции

// Функция получает начало периода исходя из периодичности.
// 
// Параметры:
//  Период  - Дата.
//  Периодичность - ПеречислениеСсылка.бит_ПериодичностьПланирования, Строка - значение периодичности.
// 
// Возвращаемое значение:
//  ТекущийПериод   - Дата.
// 
Функция ПолучитьНачалоПериода(Период, Периодичность) Экспорт
	
	Если ЗначениеЗаполнено(Период) Тогда
		НачалоПериода = НачалоДня(Период);
	Иначе 
		НачалоПериода = НачалоДня(ТекущаяДата());
	КонецЕсли; 
	
	Если ТипЗнч(Периодичность) <> Тип("Строка") Тогда
		ПериодичностьСтр = Строка(Периодичность);
	Иначе
		ПериодичностьСтр = Периодичность;
	КонецЕсли; 
	
	Если СтрСравнить(ПериодичностьСтр, "День") = 0 Тогда
		НачалоПериода = НачалоДня(НачалоПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Неделя") = 0 Тогда
		НачалоПериода = НачалоНедели(НачалоПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Декада") = 0 Тогда
		
		Сутки      = 86400;
		ДеньМесяца   = День(НачалоПериода);
		НачалоМесяца = НачалоМесяца(НачалоПериода);
		
		Если ДеньМесяца = 1 Или ДеньМесяца = 11 Или ДеньМесяца = 21 Тогда
			НачалоПериода = НачалоДня(НачалоПериода);
		ИначеЕсли ДеньМесяца <= 10 Тогда
			НачалоПериода = НачалоМесяца
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НачалоПериода = НачалоМесяца + Сутки * 10;
		Иначе
			НачалоПериода = НачалоМесяца + Сутки * 20;
		КонецЕсли;
		
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Месяц") = 0 Тогда
		НачалоПериода = НачалоМесяца(НачалоПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Квартал") = 0 Тогда
		НачалоПериода = НачалоКвартала(НачалоПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Полугодие") = 0 Тогда
		
		Если НачалоПериода < ДобавитьМесяц(НачалоГода(НачалоПериода), 6) Тогда
			НачалоПериода = НачалоГода(НачалоПериода);
		Иначе
			НачалоПериода = ДобавитьМесяц(НачалоГода(НачалоПериода), 6);
		КонецЕсли; 
		
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Год") = 0 Тогда
		НачалоПериода = НачалоГода(НачалоПериода);
	КонецЕсли; 
	
	Возврат НачалоПериода;
   
КонецФункции

// Функция получает конец периода исходя из периодичности.
// 
// Параметры:
//  Период  - Дата.
//  Периодичность - ПеречислениеСсылка.бит_ПериодичностьПланирования.
// 
// Возвращаемое значение:
//  ТекущийПериод   - Дата.
// 
Функция ПолучитьКонецПериода(Период, Периодичность) Экспорт
	
	КонецПериода = КонецДня(Период);
	Если ТипЗнч(Периодичность) <> Тип("Строка") Тогда
		ПериодичностьСтр = Строка(Периодичность);
	Иначе
		ПериодичностьСтр = Периодичность;
	КонецЕсли; 
	
	Если СтрСравнить(ПериодичностьСтр, "День") = 0 Тогда
		КонецПериода = КонецДня(КонецПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Неделя") = 0 Тогда
		КонецПериода = КонецНедели(КонецПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Декада") = 0 Тогда
		
		Сутки     = 86400;
		ДеньМесяца   = День(КонецПериода);
		КонецМесяца  = КонецМесяца(КонецПериода);
		НачалоМесяца = НачалоМесяца(КонецПериода);
		
		Если ДеньМесяца = 10 Или ДеньМесяца = 20 Или ДеньМесяца = День(КонецМесяца) Тогда
			КонецПериода = КонецДня(КонецПериода);
		ИначеЕсли ДеньМесяца <= 9 Тогда
			КонецПериода = НачалоМесяца - 1 + Сутки * 10
		ИначеЕсли ДеньМесяца <= 19 Тогда
			КонецПериода = НачалоМесяца - 1 + Сутки * 20;
		Иначе
			КонецПериода = КонецМесяца;
		КонецЕсли;
		
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Месяц") = 0 Тогда
		КонецПериода = КонецМесяца(КонецПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Квартал") = 0 Тогда
		КонецПериода = КонецКвартала(КонецПериода);
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Полугодие") = 0 Тогда
		
		Если КонецПериода < ДобавитьМесяц(НачалоГода(КонецПериода), 6) Тогда
			КонецПериода = ДобавитьМесяц(НачалоГода(КонецПериода), 6) - 1;
		Иначе
			КонецПериода = КонецГода(КонецПериода);
		КонецЕсли; 
		
	ИначеЕсли СтрСравнить(ПериодичностьСтр, "Год") = 0 Тогда
		КонецПериода = КонецГода(КонецПериода);
	КонецЕсли; 
	
	Возврат КонецПериода;
   
КонецФункции

// Функция вычисляет разность дат исходя из заданной периодичности.
// 
// Параметры:
//  НачалоПериода    - Дата
//  ОкончаниеПериода - Дата
//  ТипРазности - Строка, ПеречислениеСсылка.бит_ПериодичностьПланирования.
// 
// Возвращаемое значение:
//   Разность   - Число
// 
Функция РазностьДат(НачалоПериода, ОкончаниеПериода, ТипРазности) Экспорт
	
	Если ТипЗнч(ТипРазности) <> Тип("Строка") Тогда
		ТипРазностиСтр = Строка(ТипРазности);
	Иначе
		ТипРазностиСтр = ТипРазности;
	КонецЕсли; 
	
	Разность = 0;
	Если ЗначениеЗаполнено(НачалоПериода) И ЗначениеЗаполнено(ОкончаниеПериода) Тогда
		
		Если СтрСравнить(ТипРазностиСтр, "День") = 0 Тогда
			
			Разность = Цел((НачалоДня(ОкончаниеПериода) - НачалоДня(НачалоПериода))/(24 * 60 *60));						
						
		ИначеЕсли СтрСравнить(ТипРазностиСтр, "Неделя") = 0 Тогда
			
			Разность = Цел((НачалоНедели(ОкончаниеПериода) - НачалоНедели(НачалоПериода))/(7 * 24 * 60 *60));
			
		ИначеЕсли СтрСравнить(ТипРазностиСтр, "Декада") = 0 Тогда
			
			РазностьМесяцев = РазностьДат(НачалоПериода, ОкончаниеПериода, "Месяц");
			Разность = РазностьМесяцев * 3 + НомерДекады(ОкончаниеПериода) - НомерДекады(НачалоПериода);
			
		ИначеЕсли СтрСравнить(ТипРазностиСтр, "Месяц") = 0 Тогда
			
			Если НачалоМесяца(НачалоПериода) <= НачалоМесяца(ОкончаниеПериода)  Тогда
				Коэф = 1;
			Иначе
				Коэф = - 1;
			КонецЕсли;
			
			КонецПериода = НачалоМесяца(НачалоПериода);
			Пока КонецПериода <> НачалоМесяца(ОкончаниеПериода) Цикл
				Разность = Разность + Коэф;
				КонецПериода = ДобавитьМесяц(КонецПериода, Коэф);
			КонецЦикла;

		ИначеЕсли СтрСравнить(ТипРазностиСтр, "Квартал") = 0 Тогда
			
			РазностьМесяцев = РазностьДат(НачалоПериода,ОкончаниеПериода,"Месяц");
			Разность		= Цел(РазностьМесяцев / 3);
			
		ИначеЕсли СтрСравнить(ТипРазностиСтр, "Полугодие") = 0 Тогда
			
			РазностьМесяцев = РазностьДат(НачалоПериода,ОкончаниеПериода,"Месяц");
			Разность	    = Цел(РазностьМесяцев / 6);
			
		ИначеЕсли СтрСравнить(ТипРазностиСтр, "Год") = 0 Тогда	
			
			РазностьМесяцев = РазностьДат(НачалоПериода,ОкончаниеПериода,"Месяц");
			Разность		 = Цел(РазностьМесяцев / 12);
			
		КонецЕсли; 
		
	КонецЕсли; 
	       	 
	Возврат Разность;
	 
КонецФункции // РазностьДат()

// Функция вычисляет номер декады в месяце.
// 
// Параметры:
//  ТекущаяДата  - Дата
// 
// Возвращаемое значение:
//   НомерДекады   - Число.
// 
Функция НомерДекады(ТекущаяДата) Экспорт

	НомерДня = День(ТекущаяДата);
	Если НомерДня <= 10 Тогда
		НомерДекады = 1;
	ИначеЕсли НомерДня <= 20 Тогда
	 	НомерДекады = 2;
	Иначе
	 	НомерДекады = 3;
	КонецЕсли; 

	Возврат НомерДекады;

КонецФункции

#КонецОбласти 

Функция МодульЧисла(ВхЧисло) Экспорт

	Если ТипЗнч(ВхЧисло) = Тип("Число") Тогда
		Результат = Макс(ВхЧисло, - ВхЧисло);
	Иначе
		ВызватьИсключение Нстр("ru = 'Вычисление модуля для нечисловых данных не поддерживается.'");
	КонецЕсли; 

	Возврат Результат;
	
КонецФункции

// Функция пересчитывает сумму из валюты ВалютаНач по курсу ПоКурсуНач 
// в валюту ВалютаКон по курсу ПоКурсуКон.
// 
// Параметры:      
// 	Сумма          - сумма, которую следует пересчитать;
// 	ВалютаНач      - ссылка на элемент справочника Валют;
//                   определяет валюты из которой надо пересчитвать;
// 	ВалютаКон      - ссылка на элемент справочника Валют;
//                   определяет валюты в которую надо пересчитвать;
// 	ПоКурсуНач     - курс из которого надо пересчитать;
// 	ПоКурсуКон     - курс в который надо пересчитать;
// 	ПоКратностьНач - кратность из которого надо пересчитать (по умолчанию = 1);
// 	ПоКратностьКон - кратность в который надо пересчитать  (по умолчанию = 1);
// 
// Возвращаемое значение: 
//  Сумма, пересчитанная в другую валюту.
// 
Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, 
	                               ПоКратностьНач = 1, ПоКратностьКон = 1 ) Экспорт

	Если (ВалютаНач = ВалютаКон) Тогда

		// Считаем, что пересчет не нужен.
		Возврат Сумма;

	КонецЕсли;

	Если (ПоКурсуНач     = ПоКурсуКон) 
	   И (ПоКратностьНач = ПоКратностьКон) Тогда

		// Ну, тут и считать нечего...
		Возврат Сумма;

	КонецЕсли;

	Если ПоКурсуНач     = 0 
	 ИЛИ ПоКурсуКон     = 0 
	 ИЛИ ПоКратностьНач = 0 
	 ИЛИ ПоКратностьКон = 0 Тогда
	 
	 ТекстСообщения = "Процедура ""ПересчитатьИзВалютыВВалюту()"": при пересчете обнаружен нулевой курс. Валюта начальная """
	                  + ВалютаНач
					  + """, валюта конечная "
					  + ВалютаКон
					  + """.";
	 
		ВывестиСообщение(ТекстСообщения);
		Возврат 0;

	КонецЕсли;

	СуммаРез = (Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач);
	
	Возврат СуммаРез;

КонецФункции // ПересчитатьИзВалютыВВалюту()

// Функция формирует информацию о статусе.
// 
// Параметры:
//  СтруктураПараметров - Структура
//                          Статус - СправочникСсылка.бит_СтатусыОбъектов.
//                          ДатаИзмененияСтатуса - Дата.
// 
// Возвращаемое значение:
//  Строка
// 
Функция СформироватьИнформациюСтатус(СтруктураПараметров) Экспорт

	Результат = Строка(СтруктураПараметров.Статус);
	Если ЗначениеЗаполнено(СтруктураПараметров.ДатаИзмененияСтатуса) Тогда
		
		Результат = Результат
					+ " (" + НСтр("ru = 'изменен:'")
					+ Формат(СтруктураПараметров.ДатаИзмененияСтатуса, "ДЛФ=DT")
					+ ")";
		
	КонецЕсли; 

	Возврат Результат;
	
КонецФункции // СформироватьИнформациюСтатус()

// Функция формирует текст точки алгоритма.
// 
// Параметры:
//  СтруктураПараметров - Структура.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция СформироватьТекстТочки(СтруктураПараметров)  Экспорт

	Если СтруктураПараметров.Свойство("Решение") И ЗначениеЗаполнено(СтруктураПараметров.Решение) Тогда
		ТекстЗаголовка = Строка(СтруктураПараметров.Точка)+"/"+Строка(СтруктураПараметров.Решение);
	Иначе	
		ТекстЗаголовка = Строка(СтруктураПараметров.Точка);
	КонецЕсли; 

	Возврат ТекстЗаголовка;
	
КонецФункции // СформироватьТекстТочки()

// Процедура УстановитьОтборУСпискаНаРавенство добавляет элемент
// в отбор компоновки данных левому и правому значениям на равенство.
// 
// Параметры:
//  ОтборСКД           	   - ОтборКомпоновкиДанных.
//  ЛевоеЗначение      	   - ПолеКомпоновкиДанных.
//  ПравоеЗначение	   	   - Произвольный, значение, проверяемое на равно.
//  ВидСравненияОтбора 	   - ВидСравненияКомпоновкиДанных. По умолчанию Равно.
//  ОбновлятьЭлементОтбора - Булево. По умолчанию Истина.
//  РежимОтображения       - РежимОтображенияЭлементаНастройкиКомпоновкиДанных.
// 
//  Пример использования:
//   бит_ОбщегоНазначенияКлиентСервер.УстановитьОтборУСписка(
//                   Список.Отбор,
//                   Новый ПолеКомпоновкиДанных("ИмяСвойства"),
//                   ЗначениеОтбора);
// 
Процедура УстановитьОтборУСписка(ОтборСКД
                                ,Знач ЛевоеЗначение
                                ,Знач ПравоеЗначение
								,ВидСравненияОтбора = Неопределено
								,ОбновлятьЭлементОтбора = Истина
								,РежимОтображения = Неопределено) Экспорт
	
	ЭлементыОтбора 		= ОтборСКД.Элементы;
	ЭлементОтбораДанных = Неопределено;
	
	Если ВидСравненияОтбора = Неопределено Тогда
		ВидСравненияОтбора = ВидСравненияКомпоновкиДанных.Равно;
	КонецЕсли;
	
	// Если необходимо обновить условие для существующего элемента отбора, тогда.
	Если ОбновлятьЭлементОтбора Тогда
		
		Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
			
			Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
				
				Если ЭлементОтбораДанных = Неопределено Тогда
					ЭлементОтбораДанных = ЭлементОтбора;
				Иначе
					ЭлементОтбора.Использование = Ложь;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЭлементОтбораДанных = Неопределено Тогда
		
		ЭлементОтбораДанных = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбораДанных.ЛевоеЗначение = ЛевоеЗначение;
		
	КонецЕсли;
	
	ЭлементОтбораДанных.ВидСравнения   = ВидСравненияОтбора;
	ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
	ЭлементОтбораДанных.Использование  = Истина;
	
	Если РежимОтображения <> Неопределено Тогда
	
		ЭлементОтбораДанных.РежимОтображения = РежимОтображения
	
	КонецЕсли; 
	
КонецПроцедуры // УстановитьОтборУСписка()

// Функция выполняет поиск элементаПользовательскойНастройки по УникальномуИдентификатору.
// 
// Параметры:
//  ИД          - Строка - УникальныйИдентификатор.
//  Компоновщик - КомпоновщикНастроекКомпоновкиДанных.
// 
// Возвращаемое значение:
//   ЭлементПользовательскойНастройки - элемент коллекции КоллекцияЭлементовПользовательскихНастроекКомпоновкиДанных. 
// 
Функция НайтиЭлементПользовательскойНастройки(ИД,Компоновщик) Экспорт
	
  ЭлементПользовательскойНастройки = Неопределено;
  Для каждого Элемент Из Компоновщик.ПользовательскиеНастройки.Элементы Цикл
  
  	Если Элемент.ИдентификаторПользовательскойНастройки = ИД Тогда
	
		ЭлементПользовательскойНастройки = Элемент;
		Прервать;
	
	КонецЕсли; 
  
  КонецЦикла; 
	
 Возврат ЭлементПользовательскойНастройки;
	
КонецФункции // НайтиЭлементПользовательскойНастройки()

// Процедура вычисляет сумму в строке табличной части.
// 
// Параметры:
//  ТекущаяСтрока        - Строка табличной части.
//  ПоказательСуммы      - Строка, по умолчанию "Сумма".
//  ПоказательЦены       - Строка, по умолчанию "Цена".
//  ПоказательКоличества - Строка, по умолчанию "Количество".
// 
Процедура РассчитатьСуммуВСтрокеТЧ(ТекущаяСтрока,
									ПоказательСуммы = "Сумма",
									ПоказательЦены = "Цена",
									ПоказательКоличества = "Количество") Экспорт
	
	ТекущаяСтрока[ПоказательСуммы] = ТекущаяСтрока[ПоказательЦены] * ТекущаяСтрока[ПоказательКоличества];

КонецПроцедуры // РассчитатьСуммуВСтрокеТЧ()

// Процедура вычисляет цену в строке табличной части.
// 
// Параметры:
//  ТекущаяСтрока        - Строка табличной части.
//  ПоказательСуммы      - Строка, по умолчанию "Сумма".
//  ПоказательЦены       - Строка, по умолчанию "Цена".
//  ПоказательКоличества - Строка, по умолчанию "Количество".
// 
Процедура РассчитатьЦенуВСтрокеТЧ(ТекущаяСтрока,
									ПоказательСуммы = "Сумма",
									ПоказательЦены = "Цена",
									ПоказательКоличества = "Количество") Экспорт

	РасчетноеКоличество = ТекущаяСтрока[ПоказательКоличества];
	Если РасчетноеКоличество = 0 Тогда
		ТекущаяСтрока[ПоказательЦены] = 0;
	Иначе
		ТекущаяСтрока[ПоказательЦены] = ТекущаяСтрока[ПоказательСуммы] / ТекущаяСтрока[ПоказательКоличества];
	КонецЕсли; 

КонецПроцедуры // ПриИзмененииСуммыТабЧасти()

// Процедура устанавливает параметры выбора элемента.
// 
// Параметры:
//  Элемент 		- ПолеФормы.
//  СтруктураОтбора - Структура.
// 
Процедура УстановитьПараметрыВыбораЭлемента(Элемент, СтруктураОтбора) Экспорт

	МассивПараметров = Новый Массив;
	
	Для Каждого ЭлементСтруктуры Из СтруктураОтбора Цикл
		
		НовыйПараметр = Новый ПараметрВыбора("Отбор." + ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		МассивПараметров.Добавить(НовыйПараметр);
		
	КонецЦикла;
	
	ПараметрыВыбора = Новый ФиксированныйМассив(МассивПараметров);
	
	Элемент.ПараметрыВыбора = ПараметрыВыбора;

КонецПроцедуры // УстановитьПараметрыВыбораЭлемента()

// Процедура устанавливает связь параметра выбора элемента.
// 
// Параметры:
//  Элемент 		  - ПолеФормы.
//  Имя               - Строка.
//  ПутьКДанным       - Строка.
//  ИзменениеЗначения - Строка.
// 
Процедура УстановитьСвязьПараметраВыбораЭлемента(Элемент, Имя, ПутьКДанным, ИзменениеЗначения) Экспорт
	
	НовыйМассив = Новый Массив;
	
	НоваяСвязь  = Новый СвязьПараметраВыбора(Имя,ПутьКДанным,ИзменениеЗначения);
	НовыйМассив.Добавить(НоваяСвязь);
	
	СвязиПараметров = Новый ФиксированныйМассив(НовыйМассив); 
	
	Элемент.СвязиПараметровВыбора = СвязиПараметров;

КонецПроцедуры // УстановитьСвязьПараметраВыбораЭлемента()

// Процедура заполняет представления элементов всех коллекций построителя отчета на
//  основании соответствия имен и представлений переданных в параметре.
// 
// Параметры
//  СтруктураСоответствияИмен - Структура, ключ - имя поля, значение - представление поля.
//  ПостроительОтчета         - ПостроительОтчета.
// 
Процедура ЗаполнитьПредставленияПолей(СтруктураСоответствияИмен, ПостроительОтчета) Экспорт

	СтруктураКоллекцийПостроителяОтчета = Новый Структура("ДоступныеПоля, ВыбранныеПоля, ИзмеренияКолонки, ИзмеренияСтроки, Отбор, Порядок");
	
	Для каждого ЭлементСтруктуры Из СтруктураКоллекцийПостроителяОтчета Цикл
		Для а = 0 По ПостроительОтчета[ЭлементСтруктуры.Ключ].Количество() - 1 Цикл
			Если ПустаяСтрока(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				Продолжить;
			КонецЕсли;
			Если СтруктураСоответствияИмен.Свойство(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Представление = СтруктураСоответствияИмен[ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя];
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьПредставленияПолей()

// Функция считает сумму по массиву чисел.
// 
// Параметры:
//  ВхМассив - Массив.
// 
// Возвращаемое значение:
//   Число.
// 
Функция ИтогПоМассиву(ВхМассив) Экспорт

	Результат = 0;
	
	Для каждого Элемент Из ВхМассив Цикл
	
		 Если ТипЗнч(Элемент) = Тип("Число") Тогда
		 
		 	Результат = Результат+Элемент
		 
		 КонецЕсли; 
	
	КонецЦикла; 

	Возврат Результат;
	
КонецФункции // ИтогПоМассиву()

// Процедура выполняет установку/снятие/инвертирование флагов в таблице.
// 
// Параметры:
// Таблица     - ТабличнаяЧасть, ТаблицаЗначений.
// ИмяФлага    - Строка. Имя реквизита, флаг в таблице.
// ТекЗначение - Число. / 0 - Ложь / 1 - Истина / 2 - Инвертировать /.
// 
Процедура ОбработатьФлаги(Таблица, ИмяФлага, ТекЗначение) Экспорт
	
	Для каждого ТекущаяСтрока Из Таблица Цикл
		
		Если ТекЗначение = 0 Тогда
			ТекущаяСтрока[ИмяФлага] = Ложь;
			
		ИначеЕсли ТекЗначение = 1 Тогда
			ТекущаяСтрока[ИмяФлага] = Истина;	
			
		ИначеЕсли ТекЗначение = 2 Тогда			
			ТекущаяСтрока[ИмяФлага] = Не ТекущаяСтрока[ИмяФлага];
			
		КонецЕсли;   
		
	КонецЦикла; 
	
КонецПроцедуры // ОбработатьФлаги()

// Процедура разбирает строку с разделителями и упаковывает значения в массив.
// 
// Параметры:
//  ИсходнаяСтрока - Строка.
//  Разделитель    - Строка.
// 
Функция РазобратьСтрокуСРазделителями(ИсходнаяСтрока,Разделитель = ",") Экспорт
	
	РезМассив = Новый Массив;
	
	// Разделитель бывает динной строки > 1, учитывая особенность "СтрЗаменить",
	// заменим его на редкий односимвольный разделитель (смайлик) Символ(9786).
	Сепаратор = Символ(9786);
	Образец   = СтрЗаменить(ИсходнаяСтрока, Разделитель, Сепаратор);
	РезМассив = СтрРазделить(Образец, Сепаратор, Ложь);
		
	Возврат РезМассив;
	
КонецФункции // РазобратьСтрокуСРазделителями()

// Выполняет проверку на наличие спецсимволов.
//
// Параметры
//  ИсходнаяСтрока - Строка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПроверитьСпецСимволы(ИсходнаяСтрока,СпецСимволы = " .,;:[]{}'""/\?!@#$%^&*+=<>~`|()№",ИмяКолонки) Экспорт
	
	ПрошлаПроверка = Истина;
	СтрокаНаПроверку = ИсходнаяСтрока;
	
	ТекстСообщения = "";
	
	ЗапрещенныеСимволы = "";
	Для ном = 1 По СтрДлина(СпецСимволы) Цикл
		ТекСимв = Сред(СпецСимволы, Ном, 1);
		ПозСимв = Найти(СтрокаНаПроверку, ТекСимв);		
		Если ПозСимв > 0 Тогда
			СтрокаНаПроверку = СтрЗаменить(СтрокаНаПроверку,ТекСимв,"");
			ЗапрещенныеСимволы = ЗапрещенныеСимволы+ТекСимв;
			ПрошлаПроверка = Ложь;
		КонецЕсли;	
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ЗапрещенныеСимволы) Тогда
		ТекстСообщения = ТекстСообщения+?(ПустаяСтрока(ТекстСообщения),"",Символы.ПС)+ "Символы """+ЗапрещенныеСимволы+""" не могут быть использованы при заполнении поля """+ИмяКолонки+""".";
		ВывестиСообщение(ТекстСообщения);	
	КонецЕсли; 
	
	Возврат СтрокаНаПроверку;
	
КонецФункции // ПроверитьСимвол()

// Преобразует строку в допустимое наименование колонки таблицы значений, заменяя недопустимые
// символы на символ подчеркивания.
//
// Параметры:
//  Строка - Строка - Строка для преобразования.
// 
// Возвращаемое значение:
//  Результат - Строка, содержащая только допустимые символы для наименования колонок таблицы значений.
//
Функция ПреобразоватьСтрокуВДопустимоеНаименованиеКолонки(Строка) Экспорт  
	
	Результат = ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыXML(Строка, "_");
	
	ЗаменяемыеСимволы = " .,;:[]{}'""/\?!@#$%^&*+=<>~`|()№";
	Для Индекс = 1 По СтрДлина(ЗаменяемыеСимволы) Цикл
		Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, Индекс, 1), "_");
	КонецЦикла;
	
	Цмфры = СтрРазделить("1,2,3,4,5,6,7,8,9,0", ",");
	Индекс = 9;
	Пока Индекс >=0 Цикл
		Если Лев(Результат, 1) = Цмфры[Индекс] Тогда
			// Колонка не может начинаться с цифры.
			Результат = "_" + Результат;
			Индекс = -1;
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Функция разбирает текст на разных языках.
// 
// Параметры:
//  СтрИсходная  - Структура
// 
// Возвращаемое значение:
//   РезСтр   - Структура
// 
Функция РазобратьТекстНаЯзыки(СтрИсходная) Экспорт
	
	РезСтр = Новый Структура;
	
	МассивСтрок = РазобратьСтрокуСРазделителями(СтрИсходная,""";");
	
	Для каждого элемент из МассивСтрок Цикл
		
		позицияРавно = Найти(Элемент,"=");
		
		Если позицияРавно > 0 Тогда
			
			// Выделим код языка
			СтрКод = Лев(Элемент,позицияРавно-1);
			СтрКод = СтрЗаменить(СтрКод," ","");
			СтрКод = СтрЗаменить(СтрКод,";","");
			СтрКод = СокрЛП(СтрКод);
			
			// Выделим текст
			СтрТекст = Сред(Элемент,ПозицияРавно+1);
			СтрТекст = СокрЛП(СтрТекст);
			// Уберем начальную кавычку
			Если Лев(СтрТекст,1) = """" Тогда
				
				СтрТекст = Сред(СтрТекст,2);
				
			КонецЕсли;	
			// Уберем конечную кавычку
			Если Прав(СтрТекст,1) = """" Тогда
				
				СтрТекст = Сред(СтрТекст,1,СтрДлина(СтрТекст)-1);
				
			КонецЕсли;	
			
			Если НЕ ПустаяСтрока(СтрКод) Тогда
				
				РезСтр.Вставить(СтрКод,СтрТекст);
				
			КонецЕсли; 
			
		КонецЕсли;	
		
	КонецЦикла;	
	
	Возврат РезСтр;
	
КонецФункции // РазобратьТекстНаЯзыки()

// Функция формирует текст на разных языках.
// 
// Параметры:
//  СтрЯзыки  - Структура - Ключ:КодЯзыка, Значение: Текст на этом языке.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция СформироватьТекстНаРазныхЯзыках(СтрЯзыки) Экспорт

	РезСтрока = "";
	
	Для каждого КиЗ Из СтрЯзыки Цикл
		
		Если ЗначениеЗаполнено(КиЗ.Значение) Тогда
			
		  Если НЕ ПустаяСтрока(РезСтрока) Тогда
		  
		  	  РезСтрока = РезСтрока + "; ";
		  
		  КонецЕсли; 	
		  РезСтрока = РезСтрока + КиЗ.Ключ + " = """ + КиЗ.Значение + """";
		
		КонецЕсли; 
	
	КонецЦикла; 

	Возврат РезСтрока;
	
КонецФункции // СформироватьТекстНаРазныхЯзыках()

// Функция получает имя варианта стандартного периода.
// 
// Параметры:
//  ТекущийВариант - ВариантСтандартногоПериода.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ИмяВариантаСтандартногоПериода(ТекущийВариант) Экспорт
	
	ИмяВарианта = "ПроизвольныйПериод";
	
	Имена = Новый Структура;
	Имена.Вставить("Вчера");
	Имена.Вставить("ДоКонцаЭтогоГода");
	Имена.Вставить("ДоКонцаЭтогоКвартала");
	Имена.Вставить("ДоКонцаЭтогоМесяца");
	Имена.Вставить("ДоКонцаЭтогоПолугодия");
	Имена.Вставить("ДоКонцаЭтойДекады");
	Имена.Вставить("ДоКонцаЭтойНедели");
	Имена.Вставить("Завтра");
	Имена.Вставить("Месяц");
	Имена.Вставить("Последние7Дней");
	Имена.Вставить("ПроизвольныйПериод");
	Имена.Вставить("ПрошлаяДекада");
	Имена.Вставить("ПрошлаяДекадаДоТакогоЖеНомераДня");
	Имена.Вставить("ПрошлаяНеделя");
	Имена.Вставить("ПрошлаяНеделяДоТакогоЖеДняНедели");
	Имена.Вставить("ПрошлоеПолугодие");
	Имена.Вставить("ПрошлоеПолугодиеДоТакойЖеДаты");
	Имена.Вставить("ПрошлыйГод");
	Имена.Вставить("ПрошлыйГодДоТакойЖеДаты");
	Имена.Вставить("ПрошлыйКвартал");
	Имена.Вставить("ПрошлыйКварталДоТакойЖеДаты");
	Имена.Вставить("ПрошлыйМесяц");
	Имена.Вставить("ПрошлыйМесяцДоТакойЖеДаты");
	Имена.Вставить("Сегодня");
	Имена.Вставить("СледующаяДекада");
	Имена.Вставить("СледующаяДекадаДоТакогоЖеНомераДня");
	Имена.Вставить("СледующаяНеделя");
	Имена.Вставить("СледующаяНеделяДоТакогоЖеДняНедели");
	Имена.Вставить("СледующееПолугодие");
	Имена.Вставить("СледующееПолугодиеДоТакойЖеДаты");
	Имена.Вставить("Следующие7Дней");
	Имена.Вставить("СледующийГод");
	Имена.Вставить("СледующийГодДоТакойЖеДаты");
	Имена.Вставить("СледующийКвартал");
	Имена.Вставить("СледующийКварталДоТакойЖеДаты");
	Имена.Вставить("СледующийМесяц");
	Имена.Вставить("СледующийМесяцДоТакойЖеДаты");
	Имена.Вставить("СНачалаЭтогоГода");
	Имена.Вставить("СНачалаЭтогоКвартала");
	Имена.Вставить("СНачалаЭтогоМесяца");
	Имена.Вставить("СНачалаЭтогоПолугодия");
	Имена.Вставить("СНачалаЭтойДекады");
	Имена.Вставить("СНачалаЭтойНедели");
	Имена.Вставить("ЭтаДекада");
	Имена.Вставить("ЭтаНеделя");
	Имена.Вставить("ЭтоПолугодие");
	Имена.Вставить("ЭтотГод");
	Имена.Вставить("ЭтотКвартал");
	Имена.Вставить("ЭтотМесяц");
	
	Для каждого КиЗ из Имена Цикл
		
		Если ТекущийВариант = ВариантСтандартногоПериода[КиЗ.Ключ] Тогда
			ИмяВарианта = КиЗ.Ключ;
			Прервать;
		КонецЕсли;	
		
	КонецЦикла;
	
	Возврат ИмяВарианта;
	
КонецФункции // ИмяВариантаСтандартногоПериода()

// Функция возвращает имя вида сравнения.
// 
// Параметры:
//  ТекущийВидСравнения  - СистемныеПеречисления.ВидСравнения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ИмяВидаСравнения(ТекущийВидСравнения) Экспорт

	Имя = "Равно";
	
	Имена = Новый Структура;
	Имена.Вставить("Больше");
	Имена.Вставить("БольшеИлиРавно");
	Имена.Вставить("ВИерархии");
	Имена.Вставить("ВСписке");
	Имена.Вставить("ВСпискеПоИерархии");
	Имена.Вставить("Интервал");
	Имена.Вставить("ИнтервалВключаяГраницы");
	Имена.Вставить("ИнтервалВключаяНачало");
	Имена.Вставить("ИнтервалВключаяОкончание");
	Имена.Вставить("Меньше");
	Имена.Вставить("МеньшеИлиРавно");
	Имена.Вставить("НеВИерархии");
	Имена.Вставить("НеВСписке");
	Имена.Вставить("НеВСпискеПоИерархии");
	Имена.Вставить("НеРавно");
	Имена.Вставить("НеСодержит");
	Имена.Вставить("Равно");
	Имена.Вставить("Содержит");
	
	Для каждого КиЗ из Имена Цикл
		
		Если ТекущийВидСравнения =  ВидСравнения[КиЗ.Ключ] Тогда
			Имя = КиЗ.Ключ;
			Прервать;
		КонецЕсли;	
		
	КонецЦикла;
	
	Возврат Имя;
	
КонецФункции // ИмяВидаСравнения()

// Функция определяет формат для строки правил. Первый приоритет настройка формата из строки,
// далее из шапки, если формат не задан, то Число(15,2).
// 
// Параметры:
//  СтрокаПравил - СтрокаТабличнойЧасти.ПравилаЗаполнения.
//  ФорматЧисел  - Строка - Формат поумолчанию.
//  КодСтраны    - Строка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ОпределитьФорматПоСтрокеПравил(СтрокаПравил,ФорматЧисел,КодСтраны) Экспорт
	
	// Определим, какую настройку формата применять.
	Если НЕ ПустаяСтрока(СтрокаПравил.ФорматЧисел) Тогда
		
		СтрФормат = СтрокаПравил.ФорматЧисел;
		
	Иначе	
		
		Если НЕ ПустаяСтрока(ФорматЧисел) Тогда			
			СтрФормат = ФорматЧисел;			
		Иначе			
			СтрФормат = "ЧЦ=15; ЧДЦ=2";			
		КонецЕсли; 
		
	КонецЕсли; 
	
	// Если язык не установлен установки из шапки отчета.
	Если Найти(СтрокаПравил.ФорматЧисел, "Л=") = 0 Тогда		
		СтрФормат = "Л=" + КодСтраны + ";" + СтрФормат;	
	КонецЕсли; 
	
	Возврат СтрФормат;
	
КонецФункции // ОпределитьФорматПоСтрокеПравил()

// Функция упаковывает ДанныеФормыКоллекция в массив структур. 
// Может использоваться для передачи таблицы между клиентом и сервером.
// 
// Параметры:
//  ДФК          - ДанныеФормыКоллекция.
//  ИменаКолонок - Массив.
// 
// Возвращаемое значение:
//   Массив.
// 
Функция УпаковатьДанныеФормыКоллекция(ДФК,ИменаКолонок) Экспорт
	
  РезМассив = Новый Массив;
  
  Для Каждого СтрокаТаблицы ИЗ ДФК Цикл
	  
	  МодельСтроки = Новый Структура;
	  
	  Для Каждого Элемент ИЗ ИменаКолонок Цикл
		  
		  Если ТипЗнч(ИменаКолонок) = Тип("Структура") Тогда
			  ИмяКолонки = Элемент.Ключ;
		  Иначе	  
			  ИмяКолонки = Элемент;
		  КонецЕсли;	  
			  
		  МодельСтроки.Вставить(ИмяКолонки,СтрокаТаблицы[ИмяКолонки]);
		  
	  КонецЦикла; // ИменаКолонок.
	  
	  РезМассив.Добавить(МодельСтроки);
	  
  КонецЦикла; // ДФК.
  
  Возврат РезМассив;
	
КонецФункции // УпаковатьДанныеФормыКоллекция()

// Функция проверяет, правильно ли задан интервал дат.
// 
// Параметры:
//  ДатаНачала           - Дата.
//  ДатаОкончания        - Дата.
//  СинонимДатаНачала    - Строка (По умолчанию = "Дата начала").
//  СинонимДатаОкончания - Строка (По умолчанию = "Дата окончания").
//  Режим                - Строка.
//  ВыводитьСообщения    - Булево.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ВременнойИнтервалКорректный(ДатаНачала
	                                , ДатаОкончания
									, СинонимДатаНачала = Неопределено
									, СинонимДатаОкончания = Неопределено
									, Режим = ""
									, ВыводитьСообщения =  Истина) Экспорт
	
	РезультатПроверки = Истина;
	ТекстОшибок = "";
	
	Если СинонимДатаНачала = Неопределено Тогда
		СинонимДатаНачала = НСтр("ru ='Дата начала периода'");	
	КонецЕсли;
	Если СинонимДатаОкончания = Неопределено Тогда
		СинонимДатаОкончания = НСтр("ru ='даты конца периода'");	
	КонецЕсли;
	
	ПроверятьДатуОкончания = ДатаОкончания <> '00010101000000';
	
	Если ПроверятьДатуОкончания 
		И ДатаОкончания < ДатаНачала Тогда
		
		РезультатПроверки = Ложь;
		ТекстОшибок = СтрШаблон(Нстр("ru = '%1 не может быть больше %2'"), СинонимДатаНачала, СинонимДатаОкончания); 
	КонецЕсли; 
	
	Если НЕ РезультатПроверки И ВыводитьСообщения Тогда		
		ВывестиСообщение(ТекстОшибок); 		
	КонецЕсли; 
	
	Возврат РезультатПроверки;
	
КонецФункции // ВременнойИнтервалКорректный()

// Процедура управляет состояние поля табличного документа.
// 
// Параметры:
//  ПолеТабличногоДокумента - ПолеФормы - поле формы с видом ПолеТабличногоДокумента,
//                            для которого необходимо установить состояние.
//  Состояние               - Строка - задает вид состояния.
// 
Процедура УстановитьСостояниеПоляТабличногоДокумента(ПолеТабличногоДокумента, Состояние = "НеИспользовать") Экспорт
	
	Если ТипЗнч(ПолеТабличногоДокумента) = Тип("ПолеФормы") 
		И ПолеТабличногоДокумента.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
		ОтображениеСостояния = ПолеТабличногоДокумента.ОтображениеСостояния;
		Если ВРег(Состояние) = "НЕИСПОЛЬЗОВАТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Ложь;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.НеИспользовать;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = "";
		ИначеЕсли ВРег(Состояние) = "НЕАКТУАЛЬНОСТЬОТЧЕТА" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет не сформирован. Нажмите ""Сформировать"" для получения отчета.'");;
		ИначеЕсли ВРег(Состояние) = "НЕАКТУАЛЬНОСТЬТАБДОК" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Табличный документ не сформирован. Нажмите ""Обновить"".'");;
		ИначеЕсли ВРег(Состояние) = "ФОРМИРОВАНИЕОТЧЕТА" Тогда  
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = БиблиотекаКартинок.ДлительнаяОперация48;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет формируется...'");
		Иначе
			ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''2'')'"));
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''1'')'"));
	КонецЕсли;
	
КонецПроцедуры // УстановитьСостояниеПоляТабличногоДокумента()

// Функция разбирает полное имя объекта на ИмяОбъекта и имя "Класса" (Справочник, Документ и т.п.).
// По имени класса определяется ИмяКоллекции.
// 
// Параметры:
//  ИмяОбъектаПолное - Строка.
// 
// Возвращаемое значение:
//  РезСтр - Структура("ИмяКоллекции,ИмяКласса,ИмяОбъекта").
// 
Функция РазобратьПолноеИмяОбъекта(ИмяОбъектаПолное) Экспорт

	РезСтр = Новый Структура("ИмяКоллекции,ИмяКласса,ИмяОбъекта","","","");
	
	ПозицияТочки = Найти(ИмяОбъектаПолное,".");
	
	Если ПозицияТочки >0 Тогда
			
		
	  РезСтр.ИмяКласса        = Лев(ИмяОбъектаПолное,ПозицияТочки-1);
	  РезСтр.ИмяОбъекта       = Сред(ИмяОбъектаПолное,ПозицияТочки+1);
	  
	  ИмяКоллекции = ПолучитьИмяКоллекции(РезСтр.ИмяКласса);
	  
	  Если ТипЗнч(ИмяКоллекции) = Тип("Строка") Тогда
	  
	  	  РезСтр.ИмяКоллекции = ИмяКоллекции;
	  
	  КонецЕсли; 
	  
	КонецЕсли; 

	Возврат РезСтр;
	
КонецФункции // РазобратьПолноеИмяОбъекта()

// Функция получает имя коллекции по имени класса объекта.
// 
// Параметры:
//   ИмяКласса - Строка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяКоллекции(ИмяКласса) Экспорт

	ИмяКоллекции = "";
	
	Если ИмяКласса = "Справочник" Тогда
	
		ИмяКоллекции = "Справочники";
		
	ИначеЕсли ИмяКласса = "Документ" Тогда 
		
		ИмяКоллекции = "Документы";
		
	ИначеЕсли ИмяКласса = "ЖурналДокументов" Тогда 
		
		ИмяКоллекции = "ЖурналыДокументов";
	
	ИначеЕсли ИмяКласса = "Перечисление" Тогда 
		
		ИмяКоллекции = "Перечисления";
	
	ИначеЕсли ИмяКласса = "Отчет" Тогда 
		
		ИмяКоллекции = "Отчеты";
	
	ИначеЕсли ИмяКласса = "Обработка" Тогда 
		
		ИмяКоллекции = "Обработки";
	
	ИначеЕсли ИмяКласса = "ПланВидовХарактеристик" Тогда 
		
		ИмяКоллекции = "ПланыВидовХарактеристик";
	
	ИначеЕсли ИмяКласса = "ПланСчетов" Тогда 
		
		ИмяКоллекции = "ПланыСчетов";
	
	ИначеЕсли ИмяКласса = "ПланВидовРасчета" Тогда 
		
		ИмяКоллекции = "ПланыВидовРасчета";
	
	ИначеЕсли ИмяКласса = "РегистрСведений" Тогда 
		
		ИмяКоллекции = "РегистрыСведений";
	
	ИначеЕсли ИмяКласса = "РегистрНакопления" Тогда 
		
		ИмяКоллекции = "РегистрыНакопления";
	
	ИначеЕсли ИмяКласса = "РегистрБухгалтерии" Тогда 
		
		ИмяКоллекции = "РегистрыБухгалтерии";
	
	ИначеЕсли ИмяКласса = "РегистрРасчета" Тогда 
		
		ИмяКоллекции = "РегистрыРасчета";
	
	ИначеЕсли ИмяКласса = "БизнесПроцесс" Тогда 
		
		ИмяКоллекции = "БизнесПроцессы";
		
	ИначеЕсли ИмяКласса = "Задача" Тогда 
		
		ИмяКоллекции = "Задачи";		
		
	КонецЕсли; 

	Возврат ИмяКоллекции;
	
КонецФункции // ПолучитьИмяКоллекции()

// Функция формирует соответствие имен "классов" объектов и имен коллекций объектов. 
// "Справочник - Справочники" и т.п.
// 
// Параметры:
//  Режим - Строка - "КоллекцияКласс", "КлассКоллекция".
// 
// Возвращаемое значение:
//  Соответствие.
// 
Функция СоответствиеИменКлассовКоллекций(Режим = "КлассКоллекция") Экспорт

	Пары = Новый Массив;

	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "Справочник", "Справочники");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "Документ", "Документы");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "ЖурналДокументов", "ЖурналыДокументов");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "Перечисление", "Перечисления");
	Пары.Добавить(Пара);

	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "Отчет", "Отчеты");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "Обработка", "Обработки");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "ПланВидовХарактеристик", "ПланыВидовХарактеристик");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "ПланСчетов", "ПланыСчетов");
	Пары.Добавить(Пара);	
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "ПланВидовРасчета", "ПланыВидовРасчета");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "РегистрСведений", "РегистрыСведений");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "РегистрНакопления", "РегистрыНакопления");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "РегистрБухгалтерии", "РегистрыБухгалтерии");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "РегистрРасчета", "РегистрыРасчета");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "БизнесПроцесс", "БизнесПроцессы");
	Пары.Добавить(Пара);
	
	Пара = Новый Структура("ИмяКласса, ИмяКоллекции", "Задача", "Задачи");
	Пары.Добавить(Пара);
	
	Имена = Новый Соответствие;
	
	Для каждого пара Из Пары Цикл
		
		Если ВРег(Режим) = ВРег("КоллекцияКласс") Тогда			
			Имена.Вставить(пара.ИмяКоллекции,пара.ИмяКласса);			
		Иначе				
			Имена.Вставить(пара.ИмяКласса,пара.ИмяКоллекции);			
		КонецЕсли; 	
		
	КонецЦикла; 

	Возврат Имена;
	
КонецФункции // СоответствиеИменКлассовКоллекций()

// Функция формирует список возможных в системе периодичностей.
// 
// Возвращаемое значение:
//  РезКоллекция - Соответствие, СписокЗначений.
// 
Функция ПолучитьПериодичности(ТипКоллекции = "СписокЗначений") Экспорт

	Периодичность = Новый Соответствие;
	Периодичность.Вставить(0, "Период");
	Периодичность.Вставить(1, "Запись");
	Периодичность.Вставить(2, "Регистратор");
	Периодичность.Вставить(3, "Секунда");
	Периодичность.Вставить(4, "Минута");
	Периодичность.Вставить(5, "Час");
	Периодичность.Вставить(6, "День");
	Периодичность.Вставить(7, "Неделя");
	Периодичность.Вставить(8, "Декада");
	Периодичность.Вставить(9, "Месяц");
	Периодичность.Вставить(10, "Квартал");
	Периодичность.Вставить(11, "Полугодие");
	Периодичность.Вставить(12, "Год");
	Периодичность.Вставить(13, "Авто");
	
	Если ВРег(ТипКоллекции) = ВРег("СписокЗначений") Тогда
		
		РезКоллекция = Новый СписокЗначений;
		
		Для каждого КиЗ Из Периодичность Цикл		
			РезКоллекция.Добавить(КиЗ.Ключ, КиЗ.Значение);		
		КонецЦикла; 
		
	Иначе	
		
		РезКоллекция = Периодичность;
		
	КонецЕсли; 
	
	Возврат РезКоллекция;	

КонецФункции // ПолучитьПериодичности()

// Функция проверяет наличие колонки в колонках таблицы значений.
// 
// Параметры:
// ИмяКолонки - Строка.
// Колонки    - КолонкиТаблицыЗначений.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЕстьКолонка(ИмяКолонки, Колонки)  Экспорт

	Есть = ?(Колонки.Найти(ИмяКолонки) = Неопределено, Ложь, Истина);

	Возврат Есть;
	
КонецФункции // ЕстьКолонка()

// Функция определяет, является ли данная ИБ файловой.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоФайловаяИБ() Экспорт
	
	СтрСоединения = ВРег(СтрокаСоединенияИнформационнойБазы());
	
	флФайловая = ?(Найти(СтрСоединения,"FILE=")>0,Истина,Ложь);
	
	Возврат флФайловая;
	
КонецФункции // ЭтоФайловаяИБ()

// Функция определяет, запущена ли база в режиме WEB-клиента.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоВебКлиент() Экспорт
	
	СтандартныйПрефикс = ПолучитьНавигационнуюСсылкуИнформационнойБазы() + "/";
	флЭтоВебКлиент = Найти(СтандартныйПрефикс, "http://") > 0;
	
	Возврат флЭтоВебКлиент;
	
КонецФункции // ЭтоВебКлиент()

// Функция открыта ли конфигурация в IE или нет.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоИнтернетЭксплорер() Экспорт

	СисИнфо = Новый СистемнаяИнформация;
	ЭтоИЕ = ?(Найти(СисИнфо.ИнформацияПрограммыПросмотра,"IE")>0, Истина ,Ложь);

	Возврат ЭтоИЕ;
	
КонецФункции // ЭтоИнтернетЭксплорер()

// Функция определяет, является ли данный объект объектом БИТ.
//
// Параметры:
//  ИмяОбъекта - Строка.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоОбъектБИТ(ИмяОбъекта) Экспорт

	флЭтоОбъектБИТ = ?(ВРЕГ(Лев(ИмяОбъекта, 4)) = ВРЕГ("бит_"), Истина, Ложь);
	
	Возврат флЭтоОбъектБИТ;
	
КонецФункции // ЭтоОбъектБИТ()

// Функция формирует массив типов по строковому представлению.
// 
// Параметры:
//   СтрТипы     - Строка, Массив.
//   Разделитель - Строка.
// 
// Возвращаемое значение:
//  МассивТипов - Массив(Тип).
// 
Функция ПолучитьТипыИзСтроки(СтрТипы, Разделитель = "/") Экспорт

	Если ТипЗнч(СтрТипы) = Тип("Массив") Тогда		
		МассивСтрок = СтрТипы;		
	Иначе		
		МассивСтрок = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(СтрТипы, Разделитель);		
	КонецЕсли; 
	
	МассивТипов = Новый Массив;
	
	Для каждого ТекСтр Из МассивСтрок Цикл
		
		ИмяТипаСтр = ТекСтр;
		
		Если Найти(ИмяТипаСтр,"Строка(") > 0 Тогда		
			ИмяТипаСтр = "Строка";		
		КонецЕсли; 
		
		Если Найти(ИмяТипаСтр, "Число(") > 0 Тогда		
			ИмяТипаСтр = "Число";		
		КонецЕсли; 
		
		Если Найти(ИмяТипаСтр, "Дата(") > 0 Тогда		
			ИмяТипаСтр = "Дата";		
		КонецЕсли; 
		
		Попытка		
			Если НЕ ИмяТипаСтр = "ДокументСсылка.бит_му_ШаблонДокумента" Тогда
				ТекТип = Тип(ИмяТипаСтр);
				МассивТипов.Добавить(ТекТип);		
			КонецЕсли; 
		Исключение			
            //ТекстСообщения = НСтр("ru = 'Не удалось создать тип ""%1%""!'");
            //ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ТекСтр);
            //бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);			
		КонецПопытки;
	
	КонецЦикла; 

	Возврат МассивТипов;
	
КонецФункции // ПолучитьТипыИзСтроки()

// Функция создает описание типов по строковому представлению.
// 
// Параметры:
//  СтрТипы        - Строка.
//  Разделитель    - Строка.
//  ТипПоУмолчанию - ОписаниеТипов.
// 
// Возвращаемое значение:
//  Описание - ОписаниеТипов.
// 
Функция ПолучитьОписаниеИзСтроки(СтрТипы, Разделитель = "/", ТипПоУмолчанию = Неопределено ) Экспорт
	
	МассивСтрок = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(СтрТипы, Разделитель);
	
	МассивТипов = ПолучитьТипыИзСтроки(МассивСтрок, Разделитель);
	
	// Определение квалификаторов при необходимости.
	КвалификаторыЧисла  = Неопределено;
	КвалификаторыСтроки = Неопределено;
	КвалификаторыДаты   = Неопределено;
	
	Для каждого СтрТип Из МассивСтрок Цикл
		
		Если Найти(СтрТип,"Строка(") > 0 Тогда
			
		   // Определение квалификаторов строки.	
		   
			ПозНач = Найти(СтрТип,"(");
			ПозКон = Найти(СтрТип,")");
			
			СтрДлина = Сред(СтрТип,ПозНач+1,ПозКон-ПозНач-1);
			
			Попытка			
				Длина = Число(СтрДлина);			
			Исключение				
				Длина = 0;				
			КонецПопытки;
			
			Если Длина > 0  Тогда			
				КвалификаторыСтроки = Новый КвалификаторыСтроки(Длина);			
			КонецЕсли; 
		
		ИначеЕсли Найти(СтрТип, "Дата(") > 0 Тогда
			
		    // Определение квалификаторов даты.			
			
			ПозНач = Найти(СтрТип,"(");
			ПозКон = Найти(СтрТип,")");
			
			СоставДаты = Сред(СтрТип,ПозНач+1,ПозКон-ПозНач-1);
			
			Если СоставДаты = "Дата" Тогда				
				КвалификаторыДаты = Новый КвалификаторыДаты(ЧастиДаты.Дата);				
			ИначеЕсли СоставДаты = "Время" Тогда				
				КвалификаторыДаты = Новый КвалификаторыДаты(ЧастиДаты.Время);				
			Иначе
				
				КвалификаторыДаты = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);				
			КонецЕсли; 
		
		ИначеЕсли Найти(СтрТип, "Число(") > 0 Тогда
			
		    // Определение квалификаторов числа.
		
			ПозНач = Найти(СтрТип,"(");
			ПозКон = Найти(СтрТип,")");
			
			СтрПараметры = Сред(СтрТип,ПозНач+1,ПозКон-ПозНач-1);

			ПозНач = Найти(СтрПараметры,",");
			
			СтрДлина = Лев(СтрПараметры, ПозНач-1);
			СтрТочность = Сред(СтрПараметры, ПозНач+1);
			
			Попытка			
				Длина = Число(СтрДлина);			
			Исключение				
				Длина = 0;				
			КонецПопытки;
			
			Попытка			
				Точность = Число(СтрТочность);			
			Исключение				
				Точность = 0;				
			КонецПопытки;
			
			Если Длина > 0 Тогда			
				КвалификаторыЧисла = Новый КвалификаторыЧисла(Длина, Точность);			
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; // МассивСтрок.	
	
	Описание = Новый ОписаниеТипов(МассивТипов, КвалификаторыЧисла, КвалификаторыСтроки, КвалификаторыДаты);	
	Если НЕ ЗначениеЗаполнено(Описание) И ЗначениеЗаполнено(ТипПоУмолчанию) Тогда
	
		Описание = ТипПоУмолчанию;
	
	КонецЕсли; 	
	
	Возврат Описание;
	
КонецФункции // ПолучитьОписаниеИзСтроки()

// Функция определяет принадлежит ли тип переданного значения к примитивным типам.
// 
// Параметры:
// 	ТекущееЗначение - любое значение, ТипЗначение.
// 
// Возвращаемое значение:
// 	Булево.
// 
Функция ЭтоПримитивныйТип(ТекущееЗначение) Экспорт
	
	ПримитивныйТип = Ложь;
	
	Если ТипЗнч(ТекущееЗначение) = Тип("Тип") Тогда
		
		Если ТекущееЗначение = Тип("Строка") 
			 ИЛИ ТекущееЗначение = Тип("Число") 
			 ИЛИ ТекущееЗначение = Тип("Дата") 
			 ИЛИ ТекущееЗначение = Тип("Булево") 
			 ИЛИ ТекущееЗначение = Тип("ХранилищеЗначения") 
			 ИЛИ ТекущееЗначение = Тип("NULL") 
			 ИЛИ ТекущееЗначение = Тип("Неопределено") Тогда
		
			ПримитивныйТип = Истина;
		
		КонецЕсли; 
		
	Иначе	
		
		Если ТипЗнч(ТекущееЗначение) = Тип("Строка") 
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Число")
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Дата")
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Булево")
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("ХранилищеЗначения")		 		 
			ИЛИ ТекущееЗначение = Неопределено
			ИЛИ ТекущееЗначение = NULL Тогда
			
			ПримитивныйТип = Истина;
			
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат ПримитивныйТип;
	
КонецФункции // ЭтоПримитивныйТип()

// Функция-конструктор структуры, моделирующей отбор.
// 
// Возвращаемое значение:
//  Структура.
// 
Функция КонструкторСтруктураОтбор() Экспорт
	
	РезСтр = Новый Структура("ПутьКДанным
	                           |, Использование
							   |, ВидСравнения
							   |, Значение
							   |, ЗначениеС
							   |, ЗначениеПо
							   |, ТипЗначения
							   |, Представление");
	
	
	
	Возврат РезСтр;
	
КонецФункции // КонструкторСтруктураОтбор()

// Функция создает ключ пригодный для структуры из уникального идентификатора.
// 
// Параметры:
//  ИД - УникальныйИдентификатор, Строка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция КлючСтруктурыИзИД(ИД) Экспорт

	Если ТипЗнч(ИД) = Тип("Строка") Тогда
		
		СтрИД = ИД;
		
	Иначе	
		
		СтрИД = Строка(ИД);
		
	КонецЕсли; 
	
	Ключ = "_" + СтрЗаменить(СтрИД, "-", "_");

	Возврат Ключ;
	
КонецФункции // КлючСтруктурыИзИД()
 
// Функция восстанавливает строковое представление уникального идентификатора из ключа структуры.
// Ключ структуры должен быть ранее создан функцией КлючСтруктурыИзИД().
// 
// Параметры:
//  Ключ - Строка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ИдИзКлючаСтруктуры(Ключ) Экспорт

	СтрИД = Сред(Ключ,1);
	СтрИД = СтрЗаменить(СтрИД, "_", "-");

	Возврат СтрИД;
	
КонецФункции // ИдИзКлючаСтруктуры()
 
// Процедура добавляет элемент отбора с указанным именем в отбор построителя.
// 
// Параметры:
//  Построитель       - ПостроительОтчета, ПостроительЗапроса.
//  ИмяЭлементаОтбора - Строка.
// 
Процедура ДобавитьЭлементОтбораПостроителя(Построитель ,ИмяЭлементаОтбора)  Экспорт
	
	#Если НЕ ТонкийКлиент Тогда
		
		ПолеНастройки = Построитель.ДоступныеПоля.Найти(ИмяЭлементаОтбора);
		Если ПолеНастройки <> Неопределено И ПолеНастройки.Отбор Тогда
			ЭлементОтбора = Построитель.Отбор.Найти(ИмяЭлементаОтбора);
			Если ЭлементОтбора = Неопределено Тогда
				Построитель.Отбор.Добавить(ИмяЭлементаОтбора);
			КонецЕсли;
		КонецЕсли; 
		
	#КонецЕсли
	
КонецПроцедуры // ДобавитьЭлементОтбораИнформация()

// Функция проверяет является ли переданный параметр структурой с заданным именем.
// 
// Параметры:
//  вхПараметр - Произвольный.
//  Имя        - Строка.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ПроверитьИмяКласса(вхПараметр, Имя) Экспорт
	
	флОК = Ложь;
	
	Если ТипЗнч(вхПараметр) = Тип("Структура") 
		 И вхПараметр.Свойство("ИмяКласса") 
		 И вхПараметр.ИмяКласса = Имя Тогда
		
		флОК = Истина;
		
	КонецЕсли; 
	
	Возврат флОК;
	
КонецФункции // ПроверитьИмяКласса()

// Функция проверяет соответсвует ли тип элемента указанному типу.
// 
// Параметры:
//  ТипЭлемента - Тип.
//  СтрокаТипа  - Строка.
//  
// Возвращаемое значение:
//   Булево.
// 
Функция ЭтоУказанныйТип(ТипЭлемента, СтрокаТипа) Экспорт

	Результат = Ложь;
	
	Попытка
		Результат = ТипЭлемента = Тип(СтрокаТипа);	
	Исключение	
	КонецПопытки; 	

	Возврат Результат;
	
КонецФункции // ЭтоУказанныйТип()

// Функция определяет старше версия обновления или нет. 
// Версия представляет собой строку чисел с разделителем "."
// Например "1.1.0.256". Сравнение выполняется по-разрядно начиная со старших разрядов. Если количество разрядов не 
// совпадает старшей считается версия с большим количеством разрядов.
// 
// Параметры:
//  ТекущаяВерсия    - Строка.
//  ВерсияОбновление - Строка.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ВерсияОбновленияСтарше(ТекущаяВерсия,ВерсияОбновления)  Экспорт

	флРезультат = Ложь;
	
	МассивТекущаяВерсия    = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(ТекущаяВерсия,".");
	МассивВерсияОбновления = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(ВерсияОбновления,"."); 
	
	КоличествоТекущаяВерсия    = МассивТекущаяВерсия.Количество();
	КоличествоВерсияОбновления = МассивВерсияОбновления.Количество();
	
	Если КоличествоТекущаяВерсия = КоличествоВерсияОбновления Тогда
		
		бит_РаботаСКоллекциямиКлиентСервер.ПреобразоватьМассивСтрокВЧисла(МассивТекущаяВерсия);
		бит_РаботаСКоллекциямиКлиентСервер.ПреобразоватьМассивСтрокВЧисла(МассивВерсияОбновления);
		
		Для й = 1 По КоличествоТекущаяВерсия Цикл
		
			Если МассивВерсияОбновления[й-1] > МассивТекущаяВерсия[й-1] Тогда
				
				флРезультат = Истина;
				Прервать;
			
			КонецЕсли; 
		
		КонецЦикла; 
		
	Иначе	
		
		Если КоличествоВерсияОбновления > КоличествоТекущаяВерсия Тогда
		
			  флРезультат = Истина;
		
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат флРезультат;

КонецФункции // ВерсияОбновленияСтарше()

// Устарела. Следует использовать ОбщегоНазначения.ОбщийМодуль() или ОбщегоНазначенияКлиент.ОбщийМодуль() от контекста.
// 
Функция ОбщийМодуль(Имя) Экспорт
	
	// Удалить в 3.1.45.
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти
