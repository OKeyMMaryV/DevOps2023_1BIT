
#Область ПрограммныйИнтерфейс

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииПараметровРаботыКлиентаПриЗапуске
Процедура ПриДобавленииПараметровРаботыКлиентаПриЗапуске(Параметры) Экспорт
	// ++ БП 
	ПарамСтарта = бит_ПолныеПрава.ПолучитьПараметрыДляСтартаСистемы("ДействияПриНачалеРаботыСистемы");
	
	УстановитьЗначенияПоУмолчанию(Параметры);
	
	Если ПарамСтарта.ЭтоЧужойПодчиненныйУзел Тогда	
		Возврат;	
	КонецЕсли; 
	
	бит_ук_СлужебныйСервер.УстановитьИдентификаторБазы();	

	Параметры.бит_ПоказатьФормуКонстант = ПоказатьФормуКонстант();	
	
	ПоказатьКонвертацию28 = ПоказатьКонвертацию28();
	Параметры.бит_ПоказатьКонвертациюДокументовБюджетирования = ПоказатьКонвертацию28;
	Параметры.бит_ПоказатьКонвертациюОборотовПоБюджету        = ПоказатьКонвертацию28;
	Параметры.бит_ПоказатьПомощникКонвертацииКодаАлгоритмов   = ПоказатьКонвертацию28;
	
	Параметры.бит_ПоказатьРабочееМестоВизирования             = ПарамСтарта.ОткрытьРабочееМестоВизирования;
	Параметры.бит_ПодключитьОжиданиеУведомленияОбУстановкеВиз = ПарамСтарта.ИнтервалУведомленияУстановкиВиз;
	Параметры.бит_ПоказатьДополнительнуюИнформацию            = ПарамСтарта.ОткрытьДополнительнуюИнформациюБИТ;
	// -- БП 
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область ПолучитьСистемнуюИнформацию

// Функция получает версию платформы
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьВерсиюПлатформы() Экспорт
	
	СисИнфо = Новый СистемнаяИнформация;	
	Возврат СисИнфо.ВерсияПриложения;	
	
КонецФункции // ПолучитьВерсиюПлатформы()

#КонецОбласти 

#Область ФункцииОпределенияТекущегоРешенияТипового

// Функция определяет, что текущее решение это "Бухгалтерия предприятия".
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоБухгалтерияПредприятия() Экспорт
	
	Возврат ЭтоСемействоБП();
	
КонецФункции // ЭтоБухгалтерияПредприятия()

// Функция определяет, что текущее решение это "Бухгалтерия КОРП".
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоКОРП() Экспорт
	
	Возврат бит_ОбщегоНазначенияПовтИсп.ЭтоКОРП();
	
КонецФункции // ЭтоКОРП()

// Функция определяет, что текущее решение это "Бухгалтерия предприятия".
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоБП() Экспорт
	
	Возврат бит_ОбщегоНазначенияПовтИсп.ЭтоБП();
	
КонецФункции // ЭтоБП()

// Функция определяет, что текущее решение "Бухгалтерия предприятия" 
// или "Бухгалтерия предприятия КОРП".
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоСемействоБП() Экспорт
	
	Результат = ЭтоБП() ИЛИ ЭтоКОРП();
	
	Возврат Результат;
	
КонецФункции // ЭтоСемействоБП()

// Функция определяет, что текущее решение УПП ИЛИ КА. 
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоСемействоУПП() Экспорт
		
	Возврат Ложь;
	
КонецФункции // ЭтоСемействоУПП()

// Функция определяет, что текущее решение УТ. 
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоУТ() Экспорт
	
	Возврат бит_ОбщегоНазначенияПовтИсп.ЭтоУТ();
	
КонецФункции

// Функция определяет, что текущее решение ERP.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоERP() Экспорт
	
	Возврат бит_ОбщегоНазначенияПовтИсп.ЭтоERP();
	
КонецФункции // ЭтоERP()

Функция ЭтоКомплекснаяАвтоматизация() Экспорт
	
	Возврат бит_ОбщегоНазначенияПовтИсп.ЭтоКомплекснаяАвтоматизация();
	
КонецФункции

// Функция определяет, что текущее решение ERP ИЛИ УТ.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоСемействоERP() Экспорт

	Результат = ЭтоУТ() ИЛИ ЭтоERP() ИЛИ ЭтоКомплекснаяАвтоматизация();
	
	Возврат Результат;
	
КонецФункции // ЭтоСемействоERP()

// Функция определяет, содержит ли данная поставка дополнительные интерфейсы.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоИнтернационаяПоставка() Экспорт
	
	Возврат бит_ОбщегоНазначенияПовтИсп.ЭтоИнтернационаяПоставка();
	
КонецФункции // ЭтоИнтернационаяПоставка()

// Функция получает набор записей из регистра с отбором.
// 
// Параметры:
//  Регистр      		- РегистрМенеджер.
//  СоответствиеОтбора  - Соответствие.
//  Прочитать			- Булево.
//  
// Возвращаемое значение:
//   НаборЗаписей.
// 
Функция ПолучитьНаборЗаписейСОтбором(Регистр, СоответствиеОтбора, Прочитать = Ложь) Экспорт

	НаборЗаписей = Регистр.СоздатьНаборЗаписей();

	Для каждого Элемент Из СоответствиеОтбора Цикл
		
		ПолеОтбора = Элемент.Ключ;
		Значение   = Элемент.Значение;
		
		НаборЗаписей.Отбор[ПолеОтбора].Установить(Значение);
		// НаборЗаписей.Отбор.Регистратор.Установить(Регистратор);
	
	КонецЦикла;	
	
	Если Прочитать Тогда
		НаборЗаписей.Прочитать();	
	КонецЕсли; 
	
	Возврат НаборЗаписей;
	
КонецФункции // ПолучитьНаборЗаписейСОтбором()

#КонецОбласти

#Область ФункцииОпределенияТекущегоРешенияБит

// Функция определяет, что текущее решение БИТ это "Управленческий учет" (УУ).
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоУУ() Экспорт
	
	Возврат СборкаДоступна("УУ");
	
КонецФункции // ЭтоУУ()

#КонецОбласти

#Область ФункцииОпределенияНаличияМеханизмовВРешении

// Функция проверяет доступность вида сборки.
// 
// Параметры:
//  ВидСбороки - Строка.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция СборкаДоступна(ВидСбороки)
	
	Возврат бит_ЛицензированиеБФCервер.СборкаДоступна(ВидСбороки);
		
КонецФункции

// Функция проверяет наличие механизма управленческого учета.
// 
// Параметры:
//  СообщатьОбОтсутствии - Булево, сообщать пользователю об отсутствии
//                         механизма управленческого учета, по умолчанию Ложь.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ЕстьМеханизмУправленческогоУчета(СообщатьОбОтсутствии = Ложь) Экспорт

	// Получим доступность функционала УУ.
	ФункционалУУДоступен = СборкаДоступна("УУ");
	
	ЕстьМеханизм = ?(ФункционалУУДоступен, Истина, Ложь);
	
    Если СообщатьОбОтсутствии 
        И Не ЕстьМеханизм Тогда
		ТекстСообщения = Нстр("ru ='Механизм управленческого учета в данной версии не доступен.'");
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
    КонецЕсли;
    
	Возврат ЕстьМеханизм;
    
КонецФункции // ЕстьМеханизмУправленческогоУчета()

// Функция проверяет наличие механизма контроля закрытого периода.
// 
// Параметры:
//  СообщатьОбОтсутствии - Булево.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ЕстьМеханизмКонтроляЗакрытогоПериода(СообщатьОбОтсутствии = Ложь) Экспорт

	Если Метаданные.ОбщиеМодули.Найти("бит_КонтрольЗакрытогоПериода") = Неопределено Тогда
	     ЕстьМеханизм = Ложь;
	Иначе	
	     ЕстьМеханизм = Истина;
	КонецЕсли; 

    Если СообщатьОбОтсутствии И НЕ ЕстьМеханизм Тогда
		ТекстСообщения = Нстр("ru = 'Механизм контроля закрытого периода в данной версии недоступен.'"); 
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
    КонецЕсли;
    
	Возврат ЕстьМеханизм;
    
КонецФункции // ЕстьМеханизмКонтроляЗакрытогоПериода()

// Функция определяет есть ли в конфигурации объекты МСФО.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЕстьОбъектыМСФО() Экспорт
	
	Возврат Не ЭтоУТ();
	
КонецФункции // ЕстьОбъектыМСФО()

// Функция проверяет наличие механизмов международного учета.
// 
// Параметры:
//  СообщатьОбОтсутствии - Булево.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ЕстьМСФО(СообщатьОбОтсутствии = Ложь) Экспорт

	ЕстьМеханизм = Ложь;
	
	Если ЕстьОбъектыМСФО() Тогда
	
		// Получим доступность функционала УУ.
		ЕстьМеханизм = СборкаДоступна("УУ") 
		                       ИЛИ СборкаДоступна("МСФО");
		
		Если СообщатьОбОтсутствии И НЕ ЕстьМеханизм Тогда
			ТекстСообщения = Нстр("ru = 'Функционал МСФО в данной версии недоступен.'"); 
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	    КонецЕсли;
	КонецЕсли;

	Возврат ЕстьМеханизм;
    
КонецФункции // ЕстьМСФО()

// Функция проверяет наличие ресурса с именем "СуммаМУ" у регистра бухгалтерии.
// 
// Параметры:
//  ИмяРегистраБухгалтерии - Строка.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЕстьРесурсСуммаМУРегистраБухгалтерии(ИмяРегистраБухгалтерии) Экспорт
	
	ЕстьРесурсСуммаМУ = Ложь;
	
	Если ЕстьМСФО() Тогда
		
		Если НЕ Метаданные.РегистрыБухгалтерии.Найти(ИмяРегистраБухгалтерии) = Неопределено Тогда
			
			// Проверим наличие ресурса с именем "СуммаМУ".
			ЕстьРесурсСуммаМУ = Не (Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].Ресурсы.Найти("СуммаМУ") = Неопределено);
			
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат ЕстьРесурсСуммаМУ;
	
КонецФункции // ЕстьРесурсСуммаМУРегистраБухгалтерии()

// Функция проверяет наличие механизма загрузки из EXCEL.
// 
// Параметры:
//  ВыводитьСообщения - Булево.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ЕстьМеханизмЗагрузкиИзEXCEL(ВыводитьСообщения = ЛОЖЬ) Экспорт

	ЕстьМеханизм = Истина;
	
	Если ВыводитьСообщения 
		И НЕ ЕстьМеханизм Тогда
		ОбщегоНазначения.СообщитьПользователю("Механизм ""Импорт объектов из EXCEL"" в данной версии не доступен.");
	
	КонецЕсли; 
	
    Возврат ЕстьМеханизм;
	
КонецФункции // ЕстьМеханизмЗагрузкиИзEXCEL()

// Процедура проверяет доступность проформ.
// 
// Параметры:
//  Назначение.
//  Отказ.
// 
Процедура ПроверитьДоступностьПроформ(Назначение, Отказ) Экспорт
	
	Если НЕ ЭтоСемействоERP() Тогда	
		
		Если Назначение = Перечисления.бит_НазначенияПроформ.ПроизвольнаяФорма Тогда
			
			Если НЕ бит_ЛицензированиеБФCервер.СборкаДоступна("УУ") Тогда
				
				Отказ = Истина;
				
			КонецЕсли; 
			
		Иначе	
			
			Если НЕ бит_ЛицензированиеБФCервер.СборкаДоступна("УХ") Тогда
				
				Отказ = Истина;
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьДоступностьПроформ()

#КонецОбласти

#Область РежимыИнтерфейса

// Функция определяет доступен ли режим такси.
// 
// Возвращаемое значение:
//  Булево.
//
Функция ДоступенРежимТакси()

	ТекущийРежимМетаданных = Метаданные.РежимСовместимостиИнтерфейса;	

	ДоступенРежимТакси = (ТекущийРежимМетаданных = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.Такси
						ИЛИ ТекущийРежимМетаданных = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.ТаксиРазрешитьВерсия8_2
						ИЛИ ТекущийРежимМетаданных = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.Версия8_2РазрешитьТакси);
						
	Возврат ДоступенРежимТакси;
	
КонецФункции // ДоступенРежимТакси()

// Функция определяет включен ли режим такси.
// 
// Параметры:
//  ТекущийПользователь - СправочникСсылка.Пользователи (По умолчанию = Неопределено).
//
// Возвращаемое значение:
//  Булево.
//
Функция ВключенРежимТакси(ТекущийПользователь = Неопределено) Экспорт

    Если ДоступенРежимТакси() Тогда
        НастройкиКП = ХранилищеСистемныхНастроек.Загрузить("Общее/НастройкиКлиентскогоПриложения", , , ТекущийПользователь);
        Если НастройкиКП = Неопределено Тогда
            ВключенРежимТакси = Истина;
        Иначе	
            ВключенРежимТакси = НастройкиКП.ВариантИнтерфейсаКлиентскогоПриложения = ВариантИнтерфейсаКлиентскогоПриложения.Такси;
        КонецЕсли;		
	Иначе	
	 	ВключенРежимТакси = Ложь;
	КонецЕсли;	
	
	Возврат ВключенРежимТакси;

КонецФункции // ВключенРежимТакси()

#КонецОбласти

#Область ИнтерфейсыКМетодамТиповыхКонфигураций

// Добавляет записи из таблицы движений в набор записей.
//
// Параметры: 
//   НаборЗаписей - Набор записей регистра накопления или регистра бухгалтерии.
//   Таблица      - Таблица значений содержащая движения соответствующего регистра (таблица движений).
// 
Процедура ДобавитьСтрокиВНаборЗаписей(НаборЗаписей, Таблица) Экспорт
	
	НаборМетаданные = НаборЗаписей.Метаданные();
		
	ЭтоРегистрБухгалтерии = (Метаданные.РегистрыБухгалтерии.Найти(НаборМетаданные.Имя)<>Неопределено);
	
	Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
	
	Период = Неопределено;
	
	Для Каждого Строка Из Таблица Цикл
		
		Запись = НаборЗаписей.Добавить();
			
		ЗаполнитьЗначенияСвойств(Запись,Строка);
			
		Запись.Активность = Истина;

		Если Запись.Период = '00010101' Тогда
			
			Если Период = Неопределено Тогда
				
				Период = Регистратор.Дата;
			
			КонецЕсли;
			
			Запись.Период = Период;
			
		КонецЕсли;
			
		Если ЭтоРегистрБухгалтерии тогда
			ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

// Формирует строку представления документа для сообщений при проведении.
// 
// Параметры
//  Документ - Ссылка на проводимый документ.
// 
// Возвращаемое значение
//  Строка с представлением документа.
// 
Функция ПредставлениеДокументаПриПроведении(Документ) Экспорт
	
	Результат = "";
	
	Если ЭтоСемействоБП() Тогда
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБПВызовСервера");
		Результат = Модуль.ПредставлениеДокументаПриПроведении(Документ);                
		
	ИначеЕсли ЭтоСемействоERP() Тогда
		
		МетаданныеДокумента = Документ.Метаданные();
		
		ВидОперацииСтр = "";
		
		Если бит_РаботаСМетаданными.ЕстьРеквизит("ВидОперации", МетаданныеДокумента) Тогда
			ВидОперацииСтр = " (" + Документ.ВидОперации + ")";
		КонецЕсли;
		
		Результат =  НСтр("ru = 'Проведение документа'")+": " + СокрЛП(Документ) + ВидОперацииСтр;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПредставлениеДокументаПриПроведении()

// Стандартная для данной конфигурации функция форматирования сумм.
// 
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать. 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты.
//  ЧН     - строка, представляющая нулевое значение числа.
//  ЧРГ    - символ-разделитель групп целой части числа.
// 
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
// 
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт
	
	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);

	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));

	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;
	
КонецФункции // ФорматСумм()

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является головной.
// 
// Параметры
//  Организация - СправочникСсылка.Организации.
// 
// Возвращаемое значение:
//   СправочникСсылка.Организации.
// 
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	Результат = Справочники.Организации.ПустаяСсылка();
	
	Если ЭтоСемействоБП() Тогда
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБПВызовСервераПовтИсп");
		Результат = Модуль.ГоловнаяОрганизация(Организация);                
		
	ИначеЕсли ЭтоСемействоERP() Тогда
		
		ГоловнаяОрганизация = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, "ГоловнаяОрганизация");
		Если Не ЗначениеЗаполнено(Организация) ИЛИ Не ЗначениеЗаполнено(ГоловнаяОрганизация) Тогда
			Результат = Организация;
		Иначе
			Результат = ГоловнаяОрганизация; 
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ГоловнаяОрганизация()

// Функция проверяет является ли организация юридическим лицом.
// 
// Параметры:
//  Организация  - СправочникСсылка.Организации.
//  
// Возвращаемое значение:
//   Булево.
// 
Функция ОрганизацияЯвляетсяЮрЛицом(Организация) Экспорт

	Результат = Организация.ЮридическоеФизическоеЛицо = Перечисления.ЮридическоеФизическоеЛицо.ЮридическоеЛицо;	
	
	Возврат Результат;
	
КонецФункции // ОрганизацияЯвляетсяЮрЛицом()

// Формирует структуру, содержащую значения реквизитов шапки документа.
// 
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки. 
// 
// Возвращаемое значение:
//  Структура.
// 
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = Новый Структура;
	
	Если ЭтоСемействоБП() Или ЭтоСемействоERP() Тогда
		
		// Первоначальные данные о документе.
		СтруктураШапкиДокумента = Новый Структура;
		СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
		СтруктураШапкиДокумента.Вставить("Дата"  , ДокументОбъект.Дата);
		СтруктураШапкиДокумента.Вставить("Номер" , ДокументОбъект.Номер);
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();
		СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
		СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
		СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", СокрЛП(ДокументОбъект));
		
		Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
			СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
		КонецЦикла;		
		
		// Отображение данных о валютах.
		ВалютаРегламентированногоУчета = Константы.ВалютаРегламентированногоУчета.Получить();
		СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета);		
		Если СтруктураШапкиДокумента.Свойство("ВалютаДокумента") Тогда
			СтруктураШапкиДокумента.Вставить("КурсДокумента"	 , бит_КурсыВалют.КурсДокумента(ДокументОбъект	   , ВалютаРегламентированногоУчета));
			СтруктураШапкиДокумента.Вставить("КратностьДокумента", бит_КурсыВалют.КратностьДокумента(ДокументОбъект, ВалютаРегламентированногоУчета));			
		КонецЕсли;
		
		// Отображение обязательных данных о договоре.
		Если СтруктураШапкиДокумента.Свойство("ДоговорКонтрагента") Тогда			
			Если ТипЗнч(СтруктураШапкиДокумента.ДоговорКонтрагента) = Тип("СправочникСсылка.ДоговорыКонтрагентов") тогда				
				СтруктураШапкиДокумента.Вставить("ВалютаВзаиморасчетов"    , СтруктураШапкиДокумента.ДоговорКонтрагента.ВалютаВзаиморасчетов);
				Если бит_РаботаСМетаданными.ЕстьРеквизит("РасчетыВУсловныхЕдиницах", СтруктураШапкиДокумента.ДоговорКонтрагента.метаданные()) Тогда
					СтруктураШапкиДокумента.Вставить("РасчетыВУсловныхЕдиницах", СтруктураШапкиДокумента.ДоговорКонтрагента.РасчетыВУсловныхЕдиницах);				
				Иначе
					СтруктураШапкиДокумента.Вставить("РасчетыВУсловныхЕдиницах", ЭтоВалютаРегл(СтруктураШапкиДокумента.ДоговорКонтрагента.ПорядокОплаты));				
				КонецЕсли; 
			КонецЕсли;			
		КонецЕсли;
		
		Если ЭтоСемействоБП() Тогда
			
			Если НЕ СтруктураШапкиДокумента.Свойство("ПодразделениеОрганизации") Тогда
				СтруктураШапкиДокумента.Вставить("ПодразделениеОрганизации", Справочники.ПодразделенияОрганизаций.ПустаяСсылка());
			КонецЕсли;
		
			СтруктураШапкиДокумента.Вставить("ОрганизацияПрименяетУСН"
								, ?(СтруктураШапкиДокумента.Свойство("Организация"), бит_БухгалтерияСервер.ПрименяетсяУСН(СтруктураШапкиДокумента.Организация, СтруктураШапкиДокумента.Дата), Ложь));
			
			Если НЕ СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете") Тогда
				СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчете", Истина);
			КонецЕсли;
			
			Если НЕ СтруктураШапкиДокумента.Свойство("ПризнаватьДоходыИРасходыПоОперациямПрошлогоГода") Тогда
				СтруктураШапкиДокумента.Вставить("ПризнаватьДоходыИРасходыПоОперациямПрошлогоГода", Истина);
			КонецЕсли;
			
			// Установка отдельного флага для отражения в налоговом учете УСН.
			Если СтруктураШапкиДокумента.Свойство("ОтражатьВНалоговомУчете") 
				 И СтруктураШапкиДокумента.Свойство("Организация") 
				 И ТипЗнч(СтруктураШапкиДокумента.Организация) = Тип("СправочникСсылка.Организации")  Тогда
				
				Если СтруктураШапкиДокумента.ОтражатьВНалоговомУчете Тогда
					
					Если СтруктураШапкиДокумента.ОрганизацияПрименяетУСН Тогда
						
						Если бит_БухгалтерияСервер.ПрименяетсяУСНДоходы(СтруктураШапкиДокумента.Организация, СтруктураШапкиДокумента.Дата) Тогда
							СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы", Истина);
							СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН"	   , Ложь);
						Иначе
							СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы", Ложь);
							СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН"	   , Истина);
						КонецЕсли;
						
						СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчете"			     , Ложь);
						СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеПредпринимателя", Ложь);
						
					Иначе
						
						СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН"	   , Ложь);
						СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы", Ложь);
						
						Если ТипЗнч(СтруктураШапкиДокумента.Организация) = Тип("СправочникСсылка.Организации") 
							И Не ОрганизацияЯвляетсяЮрЛицом(СтруктураШапкиДокумента.Организация) Тогда
							СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеПредпринимателя", Истина);
							СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчете",    Ложь);
							СтруктураШапкиДокумента.Вставить("ПризнаватьДоходыИРасходыПоОперациямПрошлогоГода", Истина);
							СтруктураШапкиДокумента.Вставить("ДляПризнанияРасходовНеТребуетсяПолучениеДохода" , Истина);
						Иначе
							СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеПредпринимателя", Ложь);
						КонецЕсли;
						
					КонецЕсли;
					
				Иначе
					
					СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН"			 , Ложь);
					СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы"		 , Ложь);
					СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеПредпринимателя", Ложь);
					
				КонецЕсли;
				
				СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН", Ложь);
				
				// Проверим проведение по разделам учета.
				Если НЕ бит_БухгалтерияСервер.ПроводитьДокументПоРазделуУчета(СтруктураШапкиДокумента.Организация, Перечисления.РазделыУчета.НУ, СтруктураШапкиДокумента.Дата) Тогда
					СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчете"				 , Ложь);
					СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСН"			 , Ложь);
					СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеУСНДоходы"		 , Ложь);
					СтруктураШапкиДокумента.Вставить("ОтражатьВНалоговомУчетеПредпринимателя", Ложь);
				КонецЕсли;
				
			КонецЕсли;
			
			Если СтруктураШапкиДокумента.Свойство("Организация") И ТипЗнч(СтруктураШапкиДокумента.Организация) = Тип("СправочникСсылка.Организации")  Тогда
				СтруктураШапкиДокумента.Вставить("Префикс", СтруктураШапкиДокумента.Организация.Префикс);
				СтруктураШапкиДокумента.Вставить("ПрименениеПБУ18", Истина);
				
				// Установка флага применения положений ПБУ 18/02.
				Если бит_БухгалтерияСервер.ПоддержкаПБУ18(СтруктураШапкиДокумента.Организация, СтруктураШапкиДокумента.Дата) Тогда
					СтруктураШапкиДокумента.Вставить("ПрименениеПБУ18", Истина);
				Иначе
					СтруктураШапкиДокумента.Вставить("ПрименениеПБУ18", Ложь);
				КонецЕсли;
				
			КонецЕсли; 	
		
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураШапкиДокумента;

КонецФункции // СформироватьСтруктуруШапкиДокумента()

// Проверяет признак ручной корректировки и очищает движения регистратора при необходимости.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция РучнаяКорректировкаОбработкаПроведения(РучнаяКорректировка, Отказ, Заголовок, ЭтотОбъект, ВыборочноОчищатьРегистры = Истина)  Экспорт

	флРезультат = Ложь;
	
	Если ЭтоСемействоБП() Тогда	
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("ПроведениеСервер");
		Модуль.ПодготовитьНаборыЗаписейКПроведению(ЭтотОбъект, ВыборочноОчищатьРегистры);                
		флРезультат = РучнаяКорректировка;
		
	ИначеЕсли ЭтоСемействоERP() Тогда
		
	    УдалитьДвиженияРегистратора(ЭтотОбъект, Отказ);
		
	КонецЕсли; 
	
	Возврат флРезультат;
	
КонецФункции // РучнаяКорректировкаОбработкаПроведения()	

// Процедура вызывает типовую процедуру по удалению движений регистратора.
// 
// Параметры:
//  ЭтотОбъект 				 - ДокументОбъект.
//  Отказ	   				 - Булево.
//  РучнаяКорректировка      - Булево.
//  ВыборочноОчищатьРегистры - Булево, по умолчанию Ложь.
// 
Процедура УдалитьДвиженияРегистратора(ЭтотОбъект
									 ,Отказ
									 ,РучнаяКорректировка = Ложь
									 ,ВыборочноОчищатьРегистры = Ложь) Экспорт
	
	Если ЭтоСемействоБП() Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБПВызовСервера");
		Модуль.УдалитьДвиженияРегистратора(ЭтотОбъект, Отказ, РучнаяКорректировка);                
	КонецЕсли;	
	
КонецПроцедуры // УдалитьДвиженияРегистратора()

// Выполняет движение по регистру.
// 
// Параметры:
//  НаборДвижений - набор движений регистра. 
// 
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено) Экспорт
	
	БП_ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения); 	
	
КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Выполняет движение по регистру.
// 
// Параметры:
//  НаборДвижений - набор движений регистра.
// 
Процедура БП_ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено)

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	Если ТаблицаДвижений.Колонки.Найти("Период") = Неопределено Тогда
		ОписаниеТиповДаты = Неопределено;
		Модуль = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБПКлиентСервер");
		ОписаниеТиповДаты = Модуль.ПолучитьОписаниеТиповДаты(ЧастиДаты.ДатаВремя);                
		ТаблицаДвижений.Колонки.Добавить("Период", ОписаниеТиповДаты);
	КонецЕсли;

	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;

	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Если МетаИзм.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;

	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если МетаРес.Тип.Типы().Количество() > 1 Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;

	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());

	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;

		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда

			ФлагКолонкиСостТипа = (ИзмеренияСостТипа.Свойство(ИмяКолонки));

			Индекс = 0;

			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда

					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;

					МассивСтрок[Индекс] = СтрокаДвижения;
					Если СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					Иначе
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					КонецЕсли;

				Иначе

					СтрокаДвижения = МассивСтрок[Индекс];

				КонецЕсли;

				Индекс = Индекс + 1;

				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда
					Если ЗначКолонки = Неопределено ИЛИ НЕ ЗначениеЗаполнено(ЗначКолонки) Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;

			КонецЦикла;

			ПерваяКолонка = Ложь;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // БП_ВыполнитьДвижениеПоРегистру()

#КонецОбласти

#Область ПодпискиНаСобытия

// Подписка на событие ПриЗаписи справочника ГруппыПользователей.
// 
Процедура бит_ПриЗаписиГруппыПользователейПриЗаписи(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
    	Возврат;
	КонецЕсли;
	
	Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_ЭтоЧужойПодчиненныйУзел") = Истина Тогда
		
	    // Функционал БФ может работать только в узлах, созданных с помощью ПО бит_Полный.
		Возврат;
	
	КонецЕсли; 			
	
	Если НЕ Отказ Тогда
		
		// Мог измениться состав группы пользователей - инициируем обновления 
		// параметров сеанса у пользователей с ограниченными ролями.
		Константы.бит_ИдентификаторКэшаНастроек.Установить(Строка(Новый УникальныйИдентификатор));
			
		// Сбросим кэш настроек текущего пользователя.
		бит_ОбщиеПеременныеСервер.ЗначениеПеременнойУстановить("бит_ЗначенияНастроекПользователей", Новый Соответствие, ИСТИНА);
		
	КонецЕсли; 
	
КонецПроцедуры // бит_ПриЗаписиГруппыПользователейПриЗаписи()

// Подписка на событие ПриЗаписи справочника ГруппыПользователей.
// 
Процедура бит_ПриЗаписиПользователиПриЗаписи(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
    	Возврат;
	КонецЕсли;
	
	Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_ЭтоЧужойПодчиненныйУзел") = Истина Тогда
		
	    // Функционал БФ может работать только в узлах, созданных с помощью ПО бит_Полный.
		Возврат;
	
	КонецЕсли; 		
		
	Если НЕ Отказ Тогда		
		РегистрыСведений.бит_ДоступныеИнтерфейсы.ПроверитьУстановитьДоступностьРусскогоИнтерфейса(Источник.Ссылка);		
	КонецЕсли; 
	
КонецПроцедуры // бит_ПриЗаписиПользователиПриЗаписи()

Процедура бит_ПередЗаписьюПрисоединенныеФайлыПередЗаписью(Источник, Отказ, РежимЗаписи, РежимПроведения) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли; 
	
	Если НЕ Отказ Тогда		
		
		ВладелецФайла = Источник.ВладелецФайла;
		МетаданныеВладельца = ВладелецФайла.Метаданные();
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Ссылка", ВладелецФайла);
		ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ТабДокумент.Ссылка,
		|	ЕСТЬNULL(ТабСтатусы.Статус, ЗНАЧЕНИЕ(Справочник.бит_СтатусыОбъектов.ПустаяСсылка)) КАК Статус
		|ИЗ
		|	#ТаблицаДокумента КАК ТабДокумент
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.бит_СтатусыОбъектов КАК ТабСтатусы
		|		ПО ТабДокумент.Ссылка = ТабСтатусы.Объект
		|			И (ТабСтатусы.ВидСтатуса = ЗНАЧЕНИЕ(Перечисление.бит_ВидыСтатусовОбъектов.Статус))
		|ГДЕ
		|	ТабДокумент.Ссылка = &Ссылка";
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ТаблицаДокумента", "Документ."+МетаданныеВладельца.Имя);			   
		Запрос.Текст = ТекстЗапроса;
		
		РезультатЗапроса = Запрос.Выполнить();
		Выборка = РезультатЗапроса.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			// Только для статуса утвержден
			Если СтрНайти(ВРег(Выборка.Статус.Наименование), ВРег("утвержд"))=0 Тогда
				Продолжить;
			КонецЕсли; 
			
			ПараметрыПолучения 	= "Дата";
			ЕстьОрганизация 	= Ложь;
			ЕстьЦФО 			= Ложь;
			СтруктураПараметров = Новый Структура;
			Если МетаданныеВладельца.Реквизиты.Найти("Организация") <> Неопределено Тогда
				ПараметрыПолучения = ПараметрыПолучения + ",Организация";
				ЕстьОрганизация = Истина;
			КонецЕсли;  
			Если МетаданныеВладельца.Реквизиты.Найти("ЦФО") <> Неопределено Тогда
				ПараметрыПолучения = ПараметрыПолучения + ",ЦФО";
				ЕстьЦФО = Истина;
			КонецЕсли;  
			
			СтрВладельца = ЗначенияРеквизитовОбъекта(ВладелецФайла, ПараметрыПолучения);
			Если ЕстьОрганизация Тогда
				СтруктураПараметров.Вставить("Организация", СтрВладельца.Организация);
			КонецЕсли;
			Если ЕстьЦФО Тогда
				СтруктураПараметров.Вставить("ЦФО", СтрВладельца.ЦФО);
			КонецЕсли; 
			
			НастройкиПрограммы = ПолучитьНастройкиПрограммы(СтрВладельца.Дата,,СтруктураПараметров,"Ошибки");	
			КонтрольБИТ = ИзвлечьНастройкуПрограммы(НастройкиПрограммы,ПланыВидовХарактеристик.бит_НастройкиПрограммы.ЗапрещатьИзменятьФайлыВУтвержденныхДокументах);
			
			Если КонтрольБИТ = Перечисления.бит_ВидыКонтроляИзмененияФайловВУтвержденныхДокументах.Запретить Тогда
				ТекстСообщения = НСтр("ru='Изменение присоединенных файлов запрещено, документ находится в статусе Утвержден!'");
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения,,,Отказ);
			КонецЕсли;	
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СостыковкаКодаБпИУпп

// Функция получает признак доступности роли с ограниченными правами.
// 
// Параметры:
//  ИмяРоли - Строка (По умолчанию "ИсполнительКазначейства").
//  
// Возвращаемое значение:
//   Булево.
// 
Функция РольДоступнаРлс(ИмяРоли = "ИсполнительКазначейства") Экспорт

	РольДоступнаРлс = Ложь;
	
	ИмяРоли = "бит_рлс_" + ИмяРоли;
	РольДоступнаРлс = Метаданные.Роли.Найти(ИмяРоли) <> Неопределено И РольДоступна(ИмяРоли);
	
	Возврат РольДоступнаРлс;
	
КонецФункции // РольДоступнаРлс()

// Процедура обрабатывает изменение организации.
// 
// Параметры:
//  ДокументОбъект      - объект документ в форме которого произошло событие.
//  ТекущийПользователь - СправочникСсылка.Пользователи - используется для совмеситмости
// 						   с форматом вызова в БП.
// 
Процедура ПриИзмененииЗначенияОрганизации(ДокументОбъект, ТекущийПользователь = Неопределено) Экспорт
	
	МетаданныеДокумента = ДокументОбъект.Ссылка.Метаданные();
	Если бит_РаботаСМетаданными.ЕстьРеквизит("Организация", МетаданныеДокумента) Тогда
		
		Если МетаданныеДокумента.Реквизиты.Найти("ПодразделениеОрганизации") <> Неопределено
			И ЗначениеЗаполнено(ДокументОбъект.Организация)
			И ЗначениеЗаполнено(ДокументОбъект.ПодразделениеОрганизации)
			И Не ДокументОбъект.ПодразделениеОрганизации.Владелец = ДокументОбъект.Организация Тогда
			
			ДокументОбъект.ПодразделениеОрганизации = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
			
		КонецЕсли;
		
		Если бит_РаботаСМетаданными.ЕстьРеквизит("ДоговорКонтрагента", МетаданныеДокумента)
			И ЗначениеЗаполнено(ДокументОбъект.Организация)
			И ЗначениеЗаполнено(ДокументОбъект.ДоговорКонтрагента)
			И НЕ ДокументОбъект.ДоговорКонтрагента.Организация = ДокументОбъект.Организация Тогда
			
			ДокументОбъект.ДоговорКонтрагента = Неопределено;
			
		КонецЕсли;
		
		Если МетаданныеДокумента.Реквизиты.Найти("БанковскийСчетОрганизации") <> Неопределено Тогда
			ДокументОбъект.БанковскийСчетОрганизации = ДокументОбъект.Организация.ОсновнойБанковскийСчет;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ПриИзмененииЗначенияОрганизации()

//////////////////////////////////////////////////////////
// Адаптация для ERP

// Функция определяет какую валюту использовать, в зависимости от порядка оплаты.
// 
// Параметры:
//  ПорядокОплаты - ПеречислениеСсылка.ПорядокОплатыПоСоглашениям.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоВалютаРегл(ПорядокОплаты) Экспорт 

	Возврат бит_ОбщегоНазначенияПереопределяемый.ЭтоРасчетыВВалютеОплатаВВалюте(ПорядокОплаты);
	
КонецФункции // ЭтоВалютаРегл()

// Функция определяет имя реквизита контрагента справочника "Договоры контрагентов"
// в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка
// 
Функция ОпределитьИмяРеквизитаКонтрагента() Экспорт
	
	Если Метаданные.Справочники.ДоговорыКонтрагентов.Владельцы.Количество() <> 0 Тогда
		Возврат "Владелец";
	Иначе
		Возврат "Контрагент";
	КонецЕсли;
		
КонецФункции // ОпределитьИмяРеквизитаКонтрагента()

// Функция определяет реквизит, который следует использовать в качества контрагента,
// в зависимости от текущего решения.
// 
// Параметры:
// 	Договор - СправочникСсылка.ДоговорыКонтрагентов.
// 
// Возвращаемое значение:
// 	СправочникСсылка.Контрагенты.	
// 
Функция ОпределитьКонтрагентаПоДоговору(Договор) Экспорт
    
    ИмяКонтрагента = ОпределитьИмяРеквизитаКонтрагента();
    
    Контрагент_Владелец = Договор[ИмяКонтрагента];
	
	Возврат Контрагент_Владелец;
		
КонецФункции // ОпределитьКонтрагентаПоДоговору()

#КонецОбласти

#Область ФормированиеПараметровОткрываемыхФорм

// Функция формирует параметры формы выбора статей оборотов.
// 
// Возвращаемое значение:
//   Структура - параметры
// 
Функция ПолучитьПараметрыФормыВыбораСтатейОборотов(ТипБюджета) Экспорт
	
	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("ТипБюджета", ТипБюджета);
 	
	Отбор = Новый Структура; 
	Отбор.Вставить("ПометкаУдаления", Ложь);
	Если ТипБюджета = Перечисления.бит_ТипыБюджетов.БДР 
		ИЛИ ТипБюджета = Перечисления.бит_ТипыБюджетов.БДДС Тогда
		
		ИмяТипаБюджета = бит_РаботаСМетаданными.ПолучитьИмяЗначенияПеречисления(Перечисления.бит_ТипыБюджетов, ТипБюджета);
		ТипСтатьи  = Перечисления.бит_ТипыСтатейОборотов[ИмяТипаБюджета];
		Отбор.Вставить("ТипСтатьи", ТипСтатьи);
		
	КонецЕсли; 
	ПараметрыФормы.Вставить("Отбор", Отбор);
	
	Возврат ПараметрыФормы;
 	
КонецФункции // ПолучитьОтбор()

#КонецОбласти

#Область Сообщения

// Процедура выводит состояние с учетом места исполнения кода.
// 
// Параметры:
//  ТекстСостояния - Строка.
// 
Процедура бит_Состояние(ТекстСостояния) Экспорт
    
    #Если Клиент Тогда
		Если НЕ ПустаяСтрока(ТекстСостояния) Тогда
			Состояние(ТекстСостояния);	
		Иначе
			Состояние();
		КонецЕсли; 
	#КонецЕсли 	
	
КонецПроцедуры // бит_Состояние()

// Процедура выводит сообщение с учетом места исполнения кода.
// 
// Параметры:
//  ТекстСообщения  - Строка.
//  СтатусСообщения - СтатусСообщения.
// 
Процедура бит_Сообщить(ТекстСообщения,Статус = Неопределено) Экспорт

	#Если Клиент Тогда
		
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);	
		
	#КонецЕсли	

КонецПроцедуры

// Функция забивает длинную строку на несколько коротких,
// перенос выполняется по словам в качестве разделителя слов применятся пробел.
// 
// Параметры:
//  ИсходнаяСтрока  - Строка - исходная строка.
//  ДопустимаяДлина - Число(4.0) - допустимая длина выводимой строки. 
// 
// Возвращаемое значение:
//   Строка - многострочная строка.
// 
Функция ВыполнитьПереносПоСловам(ИсходнаяСтрока, ДопустимаяДлина = 120) 
	
	ТекстСообщения = "";
	Если  СтрДлина(ИсходнаяСтрока) <= ДопустимаяДлина Тогда
        
        ТекстСообщения = ИсходнаяСтрока;
        
    ИначеЕсли СтрЧислоВхождений(ИсходнаяСтрока, " ") = 0 Тогда
        
        // Нет пробелов, не могу разбить строку на куски.
		ТекстСообщения = ИсходнаяСтрока;
        
    Иначе
		
		ПравСтрока = ИсходнаяСтрока;
		Пока СтрДлина(ПравСтрока) > 0 Цикл
			
			ЛевСтрока  = Лев(ПравСтрока, Мин(СтрДлина(ПравСтрока),ДопустимаяДлина));
			Если СтрЧислоВхождений(ЛевСтрока, " ") > 0 Тогда
				Пока СтрЧислоВхождений(ЛевСтрока, " ") > 0 Цикл
					ТекстСообщения = ТекстСообщения + Сред(ЛевСтрока, 1, Найти(ЛевСтрока, " "));
					ЛевСтрока      = Сред(ЛевСтрока, Найти(ЛевСтрока, " ") + 1);
				КонецЦикла;
			Иначе
				// В отрезанном куске нет пробелов.
				ТекстСообщения = ТекстСообщения + ЛевСтрока;
				ЛевСтрока = "";
			КонецЕсли;
			
			ПравСтрока     = ЛевСтрока + Сред(ПравСтрока, ДопустимаяДлина + 1);
			ТекстСообщения = ТекстСообщения + Символы.ПС;
			Если СтрДлина(ПравСтрока) <= ДопустимаяДлина Тогда
				ТекстСообщения = ТекстСообщения + ПравСтрока;
				ПравСтрока     = "";
            КонецЕсли;
            
        КонецЦикла;
        
	КонецЕсли;
	
	Возврат ТекстСообщения;	
    
КонецФункции // ВыполнитьПереносПоСловам()

// Процедура-обертка для типовой СообщитьОбОшибке, помимо типового функционала 
// выполняется перенос строк до заданной длины.
// 
// Параметры:
//  ТекстСообщения     - Строка.
//  Отказ              - Булево.
//  Заголовок          - Строка.
//  Статус             - СтатусСообщения.
//  ВызыватьИсключение - Булево.
//  ДопустимаяДлина    - Число(4.0).
// 
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено, 
			ВызыватьИсключение = Истина, ДопустимаяДлина = 120) Экспорт
	
	Если НЕ ПустаяСтрока(Заголовок) Тогда			
		ОбщегоНазначения.СообщитьПользователю(Заголовок);
		Заголовок = "";
	КонецЕсли; 
	
	ОбщегоНазначения.СообщитьПользователю(ТекстСообщения,,,,Отказ); 
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСМетаданными

// Функция определяет имя объекта ссылочного типа по описанию типов.
 // 
 // Параметры:
 //  ОписаниеТипов   - ОписаниеТипов - содержит тип, имя объекта которого нужно определить.
 //  ИмяКоллекции    - Строка - имя коллекции объектов метаданный: "Справочники","Документы" и т.п.
 //  НачалоИмениТипа - Строка - начало строкового представления типа : "СправочникСсылка", "ДокументСсылка" и т.п.
 // 
 // Возвращаемое значение:
 //  РезСтруктура   - Структура (Ключи: "Имя","Синоним","ИмяТипа"; Значения: Строка) 
 //                   Неопределено (если имя не удалось определить). 
 // 
Функция ПолучитьИмяОбъектаПоОписаниюТипов(ОписаниеТипов, ИмяКоллекции, НачалоИмениТипа) Экспорт
	 
	 РезСтруктура = Неопределено;
	 
	 Для каждого Мета Из Метаданные[ИмяКоллекции] Цикл
		 
		 ИмяТипа = НачалоИмениТипа + "." + Мета.Имя;
		 Если ОписаниеТипов.СодержитТип(Тип(ИмяТипа)) Тогда
			 
			 РезСтруктура = Новый Структура;
			 РезСтруктура.Вставить("Имя"    , Мета.Имя);
			 РезСтруктура.Вставить("Синоним", Мета.Синоним);
			 РезСтруктура.Вставить("ИмяТипа", ИмяТипа);
			 
			 Прервать;
             
		 КонецЕсли; 
		 
	 КонецЦикла; 
	 
	 Возврат РезСтруктура;
	 
 КонецФункции // ПолучитьИмяОбъектаПоОписаниюТипов()
 
// Получает имя значения перечисления по ссылке.
// 
// Параметры:
//  ТекПеречисление      - ПеречислениеМенеджер.
//  ЗначениеПеречисления - ПеречислениеСсылка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяЗначенияПеречисления(ТекПеречисление,ЗначениеПеречисления) Экспорт
	
	ТекИндекс   = ТекПеречисление.Индекс(ЗначениеПеречисления);
	ИмяЗначения = ЗначениеПеречисления.Метаданные().ЗначенияПеречисления[ТекИндекс].Имя;
	
	Возврат ИмяЗначения;
	
КонецФункции // ПолучитьИмяЗначенияПеречисления()

// Функция кэширует в структуру значения указанного перечисления. 
// Ключ имя значения перечисления, значение - ссылка. Используется для кэширования 
// значений перечислений с целью передачи на клиент.
// 
// Параметры:
//  ТекПеречисление  - ПеречислениеСсылка.
// 
// Возвращаемое значение:
//   Структура.
// 
Функция КэшироватьЗначенияПеречисления(ТекПеречисление)  Экспорт

	КэшЗначений = Новый Структура;
	
	Для каждого ЗначениеПеречисления Из ТекПеречисление Цикл
	
		  ИмяЗначения = ПолучитьИмяЗначенияПеречисления(ТекПеречисление, ЗначениеПеречисления);
		  КэшЗначений.Вставить(ИмяЗначения,ЗначениеПеречисления);
	
	КонецЦикла; 	

	Возврат КэшЗначений;
	
КонецФункции // КэшироватьЗначенияПеречисления()

// Получает менеждер по имени.
// 
// Параметры:
//  ИмяМенеджера - Строка - Имя менеджера коллекции.
//  ИмяОбъекта   - Строка - Имя объекта, менеджер которого нужно получить.
// 
// Возвращаемое значение:
//  РезМенеджер - МенеджерКоллекции, МенеджерОбъекта.
// 
Функция ПолучитьМенеджер(ИмяМенеджера, ИмяОбъекта = "")  Экспорт
	
	Менеджеры = Новый Соответствие;
	Менеджеры.Вставить("Справочники"            ,Справочники);
	Менеджеры.Вставить("Документы"              ,Документы);
	Менеджеры.Вставить("Перечисления"           ,Перечисления);	
	Менеджеры.Вставить("Обработки"              ,Обработки);
	Менеджеры.Вставить("Отчеты"                 ,Отчеты);
	Менеджеры.Вставить("РегистрыСведений"       ,РегистрыСведений);
	Менеджеры.Вставить("РегистрыНакопления"     ,РегистрыНакопления);
	Менеджеры.Вставить("РегистрыБухгалтерии"    ,РегистрыБухгалтерии);
	Менеджеры.Вставить("РегистрыРасчета"        ,РегистрыРасчета);
	Менеджеры.Вставить("ПланыСчетов"            ,ПланыСчетов);
	Менеджеры.Вставить("ПланыВидовХарактеристик",ПланыВидовХарактеристик);
	Менеджеры.Вставить("ПланыОбмена"            ,ПланыОбмена);
	Менеджеры.Вставить("ПланыВидовРасчета"      ,ПланыВидовРасчета);
	Менеджеры.Вставить("Задачи"                 ,Задачи);
	Менеджеры.Вставить("БизнесПроцессы"         ,БизнесПроцессы);
	
	РезМенеджер = Менеджеры[ИмяМенеджера];
	
	Если НЕ ПустаяСтрока(ИмяОбъекта) Тогда
	
		Попытка			
			РезМенеджер = РезМенеджер[ИмяОбъекта];		
		Исключение			
			РезМенеджер = Неопределено;			
		КонецПопытки; 
	
	КонецЕсли; 
	
	Возврат РезМенеджер;
	
КонецФункции // ПолучитьМенеджер()

// Функция определяет принадлежит значение коллекции метаданных или нет.
// 
// Параметры:
//  ИмяКоллекции    - Строка.
//  ТекущееЗначение - ЛюбаяСсылка.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЗначениеПринадлежитКоллекцииМетаданных(ИмяКоллекции, ТекущееЗначение) Экспорт
	
	ПринадлежитКоллекции = Истина;
    
	Если ЭтоПримитивныйТип(ТекущееЗначение) Тогда	
		ПринадлежитКоллекции = Ложь;	
	КонецЕсли; 
	
	Если ПринадлежитКоллекции Тогда
		
		Если Метаданные[ИмяКоллекции].Найти(ТекущееЗначение.Метаданные().Имя) = Неопределено Тогда
			ПринадлежитКоллекции = Ложь;
		Иначе	
			ПринадлежитКоллекции = Истина;
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат ПринадлежитКоллекции;

КонецФункции // ЗначениеПринадлежитКоллекцииМетаданных()

// Функция определяет принадлежит ли тип переданного значения к примитивным типам.
// 
// Параметры:
// 	ТекущееЗначение - любое значение, ТипЗначение.
// 
// Возвращаемое значение:
// 	Булево.
// 
Функция ЭтоПримитивныйТип(ТекущееЗначение) Экспорт
	
	ПримитивныйТип = Ложь;
	
	Если ТипЗнч(ТекущееЗначение) = Тип("Тип") Тогда
		
		Если ТекущееЗначение = Тип("Строка") 
			 ИЛИ ТекущееЗначение = Тип("Число") 
			 ИЛИ ТекущееЗначение = Тип("Дата") 
			 ИЛИ ТекущееЗначение = Тип("Булево") 
			 ИЛИ ТекущееЗначение = Тип("ХранилищеЗначения") 
			 ИЛИ ТекущееЗначение = Тип("NULL") 
			 ИЛИ ТекущееЗначение = Тип("Неопределено") Тогда
		
			ПримитивныйТип = Истина;
		
		КонецЕсли; 
		
	Иначе	
		
		Если ТипЗнч(ТекущееЗначение) = Тип("Строка") 
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Число")
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Дата")
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("Булево")
			ИЛИ ТипЗнч(ТекущееЗначение) = Тип("ХранилищеЗначения")		 		 
			ИЛИ ТекущееЗначение = Неопределено
			ИЛИ ТекущееЗначение = NULL Тогда
			
			ПримитивныйТип = Истина;
			
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат ПримитивныйТип;
	
КонецФункции // ЭтоПримитивныйТип()

// Функция определяет принадлежит объект указанной коллекции метаданных или нет.
// 
// Параметры:
//  ИмяКоллекции - Строка.
//  ИмяОбъекта   - Строка.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ОбъектПринадлежитКоллекцииМетаданных(ИмяКоллекции, ИмяОбъекта) Экспорт

	Если Метаданные[ИмяКоллекции].Найти(ИмяОбъекта) = НЕОПРЕДЕЛЕНО Тогда
		флПринадлежит = Ложь;
	Иначе	
		флПринадлежит = Истина;
	КонецЕсли; 
	
	Возврат флПринадлежит;

КонецФункции // ОбъектПринадлежитКоллекцииМетаданных()

// Функция определяет есть ли у данного объекта указанный реквизит.
// 
// Параметры:
//  ИмяРеквизита - Строка.
//  МетаОбъект   - ОбъектМетаданных.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ЕстьРеквизит(ИмяРеквизита, МетаОбъект) Экспорт

	флЕсть = МетаОбъект.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;

	Возврат флЕсть;
	
КонецФункции // ЕстьСтандартныйРеквизит()

// Функция определяет есть ли у данного объекта указанный стандартный реквизит.
// 
// Параметры:
//  ИмяРеквизита - Строка.
//  МетаОбъект   - ОбъектМетаданных.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ЕстьСтандартныйРеквизит(ИмяРеквизита, МетаОбъект) Экспорт

	флЕсть = Ложь;
	Для каждого МетаРеквизит Из МетаОбъект.СтандартныеРеквизиты Цикл
	
		Если МетаРеквизит.Имя = ИмяРеквизита Тогда
		
			флЕсть = Истина;
			Прервать;
		
		КонецЕсли; 
	
	КонецЦикла; 
	
	Возврат флЕсть;
	
КонецФункции // ЕстьСтандартныйРеквизит()

// Функция определяет имя коллекции, которой принадлежит объект.
// 
// Параметры:
//  МетаданныеОбъекта - ОбъектМетаданных.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ОпределитьИмяКоллекции(МетаданныеОбъекта) Экспорт
 
 	ИмяКоллекции = "";
	
	ИменаКоллекций = Новый Массив;
	ИменаКоллекций.Добавить("Справочники");
	ИменаКоллекций.Добавить("Документы");
	ИменаКоллекций.Добавить("Перечисления");
	ИменаКоллекций.Добавить("Отчеты");
	ИменаКоллекций.Добавить("Обработки");
	ИменаКоллекций.Добавить("ПланыВидовХарактеристик"); 
	ИменаКоллекций.Добавить("ПланыСчетов");
	ИменаКоллекций.Добавить("ПланыВидовРасчета");
	ИменаКоллекций.Добавить("РегистрыСведений");
	ИменаКоллекций.Добавить("РегистрыНакопления");
	ИменаКоллекций.Добавить("РегистрыБухгалтерии");
	ИменаКоллекций.Добавить("РегистрыРасчета");
	ИменаКоллекций.Добавить("БизнесПроцессы");
	ИменаКоллекций.Добавить("Задачи");
	
	ИмяОбъекта = МетаданныеОбъекта.Имя;
	Для каждого Элемент Из ИменаКоллекций Цикл
	
		Если ОбъектПринадлежитКоллекцииМетаданных(Элемент,ИмяОбъекта) Тогда		
			 ИмяКоллекции = Элемент;
			 Прервать;		
		КонецЕсли; 
	
	КонецЦикла;  	
 
 	Возврат ИмяКоллекции;
 	
КонецФункции // ОпределитьИмяКоллекции()

// Функция определяет принадлежит ли регистр коллекции движений документа.
// 
// Параметры:
//  Движения    - КоллекцияДвиженийДокумента.
//  ИмяРегистра - Строка.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция РегистрУчаствуетВДвижениях(Движения,ИмяРегистра)  Экспорт
	
	Если Движения.Найти(ИмяРегистра) = Неопределено Тогда
		УчаствуетВДвижениях = Ложь;
	Иначе	
		УчаствуетВДвижениях = Истина;
	КонецЕсли; 
	
	Возврат УчаствуетВДвижениях;
	
КонецФункции // РегистрУчаствуетВДвижениях()

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
// 
// Параметры:
//  ПутьКДанным - строка.
// 
// Возвращаемое значение:
//  Структура - путь к объекту метаданных.
// 
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, мКэшПраваДоступаКМетаданным) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка - 1);
		Структура.Вставить(СоответствиеИмен[индекс - 1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка + 1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка - 1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс - 1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка + 1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	ЕстьДоступКМетаданным = мКэшПраваДоступаКМетаданным.Получить(Структура.ТипОбъекта+"."+Структура.ВидОбъекта);
	Если ЕстьДоступКМетаданным = неопределено Тогда
		Если Структура.ТипОбъекта = "Документ" Тогда
			ЕстьДоступКМетаданным = ПравоДоступа("Чтение", Метаданные.Документы[Структура.ВидОбъекта]);
		ИначеЕсли Структура.ТипОбъекта = "Задача" Тогда
			ЕстьДоступКМетаданным = ПравоДоступа("Чтение", Метаданные.Задачи[Структура.ВидОбъекта]);
		Иначе
			ЕстьДоступКМетаданным = ПравоДоступа("Чтение", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;                                                          
	
	Структура.Вставить("ЕстьДоступКМетаданным", ЕстьДоступКМетаданным);
	мКэшПраваДоступаКМетаданным.Вставить(Структура.ТипОбъекта+"."+Структура.ВидОбъекта,ЕстьДоступКМетаданным);        
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

// Проверяет правильность заполнения строк табличной части документа.
// Если какой-то из реквизтов, влияющий на проведение не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении. 
// В значении структуры существует возможность указать условие необходимости выполнения проверки.
// 
// Параметры:
//  ДокументОбъект             - Объект проводимого документа. 
//  ИмяТабличнойЧасти          - Табличная часть документа.
//  СтруктураОбязательныхПолей - Структура - ключ: имя поля; значение: условие необходимости выполнения проверки.
//  Отказ                      - Флаг отказа в проведении.
//  Заголовок                  - Строка, заголовок сообщения об ошибке проведения.
// 
Процедура ПроверитьЗаполнениеТабличнойЧасти(ДокументОбъект
	                                         , ИмяТабличнойЧасти
											 , СтруктураОбязательныхПолей
											 , Отказ
											 , Заголовок) Экспорт

	ПредставлениеТабличнойЧасти = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление();

	ТабличнаяЧасть      = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
	
	// Цикл по строкам табличной части.
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл

		СтрокаНачалаСообщенияОбОшибке = Нстр("ru = 'В строке № %1% табличной части ""%2%"": '");
		СтрокаНачалаСообщенияОбОшибке = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(СтрокаНачалаСообщенияОбОшибке
																			, СокрЛП(СтрокаТаблицы.НомерСтроки)
																			, ПредставлениеТабличнойЧасти);
																			
		// Цикл по проверяемым полям.
		Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

			Значение = СтрокаТаблицы[КлючЗначение.Ключ];
			Если НЕ ЗначениеЗаполнено(Значение) Тогда 

				// При наличии критерия для проверки проверим соответствие условия проверки критерию.
				ТекстКритерия = КлючЗначение.Значение; 
				Если ТипЗнч(ТекстКритерия) = Тип("Строка") И НЕ ПустаяСтрока(ТекстКритерия)  Тогда
						
						Критерий = Вычислить(ТекстКритерия);						
						Если Не Критерий Тогда							
							Продолжить;							
						КонецЕсли; 
						
				КонецЕсли; 
									
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				
				ТекстСообщения = Нстр("ru = 'Не заполнено значение реквизита ""%1%""!'");
				ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, СокрЛП(ПредставлениеРеквизита));
				
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(СтрокаНачалаСообщенияОбОшибке + ТекстСообщения, , , Отказ);
		
     
			КонецЕсли;

		КонецЦикла; // По проверяемым полям.

	КонецЦикла; // По табличным частям.

КонецПроцедуры // ПроверитьЗаполнениеТабличнойЧасти()

// Функция получает имя объекта по имени формы.
// 
// Параметры:
//  ИмяФормы - Строка.
//  
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьИмяОбъектаПоИмениФормы(ИмяФормы, ПолноеИмя = Истина) Экспорт

	МассивИмениФормы = бит_СтрокиКлиентСервер.РазобратьСтрокуСРазделителями(ИмяФормы, ".");
	Результат = ?(ПолноеИмя, МассивИмениФормы[0] + ".", "") + МассивИмениФормы[1];
	
	Возврат Результат;
	
КонецФункции // ПолучитьИмяОбъектаПоИмениФормы()

// Функция по массиву типов создает список выбора для быстрого выбора составного типа.
// 
// Параметры:
//  МассивТипов - Массив.
// 
// Возвращаемое значение:
//  СписокЗначений.
// 
Функция ПодготовитьСписокВыбораТипа(МассивТипов) Экспорт
	
	СписокВыбора = Новый СписокЗначений;
	Для каждого ТекТип Из МассивТипов Цикл
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТекТип);
		Если ОбъектМетаданных = Неопределено Тогда
			ТекПредставление = Строка(ТекТип);
		Иначе	
			ТекПредставление = ОбъектМетаданных.Синоним;
		КонецЕсли; 
		
		СписокВыбора.Добавить(ТекТип,ТекПредставление);
		
	КонецЦикла; 
	
	Возврат СписокВыбора;
	
КонецФункции // ПодготовитьСписокВыбораТипа()

// Функция возвращает описание всех ссылочных типов.
// 
// Возвращаемое значение:
//  ОписаниеТипов.
// 
Функция ОписаниеЛюбаяСсылка() Экспорт

	РезОписание = Справочники.ТипВсеСсылки();
	РезОписание = Новый ОписаниеТипов(РезОписание, Документы.ТипВсеСсылки().Типы());
	РезОписание = Новый ОписаниеТипов(РезОписание, Перечисления.ТипВсеСсылки().Типы());
	РезОписание = Новый ОписаниеТипов(РезОписание, ПланыСчетов.ТипВсеСсылки().Типы());
	РезОписание = Новый ОписаниеТипов(РезОписание, ПланыВидовХарактеристик.ТипВсеСсылки().Типы());
	РезОписание = Новый ОписаниеТипов(РезОписание, ПланыВидовРасчета.ТипВсеСсылки().Типы());	

	Возврат РезОписание;
	
КонецФункции // ОписаниеЛюбаяСсылка()

// Функция определяет, присутствует ли данное значение в табличной части.
// 
// Параметры:
//  ТекОбъект    - ДокументОбъект, ДокументСсылка текущий объект.
//  ИмяТабЧасти  - Строка имя табличной части.
//  ИмяРеквизита - Строка - имя реквизита.
//  Значение     - Произвольный - значение.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ТабЧастьСодержитЗначение(ТекОбъект, ИмяТабЧасти, ИмяРеквизита, Значение) Экспорт

	флСодержитЗначение = Ложь;
	
	МетаОбъект = ТекОбъект.Метаданные();
	
	Если бит_РаботаСМетаданными.ЕстьТабЧасть(ИмяТабЧасти, МетаОбъект) 
		 И бит_РаботаСМетаданными.ЕстьРеквизитТабЧасти(ИмяРеквизита, МетаОбъект, ИмяТабЧасти) Тогда
	
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить(ИмяРеквизита,Значение);
		
		МассивСтрок = ТекОбъект[ИмяТабЧасти].НайтиСтроки(СтрОтбор);
		
		Если МассивСтрок.Количество() > 0 Тогда
		
			флСодержитЗначение = Истина;
		
		КонецЕсли; 
	
	КонецЕсли; 

	Возврат флСодержитЗначение;
	
КонецФункции // ТабЧастьСодержитЗначение()

// Функция получает имя документа по метаданным.
// 
// Параметры:
//  ДокументСсылка - ДокументСсылка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяДокумента(ДокументСсылка) Экспорт
	
	ИмяДокумента = ДокументСсылка.Метаданные().Имя;
	
	Возврат ИмяДокумента;
	
КонецФункции // ПолучитьИмяДокумента()

// Возвращает Описание типов (Строка, Число, Булево, Дата, ЛюбаяСсылка).
// 
// Возвращаемое значение:
//   ОписаниеТипов.
// 
Функция ОписаниеПроизвольногоТипа() Экспорт

	// Квалификаторы.
	КвЧисла  = Новый КвалификаторыЧисла(16, 3);
	КвСтроки = Новый КвалификаторыСтроки(999);
	КвДаты 	 = Новый КвалификаторыДаты();
	
	// Массив типов.
	МассивТипов = Новый Массив;
	
	МассивТипов.Добавить(Тип("Число"));
	МассивТипов.Добавить(Тип("Строка"));
	МассивТипов.Добавить(Тип("Дата"));
	МассивТипов.Добавить(Тип("Булево"));
	      	
    Для Каждого ЭлементТипа Из Документы.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
    КонецЦикла;  
    Для Каждого ЭлементТипа Из Справочники.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
    КонецЦикла;  
    Для Каждого ЭлементТипа Из Перечисления.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
    КонецЦикла;  
    Для Каждого ЭлементТипа Из ПланыСчетов.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла;
	Для каждого ЭлементТипа Из ПланыОбмена.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 	
	Для каждого ЭлементТипа Из ПланыВидовХарактеристик.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 
	Для каждого ЭлементТипа Из ПланыВидовРасчета.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла;
	Для каждого ЭлементТипа Из БизнесПроцессы.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 	
	Для каждого ЭлементТипа Из Задачи.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 
	
	// Описание типов.
	Возврат Новый ОписаниеТипов(МассивТипов, КвЧисла, КвСтроки, КвДаты);
		
КонецФункции // ОписаниеПроизвольногоТипа()

// Функция возвращает строковое представление описания типов.
// 
// Параметры:
//  ТекОписание - ОписаниеТипов.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция СтроковоеПредставлениеОписанияТипов(ТекОписание, СимволРазделитель = "/") Экспорт
		
	МассивТипов = ТекОписание.Типы();
	
	СтрТип = "";
	
	Если МассивТипов.Количество() = 0 Тогда
		
		СтрТип = СтрТип + "Строка";
		
	Иначе	
		
		Для каждого ТекТип Из МассивТипов Цикл
			
			Если ЭтоПримитивныйТип(ТекТип) Тогда
				
				Если ТекТип = Тип("Строка") Тогда
					
					Если ТекОписание.КвалификаторыСтроки.Длина = 0 Тогда
						
						СтрИмяТипа = "Строка";
						
					Иначе	
						
					   СтрИмяТипа = "Строка(" + Формат(ТекОписание.КвалификаторыСтроки.Длина,"ЧРГ=") + ")";
					   
					КонецЕсли; 
					
				ИначеЕсли ТекТип = Тип("Число") Тогда
					
					Если ТекОписание.КвалификаторыЧисла.Разрядность = 0 Тогда
						
						СтрИмяТипа = "Число";
						
					Иначе	
						
						СтрИмяТипа = "Число("
						              + Формат(ТекОписание.КвалификаторыЧисла.Разрядность,"ЧРГ=")
									  + ","
									  + Формат(ТекОписание.КвалификаторыЧисла.РазрядностьДробнойЧасти,"ЧРГ=")
									  + ")";
					КонецЕсли; 
					
				ИначеЕсли ТекТип = Тип("Дата") Тогда	
					
					Если ТекОписание.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
						СтрИмяТипа = "Дата(Время)";
					ИначеЕсли ТекОписание.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
						СтрИмяТипа = "Дата(Дата)";
					Иначе	
						СтрИмяТипа = "Дата";
					КонецЕсли; 
					
				ИначеЕсли ТекТип = Тип("Булево") Тогда	
					
					СтрИмяТипа = "Булево";
					
				ИначеЕсли ТекТип = Тип("Неопределено") Тогда	
					
					СтрИмяТипа = "Неопределено";
					
				ИначеЕсли ТекТип = Тип("ХранилищеЗначения") Тогда	
					
					СтрИмяТипа = "ХранилищеЗначения";
					
				ИначеЕсли ТекТип = Тип("Null") Тогда	
					
					СтрИмяТипа = "Null";
					
				КонецЕсли; 
				
				СтрТип = СтрТип+?(ПустаяСтрока(СтрТип),"","/")+СтрИмяТипа;				
				
			Иначе
				
				МетаОбъект = Метаданные.НайтиПоТипу(ТекТип);
				
				Если МетаОбъект <> Неопределено Тогда
					
					ИмяПолное  = МетаОбъект.ПолноеИмя();
					СтрИмена   = бит_ОбщегоНазначенияКлиентСервер.РазобратьПолноеИмяОбъекта(ИмяПолное);
					СтрИмяТипа = СтрИмена.ИмяКласса+"Ссылка." + СтрИмена.ИмяОбъекта;
					СтрТип     = СтрТип + ?(ПустаяСтрока(СтрТип), "", "/") + СтрИмяТипа;
					
				КонецЕсли; 
				
			КонецЕсли;	  
			
		КонецЦикла; // МассивТипов.
		
	КонецЕсли; 
	
	Если ПустаяСтрока(СтрТип) Тогда		
		СтрТип = "Строка";		
	КонецЕсли; 

	Возврат СтрТип;
	
КонецФункции // СтроковоеПредставлениеОписанияТипов()

#КонецОбласти

#Область СведенияОПрограммеБит
	
// Функция получает сведения о текущей кофигурации.
// 
// Возвращаемое значение:
//   Структура.
// 
Функция ПолучитьСведенияОПрограмме()  Экспорт
	
	Возврат бит_ОбщегоНазначенияПовтИсп.ПолучитьСведенияОПрограмме();
	
КонецФункции // ПолучитьСведенияОПрограмме()

// Функция возвращает номер релиза 1С.
//
// Возвращаемое значение:
//  Строка.
//
Функция МетаданныеВерсия() Экспорт

	Сведения = бит_ОбщегоНазначенияПовтИсп.ПолучитьСведенияОПрограмме();
	
	Возврат Сведения.НомерРелиза_1С;
	
КонецФункции // МетаданныеВерсия()

// Функция получает текущий номер релиза БИТ. 
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьКонстантуНомерРелизаБИТ() Экспорт 

	Возврат Константы.бит_НомерРелиза.Получить();
	
КонецФункции // ПолучитьКонстантуНомерРелизаБИТ()

#КонецОбласти

#Область МатематическиеФункции

// Устарело, следует использовать  бит_ОбщегоНазначенияКлиентСервер.МодульЧисла(ВхЧисло)
Функция МодульЧисла(ВхЧисло) Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСервер.МодульЧисла(ВхЧисло);
	
КонецФункции // МодульЧисла()

// Функция определяет знак числа.
// 
// Параметры:
//  ВхЧисло  - Число.
// 
// Возвращаемое значение:
//   Число.
// 
Функция ЗнакЧисла(ВхЧисло) Экспорт

	Если ВхЧисло > 0 Тогда
		Результат = 1;
	ИначеЕсли ВхЧисло < 0 Тогда
		Результат = -1;
	Иначе
		Результат = 0;
	КонецЕсли; 

	Возврат Результат;
	
КонецФункции // ЗнакЧисла()

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
// 
// Параметры:
// 		ИсхСумма   - распределяемая сумма.
// 		МассивКоэф - массив коэффициентов распределения.
// 		Точность   - точность округления при распределении. Необязателен.
// 
// 	Возврат:
// 		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
// 			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено.
// 
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт
	
	Если МассивКоэф.Количество() = 0 ИЛИ ИсхСумма = Неопределено ИЛИ ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;
	
	Для Сч = 0 По МассивКоэф.Количество() - 1 Цикл
		
		МодульЧисла = ?(МассивКоэф[Сч] > 0, МассивКоэф[Сч], - МассивКоэф[Сч]);
		
		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = Сч;
		КонецЕсли;
		
		СуммаКоэф = СуммаКоэф + МассивКоэф[Сч];
		
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для Сч = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[Сч] = Окр(ИсхСумма * МассивКоэф[Сч] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[Сч];
	КонецЦикла;
	
	// Погрешности округления отнесем на коэффициент с максимальным весом.
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;
	
	Возврат МассивСумм;
	
КонецФункции // РаспределитьПропорционально()

#КонецОбласти

#Область ПроверкиЗаполнения

Функция ВалютаУпрУчетаУстановлена(ВыводитьСообщениеОбОтсутствииВалюты = Ложь, ДокументСсылка = Неопределено) Экспорт
	
	ВалютаУпрУчета = Константы.бит_ВалютаУправленческогоУчета.Получить();
	Установлена    = ЗначениеЗаполнено(ВалютаУпрУчета);
	
	Если НЕ Установлена И ВыводитьСообщениеОбОтсутствииВалюты Тогда
		ТекстСообщения = Нстр("ru = 'Не заполнена валюта управлеческого учета!'");
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения, ДокументСсылка);
	КонецЕсли; 
	
	Возврат Установлена;
	
КонецФункции

#КонецОбласти

#Область ПроверкиНаБитыеСсылки

// Процедура выполняет удаление строк с битыми ссылками из табличной части.
// 
// Параметры:
//  ТабличнаяЧасть - ТабличнаяЧасть.
//  ИмяКолонки     - Строка, имя колонки значения которой необходимо проверять на битые ссылки.
// 
Процедура УдалитьБитыеСсылкиИзТабличнойЧасти(ТабличнаяЧасть, ИмяКолонки) Экспорт
    
    Кол_Во = ТабличнаяЧасть.Количество();
    
    Если Кол_Во = 0 Тогда
        // Проверять нечего.
        Возврат;
    КонецЕсли;
    
    Для Ном = 1 По Кол_Во Цикл
        
        ТекСтрока           = ТабличнаяЧасть[Кол_Во-Ном];
        ЗначениеДляПроверки = ТекСтрока[ИмяКолонки];
        
        Если ЗначениеЗаполнено(ЗначениеДляПроверки) 
            И ЗначениеДляПроверки.ПолучитьОбъект() = Неопределено Тогда
            // Удалим строку с битой ссылкой.
            ТабличнаяЧасть.Удалить(ТекСтрока);
        КонецЕсли;
        
    КонецЦикла;
    
КонецПроцедуры // УдалитьБитыеСсылкиИзТабличнойЧасти()

#КонецОбласти

#Область РаботаСОтборами

// Процедура заполняет элемент отбора по элементу отбора- источнику.
// 
// Параметры:
//  ЭлементОтбораИсточник - ЭлементОтбора.
//  ЭлементОтбораПриемник - ЭлементОтбора.
// 
Процедура ЗаполнитьЭлементОтбора(ЭлементОтбораИсточник, ЭлементОтбораПриемник) Экспорт
	
	ЭлементОтбораПриемник.ВидСравнения = ЭлементОтбораИсточник.ВидСравнения;
	// Если ЭлементОтбораИсточник.Значение <> Неопределено Тогда
	// 	ЭлементОтбораПриемник.Значение     = ЭлементОтбораИсточник.Значение;
	// КонецЕсли; 
	// Если ЭлементОтбораИсточник.ЗначениеС <> Неопределено Тогда
	// 	ЭлементОтбораПриемник.ЗначениеС    = ЭлементОтбораИсточник.ЗначениеС;
	// КонецЕсли; 
	// Если ЭлементОтбораИсточник.ЗначениеПо <> Неопределено Тогда
	// 	ЭлементОтбораПриемник.ЗначениеПо   = ЭлементОтбораИсточник.ЗначениеПо;
	// КонецЕсли; 
	
	Если ЭтоВидСравненияДляИнтервала(ЭлементОтбораПриемник.ВидСравнения) Тогда
		ЭлементОтбораПриемник.ЗначениеС  = ЭлементОтбораИсточник.ЗначениеС;
		ЭлементОтбораПриемник.ЗначениеПо = ЭлементОтбораИсточник.ЗначениеПо;		
	Иначе	
		ЭлементОтбораПриемник.Значение = ЭлементОтбораИсточник.Значение;
	КонецЕсли; 
	
	ЭлементОтбораПриемник.Использование = ЭлементОтбораИсточник.Использование;
	// ЭлементОтбораПриемник.Представление = ЭлементОтбораИсточник.Представление;
	
КонецПроцедуры // ЗаполнитьЭлементОтбора()

// Функция определяет работает ли данный вид сравнения со списком или нет.
// 
// Параметры:
//  ТекВидСравнения - ВидСравенения.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоВидСравненияДляСписка(ТекВидСравения) Экспорт

	МассивВидовДляСписка = Новый Массив;
	МассивВидовДляСписка.Добавить(ВидСравнения.ВСписке);
	МассивВидовДляСписка.Добавить(ВидСравнения.НеВСписке);
	МассивВидовДляСписка.Добавить(ВидСравнения.ВСпискеПоИерархии);
	МассивВидовДляСписка.Добавить(ВидСравнения.НеВСпискеПоИерархии);
	
	Если МассивВидовДляСписка.Найти(ТекВидСравения) = Неопределено Тогда
	   флДляСписка = Ложь;
	Иначе	
	   флДляСписка = Истина;
	КонецЕсли; 

	Возврат флДляСписка;
	
КонецФункции // ЭтоВидСравненияДляСписка()

// Функция определяет работает ли данный вид сравнения с интервалом или нет.
// 
// Параметры:
//  ТекВидСравнения - ВидСравенения.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЭтоВидСравненияДляИнтервала(ТекВидСравения) Экспорт

	МассивВидов = Новый Массив;
	МассивВидов.Добавить(ВидСравнения.Интервал);
	МассивВидов.Добавить(ВидСравнения.ИнтервалВключаяГраницы);
	МассивВидов.Добавить(ВидСравнения.ИнтервалВключаяНачало);
	МассивВидов.Добавить(ВидСравнения.ИнтервалВключаяОкончание);
	МассивВидов.Добавить(ВидСравнения.Меньше);
	МассивВидов.Добавить(ВидСравнения.МеньшеИлиРавно);
	
	Если МассивВидов.Найти(ТекВидСравения) = Неопределено Тогда
	   флДляИнтервала = Ложь;
	Иначе	
	   флДляИнтервала = Истина;
	КонецЕсли; 

	Возврат флДляИнтервала;
	
КонецФункции // ЭтоВидСравненияДляСписка()

// Процедура добавляет отборы построителя запроса по переданной структуре.
// 
// Параметры:
//  Построитель    - ПостроительЗапроса.
//  СтруктураОтбор - Структура.
//  ИмяОтбора      - Строка.
//  ВидСравнения   - ВидСравнения.
//  Использование  - Булево.
// 
Процедура ДобавитьОтборПостроителяПоСтруктуре(Построитель, СтруктураОтбор, ИмяОтбора, ВидСравнения, Использование = Истина) Экспорт

	Если СтруктураОтбор.Свойство(ИмяОтбора) Тогда
		
		Если Построитель.Отбор.Найти(ИмяОтбора) = Неопределено Тогда
			
			ЭлементОтбора = Построитель.Отбор.Добавить(ИмяОтбора);
			ЭлементОтбора.Использование = Использование;
			ЭлементОтбора.ВидСравнения  = ВидСравнения;
			ЭлементОтбора.Значение      = СтруктураОтбор[ИмяОтбора];
			
		КонецЕсли; 
		
	КонецЕсли; 

КонецПроцедуры // ДобавитьОтборПостроителяПоСтруктуре()

// Процедура добавляет отборы построителя запроса по переданной структуре.
// 
// Параметры:
//  Построитель    - ПостроительЗапроса.
//  СтруктураОтбор - Структура.
//  ИмяОтбора      - Строка.
//  ВидСравнения   - ВидСравнения.
//  Использование  - Булево.
// 
Процедура ДобавитьОтборПостроителя(Построитель, ИмяОтбора, ЗначениеОтбора, ВидСравнения, Использование = Истина) Экспорт
	
	Если Построитель.Отбор.Найти(ИмяОтбора) = Неопределено Тогда
		
		ЭлементОтбора = Построитель.Отбор.Добавить(ИмяОтбора);
		ЭлементОтбора.Использование = Использование;
		ЭлементОтбора.ВидСравнения  = ВидСравнения;
		ЭлементОтбора.Значение      = ЗначениеОтбора;
		
	КонецЕсли; 
	
КонецПроцедуры // ДобавитьОтборПостроителяПоСтруктуре()

#КонецОбласти

#Область РаботаСДаннымиЗаписьУдалениеОбъектовИКоллекций

// Функция выполняет блокировку объекта.
// 
// Параметры:
//  ТекущийОбъект  		 - ДокументОбъект, СправочникОбъект.
//  ТекущееПредставление - Строка.
//  Заголовок      		 - Строка.
//  РежимСообщений 		 - Строка: "Нет", "Все", "Ошибки".
// 
// 
// Возвращаемое значение:
//   Булево - объект заблокирован.
// 
Функция ЗаблокироватьОбъект(ТекущийОбъект, ТекущееПредставление = "", Заголовок = "", РежимСообщений = "Все") Экспорт
	
	ОбъектЗаблокирован = Ложь;
	
	Попытка
		
		ТекущийОбъект.Заблокировать();
		ОбъектЗаблокирован = Истина;		
		
	Исключение
		
		Если РежимСообщений <> "Нет"  Тогда
			ТекстОшибки = ОписаниеОшибки();
			ТекстОшибки = Сред(ТекстОшибки,Найти(ТекстОшибки,"ть):") + 5);
			
			Если ПустаяСтрока(ТекущееПредставление) Тогда  				
				ПредставлениеОбъекта = Строка(ТекущийОбъект);  				
			Иначе	                          				
				ПредставлениеОбъекта = ТекущееПредставление;   				
			КонецЕсли; 
			
			ТекстСообщения = Нстр("ru = 'Не удалось заблокировать объект ""%1%"".'") + Символы.ПС + ТекстОшибки;
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ПредставлениеОбъекта);
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
				
		КонецЕсли; 
		
		ОбъектЗаблокирован = Ложь;
		
	КонецПопытки;
	
	Возврат ОбъектЗаблокирован;
	
КонецФункции // ЗаблокироватьОбъект()

// Процедура выполняет запись/проведение/отмену проведения документа.
// 
// Параметры:
//  ТекущийОбъект  	    	   - ДокументОбъект,СправочникОбъект.
//  РежимЗаписи    			   - РежимЗаписиДокумента.
//  Заголовок      			   - Строка Булево (По умолчанию = "").
//  РежимСообщений 			   - Строка: "Нет","Все","Ошибки" Булево (По умолчанию = "Все").
// 	ЗаписыватьПередПроведением - Булево (По умолчанию = Истина).
//  ПроверятьЗаполнение        - Булево (По умолчанию = Истина).
// 
// Возвращаемое значение:
//   Булево - действие выполнено.
// 
Функция ЗаписатьПровестиДокумент(ТекущийОбъект, РежимЗаписи, Заголовок = "", РежимСообщений = "Все", ЗаписыватьПередПроведением = Истина, ПроверятьЗаполнение = Истина) Экспорт

	ДействиеВыполнено  = Ложь;
    
    РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
   	
	// Проверки перед проведением (записью).
    Если ПроверятьЗаполнение Тогда
        Если НЕ ПроверитьЗаполнение(ТекущийОбъект, РежимыВывода.ВыводитьОшибки, РежимЗаписи) Тогда
            Возврат ДействиеВыполнено;
        КонецЕсли;
    КонецЕсли; 
    
    // Тексты сообщений.
	Если РежимЗаписи = РежимЗаписиДокумента.Запись Тогда
		
		ТекстВыполнено = Нстр("ru = 'Записан документ ""%1%"".'"); 
		ТекстЖР = "БИТ.ОшибкаЗаписиДокумента";	
        
    ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
        
        Если ЗаписыватьПередПроведением Тогда
            ДействиеВыполнено = ЗаписатьПровестиДокумент(ТекущийОбъект, РежимЗаписиДокумента.Запись, Заголовок, РежимСообщений, , Ложь);
            Если НЕ ДействиеВыполнено Тогда
                Возврат ДействиеВыполнено;       
            КонецЕсли;    
        КонецЕсли;
                    
        ТекстВыполнено = Нстр("ru = 'Проведен документ ""%1%"".'"); 
		ТекстЖР = "БИТ.ОшибкаПроведенияДокумента";
        
    ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
        
        ТекстВыполнено = Нстр("ru = 'Отменено проведение документа ""%1%"".'"); 
		ТекстЖР = "БИТ.ОшибкаОтменыПроведенияДокумента";
				
    КонецЕсли; 
    
    // Попытка записи/ проведения/ отмены проведения.
    Попытка
			
        ТекущийОбъект.Записать(РежимЗаписи);
        
        ДействиеВыполнено = Истина;
        
        Если РежимыВывода.ВыводитьИнформацию Тогда
            ТекстВыполнено = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстВыполнено, ТекущийОбъект.Ссылка);
           ОбщегоНазначения.СообщитьПользователю(ТекстВыполнено);
        КонецЕсли; 
        
    Исключение
        
        ДействиеВыполнено = Ложь;
        
        Если РежимыВывода.ВыводитьОшибки Тогда
            ОбщегоНазначения.СообщитьПользователю(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
        КонецЕсли; 
        
        ЗаписьЖурналаРегистрации(ТекстЖР, УровеньЖурналаРегистрации.Информация, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
                    
    КонецПопытки;
	
	Возврат ДействиеВыполнено;
	
КонецФункции // ЗаписатьПровестиДокумент()

// Процедура выполняет запись элемента справочника.
// 
// Параметры:
//  ТекущийОбъект  - СправочникОбъект.
//  Заголовок      - Строка (По умолчанию = "").
//  РежимСообщений - Строка: "Нет","Все","Ошибки" (По умолчанию = "Все").
//  РежимЗагрузки  - Булево (По умолчанию = Ложь).
// 
// Возвращаемое значение:
//   Булево - действие выполнено.
// 
Функция ЗаписатьСправочник(ТекущийОбъект, Заголовок = "", РежимСообщений = "Все", РежимЗагрузки = Ложь) Экспорт

	ДействиеВыполнено  = Ложь;
	
	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	
	Попытка
		
		Если РежимЗагрузки Тогда
			
			ТекущийОбъект.ОбменДанными.Загрузка = Истина;
			ДействиеВыполнено				 	= Истина;
			
		Иначе
			
			ДействиеВыполнено = ТекущийОбъект.ПроверитьЗаполнение();
			
		КонецЕсли; 
		
		Если ДействиеВыполнено Тогда
			
			ТекущийОбъект.Записать();
			Если РежимыВывода.ВыводитьИнформацию Тогда
				ТекстСообщения = Нстр("ru = 'Записан справочник ""%1%"".'");
				ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ТекущийОбъект.Ссылка);
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);	
			КонецЕсли; 		
		
		КонецЕсли;
		 
	Исключение
		
		ДействиеВыполнено = Ложь;						
		
        Если РежимыВывода.ВыводитьОшибки Тогда
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
        КонецЕсли;
		
		ЗаписьЖурналаРегистрации("БИТ.ОшибкаЗаписиСправочника", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
        		
	КонецПопытки;
	
	Возврат ДействиеВыполнено;
	
КонецФункции // ЗаписатьСправочник()

// Процедура выполняет запись счета.
// 
// Параметры:
//  ТекущийОбъект  - ПланСчетовОбъект.
//  СинонимПС 	   - Строка, синоним плана счетов.
//  Заголовок      - Строка, по умолчанию "".
//  РежимСообщений - Строка: "Нет","Все","Ошибки"; по умолчанию "Все".
//  РежимЗагрузки  - Булево, (По умолчанию = Ложь).
// 
// Возвращаемое значение:
//   Булево - действие выполнено.
// 
Функция ЗаписатьСчет(ТекущийОбъект, СинонимПС, Заголовок = "", РежимСообщений = "Все", РежимЗагрузки = Ложь) Экспорт

	ДействиеВыполнено = Ложь;
	
	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	
	Попытка
		
		Если РежимЗагрузки Тогда
			ТекущийОбъект.ОбменДанными.Загрузка = Истина;
		КонецЕсли;
		
		ТекущийОбъект.Записать();
		ДействиеВыполнено = Истина;
		
		Если РежимыВывода.ВыводитьИнформацию Тогда
			ТекстСообщения = Нстр("ru = 'Записан счет ""%1%"". План счетов ""%2%"".'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ТекущийОбъект.Код, СинонимПС);
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		КонецЕсли;
		
	Исключение
		
		ДействиеВыполнено = Ложь;
		
		Если РежимыВывода.ВыводитьОшибки Тогда
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
        КонецЕсли; 
        
        ЗаписьЖурналаРегистрации("БИТ.ОшибкаЗаписиСчета", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
                    		
	КонецПопытки;
	
	Возврат ДействиеВыполнено;
	
КонецФункции // ЗаписатьСчет()

// Функция записывает задачу.
// 
// Параметры:
//  ЗадачаОбъект.
// 
// Возвращаемое значение:
//  флВыполнено - Булево.
// 
Функция ЗаписатьЗадачу(ЗадачаОбъект, РежимСообщений = "Ошибки") Экспорт
	
	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	
	флВыполнено = Ложь;
	
	Попытка
		
		ЗадачаОбъект.Записать();
		флВыполнено = Истина;
		
		Если РежимыВывода.ВыводитьИнформацию Тогда
            
            ТекстСообщения = Нстр("ru = 'Записана задача ""%1%"".'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
																						, ЗадачаОбъект.Наименование
																						, Строка(ОписаниеОшибки()));
			
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецЕсли; 
		
	Исключение
		
		Если РежимыВывода.ВыводитьОшибки Тогда
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
        КонецЕсли; 
        
        ЗаписьЖурналаРегистрации("БИТ.ОшибкаЗаписиЗадачи", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
                                                   		
	КонецПопытки;
	
	Возврат флВыполнено;
	
КонецФункции // ЗаписатьЗадачу()

// Функция записывает бизнес-процесс.
// 
// Параметры:
//  ПроцессОбъект - БизнесПроцесс.Объект.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ЗаписатьБизнесПроцесс(ПроцессОбъект, РежимСообщений = "Все") Экспорт
	
	флВыполнено = Ложь;
	
	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	
	Попытка
		
		ПроцессОбъект.Записать();
		флВыполнено = Истина;
		
		Если РежимыВывода.ВыводитьИнформацию Тогда
			
			ТекстСообщения = НСтр("ru = 'Записан бизнес процесс ""%1%"".'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, Строка(ПроцессОбъект));
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецЕсли; 
		
	Исключение
		
		флВыполнено = Ложь; 
		
		Если РежимыВывода.ВыводитьОшибки Тогда
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
        КонецЕсли; 
        
        ЗаписьЖурналаРегистрации("БИТ.ОшибкаЗаписиБизнесПроцесса", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
            
	КонецПопытки;
	
	Возврат флВыполнено;
	
КонецФункции // ЗаписатьБизнесПроцесс()

// Функция выполняет старт бизнес процесса.
// 
// Параметры:
//   ПроцессОбъект - БизнесПроцесс.Объект.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция СтартоватьБизнесПроцесс(ПроцессОбъект, РежимСообщений = "Все") Экспорт
	
	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	флВыполнено  = Ложь;
	
	Попытка
		
		ПроцессОбъект.Старт();
		флВыполнено = Истина;
		
		Если РежимыВывода.ВыводитьОшибки Тогда
			
			ТекстСообщения = НСтр("ru = 'Выполнен старт бизнес процесса ""%1%"".'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, Строка(ПроцессОбъект));
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецЕсли; 
		
	Исключение
		
		флВыполнено = Ложь;
		
        //Если РежимыВывода.ВыводитьОшибки Тогда
        //	
        //	ТекстСообщения = НСтр("ru = 'Не удалось стартовать бизнес процесс ""%1%"". Описание ошибки: %2%.'");
        //	ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
        //	                                                                              , Строка(ПроцессОбъект)
        //																				  , Строка(ОписаниеОшибки()));
        //	бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
        //	
        //КонецЕсли;
        
        Если РежимыВывода.ВыводитьОшибки Тогда
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
        КонецЕсли; 
        
        ЗаписьЖурналаРегистрации("БИТ.ОшибкаСтартаБизнесПроцесса", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
                  		
	КонецПопытки;
	
	Возврат флВыполнено;
	
КонецФункции // СтартоватьБизнесПроцесс()

// Процедура выполняет изменение пометки на удаление у объекта.
// 
// Параметры:
//  ТекущийОбъект     - Ссылка, Объект.
//     При передачи объекта необходимо в параметр "СтруктураПараметров" добавить ключ "ОбъектПолучен".
// 
//  ПометкаНаУдаление   - Булево, Режимы: Истина - пометить на удаление
//                                        Ложь   - снять пометку на удаление.
//  Заголовок           - Строка.
//  РежимСообщений      - Строка: "Нет","Все","Ошибки".
//  СтруктураПараметров - Структура, дополнительные параметры.
// 
// Возвращаемое значение:
//   ДействиеВыполнено - Булево.
// 
Функция ИзменитьПометкуНаУдалениеУОбъекта(ТекущийОбъект, ПометкаНаУдаление, Заголовок = "", 
                                          РежимСообщений = "Все", СтруктураПараметров = Неопределено) Экспорт

	РежимыВывода = ОпределитьРежимыВывода(РежимСообщений);
	
	Попытка
		
		ПометкаНаУдалениеУОбъекта = ТекущийОбъект.ПометкаУдаления;
		
		Если ПометкаНаУдалениеУОбъекта <> ПометкаНаУдаление Тогда
			
			УказанаСтруктураПараметров = ?(ТипЗнч(СтруктураПараметров) = Тип("Структура"), Истина, Ложь);
			
			Если УказанаСтруктураПараметров
				И СтруктураПараметров.Свойство("ОбъектПолучен") Тогда
				ПолученныйОбъект = ТекущийОбъект;
			Иначе
				ПолученныйОбъект = ТекущийОбъект.ПолучитьОбъект();
			КонецЕсли;
			
			Если УказанаСтруктураПараметров Тогда
				
				Если СтруктураПараметров.Свойство("ЭтоПометкаИзГрафикаПлатажей") Тогда
					ПолученныйОбъект.мПометкаИзГрафикаПлатажей = Истина;
				ИначеЕсли СтруктураПараметров.Свойство("ЭтоПометкаИзГрафикаНачислений") Тогда
					ПолученныйОбъект.мПометкаИзГрафикаНачислений = Истина;	
				КонецЕсли;
				
			КонецЕсли;
			
			ПолученныйОбъект.УстановитьПометкуУдаления(ПометкаНаУдаление);
			
			Если РежимыВывода.ВыводитьИнформацию Тогда
				
				Если ПометкаНаУдаление Тогда
					ТекстСообщения = "Объект «" + ТекущийОбъект.Ссылка + "» помечен на удаление.";
				Иначе
					ТекстСообщения = "У объекта «" + ТекущийОбъект.Ссылка + "» снята пометка на удаление.";
				КонецЕсли;
				
				СообщитьОбОшибке(ТекстСообщения, ,Заголовок, СтатусСообщения.Информация);
				
			КонецЕсли;
			
		КонецЕсли;
		
	Исключение
		
        Если РежимыВывода.ВыводитьОшибки Тогда
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
        КонецЕсли; 
        
        ЗаписьЖурналаРегистрации("БИТ.ОшибкаИзмененияПометкиУдаления", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
       		
	КонецПопытки;
	
    ДействиеВыполнено = ТекущийОбъект.ПометкаУдаления = ПометкаНаУдаление;
    
	Возврат ДействиеВыполнено;
    
КонецФункции // ИзменитьПометкуНаУдалениеУОбъекта()

// Функция читает набор записей регистра сведений бит_УстановленныеВизы согласно установленного отбора.
// 
// Параметры:
//   СтруктураОтбор - Структура.
//   ИмяРегистра    - Строка.
// 
// Возвращаемое значение:
//   НаборЗаписей - РегистрСведенийНаборЗаписей.бит_УстановленныеВизы.
// 
Функция ПрочитатьНаборЗаписейРегистраСведений(СтруктураОтбор,ИмяРегистра) Экспорт
	
	НаборЗаписей = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
	
	//БИТ Тртилек 11072013 добавим проверку на тип объекта. 
	//Если соответствующего типа нет - возвратим пустой набор
	Если ИмяРегистра = "бит_ДополнительныеАналитики" И СтруктураОтбор.Свойство("Объект") Тогда
		
		ДокументСсылка = СтруктураОтбор.Объект;
		
		ТипыОбъектаРегистра = Метаданные.РегистрыСведений[ИмяРегистра].Измерения.Объект.Тип;
		
		ТипДокумента = ТипЗнч(ДокументСсылка);
		
		Если НЕ ТипыОбъектаРегистра.СодержитТип(ТипДокумента) Тогда
			
			Возврат НаборЗаписей;
			
		КонецЕсли;
		
	КонецЕсли;
	///БИТ Тртилек
	
	Для каждого КлючИЗначение Из СтруктураОтбор Цикл
	
		ИмяПоля = КлючИЗначение.Ключ;
		ЗначениеПоля = КлючИЗначение.Значение;
		
		НаборЗаписей.Отбор[ИмяПоля].Использование = Истина;
		НаборЗаписей.Отбор[ИмяПоля].ВидСравнения = ВидСравнения.Равно;
        НаборЗаписей.Отбор[ИмяПоля].Значение     = ЗначениеПоля;		
		
	КонецЦикла; 
	
	НаборЗаписей.Прочитать();
	
	Возврат НаборЗаписей;
	
КонецФункции // ПрочитатьНаборВиз()

// Функция записывет набор записей регистра сведений.
// 
// Параметры:
//  НаборЗаписей   - РегистрСведенийНаборЗаписей.
//  РежимСообщений - Строка: "Нет", "Все", "Ошибки".
// 
// Возвращаемое значение:
//  Булево - действие выполнено.
// 
Функция ЗаписатьНаборЗаписейРегистра(НаборЗаписей,РежимСообщений="Все") Экспорт

	ДействиеВыполнено  = Ложь;
	
	Попытка
        НаборЗаписей.Записать();
	    ДействиеВыполнено = Истина;
    Исключение
        бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
            
        ЗаписьЖурналаРегистрации("БИТ.ОшибкаЗаписиНабораЗаписейРегистра", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
       		         
		ДействиеВыполнено = Ложь;
	КонецПопытки;

	Возврат ДействиеВыполнено;
	
КонецФункции // ЗаписатьНаборЗаписейРегистра()

// Функция удаляет набор записей регистра сведений.
// 
// Параметры:
//  НаборЗаписей   - РегистрСведенийНаборЗаписей, МенеджерЗаписи.
//  РежимСообщений - Строка: "Нет", "Все", "Ошибки".
// 
// Возвращаемое значение:
//  Булево - действие выполнено.
// 
Функция УдалитьНаборЗаписейРегистра(НаборЗаписей, РежимСообщений = "Все") Экспорт

	ДействиеВыполнено  = Ложь;
	ВрегРежимСообщений = ВРег(РежимСообщений);
	
	Попытка
        
        НаборЗаписей.Удалить();
	    ДействиеВыполнено = Истина;
        
    Исключение
        		
        бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
            
        ЗаписьЖурналаРегистрации("БИТ.ОшибкаУдаленияНабораЗаписейРегистра", УровеньЖурналаРегистрации.Ошибка, , ,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));   				
       		         
		ДействиеВыполнено = Ложь;
        
    КонецПопытки;

	Возврат ДействиеВыполнено;
	
КонецФункции // УдалитьНаборЗаписейРегистра()

#КонецОбласти

#Область ДополнительныеАналитики

// Функция получает значение дополнительной аналитики для Объекта.
// 
// Параметры:
//  ТекущийОбъект - ЛюбаяСсылка.
//  Аналитика     - ПланВидовХарактеристик.бит_ВидыДополнительныхАналитик.
// 
// Возвращаемое значение:
//  Массив.
// 
Функция ПолучитьЗначениеАналитики(ТекущийОбъект, Аналитика) Экспорт

    ЗначениеАналитики = Аналитика.ТипЗначения.ПривестиЗначение();	

    Запрос = Новый Запрос;
    Запрос.Текст =  "ВЫБРАТЬ РАЗРЕШЕННЫЕ
                 |	бит_ДополнительныеАналитики.ЗначениеАналитики
                 |ИЗ
                 |	РегистрСведений.бит_ДополнительныеАналитики КАК бит_ДополнительныеАналитики
                 |ГДЕ
                 |	бит_ДополнительныеАналитики.Объект = &Объект
                 |	И бит_ДополнительныеАналитики.Аналитика = &Аналитика";
                 
    Запрос.УстановитьПараметр("Объект",ТекущийОбъект);
    Запрос.УстановитьПараметр("Аналитика",Аналитика);

    Результат = Запрос.Выполнить();

    Выборка = Результат.Выбрать();

    Пока Выборка.Следующий() Цикл

        ЗначениеАналитики = Выборка.ЗначениеАналитики;

    КонецЦикла; 

    Возврат ЗначениеАналитики;
 
КонецФункции // ПолучитьЗначениеАналитики()

// Процедура проверяет принадлежность подчиненных справочников текущей организации.
// 
// Параметры:
//  Контейнер                - Объект,СтрокаТабличнойЧасти.
//  КонтейнерПроверочный     - Объект,СтрокаТабличнойЧасти.
//  ИмяРеквизита             - Строка.
//  ИмяПроверочногоРеквизита - Строка.
//  ИмяКонтрольногоЗначения  - Строка.
//  ИмяТипа                  - Строка.
//  НачалоСообщения          - Строка.
//  Заголовок                - Строка.
//  ТекстСообщения			 - Строка (Сформированнное сообщение).
// 
Процедура ПроверитьПринадлежностьАналитики(Контейнер
	                                       , КонтейнерПроверочный = Неопределено
										   , ИмяРеквизита
										   , ИмяПроверочногоРеквизита
										   , ИмяКонтрольногоЗначения
										   , ИмяТипа
										   , НачалоСообщения
										   , Заголовок
										   , ТекстСообщения = Неопределено) Экспорт

	СообщениеНеВозвращаетсяНаКлиент = ТекстСообщения = Неопределено;										   
	
	Если КонтейнерПроверочный = Неопределено Тогда 	
		КонтейнерПроверочный = Контейнер; 	
	КонецЕсли; 										   
										   
	Если ТипЗнч(Контейнер[ИмяРеквизита]) = Тип(ИмяТипа) 
		  И ЗначениеЗаполнено(Контейнер[ИмяРеквизита]) Тогда
		
		Если Контейнер[ИмяРеквизита][ИмяПроверочногоРеквизита] <> КонтейнерПроверочный[ИмяКонтрольногоЗначения] Тогда
			
			ТекстСообщения = НачалоСообщения 
								+ Нстр("ru = ' значение реквизита %1%: ""%2%"" не соответствовало значению реквизита %3%: ""%4%"" и было очищено!'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
															, ИмяРеквизита
															, Контейнер[ИмяРеквизита]
															, ИмяКонтрольногоЗначения
															, КонтейнерПроверочный[ИмяКонтрольногоЗначения]);
			Если СообщениеНеВозвращаетсяНаКлиент Тогда
			 	бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			КонецЕсли;
										
			Описание = Новый ОписаниеТипов(ИмяТипа);					
								
			Контейнер[ИмяРеквизита] = Описание.ПривестиЗначение();
						
		КонецЕсли; 
		
	КонецЕсли; 

КонецПроцедуры // ПроверитьПринадлежностьАналитики()

// Функция читает набор записей регистра сведений бит_ДополнительныеАналитики согласно установленного отбора. 
// 
// Параметры:
//  СтруктураОтбор - Структура. 
// 
// Возвращаемое значение:
//   НаборЗаписей - РегистрСведенийНаборЗаписей.бит_ДополнительныеАналитики. 
// 
Функция ПрочитатьНаборАналитики(СтруктураОтбор) Экспорт
	
	НаборЗаписей = ПрочитатьНаборЗаписейРегистраСведений(СтруктураОтбор,"бит_ДополнительныеАналитики");
	
	Возврат НаборЗаписей;
	
КонецФункции // ПрочитатьНаборАналитики()
 
// Процедура добавляет запись набор записей бит_ДополнительныеАналитики.
// 
// Параметры:
//  НаборЗаписей      - РегистрСведенийНаборЗаписей.бит_ДополнительныеАналитики.
//  Объект            - ДокументСсылка.
//  Аналитика         - Строка,ПланВидовХарактеристикСсылка.бит_ВидыДополнительныхАналитик.
//  ЗначениеАналитики - ПроизволныйТип.
// 
Процедура ДобавитьЗаписьАналитик(НаборЗаписей, Объект, Аналитика, ЗначениеАналитики) Экспорт
	
	Если ТипЗнч(Аналитика) = Тип("Строка") Тогда
		ТекущаяАналитика = ПланыВидовХарактеристик.бит_ВидыДополнительныхАналитик[Аналитика];
	Иначе
		ТекущаяАналитика = Аналитика;
	КонецЕсли; 
	
	Отказ = Ложь;
	
	// Исключаем дублирование.
	Для каждого СтрокаТаблицы Из НаборЗаписей Цикл
		Если СтрокаТаблицы.Аналитика = ТекущаяАналитика Тогда
			Отказ = Истина;
			Прервать;
		КонецЕсли; 
	КонецЦикла; 
	
	Если Отказ Тогда
		Возврат;	
	КонецЕсли; 
	
	Запись = НаборЗаписей.Добавить();
	Запись.Объект            = Объект;
	Запись.Аналитика         = ТекущаяАналитика;
	Запись.ЗначениеАналитики = ЗначениеАналитики;

КонецПроцедуры

//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-05-26 (#4205)
// Функция добавляет значение дополнительной аналитики для Объекта.
// 
// Параметры:
//  ТекущийОбъект - ЛюбаяСсылка.
//  Аналитика     - ПланВидовХарактеристик.бит_ВидыДополнительныхАналитик.
//  ЗначениеАналитики - ПроизволныйТип.
//
Процедура ДобавитьЗначениеАналитики(ТекущийОбъект, Аналитика, ЗначениеАналитики, СоздаватьАналитику = Истина) Экспорт

	Запись = РегистрыСведений.бит_ДополнительныеАналитики.СоздатьМенеджерЗаписи();
	Запись.Объект		= ТекущийОбъект;
	Запись.Аналитика	= Аналитика;
	
	Запись.Прочитать();
	
	Если Запись.Выбран() 
		И Запись.ЗначениеАналитики = ЗначениеАналитики 
		ИЛИ НЕ Запись.Выбран()
			И НЕ СоздаватьАналитику Тогда 
		Возврат;
	КонецЕсли;
			
	Запись.Объект				= ТекущийОбъект;
	Запись.Аналитика 			= Аналитика;
	Запись.ЗначениеАналитики 	= ЗначениеАналитики;
	
	Попытка
	
		Запись.Записать();		
	
	Исключение
		
		пТекстОшибки = НСтр("ru = 'Не удалось добавить запись в РС для объекта %1 по аналитике %2 со значением %3 по причине: 
							|%4'");
		пТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(пТекстОшибки,
																				ТекущийОбъект,
																				Аналитика,
																			  	ЗначениеАналитики,
																			  	ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

		ЗаписьЖурналаРегистрации(НСтр("ru = 'БИТ.ОшибкаЗаписиНабораЗаписейРегистра'"), УровеньЖурналаРегистрации.Ошибка, Метаданные.РегистрыСведений.бит_ДополнительныеАналитики, ТекущийОбъект, пТекстОшибки);
		
	КонецПопытки;
 
КонецПроцедуры // ДобавитьЗначениеАналитики()
//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-05-26 (#4205)

#КонецОбласти

#Область РасчетыНдс

// Процедура расчитывает суммму НДС в строке табличной части.
// 
// Параметры:
//  ТекущаяСтрока - СтрокаТабличнойЧастиБДДС.
// 
Процедура РассчитатьСуммуНДСВСтроке(ТекущаяСтрока) Экспорт

	Если ТекущаяСтрока = Неопределено Тогда		
		Возврат;		
	КонецЕсли;

	ТекущаяСтрока.НДС = бит_БухгалтерияКлиентСервер.РассчитатьСуммуНДС(ТекущаяСтрока.Сумма
	                                                        , Истина
															, Истина
															, бит_БухгалтерияСервер.ПолучитьСтавкуНДС(ТекущаяСтрока.СтавкаНДС));
	
КонецПроцедуры // бит_РассчитатьСуммуНДС()

#КонецОбласти

#Область ПроцедурыИФункцииЗаполненияРеквизитовВФорме

// Процедура предназначена для заполнения общих реквизитов документов,
// вызывается в обработчиках событий "ПриОткрытии" в модулех форм всех документов.
// 
// Параметры:
//  ДокументОбъект            - Объект редактируемого документа.
//  ТекПользователь           - Ссылка на справочник, определяет текущего пользователя.
//  ПараметрОбъектКопирования - Указывает что документ создан копированием.
//  ВидСтатьи        		  - Строка, вид статьи оборотов, по умолчанию "".
//                               принимаемые значения: ПоступлениеБДДС/РасходованиеБДДС/ПоступлениеБДР/РасходованиеБДР.
//  ЗаполнятьВидОперации	  - Булево (По умолчанию = Истина).
// 
Процедура ЗаполнитьШапкуДокумента(ДокументОбъект, ТекПользователь, ПараметрОбъектКопирования = Неопределено, ВидСтатьи = "", ЗаполнятьВидОперации = Истина) Экспорт

	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если ЗаполнятьВидОперации И бит_РаботаСМетаданными.ЕстьРеквизит("ВидОперации", МетаданныеДокумента) 
		 И НЕ ЗначениеЗаполнено(ДокументОбъект.ВидОперации) Тогда
		ДокументОбъект.ВидОперации = Перечисления[ДокументОбъект.ВидОперации.Метаданные().Имя][0];
	КонецЕсли;	
	
    Если бит_РаботаСМетаданными.ЕстьРеквизит("Организация", МетаданныеДокумента) 
	  И (НЕ ЗначениеЗаполнено(ДокументОбъект.Организация)) Тогда
		ДокументОбъект.Организация = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("ОсновнаяОрганизация");
	КонецЕсли;
	
	Если бит_РаботаСМетаданными.ЕстьРеквизит("Исполнитель", МетаданныеДокумента) Тогда
        ДокументОбъект.Исполнитель = ТекПользователь;
    КонецЕсли;
	
    Если бит_РаботаСМетаданными.ЕстьРеквизит("Ответственный", МетаданныеДокумента) Тогда
        ДокументОбъект.Ответственный = бит_УправлениеПользователямиСервер.ЗначениеПоУмолчаниюТиповой("ОсновнойОтветственный", ТекПользователь);
    КонецЕсли;
    
	Если бит_РаботаСМетаданными.ЕстьРеквизит("Сценарий", МетаданныеДокумента) 
		 И МетаданныеДокумента.Имя <> "бит_АктуализацияБюджета" Тогда
		
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.Сценарий = ПараметрОбъектКопирования.Сценарий;
        Иначе
			Если НЕ ЗначениеЗаполнено(ДокументОбъект.Сценарий) Тогда
				ДокументОбъект.Сценарий = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновнойСценарий", ТекПользователь);
            КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если МетаданныеДокумента.Имя = "бит_АктуализацияБюджета" Тогда
		
		// Для актуализации сценарий по-умолчанию подставляем в сценарий эталон.
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.СценарийЭталон = ПараметрОбъектКопирования.СценарийЭталон;
		Иначе
			Если НЕ ЗначениеЗаполнено(ДокументОбъект.СценарийЭталон) Тогда
				ДокументОбъект.СценарийЭталон = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновнойСценарий", ТекПользователь);
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли; 
	
	Если бит_РаботаСМетаданными.ЕстьРеквизит("ЦФО", МетаданныеДокумента) Тогда
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.ЦФО = ПараметрОбъектКопирования.ЦФО;
        Иначе
			Если НЕ ЗначениеЗаполнено(ДокументОбъект.ЦФО) Тогда
				ДокументОбъект.ЦФО = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновноеЦФО", ТекПользователь); 
            КонецЕсли;
		КонецЕсли;;
    КонецЕсли;
    
    Если бит_РаботаСМетаданными.ЕстьРеквизит("Проект", МетаданныеДокумента) Тогда
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.Проект = ПараметрОбъектКопирования.Проект;
        Иначе
            Если НЕ ЗначениеЗаполнено(ДокументОбъект.Проект) Тогда
                ДокументОбъект.Проект = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновнойПроект", ТекПользователь);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

    Если бит_РаботаСМетаданными.ЕстьРеквизит("НастройкаФормы", МетаданныеДокумента) Тогда
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.НастройкаФормы = ПараметрОбъектКопирования.НастройкаФормы;
        Иначе
			Если НЕ ЗначениеЗаполнено(ДокументОбъект.НастройкаФормы) Тогда
				НастройкаФормыПоУмолчанию  = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновнаяНастройкаФормыВвода", ТекПользователь);
				Если ТипЗнч(НастройкаФормыПоУмолчанию) = Тип("СправочникСсылка.бит_НастройкиФормВводаБюджета") И НЕ НастройкаФормыПоУмолчанию.ЭтоГруппа Тогда
					
					ДокументОбъект.НастройкаФормы = НастройкаФормыПоУмолчанию; 
					
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	
    Если бит_РаботаСМетаданными.ЕстьРеквизит("СтатьяОборотов", МетаданныеДокумента) Тогда
        
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.СтатьяОборотов = ПараметрОбъектКопирования.СтатьяОборотов;
        Иначе
            Если Не ВидСтатьи = "" И НЕ ЗначениеЗаполнено(ДокументОбъект.СтатьяОборотов) Тогда
                ДокументОбъект.СтатьяОборотов = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновнаяСтатья" + ВидСтатьи, ТекПользователь);
			КонецЕсли;
        КонецЕсли;
        
	КонецЕсли;
    
    Если бит_РаботаСМетаданными.ЕстьРеквизит("НоменклатурнаяГруппа", МетаданныеДокумента) Тогда
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.НоменклатурнаяГруппа = ПараметрОбъектКопирования.НоменклатурнаяГруппа;
        Иначе
            Если НЕ ЗначениеЗаполнено(ДокументОбъект.НоменклатурнаяГруппа) Тогда
                ДокументОбъект.НоменклатурнаяГруппа = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновнаяНоменклатурнаяГруппа", ТекПользователь);
			КонецЕсли;
		КонецЕсли;;
	КонецЕсли;
	
	Если бит_РаботаСМетаданными.ЕстьРеквизит("ЕдиницаИзмеренияСумм", МетаданныеДокумента) Тогда
		Если ПараметрОбъектКопирования <> Неопределено Тогда
			ДокументОбъект.ЕдиницаИзмеренияСумм = ПараметрОбъектКопирования.ЕдиницаИзмеренияСумм;
        Иначе
            Если Не ЗначениеЗаполнено(ДокументОбъект.ЕдиницаИзмеренияСумм) Тогда
                ДокументОбъект.ЕдиницаИзмеренияСумм = Перечисления.бит_ЕдиницыИзмеренияСумм.Единицы;
            КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если бит_РаботаСМетаданными.ЕстьРеквизит("ОтражатьРСБУ", МетаданныеДокумента) Тогда
	
		Если ПараметрОбъектКопирования <> Неопределено Тогда
		     ДокументОбъект.ОтражатьРСБУ = ПараметрОбъектКопирования.ОтражатьРСБУ;
		Иначе	
		     ДокументОбъект.ОтражатьРСБУ = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОтражатьРСБУ");
		КонецЕсли; 
	
	КонецЕсли; 
	
	Если бит_РаботаСМетаданными.ЕстьРеквизит("ОтражатьМСФО", МетаданныеДокумента) Тогда
	
		Если ПараметрОбъектКопирования <> Неопределено Тогда
		     ДокументОбъект.ОтражатьМСФО = ПараметрОбъектКопирования.ОтражатьМСФО;
		Иначе	
		     ДокументОбъект.ОтражатьМСФО = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОтражатьМСФО");
		КонецЕсли; 
	
	КонецЕсли;	
	
КонецПроцедуры // ЗаполнитьШапкуДокумента()

// Процедура заполняет аналитику в шапке документа.
// Аналитика: ЦФО, СтатьяОборотов, Проект.
// 
// Параметры:
//  ДокументОбъект - ДокументОбъект.
//  ТаблицаДанных  - ТабличнаяЧасть, ТаблицаЗначений.
//  Отказ 		   - Булево.
//  ПрефиксИмени   - Строка. По умолчанию "".
// 
Процедура ЗаполнитьАналитикуВШапкеДокумента(ДокументОбъект, ТаблицаДанных, Отказ, ПрефиксИмени = "") Экспорт
	
	Если Отказ
		// Или Автоматическое заполнение отключено.
		Или Константы.бит_ОтключитьАвтоматическоеЗаполнениеАналитикШапки.Получить()
		// Или установлено свойство "НеЗаполнятьАналитикуШапки".
		Или ДокументОбъект.ДополнительныеСвойства.Свойство("НеЗаполнятьАналитикуШапки") Тогда
		Возврат;
	КонецЕсли;
		
	// Проверим заполненность аналитики.
	ЦФОЗаполнено 			= ЗначениеЗаполнено(ДокументОбъект.ЦФО);
	СтатьяОборотовЗаполнена = ЗначениеЗаполнено(ДокументОбъект.СтатьяОборотов);
	ЕстьРеквизитПроект      = ДокументОбъект.Метаданные().Реквизиты.Найти("Проект") <> Неопределено;
	ПроектЗаполнен 	        = ?(ЕстьРеквизитПроект, ЗначениеЗаполнено(ДокументОбъект.Проект), Истина);
	
	//+Сундукова 12.04.16
	Если ТипЗнч(ДокументОбъект) = тип("ДокументОбъект.бит_ФормаВводаБюджета") тогда
		ЦФОЗаполнено 			= ложь;
		Бит_БК_ЦФОЗаполнено		= ложь;
		СтатьяОборотовЗаполнена = ложь;
		ПроектЗаполнен 	        = ложь;
	иначе
		Бит_БК_ЦФОЗаполнено		= Истина;
	конецЕсли;
	//-Сундукова 12.04.16
	
	ТекТаблица              = ТаблицаДанных.Выгрузить();
	Если ЕстьРеквизитПроект Тогда
		ЕстьРеквизитПроект = НЕ ТекТаблица.Колонки.Найти("Проект" + ПрефиксИмени) = Неопределено;
	КонецЕсли; 
	
	Если (ЦФОЗаполнено И СтатьяОборотовЗаполнена И ПроектЗаполнен) Или ТекТаблица.Количество() = 0 Тогда
		// Заполнять нечего.
		Возврат;
	КонецЕсли;      
	
	// Заполним не заполненную аналитику.

	// ЦФО.
	Если Не ЦФОЗаполнено Тогда
		
		МассивЦФО = ТекТаблица.ВыгрузитьКолонку("ЦФО" + ПрефиксИмени);
		бит_РаботаСКоллекциями.УдалитьПовторяющиесяЭлементыМассива(МассивЦФО);
		
		Если МассивЦФО.Количество() = 1 Тогда
			ДокументОбъект.ЦФО = МассивЦФО[0];
		КонецЕсли;
		
	КонецЕсли;
	
	//+Сундукова 12.04.16
	// Бит_БК_ЦФО
	Если Не Бит_БК_ЦФОЗаполнено Тогда
		
		МассивЦФО = ТаблицаДанных.ВыгрузитьКолонку("ЦФО" + ПрефиксИмени);
		бит_РаботаСКоллекциями.УдалитьПовторяющиесяЭлементыМассива(МассивЦФО);
		
		Если МассивЦФО.Количество() = 1 Тогда
			ДокументОбъект.бит_БК_ЦФО = МассивЦФО[0];
		КонецЕсли;
		
	КонецЕсли;
	//-Сундукова 12.04.16	
	
	// Статья оборотов.
	Если Не СтатьяОборотовЗаполнена Тогда
		
		МассивСтатейОборотов = ТекТаблица.ВыгрузитьКолонку("СтатьяОборотов" + ПрефиксИмени);
		бит_РаботаСКоллекциями.УдалитьПовторяющиесяЭлементыМассива(МассивСтатейОборотов);
		
		Если МассивСтатейОборотов.Количество() = 1 Тогда
			ДокументОбъект.СтатьяОборотов = МассивСтатейОборотов[0];
		КонецЕсли;
		
	КонецЕсли;
	
	// Проект.
	Если ЕстьРеквизитПроект И Не ПроектЗаполнен Тогда
		
		МассивПроектов = ТекТаблица.ВыгрузитьКолонку("Проект" + ПрефиксИмени);
		бит_РаботаСКоллекциями.УдалитьПовторяющиесяЭлементыМассива(МассивПроектов);
		
		Если МассивПроектов.Количество() = 1 Тогда
			ДокументОбъект.Проект = МассивПроектов[0];
		КонецЕсли;
			
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьАналитикуВШапкеДокумента()

#КонецОбласти

#Область ЗаполнениеДокументов

// Процедура предназначена для заполнения общих реквизитов документов по документу основанию,
// 	вызывается в обработчиках событий "ОбработкаЗаполнения" в модулях документов.
// 
// Параметры:
//  ДокументОбъект    - Объект редактируемого документа.
//  ДокументОснование - Объект документа основания.
// 
Процедура ЗаполнитьШапкуДокументаПоОснованию(ДокументОбъект, ДокументОснование) Экспорт

	МетаданныеДокумента          = ДокументОбъект.Метаданные();
	МетаданныеДокументаОснования = ДокументОснование.Метаданные();

	// Организация.
	Если МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("Организация") <> Неопределено Тогда
		ДокументОбъект.Организация = ДокументОснование.Организация;
	КонецЕсли;

	// Подразделение.
	Если МетаданныеДокумента.Реквизиты.Найти("Подразделение") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("Подразделение") <> Неопределено Тогда
		ДокументОбъект.Подразделение = ДокументОснование.Подразделение;
	КонецЕсли;
	Если МетаданныеДокумента.Реквизиты.Найти("ПодразделениеОрганизации") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("ПодразделениеОрганизации") <> Неопределено Тогда
		ДокументОбъект.ПодразделениеОрганизации = ДокументОснование.ПодразделениеОрганизации;
	КонецЕсли;

	// Склад.
	Если МетаданныеДокумента.Реквизиты.Найти("Склад") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("Склад") <> Неопределено Тогда
		ДокументОбъект.Склад = ДокументОснование.Склад;
	КонецЕсли;
	
	Если МетаданныеДокумента.Реквизиты.Найти("Склад") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("СкладОрдер") <> Неопределено Тогда
		ДокументОбъект.Склад = ?(ТипЗнч(ДокументОснование.СкладОрдер) = Тип("СправочникСсылка.Склады"), ДокументОснование.СкладОрдер, Неопределено);
	КонецЕсли;
	
	Если МетаданныеДокумента.Реквизиты.Найти("Склад") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("СкладГруппа") <> Неопределено Тогда
		ДокументОбъект.Склад = ?(ТипЗнч(ДокументОснование.СкладГруппа) = Тип("СправочникСсылка.Склады"), ДокументОснование.СкладГруппа, Неопределено);
	КонецЕсли;
	Если МетаданныеДокумента.Реквизиты.Найти("СкладОрдер") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("СкладОрдер") <> Неопределено Тогда
		ДокументОбъект.СкладОрдер = ДокументОснование.СкладОрдер;
	КонецЕсли;
	Если МетаданныеДокумента.Реквизиты.Найти("СкладОрдер") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("Склад") <> Неопределено Тогда
		ДокументОбъект.СкладОрдер = ДокументОснование.Склад;
	КонецЕсли;
	Если МетаданныеДокумента.Реквизиты.Найти("СкладОрдер") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("СкладГруппа") <> Неопределено Тогда
		ДокументОбъект.СкладОрдер = ?(ТипЗнч(ДокументОснование.СкладГруппа) = Тип("СправочникСсылка.Склады"), ДокументОснование.СкладГруппа, Неопределено);
	КонецЕсли;

	// Контрагент.
	Если МетаданныеДокумента.Реквизиты.Найти("Контрагент") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("Контрагент") <> Неопределено Тогда
		ДокументОбъект.Контрагент = ДокументОснование.Контрагент;
	КонецЕсли;

	Если МетаданныеДокумента.Реквизиты.Найти("Грузоотправитель") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("Грузоотправитель") <> Неопределено Тогда
		ДокументОбъект.Грузоотправитель = ДокументОснование.Грузоотправитель;
	КонецЕсли;
	Если МетаданныеДокумента.Реквизиты.Найти("Грузополучатель") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("Грузополучатель") <> Неопределено Тогда
		ДокументОбъект.Грузополучатель = ДокументОснование.Грузополучатель;
	КонецЕсли;
	
	// ДоговорКонтрагента.
	Если МетаданныеДокумента.Реквизиты.Найти("ДоговорКонтрагента") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("ДоговорКонтрагента") <> Неопределено 
	   И (МетаданныеДокумента.Реквизиты.Найти("Организация") = Неопределено 
	      ИЛИ ДокументОбъект.Организация = ДокументОснование.ДоговорКонтрагента.Организация) Тогда

		ДокументОбъект.ДоговорКонтрагента = ДокументОснование.ДоговорКонтрагента;

		// КурсВзаиморасчетов.
		Если МетаданныеДокумента.Реквизиты.Найти("КурсВзаиморасчетов") <> Неопределено Тогда
			СтруктураКурсаВзаиморасчетов = бит_КурсыВалют.ПолучитьКурсВалюты(ДокументОбъект.ДоговорКонтрагента.ВалютаВзаиморасчетов, ТекущаяДата());
			ДокументОбъект.КурсВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Курс;

			// КратностьВзаиморасчетов.
			Если МетаданныеДокумента.Реквизиты.Найти("КратностьВзаиморасчетов") <> Неопределено Тогда
				ДокументОбъект.КратностьВзаиморасчетов = СтруктураКурсаВзаиморасчетов.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// Касса
    ИмяСпрКассы = "Кассы";
	Если МетаданныеДокумента.Реквизиты.Найти("Касса") <> Неопределено Тогда

		// Если в документе-основании есть структурная единица(или касса), то берем ее оттуда.
		Если МетаданныеДокументаОснования.Реквизиты.Найти("СтруктурнаяЕдиница") <> Неопределено Тогда
			Если ЗначениеЗаполнено(ДокументОснование.СтруктурнаяЕдиница) 
			   И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка." + ИмяСпрКассы) Тогда
				ДокументОбъект.Касса = ДокументОснование.СтруктурнаяЕдиница;
			КонецЕсли;
		ИначеЕсли МетаданныеДокументаОснования.Реквизиты.Найти("Касса") <> Неопределено Тогда
			Если ЗначениеЗаполнено(ДокументОснование.Касса) Тогда
				ДокументОбъект.Касса = ДокументОснование.Касса;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// Банковский счет 
	Если МетаданныеДокумента.Реквизиты.Найти("БанковскийСчет") <> Неопределено Тогда

		// Если в документе-основании есть структурная единица(или касса), то берем ее оттуда.
		Если МетаданныеДокументаОснования.Реквизиты.Найти("СтруктурнаяЕдиница") <> Неопределено Тогда
			Если ЗначениеЗаполнено(ДокументОснование.СтруктурнаяЕдиница) 
			   И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.БанковскиеСчета") Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.СтруктурнаяЕдиница;
			КонецЕсли;
		ИначеЕсли МетаданныеДокументаОснования.Реквизиты.Найти("БанковскийСчет") <> Неопределено Тогда
			Если ЗначениеЗаполнено(ДокументОснование.БанковскийСчет) Тогда
				ДокументОбъект.БанковскийСчет = ДокументОснование.БанковскийСчет;
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	// Банковский счет организации
	Если МетаданныеДокумента.Реквизиты.Найти("БанковскийСчетОрганизации") <> Неопределено Тогда
		Если НЕ ЗначениеЗаполнено(ДокументОбъект.БанковскийСчетОрганизации) Тогда
		   Если МетаданныеДокументаОснования.Реквизиты.Найти("БанковскийСчет") <> Неопределено Тогда
				Если ЗначениеЗаполнено(ДокументОснование.БанковскийСчет)Тогда
					ДокументОбъект.БанковскийСчетОрганизации = ДокументОснование.БанковскийСчет;
				КонецЕсли;
	       ИначеЕсли МетаданныеДокументаОснования.Реквизиты.Найти("СтруктурнаяЕдиница") <> Неопределено Тогда
				Если ЗначениеЗаполнено(ДокументОснование.СтруктурнаяЕдиница)
				  И ТипЗнч(ДокументОснование.СтруктурнаяЕдиница) = Тип("СправочникСсылка.БанковскиеСчета") Тогда
					ДокументОбъект.БанковскийСчетОрганизации = ДокументОснование.СтруктурнаяЕдиница;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;
	
	// Структурная единица
	Если МетаданныеДокумента.Реквизиты.Найти("СтруктурнаяЕдиница") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("СтруктурнаяЕдиница") <> Неопределено Тогда

		Если НЕ ЗначениеЗаполнено(ДокументОбъект.СтруктурнаяЕдиница)
		  И ЗначениеЗаполнено(ДокументОснование.СтруктурнаяЕдиница)Тогда
			ДокументОбъект.СтруктурнаяЕдиница = ДокументОснование.СтруктурнаяЕдиница;
		КонецЕсли;
	КонецЕсли;
	
	// ВалютаДокумента.
	Если МетаданныеДокумента.Реквизиты.Найти("ВалютаДокумента") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("ВалютаДокумента") <> Неопределено Тогда

		// Если есть касса или банковский счет, то валюта должна браться только оттуда.
		Если МетаданныеДокумента.Реквизиты.Найти("Касса") <> Неопределено Тогда
			Если ЗначениеЗаполнено(ДокументОбъект.Касса) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.Касса.ВалютаДенежныхСредств;
			КонецЕсли;
		ИначеЕсли МетаданныеДокумента.Реквизиты.Найти("БанковскийСчет") <> Неопределено Тогда
			Если ЗначениеЗаполнено(ДокументОбъект.БанковскийСчет) Тогда
				ДокументОбъект.ВалютаДокумента = ДокументОбъект.БанковскийСчет.ВалютаДенежныхСредств;
		    КонецЕсли;
		Иначе
			ДокументОбъект.ВалютаДокумента = ДокументОснование.ВалютаДокумента;
		КонецЕсли;

		// КурсДокумента.
		Если МетаданныеДокумента.Реквизиты.Найти("КурсДокумента") <> Неопределено Тогда
			СтруктураКурсаДокумента = бит_КурсыВалют.ПолучитьКурсВалюты(ДокументОбъект.ВалютаДокумента, ТекущаяДата());
			ДокументОбъект.КурсДокумента = СтруктураКурсаДокумента.Курс;

			// КратностьДокумента.
			Если МетаданныеДокумента.Реквизиты.Найти("КратностьДокумента") <> Неопределено Тогда
				ДокументОбъект.КратностьДокумента = СтруктураКурсаДокумента.Кратность;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	// ТипЦен.
	Если МетаданныеДокумента.Реквизиты.Найти("ТипЦен") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("ТипЦен") <> Неопределено Тогда
		ДокументОбъект.ТипЦен = ДокументОснование.ТипЦен;
	КонецЕсли;

	// Дисконтная карта.
	Если МетаданныеДокумента.Реквизиты.Найти("ДисконтнаяКарта") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("ДисконтнаяКарта") <> Неопределено Тогда
		ДокументОбъект.ДисконтнаяКарта = ДокументОснование.ДисконтнаяКарта;
	КонецЕсли;

	// УчитыватьНДС.
	Если МетаданныеДокумента.Реквизиты.Найти("УчитыватьНДС") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("УчитыватьНДС") <> Неопределено Тогда
		ДокументОбъект.УчитыватьНДС = ДокументОснование.УчитыватьНДС;
	КонецЕсли;

	// СуммаВключаетНДС.
	Если МетаданныеДокумента.Реквизиты.Найти("СуммаВключаетНДС") <> Неопределено
	   И МетаданныеДокументаОснования.Реквизиты.Найти("СуммаВключаетНДС") <> Неопределено Тогда
		ДокументОбъект.СуммаВключаетНДС = ДокументОснование.СуммаВключаетНДС;
	КонецЕсли;

	// Заполнение признаков отражения в учете: из настроек пользователя по умолчанию.
	Если МетаданныеДокумента.Реквизиты.Найти("ОтражатьВУправленческомУчете") <> Неопределено Тогда
		ДокументОбъект.ОтражатьВУправленческомУчете = бит_УправлениеПользователямиСервер.ЗначениеПоУмолчаниюТиповой("ОтражатьДокументыВУправленческомУчете");
	КонецЕсли;
	
	Если МетаданныеДокумента.Реквизиты.Найти("ИспользоватьПлановуюСебестоимость") <> Неопределено Тогда
		Если МетаданныеДокументаОснования.Реквизиты.Найти("ИспользоватьПлановуюСебестоимость") <> Неопределено Тогда
			ДокументОбъект.ИспользоватьПлановуюСебестоимость = ДокументОснование.ИспользоватьПлановуюСебестоимость;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ЗаполнитьШапкуДокументаПоОснованию()

// Дополняет типовую процедуру модуля объекта ОбработкаПроверкиЗаполнения
// , проверяет правильность заполнения шапки документа.
// Если какой-то из реквизитов шапки заполнен не корректно, то выставляется флаг отказа в проведении.
// 
// Параметры: 
//  ДокументОбъект          - объект проводимого документа. 
//  ПроверяемыеРеквизиты 	- массив, содержащий имена полей, которые собственно и надо проверить.
//  Отказ                   - флаг отказа в проведении.
// 
Процедура ПроверитьЗаполнениеШапкиДокумента(ДокументОбъект, ПроверяемыеРеквизиты, Отказ) Экспорт

	Если ТипЗнч(ПроверяемыеРеквизиты) = Тип("Структура") Тогда
		ЕстьОрганизация		   = ПроверяемыеРеквизиты.Свойство("Организация");
		ЕстьДоговорКонтрагента = ПроверяемыеРеквизиты.Свойство("ДоговорКонтрагента");
	Иначе	
		ЕстьОрганизация 	   = ?(ПроверяемыеРеквизиты.Найти("Организация")=Неопределено, Ложь, Истина);
		ЕстьДоговорКонтрагента = ?(ПроверяемыеРеквизиты.Найти("ДоговорКонтрагента")=Неопределено, Ложь, Истина);
	КонецЕсли;
	
	Если ЕстьОрганизация  
		И ЕстьДоговорКонтрагента Тогда

		// Если в документе есть организация и договор - провести проверку на соответствие.
		// Организация в документе должна совпадать с организацией, указанной в договоре взаиморасчетов.
		ОрганизацияДок 		  = ДокументОбъект.Организация;
		ДоговорКонтрагентаДок = ДокументОбъект.ДоговорКонтрагента;
		Если ТипЗнч(ДоговорКонтрагентаДок) = Тип("СправочникСсылка.ДоговорыКонтрагентов") Тогда
			ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(ОрганизацияДок, ДоговорКонтрагентаДок, ДоговорКонтрагентаДок.Организация, Отказ, "");
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

#КонецОбласти

#Область ПроцедурыРаботыСоСчетамиИСубконто

// Процедура снимает/устанавливает активность проводок документа для регистра бухгалтерии.
// 
// Параметры:
//  Документ               - ДокументСсылка.
//  ИмяРегистраБухгалтерии - Строка, имя регистра бухгалтеиии.
// 
Процедура ПереключитьАктивностьПроводокДокументаДляРегистраБухгалтерии(Документ, ИмяРегистраБухгалтерии) Экспорт
	
	Если Документ.ПометкаУдаления Тогда
		Возврат;
	КонецЕсли;

	ПроводкиДокумента = РегистрыБухгалтерии[ИмяРегистраБухгалтерии].СоздатьНаборЗаписей();
	ПроводкиДокумента.Отбор.Регистратор.Установить(Документ);
	ПроводкиДокумента.Прочитать();

	КоличествоПроводок = ПроводкиДокумента.Количество();
	Если НЕ (КоличествоПроводок = 0) Тогда
		
		// Определяем текущую активность проводок по первой проводке.
		ТекущаяАктивностьПроводок = ПроводкиДокумента[0].Активность;

		// Инвертируем текущую активность проводок.
		ПроводкиДокумента.УстановитьАктивность(НЕ ТекущаяАктивностьПроводок);
		ПроводкиДокумента.Записать();

	КонецЕсли;
		
КонецПроцедуры // ПереключитьАктивностьПроводокДокументаДляРегистраБухгалтерии()

#КонецОбласти

#Область ПроцедурыИФункцииОпределенияЗначенийХарактерныхДляРазныхРешений

// Функция получает имя справочника с физическими лицами.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаФизическихЛиц() Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаФизическихЛиц();
	
КонецФункции

// Функция получает имя типа ЦФО в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяТипаЦФО() Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяТипаЦФО();
	
КонецФункции

// Функция получает имя справочника ЦФО в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаЦФО() Экспорт
		
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаЦФО();
	
КонецФункции

// Функция получает имя справочника Виды ЦФО в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаВидыЦФО() Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаВидыЦФО();
	
КонецФункции

// Функция получает имя справочника Проекты в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаПроекты() Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаПроекты();
	
КонецФункции

// Функция получает имя реквизита Проект в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяРеквизитаПроект() Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяРеквизитаПроект();
	
КонецФункции

// Функция получает имя типа справочника Проекты в зависимости от текущего решения.
// 
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьИмяТипаПроекты() Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяТипаПроекты();
	
КонецФункции

// Функция получает имя типа Сценарии бюджетирования в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяТипаСценарииБюджетирования() Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяТипаСценарииБюджетирования();
	
КонецФункции

// Функция получает имя справочника Сценарии бюджетирования в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаСценарииБюджетирования() Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаСценарииБюджетирования();
	
КонецФункции

// Возвращает имя табличной части справочника ГруппыПользователей в зависимости от текущего решения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ИмяТабЧастиГруппыПользователей() Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяТабЧастиГруппыПользователей();
	
КонецФункции

// Функция получает имя типового справочника сохраненных настроек.
//    
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьИмяСправочникаСохраненныхНастроек() Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаСохраненныхНастроек();
	
КонецФункции

// Функция получает имя справочника единиц измерения.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаЕдиницыИзмерения() Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаЕдиницыИзмерения();
	
КонецФункции

// Функция получает имя типового справочника банковских счетов.
//    
// Возвращаемое значение:
//   Строка
// 
Функция ПолучитьИмяСправочникаБанковскихСчетов() Экспорт

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаБанковскихСчетов();
	
КонецФункции

// Функция получает имя типа ОсновныеСредства.
// 
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьИмяТипаОсновныеСредства() Экспорт 
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяТипаОсновныеСредства();
	
КонецФункции

// Функция получает имя перечисления ВидыДоговоровКонтрагентов.
// 
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьИмяПеречисленияВидыДоговоровКонтрагентов() Экспорт 
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяПеречисленияВидовДоговоровКонтрагентов();
	
КонецФункции

// Функция получает имя справочника НоменклатурныеГруппы.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаНоменклатурныеГруппы() Экспорт 

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаНоменклатурныеГруппы();
	
КонецФункции

// Функция получает имя типа НоменклатурныеГруппы.
// 
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьИмяТипаНоменклатурныеГруппы() Экспорт 
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяТипаНоменклатурныеГруппы();
	
КонецФункции

// Функция получает имя справочника ОсновныеСредства.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяСправочникаОсновныеСредства() Экспорт 
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаОсновныеСредства();
	
КонецФункции

// Функция получает наименование реквизита ВидДоговора справочника 
// ДоговорыКонтрагентов в зависимости от конфигурации.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьВидДоговора() Экспорт 

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяРеквизитаВидовДоговора();
	
КонецФункции

// Функция получает имя документа ПередачаОС.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИмяДокументаПередачаОС() Экспорт 
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяДокументаПередачаОС();
	
КонецФункции

// Функция получает имя документа ПередачаОС.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИмяДокументаПередачаНМА() Экспорт 
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяДокументаПередачаНМА();
	
КонецФункции

// Функция проверяет подтверждение изменения схемы движения документов по платежам.
// Если в решении отсутствует документ ПлатежноеПоручениеИсходящее, тогда схема изменена.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция СхемаДвиженияДокументовПоПлатежамИзменена() Экспорт
		
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.СхемаДвиженияДокументовПоПлатежамИзменена();
	
КонецФункции

// Функция получает имя документа по списанию денежных средств со счета.
// СписаниеСРасчетногоСчета или ПлатежноеПоручениеИсходящее.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяДокументаПоСписаниюДС() Экспорт
    	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяДокументаСписанияБезналичныхДенежныхСредств();
	
КонецФункции

// Функция получает имя документа по поступлению денежных средств на счет.
// ПоступлениеНаРасчетныйСчет или ПлатежноеПоручениеВходящее.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьИмяДокументаПоПоступлениюДС() Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяДокументаПоступленияБезналичныхДенежныхСредств();
	
КонецФункции

// Функция получает имя справочника ОбъектыСтроительства.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИмяСправочникаОбъектыСтроительства() Экспорт 

	Возврат бит_ОбщегоНазначенияКлиентСерверПереопределяемый.ИмяСправочникаОбъектыСтроительства();
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииПроверкиДублейЗначенийВТабличнойЧасти

// Процедура проверяет наличие дублей значений табличной части документа.
// Если значение какого-то из реквизтов, влияющего на проведение продублировано,
// то выставляется флаг отказа в проведении.
// 
// Параметры:
//  ДокументОбъект              - Объект проводимого документа или ссылка. 
//  ИмяТабличнойЧасти           - Табличная часть документа, для проверки дублирования строк.
//  СтруктураОбязательныхПолей  - Структура, содержащая имена полей, которые собственно и надо проверить.
//  Отказ                       - Флаг отказа в проведении.
//  Заголовок                   - Строка, заголовок сообщения об ошибке проведения.
//                                по умолчанию пустая строка.
// 
//  ПредставлениеТабличнойЧасти - Строка, название табличной части для вывода пользователю,
// 								  по умолчанию пустая строка.
// 
Процедура ПроверитьДублированиеЗначенийВТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураОбязательныхПолей, 
                                            		   Отказ, Заголовок = "", ПредставлениеТабличнойЧасти = "") Экспорт

	ПредставлениеТабЧасти = ?(ПредставлениеТабличнойЧасти = "",
							  ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Представление(),
							  ПредставлениеТабличнойЧасти);

	ТабличнаяЧасть      = ДокументОбъект[ИмяТабличнойЧасти];
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты;
    
    СписокТаблиц = Новый Структура;
    
    ТаблицаСтрок = Новый ТаблицаЗначений;
    ТаблицаСтрок.Колонки.Добавить("Значение");
    ТаблицаСтрок.Колонки.Добавить("НомераСтрок");
    
    // Цикл по проверяемым полям.
    Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл
        
        ТекущийКлюч = КлючЗначение.Ключ;
        
        ТаблицаСтрок.Очистить();
        
        МассивТекЗначений = Новый Массив;
        
        // Цикл по строкам табличной части.
        Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
            
            Значение = СтрокаТаблицы[ТекущийКлюч];
            
            НайденноеЗначение = МассивТекЗначений.Найти(Значение);
            
            Если НайденноеЗначение = Неопределено Тогда
                МассивТекЗначений.Добавить(Значение);
            Иначе
                НовСтрока = ТаблицаСтрок.Добавить();
                НовСтрока.Значение    = Значение;
                НовСтрока.НомераСтрок = СтрокаТаблицы.НомерСтроки;
            КонецЕсли;
            
        КонецЦикла;
        
        Если ТаблицаСтрок.Количество() > 0 Тогда
            СписокТаблиц.Вставить(ТекущийКлюч, ТаблицаСтрок);
        КонецЕсли;
        
    КонецЦикла;
    
    Для Каждого КлючЗначение ИЗ СписокТаблиц Цикл
        
        ТаблицаСДанными = КлючЗначение.Значение;
        
        // Получаем таблицу с данными для вывода пользователю на экран.
        ТаблицаДляВывода = ПроставитьНомераСтрокДляЗначений(ТаблицаСДанными);
        
        ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
		
		ТекстНомерамиСтрок = "";
        Для Каждого ТекСтрока Из ТаблицаДляВывода Цикл
			ТекстНомерамиСтрок = ТекстНомерамиСтрок + Символы.ПС + "     """ + ТекСтрока.Значение + """ - " + ТекСтрока.НомераСтрок;
		КонецЦикла;
		
		ТекстСообщения = Нстр("ru = 'В табличной части ""%1%"" дублируются значения колонки ""%2%"" в строках:'")
							+ ТекстНомерамиСтрок;
		ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения
																	, ПредставлениеТабЧасти
																	, ПредставлениеРеквизита);
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения, , , Отказ);
		                            
    КонецЦикла;
    
КонецПроцедуры // ПроверитьДублированиеЗначенийВТабличнойЧасти()

#КонецОбласти

#Область ПроцедурыИФункцииДляВыполненияПользовательскойФункции

// Функция выполняет алгоритм переданной функции.
// 
// Параметры:
//  ФункцияСсылка - СправочникСсылка.бит_ПользовательскиеФункции.
// 
// 	П1 - Произвольный, по умолчанию Неопределено.
//  ...
//  ...
//  П10 - Произвольный, по умолчанию Неопределено.
// 
// Возвращаемое значение:
//  Результат - Произвольный, результат выполнения функции.
// 
Функция ВыполнитьПользовательскуюФункцию(ФункцияСсылка, П1 = Неопределено, П2 = Неопределено,
														П3 = Неопределено, П4 = Неопределено, 
														П5 = Неопределено, П6 = Неопределено, 
														П7 = Неопределено, П8 = Неопределено,
														П9 = Неопределено, П10 = Неопределено) Экспорт
    // Инициализируем Результат функции.
	Результат = Неопределено;
	
	Если ЗначениеЗаполнено(ФункцияСсылка) Тогда
		
		// Инициализируем переменные функции.
		Переменные   = Новый Структура;
		Для каждого СтрокаТаблицы Из ФункцияСсылка.Переменные Цикл
			
			Если НЕ Переменные.Свойство(СтрокаТаблицы.Имя) Тогда
				
				Переменные.Вставить(СтрокаТаблицы.Имя, СтрокаТаблицы.Значение);
				
			КонецЕсли; 
			
		КонецЦикла; 
		
		// Готовим код функции.
		КодФункции 			= "";
		ПараметрыФункции 	= ФункцияСсылка.ПараметрыФункции;		
		
		Для Каждого Параметр Из ПараметрыФункции Цикл
			// Сначала инициализируем переменную.
			ДобавитьСтрокуКТексту(КодФункции, Параметр.Наименование + " = " + "П" + Строка(ПараметрыФункции.Индекс(Параметр) + 1) + ";");
		КонецЦикла;
		
		ДобавитьСтрокуКТексту(КодФункции, ФункцияСсылка.КодПодпрограммы);		
		
		// Выполняем пользовательскую функцию.
		Попытка
			
			//izhtc-Kir 01.09.2015 ( исправление функций БП2.0 на функции БП3.0
			КодФункции = СтрЗаменить(КодФункции, "МодульВалютногоУчета.ПолучитьКурсВалюты(", "бит_КурсыВалют.ПолучитьКурсВалюты(");
			КодФункции = СтрЗаменить(КодФункции, "МодульВалютногоУчета.ПересчитатьИзВалютыВВалюту(", "бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(");
			//izhtc-Kir 01.09.2015 )
			
			Выполнить(КодФункции);
			
		Исключение
			
			ТекстСообщения = НСтр("ru = 'Ошибка вычисления пользовательской функции ""%1%"". Описание ошибки: %2%'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, Строка(ФункцияСсылка), Строка(ОписаниеОшибки()));
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецПопытки;
		
		
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции // ВыполнитьПользовательскуюФункцию()

// Функция выполняет произвольный код с параметрами.
// Вставлено: 02.02.2009.
// 
// Параметры:
//  Текст функции       - Произвольный.
//  СтруктураПараметров - Массив структур (Номер, Значение) .
//  Переменные          - Структура.
// 
// Возвращаемое значение:
//   Неопределено, в случае успешного выполнения, Описание ошибки, в случае неудачи.
// 
Функция ВыполнитьПользовательскуюФункциюСПараметрами(ТекстФункции, СтруктураПараметров, Переменные) Экспорт
	
	// Служебные переменные для передачи параметров функции.
	Перем П1, П2, П3, П4, П5, П6, П7, П8, П9, П10;
	
	Для Каждого Параметр Из СтруктураПараметров Цикл
		
		Если Параметр.Номер = 1 Тогда
			П1 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П1");
		ИначеЕсли Параметр.Номер = 2 Тогда
			П2 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П2");
		ИначеЕсли Параметр.Номер = 3 Тогда
			П3 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П3");
		ИначеЕсли Параметр.Номер = 4 Тогда
			П4 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П4");
		ИначеЕсли Параметр.Номер = 5 Тогда
			П5 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П5");
		ИначеЕсли Параметр.Номер = 6 Тогда
			П6 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П6");
		ИначеЕсли Параметр.Номер = 7 Тогда
			П7 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П7");
		ИначеЕсли Параметр.Номер = 8 Тогда
			П8 = Параметр.Значение;	
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П8");
		ИначеЕсли Параметр.Номер = 9 Тогда
			П9 = Параметр.Значение;	
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П9");
		ИначеЕсли Параметр.Номер = 10 Тогда
			П10 = Параметр.Значение;
			ТекстФункции = СтрЗаменить(ТекстФункции, Параметр.Параметр, "П10");
		КонецЕсли;	
		
	КонецЦикла;	
	
	Результат = Неопределено;
	
	Попытка
		Выполнить(ТекстФункции);
	Исключение	
		Результат = ОписаниеОшибки();
	КонецПопытки;	
	
	Возврат Результат;
	
КонецФункции // ВыполнитьПользовательскуюФункциюСПараметрами()

// Добавляет новую строку "СтрокаТекста" к тексту "Текст".
// 
// Параметры:
//  Текст        - Строка.
// 	СтрокаТекста - Строка.
// 
Процедура ДобавитьСтрокуКТексту(Текст, СтрокаТекста) Экспорт

	Текст = Текст + ?(СокрЛП(Текст) = "", "", Символы.ПС) + СтрокаТекста;

КонецПроцедуры // ДобавитьСтрокуКТексту()

#КонецОбласти

#Область ПроцедурыИФункцииПоРаботеСЕдиницамиИзмеренияСумм

// !!!БИТ.СДЕЛАТЬ - Удалить процедуру для обычного приложения?
// Функция получает размерность единицы измерения сумм.
// 
// Параметры:
//  ЕдиницаИзмеренияСумм - ПеречислениеСсылка.бит_ЕдиницыИзмеренияСумм.
// 
// Возвращаемое значение:
//  Коэффициент - Число.
// 
Функция ПолучитьРазмерностьЕдиницыИзмеренияСумм(ЕдиницаИзмеренияСумм) Экспорт

	СоответствиеКоэффициентов = Новый Соответствие;
	СоответствиеКоэффициентов.Вставить(Перечисления.бит_ЕдиницыИзмеренияСумм.Единицы , 1);
	СоответствиеКоэффициентов.Вставить(Перечисления.бит_ЕдиницыИзмеренияСумм.Тысячи  , 1000);
	СоответствиеКоэффициентов.Вставить(Перечисления.бит_ЕдиницыИзмеренияСумм.Миллионы, 1000000);
	
	Коэффициент = СоответствиеКоэффициентов.Получить(ЕдиницаИзмеренияСумм);
    Коэффициент = ?(Коэффициент = Неопределено, 1, Коэффициент);
	
	Возврат Коэффициент;
	
КонецФункции // ПолучитьРазмерностьЕдиницыИзмеренияСумм()

// Функция пересчитывает сумму из размерности РазмерностьНач в РазмерностьКон.
// 
// Параметры:      
// 	Сумма		   - Число, сумма которую следует пересчитать.
// 	РазмерностьНач - Число, размерность из которой надо пересчитать.
// 	РазмерностьКон - Число, размерность в которую надо пересчитать.
// 
// Возвращаемое значение: 
//  СуммаРез - Число, пересчитанная в другую размерность.
// 
Функция ПересчитатьИзРазмерностиВРазмерность(Сумма, РазмерностьНач, РазмерностьКон) Экспорт

	Если РазмерностьНач = РазмерностьКон Тогда
		// Считаем, что пересчет не нужен.
		Возврат Сумма;
	КонецЕсли;

	Если РазмерностьНач = 0 
		Или РазмерностьКон = 0 Тогда
		
		ТекстСообщения = "Процедура ""ПересчитатьИзРазмерностиВРазмерность()"": при пересчете обнаружена нулевая размерность.";
		СообщитьОбОшибке(ТекстСообщения);
		Возврат 0;
		
	КонецЕсли;

	СуммаРез = (Сумма * РазмерностьНач / РазмерностьКон);
	
	Возврат СуммаРез;

КонецФункции // ПересчитатьИзРазмерностиВРазмерность()

#КонецОбласти

#Область НастройкиДоступностиЭлементовУправления

// Функция получает таблицу значений с настройками элементов доступности для пользователя.
//
// Параметры:
// 	Объект 				- Документобъект.
//  ЭтоУправляемаяФорма - Булево (По умолчанию = Ложь).
//
// Возвращаемое значение:
// 	Таблица значений  
//				Колонки: ИмяЭлементаУправления - Строка, 
//						 Статус - Справочники.бит_СтатусыОбъектов.Ссылка,
//						 Доступность - Булево.
//
Функция ПолучитьНастройкиДоступностиЭлементовУправления(Объект, ЭтоУправляемаяФорма = Ложь)  Экспорт

	ТекущийПользователь = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("глТекущийПользователь");
	                                
	ОбъектСистемы 		= бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(Объект.Ссылка.Метаданные());
	ТипФормы 			= "Управляемая";
	
	ТаблицаНастроек = Новый ТаблицаЗначений;
	
	Если ЕстьИзмерениеХозОперация() Тогда
		СтрокаПолеХозОп  = "бит_НастройкиДоступностиЭлементовУправления.ХозяйственнаяОперация, ";
		ГруппировкаХозОп = "бит_НастройкиДоступностиЭлементовУправления.ХозяйственнаяОперация, ";
	Иначе
		СтрокаПолеХозОп  = "";
		ГруппировкаХозОп = "";
	КонецЕсли;
	Если ЕстьРесурсОбязательное() Тогда
		СтрокаПолеОбязательное = "МАКСИМУМ(бит_НастройкиДоступностиЭлементовУправления.Обязательное) КАК Обязательное, ";
	Иначе
		СтрокаПолеОбязательное = "";
	КонецЕсли;
		
	// Запрос для получения настроек доступности элементов управления.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТекущийПользователь"	, ТекущийПользователь);
	Запрос.УстановитьПараметр("ОбъектСистемы"		, ОбъектСистемы);
	Запрос.УстановитьПараметр("ТипФормы"			, ТипФормы);
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ГруппыПользователейПользователиГруппы.Ссылка КАК ГруппаПользователей
	|ПОМЕСТИТЬ ГруппыПользователей
	|ИЗ
	|	Справочник.ГруппыПользователей.%ИмяТабЧасти% КАК ГруппыПользователейПользователиГруппы
	|ГДЕ
	|	ГруппыПользователейПользователиГруппы.Пользователь = &ТекущийПользователь
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	&ТекущийПользователь
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	ЗНАЧЕНИЕ(Справочник.ГруппыПользователей.ВсеПользователи)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	бит_НастройкиДоступностиЭлементовУправления.ИмяЭлементаУправления,
	|	бит_НастройкиДоступностиЭлементовУправления.Статус,
	|	МАКСИМУМ(бит_НастройкиДоступностиЭлементовУправления.Доступность)  КАК Доступность,
	|	МАКСИМУМ(бит_НастройкиДоступностиЭлементовУправления.Видимость)    КАК Видимость,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-08 (#4242)
	|	МАКСИМУМ(бит_НастройкиДоступностиЭлементовУправления.ок_ПрименятьНастройкиКРодительскимЭлементам) КАК ок_ПрименятьНастройкиКРодительскимЭлементам,
	|	МИНИМУМ(бит_НастройкиДоступностиЭлементовУправления.ок_ДополнительныйПриоритет) КАК ок_ДополнительныйПриоритет,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-08 (#4242)
	|	" + СтрокаПолеОбязательное + "
	|	" + СтрокаПолеХозОп + "
	|	бит_НастройкиДоступностиЭлементовУправления.ПроизвольноеУсловие
	|ИЗ
	|	ГруппыПользователей КАК ГруппыПользователей
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.бит_НастройкиДоступностиЭлементовУправления КАК бит_НастройкиДоступностиЭлементовУправления
	|		ПО ГруппыПользователей.ГруппаПользователей = бит_НастройкиДоступностиЭлементовУправления.Пользователь
	|ГДЕ
	|	бит_НастройкиДоступностиЭлементовУправления.ОбъектСистемы = &ОбъектСистемы
	|	И бит_НастройкиДоступностиЭлементовУправления.ТипФормы = &ТипФормы
	|
	|СГРУППИРОВАТЬ ПО
	|	бит_НастройкиДоступностиЭлементовУправления.ИмяЭлементаУправления,
	|	бит_НастройкиДоступностиЭлементовУправления.Статус,
	|	" + ГруппировкаХозОп + "
	|	бит_НастройкиДоступностиЭлементовУправления.ПроизвольноеУсловие
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ ГруппыПользователей";
	
	ИмяТабЧасти = бит_ОбщегоНазначения.ИмяТабЧастиГруппыПользователей();
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "%ИмяТабЧасти%", ИмяТабЧасти);		

	ТаблицаНастроек = Запрос.Выполнить().Выгрузить();

	Возврат ТаблицаНастроек;
	
КонецФункции // ПолучитьНастройкиДоступностиЭлементовУправления()

// Функция фильтрует таблицу настроек по определенному статусу 
// и упорядочивает настройки по возрастанию приоритетов, приоритет = 0 в случае, когда статус пуст.
//
// Параметры:
//  ТаблицаНастроек   	  - Таблица значений.  
//							Колонки: ИмяЭлементаУправления - Строка, 
//								 Статус -  Справочники.бит_СтатусыОбъектов.Ссылка,
//								 Доступность - Булево.
//  Статус			  	  - СправочникСсылка.бит_СтатусыОбъектов.
//  ХозяйственнаяОперация - СправочникСсылка.бит_ХозяйственныеОперации (По умолчанию = Неопределено).
//
// Возвращаемое значение:
// 	Таблица значений  
//				Колонки: ИмяЭлементаУправления - Строка, 
//						 Статус -  Справочники.бит_СтатусыОбъектов.Ссылка
//						 Доступность - Булево.
//
Функция ПолучитьАктуальныеНастройки(ТаблицаНастроек, Статус, ХозяйственнаяОперация = Неопределено) Экспорт

	Если ЕстьРесурсОбязательное() Тогда
		СтрокаПолеОбязательное = "ТаблицаНастроек.Обязательное, ";
	Иначе
		СтрокаПолеОбязательное = "";
	КонецЕсли;
	
	СтатусПуст = Справочники.бит_СтатусыОбъектов.ПустаяСсылка(); 	
	СписокСтатусов = Новый СписокЗначений;
	СписокСтатусов.Добавить(СтатусПуст);
	СписокСтатусов.Добавить(Статус);
	
	УстанавливатьХозОперацию = ХозяйственнаяОперация <> Неопределено;
    Если УстанавливатьХозОперацию Тогда
        ХозОпПуста = Справочники["бит_ХозяйственныеОперации"].ПустаяСсылка(); // Имя справочника задано для сертификации.	
		СписокХозОп = Новый СписокЗначений;
		СписокХозОп.Добавить(ХозОпПуста);
		СписокХозОп.Добавить(ХозяйственнаяОперация); 
		СтрокаПолеХозОп = "ТаблицаНастроек.ХозяйственнаяОперация, ";
		СтрокаУсловиеХозОп = "И ТаблицаНастроек.ХозяйственнаяОперация В(&СписокХозОп) ";
	Иначе
		СтрокаПолеХозОп    = "";
		СтрокаУсловиеХозОп = "";
	КонецЕсли;                                       	
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТаблицаНастроек", ТаблицаНастроек);
	Запрос.УстановитьПараметр("СтатусПуст"	   , СтатусПуст);
	Запрос.УстановитьПараметр("СписокСтатусов" , СписокСтатусов);	
	Если УстанавливатьХозОперацию Тогда
		Запрос.УстановитьПараметр("ХозОпПуста" , ХозОпПуста);
		Запрос.УстановитьПараметр("СписокХозОп", СписокХозОп);
	КонецЕсли;
	Запрос.УстановитьПараметр("ИмяВсехПолей1", "Все элементы формы");
	Запрос.УстановитьПараметр("ИмяВсехПолей2", "Поля ввода");
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-12 (#4242)
	Запрос.УстановитьПараметр("ИмяВсехПолей3", "Все видимые элементы формы");
	Запрос.УстановитьПараметр("ИмяВсехПолей4", "Все видимые кнопки формы");
	Запрос.УстановитьПараметр("ИмяВсехПолей5", "Все кнопки формы");
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-12 (#4242)
	
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	ВЫРАЗИТЬ(ТаблицаНастроек.ИмяЭлементаУправления КАК СТРОКА(500)) КАК ИмяЭлементаУправления,
	|	ТаблицаНастроек.Доступность,
	|	ТаблицаНастроек.Видимость,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-08 (#4242)
	|	ТаблицаНастроек.ок_ПрименятьНастройкиКРодительскимЭлементам,
	|	ТаблицаНастроек.ок_ДополнительныйПриоритет,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-08 (#4242)
	|	" + СтрокаПолеОбязательное + "
	|	ТаблицаНастроек.Статус,
	|	" + СтрокаПолеХозОп + " 	
	|	ТаблицаНастроек.ПроизвольноеУсловие
	|ПОМЕСТИТЬ ТаблицаВыбранных
	|ИЗ
	|	&ТаблицаНастроек КАК ТаблицаНастроек
	|ГДЕ
	|	ТаблицаНастроек.Статус В(&СписокСтатусов)
	|	" + СтрокаУсловиеХозОп + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаНастроек.ИмяЭлементаУправления КАК ИмяЭлементаУправления,
	|	ВЫБОР
	|		КОГДА ТаблицаНастроек.ИмяЭлементаУправления = &ИмяВсехПолей1
	|			ТОГДА 0
	|		КОГДА ТаблицаНастроек.ИмяЭлементаУправления = &ИмяВсехПолей2
	|			ТОГДА 1
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-12 (#4242)
	//|		ИНАЧЕ 2              
	|		КОГДА ТаблицаНастроек.ИмяЭлементаУправления = &ИмяВсехПолей3
	|			ТОГДА 2
	|		КОГДА ТаблицаНастроек.ИмяЭлементаУправления = &ИмяВсехПолей4
	|			ТОГДА 3
	|		КОГДА ТаблицаНастроек.ИмяЭлементаУправления = &ИмяВсехПолей5
	|			ТОГДА 4
	|		ИНАЧЕ 9
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-12 (#4242)
	|	КОНЕЦ КАК ПриоритетИмени,
	|	ТаблицаНастроек.Доступность,
	|	ТаблицаНастроек.Видимость,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-08 (#4242)
	|	ТаблицаНастроек.ок_ПрименятьНастройкиКРодительскимЭлементам,
	|	ТаблицаНастроек.ок_ДополнительныйПриоритет,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-08 (#4242)
	|	" + СтрокаПолеОбязательное + "
	|	ТаблицаНастроек.Статус КАК Статус,";
	Если УстанавливатьХозОперацию Тогда
		Запрос.Текст = Запрос.Текст + "
		|	ТаблицаНастроек.ХозяйственнаяОперация,
		|	ВЫБОР
		|		КОГДА ТаблицаНастроек.Статус = &СтатусПуст И ТаблицаНастроек.ХозяйственнаяОперация = &ХозОпПуста
		|			ТОГДА 0
		|		КОГДА ТаблицаНастроек.Статус <> &СтатусПуст И ТаблицаНастроек.ХозяйственнаяОперация = &ХозОпПуста
		|			ТОГДА 1
		|		КОГДА ТаблицаНастроек.Статус = &СтатусПуст И ТаблицаНастроек.ХозяйственнаяОперация <> &ХозОпПуста
		|			ТОГДА 2
		|		ИНАЧЕ 3
		|	КОНЕЦ КАК Приоритет,";
	Иначе
		Запрос.Текст = Запрос.Текст + "
		|	ВЫБОР
		|		КОГДА ТаблицаНастроек.Статус = &СтатусПуст
		|			ТОГДА 0
		|		ИНАЧЕ 1              
		|	КОНЕЦ КАК Приоритет,";
	КонецЕсли;
	Запрос.Текст = Запрос.Текст + " 	
	|	ТаблицаНастроек.ПроизвольноеУсловие КАК ПроизвольноеУсловие
	|ИЗ
	|	ТаблицаВыбранных КАК ТаблицаНастроек
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПриоритетИмени,
	|	Приоритет,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-12 (#4242)
	|	ок_ДополнительныйПриоритет,
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-12 (#4242)
	|	ИмяЭлементаУправления
	//|	Статус
	|";
	
	ТаблицаАктуальныхНастроек = Новый ТаблицаЗначений;
	ТаблицаАктуальныхНастроек = Запрос.Выполнить().Выгрузить();
			
	Возврат ТаблицаАктуальныхНастроек;
	
КонецФункции // ПолучитьАктуальныеНастройки()

// Процедура устанавливает доступность элементов управления.
//
// Параметры:
//  Форма  - Форма 
//				Колонки: ИмяЭлементаУправления - Строка, 
//						 Статус -  Справочники.бит_СтатусыОбъектов.Ссылка,
//						 Доступность - Булево.
//  ТаблицаНастроек - ТаблицаЗначений.
//  ПараметрыУсловия - Стуктура
//                     Ключи: 
//                            ТекущийОбъект - ДокументОбъект,СправочникОбъект
//                            Статус        - СправочникСсылка.бит_СтатусыОбъектов.
//
Процедура УстановитьДоступностьЭлементовУправленияПоНастройкам(Форма, ТаблицаНастроек, ПараметрыУсловия) Экспорт

	ЭлементыФормы = Форма.Элементы;
	СписокИсключений = Новый СписокЗначений;
		
	Для каждого НастройкиЭлемента Из ТаблицаНастроек Цикл
		
		ТекТабЧасть = Неопределено;
		ТекЭлемент  = Неопределено;
		
 		ИмяЭлемента  = СокрЛП(НастройкиЭлемента.ИмяЭлементаУправления);
		
		// Если произвольное условие заполнено проверим его.
		Если ЗначениеЗаполнено(НастройкиЭлемента.ПроизвольноеУсловие) Тогда		
			флРезультат = бит_уп_Сервер.ПроверитьПользовательскоеУсловие(НастройкиЭлемента.ПроизвольноеУсловие, ПараметрыУсловия);   			
			Если НЕ флРезультат Тогда   			
				Продолжить; 			
			КонецЕсли; 			
		КонецЕсли;
		
		ВрегИмяЭлемента = ВРег(СтрЗаменить(ИмяЭлемента, " ", ""));
		Если ВрегИмяЭлемента = ВРег("ВсеЭлементыФормы") ИЛИ ВрегИмяЭлемента = ВРег("ПоляВвода") Тогда
			
			Для каждого ТекЭлемент Из ЭлементыФормы Цикл
				Если СписокИсключений.НайтиПоЗначению(ИмяЭлемента) = Неопределено Тогда
					
					ТипЭлемента = ТипЗнч(ТекЭлемент);
					Если ТипЭлемента = Тип("ПолеФормы")
					  ИЛИ ТипЭлемента = Тип("ТаблицаФормы")
					  ИЛИ ТипЭлемента = Тип("ГруппаФормы") Тогда
					    Проверять = Истина;
					Иначе
						Проверять = Ложь;	
					КонецЕсли;
					
					Если Проверять Тогда
						УстановитьДоступностьВидимостьЭлемента(ТекЭлемент, Истина, НастройкиЭлемента);
					КонецЕсли;
				КонецЕсли;                                                                                       				
			КонецЦикла;
			
			Продолжить;
			
		//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-12 (#4242)
		// Данная доработка необходима, т.к. нет возможности заблокировать все элементы формы без нарушения видимости и обязательности элементов.
		// Данное ключевое слово добавлено и влияет только на видимость и доступность видимых элементов на форме.
		// Данное ключевое слово не позволяет открыть видимость для уже скрытых элементов формы. 
		// Скрытые элементы на форме необходимо открывать по ключевому слову "ВсеКнопкиФормы", либо каждый элемент отдельно.
		ИначеЕсли ВрегИмяЭлемента = ВРег("ВсеВидимыеЭлементыФормы") Тогда
			
			Для каждого ТекЭлемент Из ЭлементыФормы Цикл
				Если СписокИсключений.НайтиПоЗначению(ИмяЭлемента) = Неопределено Тогда
					
					ТипЭлемента = ТипЗнч(ТекЭлемент);
					Если (ТипЭлемента = Тип("ПолеФормы")
					  		ИЛИ ТипЭлемента = Тип("ТаблицаФормы")
					  		ИЛИ ТипЭлемента = Тип("ГруппаФормы"))
					  	И ТекЭлемент.Видимость Тогда
					    Проверять = Истина;
					Иначе
						Проверять = Ложь;	
					КонецЕсли;
					
					Если Проверять Тогда
						УстановитьДоступностьВидимостьЭлемента(ТекЭлемент, Истина, НастройкиЭлемента);
					КонецЕсли;
				КонецЕсли;                                                                                       				
			КонецЦикла;
			
			Продолжить;
			
		// Данная доработка необходима, т.к. нет возможности взаимодействовать на все кнопки формы разом, а прописывать каждую кнопку формы трудоемко.
		// Данное ключевое слово добавлено и влияет только на видимость и доступность видимых кнопок на форме.
		// Данное ключевое слово не позволяет открыть видимость для уже скрытых кнопок. 
		// Скрытые кнопки на форме необходимо открывать по ключевому слову "ВсеКнопкиФормы", либо каждую кнопку отдельно.
		ИначеЕсли ВрегИмяЭлемента = ВРег("ВсеВидимыеКнопкиФормы") Тогда
			
			Для каждого ТекЭлемент Из ЭлементыФормы Цикл
				Если СписокИсключений.НайтиПоЗначению(ИмяЭлемента) = Неопределено Тогда
					
					ТипЭлемента = ТипЗнч(ТекЭлемент);
					Если ТипЭлемента = Тип("КнопкаФормы")
						И ТекЭлемент.Видимость Тогда
					    Проверять = Истина;
					Иначе
						Проверять = Ложь;	
					КонецЕсли;
					
					Если Проверять Тогда
						УстановитьДоступностьВидимостьЭлемента(ТекЭлемент, Истина, НастройкиЭлемента);
					КонецЕсли;
				КонецЕсли;                                                                                       				
			КонецЦикла;
			
			Продолжить;
			
		// Данное ключевое слово влияет на все кнопки формы без ограничений.
		ИначеЕсли ВрегИмяЭлемента = ВРег("ВсеКнопкиФормы") Тогда
			
			Для каждого ТекЭлемент Из ЭлементыФормы Цикл
				Если СписокИсключений.НайтиПоЗначению(ИмяЭлемента) = Неопределено Тогда
					
					ТипЭлемента = ТипЗнч(ТекЭлемент);
					Если ТипЭлемента = Тип("КнопкаФормы") Тогда
					    Проверять = Истина;
					Иначе
						Проверять = Ложь;	
					КонецЕсли;
					
					Если Проверять Тогда
						УстановитьДоступностьВидимостьЭлемента(ТекЭлемент, Истина, НастройкиЭлемента);
					КонецЕсли;
				КонецЕсли;                                                                                       				
			КонецЦикла;
			
			Продолжить;
			
		//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-12 (#4242)
		
		Иначе
			
			СписокИсключений.Добавить(ИмяЭлемента);
			
		КонецЕсли;
		
		НомерТочки = Найти(ИмяЭлемента, ".");
		Если НомерТочки = 0 Тогда
			
			ТекЭлемент = ЭлементыФормы.Найти(ИмяЭлемента);
						
		Иначе // Реквизит табличной части
			
			ИмяТч = Лев(ИмяЭлемента, НомерТочки - 1);
			ИмяРв = Прав(ИмяЭлемента, СтрДлина(ИмяЭлемента) - НомерТочки);
			ТекЭлемент = ЭлементыФормы.Найти(ИмяРв);
		КонецЕсли; 		
		
		// Ничего не делаем, если элемент формы не найден.        
		Если ТекЭлемент = Неопределено Тогда
			Продолжить;
		КонецЕсли;
				
		УстановитьДоступностьВидимостьЭлемента(ТекЭлемент, Истина, НастройкиЭлемента);
				
 	КонецЦикла;	

КонецПроцедуры // УстановитьДоступностьЭлементовУправленияПоНастройкам()

// Процедура применяет настройки доступности и видимости для элементов формы.
//
// Параметры:
//  ЭтаФорма.
//  Объект.
//  ТекущийСтатус.
//  ХозяйственнаяОперация.
//
Процедура УстановитьНастройкиДоступностиЭлементовДляФормы(ЭтаФорма, Объект, ТекущийСтатус = Неопределено, ХозяйственнаяОперация = Неопределено) Экспорт

	// Получение таблицы настроек доступности элементов управления.
	ТаблицаНастроекДоступности = бит_ОбщегоНазначения.ПолучитьНастройкиДоступностиЭлементовУправления(Объект, Истина);
   	
	// Фильтр таблицы настроек по статусу.
	ТаблицаАктуальныхНастроек = бит_ОбщегоНазначения.ПолучитьАктуальныеНастройки(ТаблицаНастроекДоступности, ТекущийСтатус, ХозяйственнаяОперация);
	
	// Структура параметров для проверки произвольного условия.
	Если ТекущийСтатус = Неопределено Тогда
		ПараметрыУсловия = Новый Структура("ТекущийОбъект", Объект);
	Иначе	
		ПараметрыУсловия = Новый Структура("ТекущийОбъект,Статус", Объект, ТекущийСтатус);
	КонецЕсли;
    
    // Применяем настройки.
	бит_ОбщегоНазначения.УстановитьДоступностьЭлементовУправленияПоНастройкам(ЭтаФорма, ТаблицаАктуальныхНастроек, ПараметрыУсловия);
		
КонецПроцедуры // УстановитьНастройкиДоступностиЭлементовДляФормы()

// Процедура устанавливает доступность элементов управления.
//
// Параметры:
//  ТаблицаАктуальныхНастроек - ТаблицаЗначений.
//  ПроверяемыеРеквизиты 	  - Массив.
//  ЭтотОбъектМетаданные 	  - ОбъектМетаданных.
//  ПараметрыУсловия.
//
Процедура УстановитьПроверяемыеРеквизиты(ТаблицаАктуальныхНастроек, ПроверяемыеРеквизиты, ЭтотОбъектМетаданные, ПараметрыУсловия) Экспорт

	Для каждого НастройкиЭлемента Из ТаблицаАктуальныхНастроек Цикл
	
		ИмяЭлемента  = СокрЛП(НастройкиЭлемента.ИмяЭлементаУправления);
		Обязательное = НастройкиЭлемента.Обязательное;
		
		// Если произвольное условие заполнено проверим его.
		Если ЗначениеЗаполнено(НастройкиЭлемента.ПроизвольноеУсловие) Тогда
			флРезультат = бит_уп_Сервер.ПроверитьПользовательскоеУсловие(НастройкиЭлемента.ПроизвольноеУсловие, ПараметрыУсловия);   			
			Если НЕ флРезультат Тогда   			
				Продолжить; 			
			КонецЕсли; 			
		КонецЕсли;
		
		ИндексТЧ = СтрНайти(ИмяЭлемента,".",,1);
		ВрегИмяЭлемента = ВРег(СтрЗаменить(ИмяЭлемента, " ", ""));
		Если ВрегИмяЭлемента = ВРег("ВсеЭлементыФормы") ИЛИ ВрегИмяЭлемента = ВРег("ПоляВвода") Тогда
			
			Для каждого Реквизит Из ЭтотОбъектМетаданные.Реквизиты Цикл

				ИмяРевизита = Реквизит.Имя;
				ИдРекв 		= ПроверяемыеРеквизиты.Найти(ИмяРевизита);
				
				Если Обязательное Тогда
					Если ИдРекв = Неопределено Тогда
						ПроверяемыеРеквизиты.Добавить(ИмяРевизита);
					КонецЕсли;
				Иначе
					Если ИдРекв <> Неопределено Тогда
						ПроверяемыеРеквизиты.Удалить(ИдРекв);					
					КонецЕсли;
				КонецЕсли; 					  

			КонецЦикла; 			
			
		ИначеЕсли бит_РаботаСМетаданными.ЕстьРеквизит(ИмяЭлемента, ЭтотОбъектМетаданные) Тогда 
			
			ИдРекв = ПроверяемыеРеквизиты.Найти(ИмяЭлемента);
			Если Обязательное Тогда
				Если ИдРекв = Неопределено Тогда
					ПроверяемыеРеквизиты.Добавить(ИмяЭлемента);  				
				КонецЕсли;
			Иначе
				Если ИдРекв <> Неопределено Тогда
					ПроверяемыеРеквизиты.Удалить(ИдРекв);					
				КонецЕсли;
			КонецЕсли; 
			
		ИначеЕсли ИндексТЧ > 0 Тогда
						
			ИмяТЧ          = Лев(ИмяЭлемента, ИндексТЧ-1);
			ИмяРеквизита   = Прав(ИмяЭлемента, СтрДлина(ИмяЭлемента) - СтрДлина(ИмяТЧ) - ИндексТЧ);			
			ИмяРеквизитаТЧ = ИмяТЧ +"."+ ИмяРеквизита;
			
			ИдРекв = ПроверяемыеРеквизиты.Найти(ИмяРеквизитаТЧ);
			Если Обязательное Тогда
				Если ИдРекв = Неопределено Тогда
					ПроверяемыеРеквизиты.Добавить(ИмяРеквизитаТЧ);  				
				КонецЕсли;
			Иначе
				Если ИдРекв <> Неопределено Тогда
					ПроверяемыеРеквизиты.Удалить(ИдРекв);					
				КонецЕсли;
			КонецЕсли; 
			
		КонецЕсли;
			
	КонецЦикла;

КонецПроцедуры // УстановитьПроверяемыеРеквизиты()

// Процедура применяет настройки обязательности реквизитов.
//
Процедура УстановитьНастройкиОбязательностиРеквизитов(ЭтотОбъект, ПроверяемыеРеквизиты, ТекущийСтатус = Неопределено, ХозяйственнаяОперация = Неопределено) Экспорт

	Если Метаданные.РегистрыСведений.бит_НастройкиДоступностиЭлементовУправления.Ресурсы.Найти("Обязательное") = Неопределено Тогда
		Возврат;	
	КонецЕсли;
	
	// Получение таблицы настроек доступности элементов управления
	ТаблицаНастроекДоступности = ПолучитьНастройкиДоступностиЭлементовУправления(ЭтотОбъект, Истина);     	
	
	// Фильтр таблицы настроек по статусу
	ТаблицаАктуальныхНастроек = ПолучитьАктуальныеНастройки(ТаблицаНастроекДоступности, ТекущийСтатус, ХозяйственнаяОперация);
	
	// Структура параметров для проверки произвольного условия
	ПараметрыУсловия = Новый Структура("ТекущийОбъект,Статус", ЭтотОбъект, ТекущийСтатус);
    
    // Изменение массива проверяемых реквизитов
	бит_ОбщегоНазначения.УстановитьПроверяемыеРеквизиты(ТаблицаАктуальныхНастроек, ПроверяемыеРеквизиты, ЭтотОбъект.Метаданные(), ПараметрыУсловия);
		
КонецПроцедуры // УстановитьНастройкиОбязательностиРеквизитов()

#КонецОбласти

#Область ВнешниеОбработки

// Процедура обработчик подписки "бит_ПередЗаписьюСправочникаВнешниеОбработки" 
// на событие "ПередЗаписью".
// 
// Параметры:
//  Источник - СправочникОбъект.ВнешниеОбработки.
//  Отказ    - Булево.
// 
Процедура бит_ПередЗаписьюСправочникаВнешниеОбработкиПередЗаписью(Источник, Отказ) Экспорт
	
	// Для совместмости с ЕРП.
	
КонецПроцедуры // бит_ПередЗаписьюСправочникаВнешниеОбработкиПередЗаписью()

#КонецОбласти

#Область СобственныеКонтрагенты

// Функция определяет, является ли контрагент собственным.
// 
// Параметры:
//  Контрагент - СправочникСсылка.Контрагенты.
// 	ВидСвязи   - Неопределено, ПеречислениеСсылка.бит_ВидыСобственныхКонтрагентов.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция СобственныйКонтрагент(Контрагент, ВидСвязи=Неопределено) Экспорт

	УсловиеВидСвязи = "";
	
	Если ВидСвязи = Перечисления.бит_ВидыСобственныхКонтрагентов.Организация Тогда
		УсловиеВидСвязи = " И бит_СобственныеКонтрагенты.ВидСвязи = ЗНАЧЕНИЕ(Перечисление.бит_ВидыСобственныхКонтрагентов.Организация)";
	ИначеЕсли ВидСвязи = Перечисления.бит_ВидыСобственныхКонтрагентов.ФизЛицо Тогда
		УсловиеВидСвязи = " И бит_СобственныеКонтрагенты.ВидСвязи = ЗНАЧЕНИЕ(Перечисление.бит_ВидыСобственныхКонтрагентов.ФизЛицо)";
	КонецЕсли;
	
    ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
                   |	бит_СобственныеКонтрагенты.Объект
                   |ИЗ
                   |	РегистрСведений.бит_СобственныеКонтрагенты КАК бит_СобственныеКонтрагенты
                   |ГДЕ
                   |	бит_СобственныеКонтрагенты.Контрагент = &Контрагент";
				   
	ТекстЗапроса = ТекстЗапроса + УсловиеВидСвязи;			   
				   
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Результат = Ложь;
	Иначе
		Результат = Истина;
	КонецЕсли;
				   
	Возврат Результат;
	
КонецФункции // СобственныйКонтрагент()

// Функция получает собственную организацию по контрагенту.
// 
// Параметры:
// 	Контрагент - СправочникСсылка.Контрагенты 
// 						(контрагент для которого надо найти организацию).
// 
// Возвращаемое значение:
// 	СобственнаяОрганизация - СправочникСсылка.Организации 
// 							(найденная организация или пустая ссылка, если организация не найдена).
// 
Функция ПолучитьСобственнуюОрганизациюПоКонтрагенту(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	бит_СобственныеКонтрагенты.Объект
	|ИЗ
	|	РегистрСведений.бит_СобственныеКонтрагенты КАК бит_СобственныеКонтрагенты
	|ГДЕ
	|	бит_СобственныеКонтрагенты.ВидСвязи = ЗНАЧЕНИЕ(Перечисление.бит_ВидыСобственныхКонтрагентов.Организация)
	|	И бит_СобственныеКонтрагенты.Контрагент = &Контрагент";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Если Выборка.Следующий() Тогда
		СобственнаяОрганизация = Выборка.Объект;
	Иначе
		СобственнаяОрганизация = Справочники.Организации.ПустаяСсылка();
	КонецЕсли;
	
	Возврат СобственнаяОрганизация;
	
КонецФункции // ПолучитьСобственнуюОрганизациюПоКонтрагенту()

// Функция получает собственного контрагента по организации.
// 
// Параметры:
// 	Организация - СправочникСсылка.Организации 
// 					(организация для которой надо найти контрагента).
// 
// Возвращаемое значение:
// 	СобственныйКонтрагент - СправочникСсылка.Контрагенты 
// 							(найденный контрагент или пустая ссылка, если контрагент не найден).
// 
Функция ПолучитьСобственногоКонтрагентаПоОрганизации(Организация) Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	бит_СобственныеКонтрагенты.Контрагент
	|ИЗ
	|	РегистрСведений.бит_СобственныеКонтрагенты КАК бит_СобственныеКонтрагенты
	|ГДЕ
	|	бит_СобственныеКонтрагенты.ВидСвязи = ЗНАЧЕНИЕ(Перечисление.бит_ВидыСобственныхКонтрагентов.Организация)
	|	И бит_СобственныеКонтрагенты.Объект = &Организация";
	
	Запрос.УстановитьПараметр("Организация", Организация);
	
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Если Выборка.Следующий() Тогда
		СобственныйКонтрагент = Выборка.Контрагент;
	Иначе
		СобственныйКонтрагент = Справочники.Контрагенты.ПустаяСсылка();
	КонецЕсли;
	
	Возврат СобственныйКонтрагент;
	
КонецФункции // ПолучитьСобственногоКонтрагентаПоОрганизации()

// Функция получает список собственных контрагентов по организации.
// 
// Параметры:
//  Организация - СправочникСсылка.Организации.
// 
// Возвращаемое значение:
//  Список значений.
// 
Функция ПолучитьСписокСобственныхКонтрагентовПоОрганизации(Организация) Экспорт

	СписокСобственных = Новый СписокЗначений;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация", Организация);
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
    |	СобственныеКонтрагенты.Контрагент
    |ИЗ
    |	РегистрСведений.бит_СобственныеКонтрагенты КАК СобственныеКонтрагенты
    |ГДЕ
    |	СобственныеКонтрагенты.ВидСвязи = ЗНАЧЕНИЕ(Перечисление.бит_ВидыСобственныхКонтрагентов.Организация)
    |	И СобственныеКонтрагенты.Объект = &Организация
    |
    |";
	РезультатЗапроса = Запрос.Выполнить();
	Если Не РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Пока Выборка.Следующий() Цикл		
			СписокСобственных.Добавить(Выборка.Контрагент);		
		КонецЦикла;
		
	КонецЕсли;	
	
	Возврат СписокСобственных;

КонецФункции // ПолучитьСобственныхКонтрагентовПоОрганизации()

#КонецОбласти

#Область РучнаяКорректировка

// Функция определяет была ли ручная корректировка движений документа.
// 
// Параметры:
//  Источник - ДокументОбъект, ДокументСсылка.
// 
// Возвращаемое значение:
//   Булево.
// 
Функция РучнаяКорректировка(Источник)  Экспорт

	флРучнаяКорректировка = Ложь;
	
	МетаданныеИсточника = Источник.Метаданные();
	Если бит_РаботаСМетаданными.ЕстьРеквизит("РучнаяКорректировка", МетаданныеИсточника) Тогда
	
	     Если Источник.РучнаяКорректировка Тогда		 
	        флРучнаяКорректировка = Истина;		 
		 КонецЕсли; 
	
	КонецЕсли; 

	Возврат флРучнаяКорректировка;
	
КонецФункции // РучнаяКорректировка()

// Функция выполняет синхронизацию реквизита документа РучнаяКорректировка.
// 
// Параметры:
//  ДокументОбъект 		- ДокументОбъект.
//  РучнаяКорректировка - Булево.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ВыполнитьСинхронизациюРучнойКорректировки(ДокументОбъект, РучнаяКорректировка) Экспорт
	
	ДействиеВыполнено = Ложь;
	
	ОтменаРучнойКорректировки 		   = ДокументОбъект.РучнаяКорректировка;
	ДокументОбъект.РучнаяКорректировка = РучнаяКорректировка;
	
	Если ОтменаРучнойКорректировки Тогда
		
		Попытка
			
			Если ДокументОбъект.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
				РежимПроведения = ?(ДокументОбъект.Проведен, РежимЗаписиДокумента.Проведение, РежимЗаписиДокумента.ОтменаПроведения);
			Иначе
				РежимПроведения = РежимЗаписиДокумента.Запись;
				
				Для Каждого ТекРегистр Из ДокументОбъект.Движения Цикл
					ТекРегистр.Очистить();
				КонецЦикла;
			КонецЕсли;
			
			ДокументОбъект.Записать(РежимПроведения);
			ДокументЗаписан = Истина;
			
		Исключение
			
			ТекстСообщения = "ru = 'При попытке проведения документа возникла ошибка. Проведение документа отменено.'";
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(НСтр(ТекстСообщения));
			
			ДокументЗаписан = ЗаписатьПровестиДокумент(ДокументОбъект
												      ,РежимЗаписиДокумента.ОтменаПроведения
													  ,
													  ,"Ошибки");
		КонецПопытки;
		
	Иначе
		
		ДокументЗаписан = ЗаписатьПровестиДокумент(ДокументОбъект
												  ,РежимЗаписиДокумента.Запись
												  ,
												  ,"Ошибки");
		
	КонецЕсли; // Если ОтменаРучнойКорректировки Тогда.
	
	ДействиеВыполнено = ?(ДокументЗаписан, Истина, Ложь);
	
	Возврат ДействиеВыполнено;
	
КонецФункции // ВыполнитьСинхронизациюРучнойКорректировки()

#КонецОбласти

#Область ПередачаДанныхССервераНаСерверЧерезКлиент

// Функция упаковывает таблицу значений для передачи через клиент.
// 
// Параметры:
//  ТаблицаЗнч - Таблица значений.
//  
// Возвращаемое значение:
//   ХранилищеЗначений.
// 
Функция УпаковатьТаблицуЗначений(ТаблицаЗнч) Экспорт

	УпакованнаяТаблица = Новый ХранилищеЗначения(ТаблицаЗнч);

	Возврат УпакованнаяТаблица;
	
КонецФункции // УпаковатьТаблицуЗначений()

// Функция распаковывает таблицу значений после передачи через клиент.
// 
// Параметры:
//  УпакованнаяТаблица - Хранилище значений.
//  
// Возвращаемое значение:
//   Таблица значений.
// 
Функция РаспаковатьТаблицуЗначений(УпакованнаяТаблица) Экспорт

	Если УпакованнаяТаблица = Неопределено Тогда
		ТаблицаЗнч = Неопределено;
	Иначе
	 	ТаблицаЗнч = УпакованнаяТаблица.Получить();	
	КонецЕсли;                                     	
	
	Возврат ТаблицаЗнч;
	
КонецФункции // РаспаковатьТаблицуЗначений()

// Функция упаковывает дерево значений для передачи через клиент.
// 
// Параметры:
//  ДеревоЗнч - Дерево значений.
//  
// Возвращаемое значение:
//   ХранилищеЗначений.
// 
Функция УпаковатьДеревоЗначений(ДеревоЗнч) Экспорт

	УпакованноеДерево = Новый ХранилищеЗначения(ДеревоЗнч);

	Возврат УпакованноеДерево;
	
КонецФункции // УпаковатьДеревоЗначений()

// Функция распаковывает дерево значений после передачи через клиент.
// 
// Параметры:
//  УпакованнаяТаблица - Хранилище значений.
//  
// Возвращаемое значение:
//   Дерево значений.
// 
Функция РаспаковатьДеревоЗначений(УпакованноеДерево) Экспорт

	ДеревоЗнч = УпакованноеДерево.Получить();
	
	Возврат ДеревоЗнч;
	
КонецФункции // РаспаковатьДеревоЗначений()

// Функция является оберткой для метода платформы ПринадлежитЭлементу(). 
// Для безопасности вызова проверяется существование родительского объекта.
// 
// Параметры:
//  МодельТаблицы      - Массив, моделирующий таблицу значений. Элементы 
//                       массива структуры, ключ - имя колонки, значение - значение колонки.
//  ИменаКолонок       - Структура, Массив.
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция РаспаковатьТаблицуИзМассива(МодельТаблицы,ИменаКолонок) Экспорт
	
	ТЗ = Новый ТаблицаЗначений;
	
	Если ТипЗнч(ИменаКолонок) = Тип("Структура") Тогда
		
		Для Каждого КиЗ ИЗ ИменаКолонок Цикл			
			ТЗ.Колонки.Добавить(КиЗ.Ключ, КиЗ.Значение);			
		КонецЦикла;
		
	Иначе
		
		Для Каждого ИмяКолонки ИЗ ИменаКолонок Цикл			
			ТЗ.Колонки.Добавить(ИмяКолонки);			
		КонецЦикла;
		
	КонецЕсли;	
	
	КолонкиТаблицы = ТЗ.Колонки;
	
	Для Каждого СтрСтроки ИЗ МодельТаблицы Цикл
		
		НоваяСтрока = ТЗ.Добавить();
        
		Для Каждого КиЗ ИЗ СтрСтроки Цикл
			
			Если КолонкиТаблицы.Найти(КиЗ.Ключ) <> Неопределено Тогда				
				НоваяСтрока[КиЗ.Ключ] = КиЗ.Значение;				
			КонецЕсли; // Есть колонка.
			
		КонецЦикла;	// СтрСтроки.
		
	КонецЦикла;  // МодельТаблицы.
	
	Возврат ТЗ;
	
КонецФункции // РаспаковатьТаблицуИзМассива()

#КонецОбласти

#Область ПользователиРоли

// Функция получает текущего пользователя.
// 
// Возвращаемое значение:
//  СправочникСсылка.Пользователи.
// 
Функция ПолучитьТекущегоПользователя() Экспорт
	
	ТекущийПользователь = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("глТекущийПользователь");
	
	Возврат ТекущийПользователь;
	
КонецФункции // ПолучитьТекущегоПользователя()

// Функция определяет следует ли устанавливать роль бит_БухгалтерДополнение пользователю.
// 
// Параметры:
//  РолиПользователя - Коллекция ролей пользователя.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция НеобходимоУстановитьРольБухгалтерДополнение(РолиПользователя) Экспорт
	
	флУстановить = Ложь;
	
	// Для общности вызовов преобразуем входящий параметр к массиву ОбъектовМетаданных.Роль.
	МассивРолей = СформироватьМассивРолей(РолиПользователя);
	
	// Если это "Бухгалтерия предприятия", тогда.
	Если ЭтоБухгалтерияПредприятия() Тогда
		
		флЕстьМСФО               = Истина;
		РольБухгалтер            = Метаданные.Роли.ДобавлениеИзменениеДанныхБухгалтерии;	
		РольФинансистПолныеПрава = Метаданные.Роли.бит_ФинансистПолныеПрава;
		
		Если флЕстьМСФО Тогда
			РольМСФОПолныеПрава = Метаданные.Роли.бит_му_ПолныеПрава;	
			РольСпециалистМСФО  = Метаданные.Роли.бит_рлс_му_Специалист;
			флНЕСодержитМСФО    = НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольМСФОПолныеПрава) 
			                      И НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольСпециалистМСФО);
		Иначе	
			РольМСФОПолныеПрава = НЕОПРЕДЕЛЕНО;	
			РольСпециалистМСФО  = НЕОПРЕДЕЛЕНО;
			флНЕСодержитМСФО    = Истина;
		КонецЕсли;
		
		РольФинансист    = Метаданные.Роли.бит_рлс_Финансист;
		РольФинансистЦФО = Метаданные.Роли.бит_рлс_ФинансистЦФО;
		РольПолныеПрава  = Метаданные.Роли.ПолныеПрава;
		РольБухгалтерДоп = Метаданные.Роли.бит_БухгалтерДополнение;
		
		Если бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольБухгалтер) Тогда
			
			Если НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольПолныеПрава) 
				И НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольФинансист)
				И НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольФинансистЦФО)				
				И НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольБухгалтерДоп)	
				И флНЕСодержитМСФО
				И НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей, РольФинансистПолныеПрава) Тогда
				
				флУстановить = Истина;
				
			КонецЕсли; 
			
		КонецЕсли;	   
			
	КонецЕсли;
	
	Возврат флУстановить;		
	
КонецФункции // НеобходимоУстановитьРольБухгалтерДополнение()

// Функция определяет следует ли устанавливать роль бит_ФинансПользователь пользователю.
// 
// Параметры:
//  РолиПользователя - Коллекция ролей пользователя, Массив.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция НеобходимоУстановитьРольПользовательФинанс(РолиПользователя)  Экспорт
	
	флУстановить = Ложь;
	
	// Для общности вызовов преобразуем входящий параметр к массиву ОбъектовМетаданных.Роль.
	МассивРолей = СформироватьМассивРолей(РолиПользователя);
	
	// Роль бит_ФинансПользователь должна быть у всех кроме полных прав.
	РольПолныеПрава        = Метаданные.Роли.ПолныеПрава;
	РольПользовательФинанс = Метаданные.Роли.бит_ФинансПользователь;
	
	Если НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей,РольПолныеПрава) 
		И НЕ бит_РаботаСКоллекциямиКлиентСервер.МассивСодержит(МассивРолей,РольПользовательФинанс) Тогда
		
		флУстановить = Истина;
		
	КонецЕсли;	   
	
	Возврат флУстановить;		
	
КонецФункции // НеобходимоУстановитьРольБухгалтерДополнение()

#КонецОбласти

#Область НастройкиИУчетнаяПолитика

// Функция применяется при необходимости получить сведения об учетной политике организации.
// 
// Возвращаемое значение: 
//  Таблица значений. Таблица, каждая строка которой соответствует записи регистра. 
// 
Функция ЗаполнениеНастроекПрограммы() Экспорт
	
	Запрос = Новый Запрос();
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.бит_НастройкиПрограммы КАК УчетнаяПолитика";
	
	ТаблицаРезультат = Запрос.Выполнить().Выгрузить();
	ТаблицаРезультат.Сортировать("Период");
	
	Возврат ТаблицаРезультат;
	
КонецФункции // ЗаполнениеНастроекПрограммы();

// Функция применяется при необходимости получить сведения об учетной политике МСФО организации.
// 
// Возвращаемое значение - таблица значений. Таблица, каждая строка которой 
//  соответствует записи регистра. 
// 
Функция ЗаполнениеУчетнойПолитикиМУ() Экспорт
	
	Запрос = Новый Запрос();
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	*
	|ИЗ
	|	РегистрСведений.бит_му_УчетнаяПолитика КАК УчетнаяПолитика";
	
	ТаблицаРезультат = Запрос.Выполнить().Выгрузить();
	ТаблицаРезультат.Сортировать("Период");

	Возврат ТаблицаРезультат;
	
КонецФункции // ЗаполнениеУчетнойПолитикиМУ();

// Функция заполняет настройки режимов трансляции.
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция ЗаполнениеНастроекРежимовТрансляции() Экспорт
	
	Запрос = Новый Запрос();
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               | *
	               |ИЗ
	               |	РегистрСведений.бит_НастройкиРежимовТрансляции КАК бит_НастройкиРежимовТрансляции";
				   
    ТаблицаРезультат = Запрос.Выполнить().Выгрузить();
    ТаблицаРезультат.Сортировать("Период");

	Возврат ТаблицаРезультат;
	
КонецФункции // ЗаполнениеНастроекРежимовТрансляции()

// Функция заполняет таблицу дат начала открытого периода.
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция ЗаполнениеДатОткрытогоПериода()  Экспорт

    Если ЕстьМеханизмКонтроляЗакрытогоПериода() Тогда

        Запрос = Новый Запрос;

        Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
        |*
        |ИЗ
        |	РегистрСведений.бит_НачалоОткрытогоПериода КАК бит_му_НачалоОткрытогоПериода";

        ТаблицаРезультат = Запрос.Выполнить().Выгрузить();

    Иначе

        ТаблицаРезультат = Неопределено;

    КонецЕсли; 

    Возврат ТаблицаРезультат;

КонецФункции // ЗаполнениеДатОткрытогоПериода()

// Функция получает настройки программы на текущую дату.
// 
// Параметры:
//  ТекущаяДата              - Дата.
//  Отказ                    - Булево.
//  СтруктурноеПодразделение - СправочникСсылка.Организации,СправочникСсылка.бит_ЦФО.
//  РежимСообщений           - Строка: "Нет","Все","Ошибки".
//                
// Возвращаемое значение:
//  Соответствие.
// 
Функция ПолучитьНастройкиПрограммы(ТекущаяДата, Отказ = Ложь, СтруктураПараметров = Неопределено, РежимСообщений = "Все") Экспорт

	РезСоответствие = Новый Соответствие;
	
	Если НЕ ЗначениеЗаполнено(ТекущаяДата) Тогда	
		Возврат РезСоответствие;	
	КонецЕсли; 
	
	Если СтруктураПараметров = Неопределено Тогда	
		СтруктураПараметров = Новый Структура;	
	КонецЕсли; 
	
	ТаблицаДанныхВрем = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_НастройкиПрограммы");	
	
	// Получаем имя типа ЦФО.
	ИмяТипаЦФО = ПолучитьИмяТипаЦФО();
	
	// Получаем имя справочника ЦФО в зависимости от текущего решения.
	ИмяСправочникаЦФО = ПолучитьИмяСправочникаЦФО();
	
	ОписаниеТиповЗначенияНастройки = ТаблицаДанныхВрем.Колонки.ЗначениеНастройки.ТипЗначения;
	ИсключаемыеТипы = "NULL, Неопределено";
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	ТаблицаДанных.Колонки.Добавить("Период"                  , Новый ОписаниеТипов("Дата"));
	ТаблицаДанных.Колонки.Добавить("СтруктурноеПодразделение", Новый ОписаниеТипов("СправочникСсылка.Организации," + ИмяТипаЦФО + ",СправочникСсылка.бит_ГруппыСтруктурныхПодразделений,НЕОПРЕДЕЛЕНО"));
	ТаблицаДанных.Колонки.Добавить("Настройка"               , Новый ОписаниеТипов("ПланВидовХарактеристикСсылка.бит_НастройкиПрограммы"));
	ТаблицаДанных.Колонки.Добавить("ЗначениеНастройки"       , Новый ОписаниеТипов(ОписаниеТиповЗначенияНастройки, , ИсключаемыеТипы));
	
	Для каждого СтрокаТаблицы Из ТаблицаДанныхВрем Цикл	
		НоваяСтрока = ТаблицаДанных.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);	
	КонецЦикла;
	
	Организация = ПолучитьЗначениеИзСтруктуры(СтруктураПараметров, "Организация");
	ЦФО         = ПолучитьЗначениеИзСтруктуры(СтруктураПараметров, "ЦФО");
    
    Если НЕ ЗначениеЗаполнено(ЦФО) Тогда
	    // Значение по которому заведомо ничего не будет.
		ЦФО = 9999;
	КонецЕсли; 
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СтруктурноеПодразделение", Организация);
	Запрос.УстановитьПараметр("ЦФО"                     , ЦФО);
	
	Запрос.Текст =  
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	бит_ГруппыСтруктурныхПодразделенийСостав.Ссылка КАК Группа
	|ИЗ
	|	Справочник.бит_ГруппыСтруктурныхПодразделений.Состав КАК бит_ГруппыСтруктурныхПодразделенийСостав
	|ГДЕ
	|	(бит_ГруппыСтруктурныхПодразделенийСостав.СтруктурноеПодразделение = &СтруктурноеПодразделение
	|			ИЛИ бит_ГруппыСтруктурныхПодразделенийСостав.СтруктурноеПодразделение = &ЦФО)
	|	И (НЕ бит_ГруппыСтруктурныхПодразделенийСостав.Ссылка.ПометкаУдаления)";
					
	Результат = Запрос.Выполнить();
	МассивГрупп = Результат.Выгрузить().ВыгрузитьКолонку("Группа");
	
    Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТаблицаДанных"           , ТаблицаДанных);
	Запрос.УстановитьПараметр("ТекущаяДата"             , ТекущаяДата);
	Запрос.УстановитьПараметр("СтруктурноеПодразделение", Организация);
	Запрос.УстановитьПараметр("ЦФО"                     , ЦФО);
	Запрос.УстановитьПараметр("МассивГрупп"				, МассивГрупп);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ТаблицаДанных.Период,
	|	ТаблицаДанных.СтруктурноеПодразделение,
	|	ТаблицаДанных.Настройка,
	|	ТаблицаДанных.ЗначениеНастройки
	|ПОМЕСТИТЬ Настройки
	|ИЗ
	|	&ТаблицаДанных КАК ТаблицаДанных
	|ГДЕ
	|	(ТаблицаДанных.СтруктурноеПодразделение = &СтруктурноеПодразделение
	|			ИЛИ ТаблицаДанных.СтруктурноеПодразделение = &ЦФО
	|			ИЛИ ТаблицаДанных.СтруктурноеПодразделение В (&МассивГрупп)
	|			ИЛИ ТаблицаДанных.СтруктурноеПодразделение = НЕОПРЕДЕЛЕНО
	|			ИЛИ ТаблицаДанных.СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	|			ИЛИ ТаблицаДанных.СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаЦФО + ".ПустаяСсылка)
	|			ИЛИ ТаблицаДанных.СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.бит_ГруппыСтруктурныхПодразделений.ПустаяСсылка))
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Настройки.СтруктурноеПодразделение,
	|	Настройки.Настройка,
	|	МАКСИМУМ(Настройки.Период) КАК Период
	|ПОМЕСТИТЬ ТаблицаДат
	|ИЗ
	|	Настройки КАК Настройки
	|ГДЕ
	|	Настройки.Период <= &ТекущаяДата
	|
	|СГРУППИРОВАТЬ ПО
	|	Настройки.СтруктурноеПодразделение,
	|	Настройки.Настройка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаДат.Период,
	|	ТаблицаДат.СтруктурноеПодразделение,
	|	ТаблицаДат.Настройка КАК Настройка,
	|	Настройки.ЗначениеНастройки,
	|	ВЫБОР
	|		КОГДА Настройки.СтруктурноеПодразделение = НЕОПРЕДЕЛЕНО
	|				ИЛИ Настройки.СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	|				ИЛИ Настройки.СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник." + ИмяСправочникаЦФО + ".ПустаяСсылка)
	|				ИЛИ Настройки.СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.бит_ГруппыСтруктурныхПодразделений.ПустаяСсылка)
	|			ТОГДА 4
	|		КОГДА Настройки.СтруктурноеПодразделение ССЫЛКА Справочник.бит_ГруппыСтруктурныхПодразделений
	|			ТОГДА 3
	|		КОГДА Настройки.СтруктурноеПодразделение ССЫЛКА Справочник.Организации
	|			ТОГДА 2
	|		КОГДА Настройки.СтруктурноеПодразделение ССЫЛКА Справочник." + ИмяСправочникаЦФО + "
	|			ТОГДА 1
	|		ИНАЧЕ 1
	|	КОНЕЦ КАК Приоритет
	|ИЗ
	|	ТаблицаДат КАК ТаблицаДат
	|		ЛЕВОЕ СОЕДИНЕНИЕ Настройки КАК Настройки
	|		ПО ТаблицаДат.СтруктурноеПодразделение = Настройки.СтруктурноеПодразделение
	|			И ТаблицаДат.Настройка = Настройки.Настройка
	|			И ТаблицаДат.Период = Настройки.Период
	|
	|УПОРЯДОЧИТЬ ПО
	|	Приоритет
	|ИТОГИ ПО
	|	Настройка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ Настройки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ ТаблицаДат";
				   
	Результат = Запрос.Выполнить();
	
	ВыборкаНастройка = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ВыборкаНастройка.Следующий() Цикл
	
		Выборка = ВыборкаНастройка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Пока Выборка.Следующий() Цикл
			
		    РезСоответствие.Вставить(Выборка.Настройка,Выборка.ЗначениеНастройки);
			Прервать;
		
		КонецЦикла; 
	
	КонецЦикла;
	
	Возврат РезСоответствие;
    
КонецФункции // ПолучитьНастройкиПрограммы()

// Функция получает указанную настройку из соответствия настроек программы. 
// Если в соответствии указанной настройки нет возвращается пустое значение типа.
// 
// Параметры:
//  НастройкиПрограммы - Соответствие.
//  вхНастройка        - ПланыВидовХарактеристикСсылка.бит_НастройкиПрограммы, Строка.
// 
// Возвращаемое значение:
//  Произвольный.
// 
Функция ИзвлечьНастройкуПрограммы(НастройкиПрограммы,вхНастройка) Экспорт

	Если ТипЗнч(вхНастройка) = Тип("Строка") Тогда		
		Настройка = ПланыВидовХарактеристик.бит_НастройкиПрограммы[вхНастройка];		
	Иначе			
		Настройка = вхНастройка;		
	КонецЕсли; 
	
	РезЗначение = НастройкиПрограммы[Настройка];
	Если РезЗначение = Неопределено Тогда		
		РезЗначение = Настройка.ТипЗначения.ПривестиЗначение();		
	КонецЕсли; 

	Возврат РезЗначение;
	
КонецФункции // ПолучитьНастройкуПрограммы()

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Функция возвращает признак расчетов с поставщиками, покупателями.
// 
// Параметры:
//  ВидОперации - ПеречислениеСсылка.
// 
// Возвращаемое значение:
//  Булево. 
// 
Функция ЕстьРасчетыСПоставщикамиПокупателями(ВидОперации = Неопределено) Экспорт

	ЕстьРасчеты = ?(	ВидОперации = Перечисления.бит_ВидыОперацийЗаявкаНаРасходование.ОплатаПоставщику
					ИЛИ ВидОперации = Перечисления.бит_ВидыОперацийЗаявкаНаРасходование.ВозвратДенежныхСредствПокупателю
				   ,Истина
				   ,Ложь);

	Возврат ЕстьРасчеты;

КонецФункции // ЕстьРасчетыСПоставщикамиПокупателями()

// Функция возвращает массив вышестоящих групп указанного элемента.
// 
// Параметры:
//  Элемент - Элемент справочника, для которого ищется родитель.
// 
// Возвращаемое значение
//  Массив вышестоящих групп.
// 
Функция ПолучитьСписокВышеСтоящихГрупп(ЭлементСправочника) Экспорт
	
	Результат = Новый Массив;		
	
	Если НЕ ЗначениеЗаполнено(ЭлементСправочника) Тогда
		Возврат Результат;
	КонецЕсли;
	
	МетаданныеСправочника = ЭлементСправочника.Метаданные();
	Если НЕ МетаданныеСправочника.Иерархический Тогда
		Возврат Результат;
    КонецЕсли;
    
	ИмяСправочника = МетаданныеСправочника.Имя;	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";
	
	ТекущийЭлемент = ЭлементСправочника;
	
	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл		
		Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Для Индекс = 1 по 5 Цикл
				ТекущийЭлемент = Выборка["Родитель" + Индекс];
				Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда
					Результат.Добавить(ТекущийЭлемент);
				Иначе
					Прервать;
				КонецЕсли;				
			КонецЦикла;
		Иначе
			ТекущийЭлемент = Неопределено;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Результат;
	
КонецФункции // ПолучитьСписокВышеСтоящихГрупп()

// Функция получает массив типов которые может принимать элемент ПВХ.
//
// Параметры:
//  ЭлементПВХ.
//
Функция ПолучитьМассивТиповЭлементаПВХ(ЭлементПВХ) Экспорт
	
	Если ЗначениеЗаполнено(ЭлементПВХ) Тогда
		МассивТипов = ЭлементПВХ.ТипЗначения.Типы();
	Иначе
		МассивТипов = Новый Массив;
	КонецЕсли;
	
	Возврат МассивТипов;
	
КонецФункции // ПолучитьМассивТиповЭлементаПВХ()

// Функция является оберткой для метода платформы ПринадлежитЭлементу(). 
// Для безопасности вызова проверяется существование родительского объекта.
// 
// Параметры:
//  ТекущийОбъект      - СправочникСсылка,ПланСчетовСсылка,ПланВидовХарактеристикСсылка.
//  РодительскийОбъект - СправочникСсылка,ПланСчетовСсылка,ПланВидовХарактеристикСсылка.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ОбъектПодчинен(ТекущийОбъект,РодительскийОбъект) Экспорт

	ОбъектПодчинен = Ложь;
	
	Если ЗначениеЗаполнено(РодительскийОбъект) И ЗначениеЗаполнено(ТекущийОбъект) Тогда
		ОбъектПодчинен = ТекущийОбъект.ПринадлежитЭлементу(РодительскийОбъект) 
		                   ИЛИ ТекущийОбъект = РодительскийОбъект;
	КонецЕсли; 

	Возврат ОбъектПодчинен;
	
КонецФункции // ОбъектПодчинен()

// Функция является оберткой для метода платформы СтрЧислоВхождений().
// Выполняется без учета регистра.
//
// Параметры:
//  ИсходнаяСтрока	 - Строка - Исходная строка. 
//  ПодстрокаПоиска	 - Строка - Искомая подстрока.
// 
// Возвращаемое значение:
//  Содержит - булево. 
//
Функция Содержит(ИсходнаяСтрока, ПодстрокаПоиска) Экспорт

	Содержит = Ложь;
	
	Если ТипЗнч(ИсходнаяСтрока) = Тип("Строка") И ТипЗнч(ПодстрокаПоиска) = Тип("Строка") Тогда
		Содержит = СтрЧислоВхождений(Врег(ИсходнаяСтрока), Врег(ПодстрокаПоиска)) > 0;		
	КонецЕсли; 

	Возврат Содержит;
	
КонецФункции

// Функция является оберткой для метода платформы СтрНачинаетсяС().
// Выполняется без учета регистра.
//
// Параметры:
//  ИсходнаяСтрока	 - Строка - Исходная строка. 
//  ПодстрокаПоиска	 - Строка - Искомая подстрока.
// 
// Возвращаемое значение:
//  НачинаетсяС - булево. 
//
Функция НачинаетсяС(ИсходнаяСтрока, ПодстрокаПоиска) Экспорт

	НачинаетсяС = Ложь;
	
	Если ТипЗнч(ИсходнаяСтрока) = Тип("Строка") И ТипЗнч(ПодстрокаПоиска) = Тип("Строка") Тогда
		НачинаетсяС = СтрНачинаетсяС(Врег(ИсходнаяСтрока), Врег(ПодстрокаПоиска));		
	КонецЕсли; 

	Возврат НачинаетсяС;

КонецФункции

// Функция получает новое наименование для копии объекта.
// 
// Параметры:
//  СтароеНаименование - Строка.
//  МетаОбъект  	   - Метаданные объекта.
//  
// Возвращаемое значение:
//   Строка.
// 
Функция ПолучитьНаименованиеКопии(СтароеНаименование, МетаОбъект) Экспорт

	НовоеНаименование = СтароеНаименование + " - Копия";
	
	ОбъектСистемы = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(МетаОбъект);
	Если ОбъектСистемы <> Неопределено Тогда
		
		ИмяОбъектаПолное = ОбъектСистемы.ИмяОбъектаПолное;
	 	
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Наименование", НовоеНаименование + "%");
		Запрос.Текст = "
		|ВЫБРАТЬ
		|	ТаблицаОбъект.Наименование
		|ИЗ
		|	" + ИмяОбъектаПолное + " КАК ТаблицаОбъект
		|ГДЕ
		|	ТаблицаОбъект.Наименование ПОДОБНО &Наименование
		|";
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			
			Выборка = Результат.Выбрать();
			СписокСч = Новый СписокЗначений;
			Пока Выборка.Следующий() Цикл
				
				НаименованиеСч = СтрЗаменить(Выборка.Наименование, НовоеНаименование, "");
				Если ЗначениеЗаполнено(НаименованиеСч) Тогда
					Если Лев(НаименованиеСч, 2) = " (" И Прав(НаименованиеСч, 1) = ")" Тогда
						Попытка	
							НаименованиеСч = Сред(НаименованиеСч, 3, СтрДлина(НаименованиеСч)-3);
							Счетчик = Число(НаименованиеСч); 										
						Исключение
						    Счетчик = 0;
						КонецПопытки;
						Если Счетчик <> 0 Тогда
							СписокСч.Добавить(Счетчик);
						КонецЕсли;									
					КонецЕсли;
				Иначе	
					СписокСч.Добавить(1);
				КонецЕсли;
			
			КонецЦикла;
			
			СписокСч.СортироватьПоЗначению();
			Для i = 2 По СписокСч.Количество() + 1 Цикл
				Если СписокСч.НайтиПоЗначению(i) = Неопределено Тогда
					Постфикс = " (" + Строка(i) + ")";
					НовоеНаименование = НовоеНаименование + Постфикс;
					Прервать;
				КонецЕсли;  			
			КонецЦикла;
		
		КонецЕсли; 
	
	КонецЕсли;					
						
	Возврат НовоеНаименование;
	
КонецФункции // ПолучитьНаименованиеКопии()

// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
// 
// Параметры:
//  ТекстXML - Текст в формате XML.
//      Схема XML:
// 			<?xml version="1.0" encoding="utf-8"?>
// 			<xs:schema attributeFormDefault="unqualified" 
// 						elementFormDefault="qualified" xmlns:xs="http:// www.w3.org/2001/XMLSchema">
//			  <xs:element name="Items">
//			 	<xs:complexType>
// 				  <xs:sequence>
// 					<xs:element maxOccurs="unbounded" name="Item">
// 					  <xs:complexType>
// 						<xs:attribute name="Code" type="xs:integer" use="required" />
// 						<xs:attribute name="Name" type="xs:string" use="required" />
// 						<xs:attribute name="Socr" type="xs:string" use="required" />
// 						<xs:attribute name="Index" type="xs:string" use="required" />
// 					  </xs:complexType>
// 					</xs:element>
// 				  </xs:sequence>
// 				  <xs:attribute name="Description" type="xs:string" use="required" />
// 				  <xs:attribute name="Columns" type="xs:string" use="required" />
// 				</xs:complexType>
// 			 </xs:element>
//			 </xs:schema> 
//      Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(РегистрыСведений.АдресныйКлассификатор.
//       ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст());
// 
// Возвращаемое значение:
//  ТаблицаЗначений.
// 
Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат.
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Функция выполняет поиск ссылочного значения в базе по УникальномуИдентификатору.
// 
// Параметры:
//  СтрИмена - Структура.
//  ИД       - Строка.
// 
// Возвращаемое значение:
//  Произвольный.
// 
Функция НайтиСсылкуПоИД(СтрИмена, ИД) Экспорт

	Менеджер        = бит_ОбщегоНазначения.ПолучитьМенеджер(СтрИмена.ИмяКоллекции, СтрИмена.ИмяОбъекта);
	НайденнаяСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(ИД));

	Возврат НайденнаяСсылка;
	
КонецФункции // НайтиСсылкуПоИД()

// Функция преобразует данные в формат JSON.
// 
// Параметры:
//  Данные - Произвольный.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция JSON_Stringify(Данные) Экспорт

	СтрДанные = "";
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		
		СтрДанные = СтрДанные + "[";
		
		Сч = 0;
		Для каждого Элемент Из Данные Цикл			
			СтрДанные = СтрДанные + ?(Сч > 0, ",", "") + Символы.ПС + JSON_Stringify(Элемент);			
			Сч = Сч + 1;
		КонецЦикла; 
		
		СтрДанные = СтрДанные+Символы.ПС+"]";
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура") 
		ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда	
		
		СтрДанные = СтрДанные + "{";
		
		Сч = 0;
		Для каждого КиЗ Из Данные Цикл		
			СтрДанные = СтрДанные + ?(Сч > 0, ",", "") + Символы.ПС + """" + КиЗ.Ключ + """:" + JSON_Stringify(КиЗ.Значение);			
		    Сч = Сч + 1;	
		КонецЦикла; 
		
		СтрДанные = СтрДанные + Символы.ПС+ "}";
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Число") Тогда
		
		СтрДанные = СтрДанные + Формат(Данные, "ЧРД=.; ЧН=0; ЧГ=");
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Булево") Тогда
		
		СтрДанные = СтрДанные + Формат(Данные, "БЛ=false; БИ=true");
		
	Иначе 
		
		ТекСтрДанные = Строка(Данные);
		ТекСтрДанные = СтрЗаменить(ТекСтрДанные, "\", "\\");				
		ТекСтрДанные = СтрЗаменить(ТекСтрДанные, """", "\""");
		СтрДанные = СтрДанные + """" + ТекСтрДанные + """";
		
	КонецЕсли; 

	СтрДанные = СтрЗаменить(СтрДанные, Символы.ПС, "");
	
	Возврат СтрДанные;
	
КонецФункции // JSON_Stringify()

// Функция.
// 
// Параметры:
//  ВхСтрока - Строка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция JSON_Parse(ВхСтрока) Экспорт
	
	МассивСтрок  = бит_СтрокиКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВхСтрока, Символы.ПС);
	РезДанные    = Неопределено;
	ТекПриемник  = Неопределено;
	Приемники    = Новый Массив;
    
	Для каждого ТекСтрока Из МассивСтрок Цикл
		
		ПервыйСимвол = Лев(СокрЛП(ТекСтрока),1);
		Если ПервыйСимвол = "[" Тогда
			
			ТекПриемник = Новый Массив;
			Приемники.Добавить(ТекПриемник);
			
		ИначеЕсли ПервыйСимвол = "]" Тогда
			
			КолПр = Приемники.Количество();
			Если КолПр > 1 Тогда
				
				ПрРодитель = Приемники[КолПр - 2];
				
				Если ТипЗнч(ПрРодитель) = Тип("Массив") Тогда
					
					ПрРодитель.Добавить(ТекПриемник);
					
				ИначеЕсли ТипЗнч(ПрРодитель) = Тип("Структура") Тогда
					
					Для Каждого КиЗ ИЗ ПрРодитель Цикл
						
						Если КиЗ.Значение = "PropertyForCollection" Тогда							
							ПрРодитель[КиЗ.Ключ] = ТекПриемник;							
						КонецЕсли;	
						
					КонецЦикла;	
					
                КонецЕсли;
                
				Приемники.Удалить(Приемники.ВГраница());
				ТекПриемник = Приемники[Приемники.ВГраница()];	
                
			КонецЕсли;			
			
		ИначеЕсли ПервыйСимвол = "{" Тогда	
			
			ТекПриемник = Новый Структура;
			Приемники.Добавить(ТекПриемник);
			
		ИначеЕсли ПервыйСимвол = "}" Тогда	
			
			КолПр = Приемники.Количество();
			Если КолПр > 1 Тогда
				
				ПрРодитель = Приемники[КолПр - 2];				
				Если ТипЗнч(ПрРодитель) = Тип("Массив") Тогда					
					ПрРодитель.Добавить(ТекПриемник);					
				КонецЕсли; 
				Приемники.Удалить(Приемники.ВГраница());
				ТекПриемник = Приемники[Приемники.ВГраница()];
                
			КонецЕсли;
			
		Иначе
			
			// Значение.
			ПозРазделитель = Найти(ТекСтрока, ":");
			Если ПозРазделитель > 0 Тогда
				
				Имя = Лев(ТекСтрока,ПозРазделитель - 1);
				Имя = СокрЛП(Имя);
				Имя = СтрЗаменить(Имя, """", "");
				
				ЗнчСтр = СокрЛП(Сред(ТекСтрока, ПозРазделитель + 1));
                
                Если Лев(ЗнчСтр,1) = """" Тогда				
					ЗнчСтр = Сред(ЗнчСтр, 2);				
                КонецЕсли; 
                
				Если Прав(ЗнчСтр, 1) = "," Тогда				
					ЗнчСтр = Сред(ЗнчСтр, 1, СтрДлина(ЗнчСтр) - 1);				
				КонецЕсли; 				
                
                Если Прав(ЗнчСтр, 1) = """" Тогда				
					ЗнчСтр = Сред(ЗнчСтр, 1, СтрДлина(ЗнчСтр) - 1);				
				КонецЕсли; 
				
				Если Лев(ЗнчСтр,1) = "[" Тогда
					
					ТекПриемник.Вставить(Имя, "PropertyForCollection");
					ТекПриемник = Новый Массив;
					Приемники.Добавить(ТекПриемник);					
					
				Иначе
					
					ТекПриемник.Вставить(Имя, ЗнчСтр);
					
				КонецЕсли;	
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	РезДанные = Приемники[0];
	Возврат РезДанные;
	
КонецФункции // JSON_Parse()

// Функция определяет режимы вывода сообщений.
// 
// Параметры:
//  РежимСообщений - Строка - "Нет","Все","Ошибки".
// 
// Возвращаемое значение:
//  Структура.
// 
Функция ОпределитьРежимыВывода(РежимСообщений) Экспорт

	РежимыВывода       = Новый Структура("ВыводитьОшибки,ВыводитьИнформацию");
	
	РежимыВывода.ВыводитьОшибки     = ВРег(РежимСообщений)= ВРег("Все") ИЛИ ВРег(РежимСообщений) = ВРег("Ошибки");
	РежимыВывода.ВыводитьИнформацию = ВРег(РежимСообщений)= ВРег("Все");

	Возврат РежимыВывода;
	
КонецФункции // ОпределитьРежимВывода()

// Функция проверяет наличие измененных реквизитов у объекта 
// и возвращает структуру с этими измененными реквизитами.
// 
// Параметры:
//  Объект  - ДокументОбъект, СправочникОбъект - объект, у которого
// 			  проверяется наличе измененных реквизитов. 
//  СтруктураРеквизитов  - Структура - структура с реквизитами,
//                 		   которые нужно проверить.
// 	ВыводитьСообщения	 - Булево - Истина, если нужно сообщать 
// 						   об измененных реквизитах, в противном случае - Ложь.
// 
// Возвращаемое значение:
//   Стуктура   - Структура с измененными реквизитами. 
// 	  			  Если реквизитов нет, то возвращается Неопределено.
// 
Функция ПолучитьСтруктуруИзмененныхРеквизитовОбъекта(Объект, СтруктураРеквизитов, ВыводитьСообщения = Ложь) Экспорт
	
	// Создаем структуру для измененных реквизитов.
	СтруктураИзмененнныхРеквизитов = Новый Структура;
	
	Для Каждого Реквизит Из СтруктураРеквизитов Цикл
		
		// Если реквизит изменен
		Если Не Объект[Реквизит.Ключ] = Объект.Ссылка[Реквизит.Ключ] Тогда
			
			// Добавляем измененный реквизит в соответствующую структуру.
			СтруктураИзмененнныхРеквизитов.Вставить(Реквизит.Ключ, Объект.Метаданные().Реквизиты[Реквизит.Ключ].Синоним);
			
			Если ВыводитьСообщения Тогда
				
				ТекстСообщения = НСтр("ru='Реквизит ""%1%"" был изменен!'");
				ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения,Объект.Метаданные().Реквизиты[Реквизит.Ключ].Синоним);
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
				
			КонецЕсли;	
			
		КонецЕсли;	
		
	КонецЦикла;
	
	// Если есть измененнные реквизиты, то возвращаем структуру, в противном случае Неопределено.
	Если СтруктураИзмененнныхРеквизитов.Количество() > 0 Тогда		
		Возврат СтруктураИзмененнныхРеквизитов;		
	Иначе		
		Возврат Неопределено;		
	КонецЕсли;	

КонецФункции // ПолучитьСтруктуруИзмененныхРеквизитовОбъекта()

// Функция получает значение реквизита объекта по имени объекта.
// 
// Параметры:
//  ТекущийОбъект - ДокументОбъект, СправочникОбъект.
//  ИмяРеквизита  - Строка.
// 
// Возвращаемое значение:
//  Строка.
// 
Функция ПолучитьЗначениеРеквизитаОбъекта(ТекущийОбъект, ИмяРеквизита) Экспорт
	
	ЗначениеРеквизита = Неопределено;	
	
	МетаданныеОбъекта = ТекущийОбъект.Метаданные();
	Если бит_РаботаСМетаданными.ЕстьРеквизит(ИмяРеквизита, МетаданныеОбъекта) Тогда		
		ЗначениеРеквизита = ТекущийОбъект[ИмяРеквизита];		
	КонецЕсли; 	
	
	Возврат ЗначениеРеквизита;

КонецФункции // ПолучитьЗначениеРеквизитаОбъекта()

// Функция получает значение из структуры. Выполняется проверка на наличие свойства с заданным именем.
// 
// Параметры:
//  СтруктураПараметров - Структура.
//  ИмяСвойства         - Строка.
// 
// Возвращаемое значение:
//   Произвольный.
// 
Функция ПолучитьЗначениеИзСтруктуры(СтруктураПараметров, ИмяСвойства) Экспорт

	Если ТипЗнч(СтруктураПараметров) = Тип("Структура") И СтруктураПараметров.Свойство(ИмяСвойства) Тогда
		РезЗначение = СтруктураПараметров[ИмяСвойства];
	Иначе	
		РезЗначение = Неопределено;
	КонецЕсли; 

     Возврат РезЗначение;
	 
 КонецФункции // ПолучитьЗначениеИзСтруктуры()
 
// Функция определяет есть подчиненные документы у данного или нет.
// 
// Параметры:
//  ДокументОснование        - ДокументСсылка.
//  ИмяПодчиненногоДокумента - Строка.
//  УсловиеПроведен          - Строка - "Все","Проведен","НеПроведен".
// 
// Возвращаемое значение:
//  Булево
// 
Функция ЕстьПодчиненныеДокументы(ДокументОснование, ИмяПодчиненногоДокумента, УсловиеПроведен = "Все") Экспорт

	ЕстьДокументы = Ложь;
	
	Если УсловиеПроведен = "Проведен" Тогда
		ТекстПроведен = "ПодчиненныйДокумент.Проведен";
	ИначеЕсли УсловиеПроведен = "НеПроведен" Тогда
		ТекстПроведен = "НЕ ПодчиненныйДокумент.Проведен";
	Иначе
		ТекстПроведен = "ИСТИНА";
	КонецЕсли; 
	
	ТекстЗапроса =  
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПодчиненныйДокумент.Ссылка КАК Ссылка
	|ИЗ
	|	#Таблица КАК ПодчиненныйДокумент
	|ГДЕ
	|	ПодчиненныйДокумент.ДокументОснование = &ДокументОснование
	|	И &ДокументПроведен";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#Таблица", "Документ." + ИмяПодчиненногоДокумента);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДокументПроведен", ТекстПроведен);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("ДокументОснование",ДокументОснование);
	
	Результат = Запрос.Выполнить();
	Если НЕ Результат.Пустой() Тогда
		ЕстьДокументы = Истина;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
    Возврат ЕстьДокументы;
    
КонецФункции // ЕстьПодчиненныеДокументы()
  
// Функция выполняет поиск подчиненных документов у данного.
// 
// Параметры:
//  ДокументОснование        - ДокументСсылка.
//  ИмяПодчиненногоДокумента - Строка.
//  УсловиеПроведен          - Строка - "Все","Проведен","НеПроведен".
// 
// Возвращаемое значение:
//  Массив
// 
Функция НайтиПодчиненныеДокументы(ДокументОснование, ИмяПодчиненногоДокумента, УсловиеПроведен = "Все") Экспорт

	МассивДокументов = Новый Массив;
	
	Если УсловиеПроведен = "Проведен" Тогда
		ТекстПроведен = "ПодчиненныйДокумент.Проведен";
	ИначеЕсли УсловиеПроведен = "НеПроведен" Тогда
		ТекстПроведен = "НЕ ПодчиненныйДокумент.Проведен";
	Иначе
		ТекстПроведен = "ИСТИНА";
	КонецЕсли; 
	
	ТекстЗапроса =  
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ПодчиненныйДокумент.Ссылка КАК Ссылка
	|ИЗ
	|	#Таблица КАК ПодчиненныйДокумент
	|ГДЕ
	|	ПодчиненныйДокумент.ДокументОснование = &ДокументОснование
	|	И &ДокументПроведен";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#Таблица", "Документ." + ИмяПодчиненногоДокумента);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДокументПроведен", ТекстПроведен);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("ДокументОснование",ДокументОснование);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл	
		МассивДокументов.Добавить(Выборка.Ссылка);	
	КонецЦикла;  				   
	
    Возврат МассивДокументов;
	
КонецФункции // НайтиПодчиненныеДокументы()
 
// Функция формирует массив видов операций документов по движению денежных средств, 
// которые формируются в валюте документа, т.е. валюта взаиморасчетов не заполняется.
// 
// 
// Возвращаемое значение:
//  Массив.
// 
Функция СформироватьМассивВидовОперацийВВалютеДокумента() Экспорт

	МассивОпераций = Новый Массив;
		
    // Списание с расчетного счета.
    МассивОпераций.Добавить(Перечисления.ВидыОперацийСписаниеДенежныхСредств.ПрочееСписание);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийСписаниеДенежныхСредств.ПеречислениеНалога);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийСписаниеДенежныхСредств.ПереводНаДругойСчет);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийСписаниеДенежныхСредств.ПеречислениеПодотчетномуЛицу);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийСписаниеДенежныхСредств.ПеречислениеЗП);
    
    // Поступление на расчетный счет.
    МассивОпераций.Добавить(Перечисления.ВидыОперацийПоступлениеДенежныхСредств.ПрочееПоступление);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийПоступлениеДенежныхСредств.Инкассация);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийПоступлениеДенежныхСредств.ПриобретениеИностраннойВалюты);	  
    
    // ПКО.
    МассивОпераций.Добавить(Перечисления.ВидыОперацийПКО.РозничнаяВыручка);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийПКО.ВозвратОтПодотчетногоЛица);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийПКО.ПолучениеНаличныхВБанке);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийПКО.ПрочийПриход);
    
    // РКО.
    МассивОпераций.Добавить(Перечисления.ВидыОперацийРКО.ВыдачаПодотчетномуЛицу);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийРКО.ВыплатаЗаработнойПлатыПоВедомостям);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийРКО.ВыплатаЗаработнойПлатыРаботнику);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийРКО.ВзносНаличнымиВБанк);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийРКО.Инкассация);
    МассивОпераций.Добавить(Перечисления.ВидыОперацийРКО.ВыплатаДепонентов);	  
    МассивОпераций.Добавить(Перечисления.ВидыОперацийРКО.ПрочийРасход);
			
	Возврат МассивОпераций;
	
КонецФункции // СформироватьМассивВидовОперацийВВалютеДокумента()

// Процедура устанавливает в Приемник свойство из структуры.
// 
// Параметры:
//  Приемник            - Произвольный - должен содержать свойство с заданными именем.
//  СтруктураИсточник   - Структура.
//  ИмяСвойства         - Строка.
//  ИмяСвойстваПриемник - Строка.
// 
Процедура УстановитьСвойствоИзСтруктуры(Приемник,СтруктураИсточник, ИмяСвойства, ИмяСвойстваПриемник="") Экспорт

    Если СтруктураИсточник.Свойство(ИмяСвойства) Тогда

        ИмяВПриемнике = ?(ПустаяСтрока(ИмяСвойстваПриемник),ИмяСвойства,ИмяСвойстваПриемник); 

        Приемник[ИмяВПриемнике] = СтруктураИсточник[ИмяСвойства];

    КонецЕсли; 	

КонецПроцедуры // УстановитьСвойствоИзСтруктуры()

// Процедура записывает историю изменения реквизитов в регистр сведений бит_ИсторияРедактированияРеквизитов.
// 
// Параметры:
//  ТекОбъект     - ЛюбаяСсылка.
//  ТекПериод     - Дата- Дата установки новых значений.
//  СтруктураИмен - Структура - Структура с именами "периодических" реквизитов. Ключ соответствует имени реквизита.
// 
Процедура ЗаписатьИзмененияРеквизитов(ТекОбъект,ТекПериод,СтруктураИмен) Экспорт
 
    Запрос = Новый Запрос;
    Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
    |	бит_ИсторияРедактированияРеквизитовСрезПоследних.ИмяРеквизита,
    |	бит_ИсторияРедактированияРеквизитовСрезПоследних.ЗначениеРеквизита
    |ИЗ
    |	РегистрСведений.бит_ИсторияРедактированияРеквизитов.СрезПоследних(&ДатаЗапроса, Объект = &ТекСсылка) КАК бит_ИсторияРедактированияРеквизитовСрезПоследних";

    Запрос.УстановитьПараметр("ДатаЗапроса",ТекПериод);
    Запрос.УстановитьПараметр("ТекСсылка"  ,ТекОбъект.Ссылка);
    ТаблицаУстановленных = Запрос.Выполнить().Выгрузить();	 

    Для каждого КлючИЗначение Из СтруктураИмен Цикл

        НайденнаяСтрока = ТаблицаУстановленных.Найти(КлючИЗначение.Ключ,"ИмяРеквизита");
        Если НайденнаяСтрока = Неопределено Тогда
            ПериодЗаписи = '19800101';
        Иначе	
            ПериодЗаписи = ТекПериод;
            Если ТекОбъект[КлючИЗначение.Ключ] = НайденнаяСтрока.ЗначениеРеквизита  Тогда
                Продолжить;
            КонецЕсли; 
        КонецЕсли; 

        МенеджерЗаписи = РегистрыСведений.бит_ИсторияРедактированияРеквизитов.СоздатьМенеджерЗаписи();
        МенеджерЗаписи.Период            = ПериодЗаписи;
        МенеджерЗаписи.Объект            = ТекОбъект.Ссылка;
        МенеджерЗаписи.ИмяРеквизита      = КлючИЗначение.Ключ;
        МенеджерЗаписи.ЗначениеРеквизита = ТекОбъект[КлючИЗначение.Ключ];
        МенеджерЗаписи.Пользователь      = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("глТекущийПользователь");

        Попытка
            МенеджерЗаписи.Записать();
            Исключение
            бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение("Не удалось записать историю изменения реквизитов : " + ОписаниеОшибки());
            Отказ = Истина;
        КонецПопытки;		 

    КонецЦикла; 	 

КонецПроцедуры // ЗаписатьИзмененияРеквизитов()

// Процедура переключает активность движений в регистрах бухгалтерии и накопления.
// 
// Параметры:
//  ДокументСсылка     - ДокументСсылка.
//  МассивДляОбработки - Массив.
// 
Процедура ПереключитьАктивностьДвижений(ДокументСсылка,МассивДляОбработки) Экспорт

	Если ДокументСсылка.ПометкаУдаления Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеДокумента = ДокументСсылка.Метаданные();
	
	Для каждого МетаРегистр Из МассивДляОбработки Цикл
		
		// Проверим участвует ли данный регистр в движениях документа.
		Если НЕ МетаданныеДокумента.Движения.Содержит(МетаРегистр) Тогда		
			 Продолжить;		
		КонецЕсли; 
		
		ИмяРегистра = МетаРегистр.Имя;
		Если ОбъектПринадлежитКоллекцииМетаданных("РегистрыБухгалтерии", ИмяРегистра) Тогда			
			НаборЗаписей = РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();			
		ИначеЕсли ОбъектПринадлежитКоллекцииМетаданных("РегистрыНакопления", ИмяРегистра) Тогда			
			НаборЗаписей = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();			
		Иначе				
			Продолжить;			
		КонецЕсли; 
		
		НаборЗаписей.Отбор.Регистратор.Установить(ДокументСсылка);
		НаборЗаписей.Прочитать();
		
		КоличествоПроводок = НаборЗаписей.Количество();
		Если НЕ (КоличествоПроводок = 0) Тогда
			
			// Определяем текущую активность проводок по первой проводке.
			ТекущаяАктивность = НаборЗаписей[0].Активность;
			
			// Инвертируем текущую активность проводок.
			НаборЗаписей.УстановитьАктивность(НЕ ТекущаяАктивность);
			НаборЗаписей.Записать();
			
		КонецЕсли;
		
	КонецЦикла;  // По массиву обработки.

КонецПроцедуры // ПереключитьАктивностьДвижений()

// Процедура выполняет синхронизацию свойств в Источнике и Приемнике.
// 
// Параметры:
//  КонтейнерИсточник  - Произвольный - должен содержать свойства, указанные в структуре.
//  Приемник           - Произвольный - должен содержать свойства, указанные в структуре.
//  СтруктураСвойств   - Структура - Ключ: имя в Источник, Значение: имя в Приемнике.
//  Режим              - Строка - "Безусловно".
// 
Процедура СинхронизироватьСвойстваКонтейнера(КонтейнерИсточник, Приемник, СтруктураСвойств, Режим = "") Экспорт

	Если КонтейнерИсточник = Неопределено Тогда	 
		 Возврат;	
    КонецЕсли; 
	 
	Если Приемник = Неопределено Тогда	
		 КонтейнерПриемник = КонтейнерИсточник;		 
	Иначе		 
		 КонтейнерПриемник = Приемник;	
	КонецЕсли;  
	
	Для каждого КиЗ Из СтруктураСвойств Цикл
		
		ИмяИсточник = КиЗ.Ключ;
		ИмяПриемник = КиЗ.Значение;
		
		ЗначениеИсточник = КонтейнерИсточник[ИмяИсточник];
		ЗначениеПриемник = КонтейнерИсточник[ИмяПриемник];
		
		Если ВРЕГ(Режим) = ВРЕГ("Безусловно") Тогда
            
            КонтейнерПриемник[ИмяПриемник] = ЗначениеИсточник;
            
        Иначе
            
            Если ЗначениеЗаполнено(ЗначениеИсточник) 
				И НЕ ЗначениеЗаполнено(ЗначениеПриемник) Тогда
				
				КонтейнерПриемник[ИмяПриемник] = ЗначениеИсточник;
				
            КонецЕсли; // Проверка заполнения.
            
		КонецЕсли; // проверка режима.		
		
	КонецЦикла; // По синхронизируемым реквизитам.		

КонецПроцедуры // СинхронизироватьСвойстваКонтейнера()

// Функция получает итог таблицы, с возможностью указания отбора.
// 
// Параметры:
//  Таблица    - ТабличнаяЧасть, ТаблицаЗначений.
//  ИмяКолонки - Строка, по которым необходимо получить итог.
//  ОтборСтрок - Отбор, по умолчанию Неопределено.
// 
// Возвращаемое значение:
//  Число.
// 
Функция ИтогТаблицыСОтбором(Таблица, ИмяКолонки, ОтборСтрок = Неопределено) Экспорт
	
    СуммаИтога 		= 0;
	СтруктураОтбора = Новый Структура;
	
	// Если указан отбор, тогда сформируем структуру отбора.
	Если ОтборСтрок <> Неопределено Тогда
		
		Для Каждого ЭлементОтбора Из ОтборСтрок Цикл
			
			Если ЭлементОтбора.Использование Тогда
				СтруктураОтбора.Вставить(ЭлементОтбора.Имя, ЭлементОтбора.Значение);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;

    Если СтруктураОтбора.Количество() = 0 Тогда
        
		СуммаИтога = Таблица.Итог(ИмяКолонки);
        
	Иначе
		
		НайденныеСтроки = Таблица.НайтиСтроки(СтруктураОтбора);
		
		Для Каждого ТекСтрока Из НайденныеСтроки Цикл
			СуммаИтога = СуммаИтога + ТекСтрока[ИмяКолонки];
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СуммаИтога;
	
КонецФункции // ИтогТаблицыСОтбором()

// Функция определяет следует ли проверять актуальность параметров сеанса для текущего пользователя.
// 
// Возвращаемое значение:
//  Булево
// 
Функция НеобходимоПроверятьАктуальностьКэшаПараметров()  Экспорт

	флНеобходимо = Ложь;
	
	Если Константы.бит_ИнтервалПроверкиАктуальностиКэшаНастроек.Получить() >0 Тогда
		
		Если НЕ РольДоступна(Метаданные.Роли.ПолныеПрава) 
			 И (РольДоступнаРлс("ИсполнительКазначейства") 
				ИЛИ РольДоступнаРлс("Финансист")) Тогда
		
			флНеобходимо = Истина;
		
		КонецЕсли; 		
		
	КонецЕсли;
		
	Возврат флНеобходимо;
	
КонецФункции // НеобходимоПроверятьАктуальностьКэшаПараметров()

// Функция получает значение переменной (параметра) из глобального Кэша.
// 
// Параметры:
//  Имя - Строка. Имя получаемой переменной (параметра).
// 
// Возвращаемое значение:
//  Произвольный.
// 
Функция ПолучитьЗначениеПеременной(Имя) Экспорт
	
	ПолученноеЗначение = бит_ОбщиеПеременныеСервер.ЗначениеПеременной(Имя);
	
	Возврат ПолученноеЗначение;
	
КонецФункции // ПолучитьЗначениеПеременной()

// Функция пересчитывает сумму из исходной валюты в новую валюту.
// 
// Параметры:
// 	Сумма          - Число.
//  ИсходнаяВалюта - СправочникСсылка.Валюты.
//  НоваяВалюта    - СправочникСсылка.Валюты.
//  Дата           - Дата.
// 
// Возвращаемое значение:
//  Число.
// 
Функция ПересчитатьВВалюту(Знач Сумма, Знач ИсходнаяВалюта, Знач НоваяВалюта, Знач Дата) Экспорт
	
	Если ЗначениеЗаполнено(ИсходнаяВалюта) 
		И ЗначениеЗаполнено(НоваяВалюта) Тогда
	
		СтруктураКурсыИсходнаяВалюта = бит_КурсыВалют.ПолучитьКурсВалюты(ИсходнаяВалюта, Дата);
		СтруктураКурсыНоваяВалюта = бит_КурсыВалют.ПолучитьКурсВалюты(НоваяВалюта, Дата);
		
		Возврат бит_КурсыВалютКлиентСервер.ПересчитатьПоВалюте(Сумма, СтруктураКурсыИсходнаяВалюта, СтруктураКурсыНоваяВалюта);
		
    Иначе	
        
		Возврат Сумма;
        
	КонецЕсли; 
		
КонецФункции // ПересчитатьВВалюту()

// Проверяет доступность реквизита выбранной версии продукта и формы констант.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЕстьДоступНаИзменениеВерсииПродукта() Экспорт
	
	Возврат ПравоДоступа("Изменение", Метаданные.Константы.бит_ТекущаяВерсияПродукта) И 
		ПравоДоступа("Просмотр", Метаданные.ОбщиеФормы.бит_КонстантыУправляемая);
		
КонецФункции // ЕстьДоступНаИзменениеВерсииПродукта()

#КонецОбласти

#Область УстановкаОтключениеМонопольногоРежима

// Процедура устанавливает монопольный режим. 
// 
// Параметры:
//  флВыполнять - Булево.
// 
Процедура УстановкаМонопольногоРежима(флВыполнять, ВключенМеханизмПрав) Экспорт 

	БазоваяПоставка = (Найти(ВРег(Метаданные.Имя), "БАЗОВАЯ") > 0);

	// Установка монопольного режима для обновления информационной базы.
	Если НЕ БазоваяПоставка Тогда
	
		Попытка
			УстановитьМонопольныйРежим(Истина);
		Исключение
			ТекстСообщения =  НСтр("ru = 'Не удалось установить монопольный режим. Описание ошибки: %1%. Работа системы будет завершена.'");
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, Строка(ОписаниеОшибки()));
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
			флВыполнять = Ложь;
			
		КонецПопытки;
	
	КонецЕсли; 
	
	Если флВыполнять Тогда
		
		// Если включен режим разделения доступа на уровне базы его необходимо выключить на период обновления.
		Если Константы.бит_ИспользоватьРазделениеДоступаНаУровнеБазы.Получить() Тогда
			ВключенМеханизмПрав = Истина;
			Константы.бит_ИспользоватьРазделениеДоступаНаУровнеБазы.Установить(Ложь);
		КонецЕсли; 
		
	КонецЕсли;	
	
КонецПроцедуры // УстановкаМонопольногоРежима()

// Процедура отключает монопольный режим. 
// 
// Параметры:
//  флВыполнять - Булево.
// 
Процедура ОтключениеМонопольногоРежима(флВыполнять, ВключенМеханизмПрав) Экспорт 
	
	БазоваяПоставка = (Найти(ВРег(Метаданные.Имя), "БАЗОВАЯ") > 0);
	
	Если флВыполнять Тогда
				
		// Механизм прав был выключен на период обновления - следует его включить.
		Если ВключенМеханизмПрав Тогда
			Константы.бит_ИспользоватьРазделениеДоступаНаУровнеБазы.Установить(Истина);
		КонецЕсли;
		
	КонецЕсли; 

	// Откючение монопольного режима.
	Если НЕ БазоваяПоставка Тогда
		УстановитьМонопольныйРежим(Ложь);
	КонецЕсли; 	
	
КонецПроцедуры // ОтключениеМонопольногоРежима()
	
#КонецОбласти 

#Область РучнаяКорректировкаФакта

// Обработчик подписки "бит_ПередЗаписьюДокументаРучнаяКорректировкаФактаБП".
// Процедура выполняет действия для ручной корректировки факта перед записью документа.
// 
Процедура ПередЗаписьюДокументаРучнаяКорректировкаФакта(Источник, Отказ, РежимЗаписи, РежимПроведения)	Экспорт

	Если Источник.ОбменДанными.Загрузка Тогда
    	Возврат;
	КонецЕсли;
	
	Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_ЭтоЧужойПодчиненныйУзел") = Истина Тогда
		Возврат;
	КонецЕсли; 		

	Если НЕ ЭтоСемействоБП() Тогда
	     Возврат;
	КонецЕсли; 
	 
	Если ТипЗнч(Источник) = Тип("ДокументОбъект.РегламентнаяОперация") ИЛИ ТипЗнч(Источник) = Тип("ДокументОбъект.ОперацияБух") Тогда
	    Возврат;
	ИначеЕсли НЕ РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда 
		Возврат;
	КонецЕсли; 
 
	МетаданныеОбъекта   = Источник.Метаданные();	
	
	// Чтение данных проводок документа необходимо осуществлять 
	// в привилегирированном режиме, т.к. возможно чтение регистров с запретом RLS.
	// см. Обработка.КорректировкаДвижений.ОсновнаяФорма, процедура ОбновитьДвиженияНаСервере().
	УстановитьПривилегированныйРежим(Истина);
	МассивИменРегистров = ПроведениеСервер.ПолучитьМассивИспользуемыхРегистров(
									Источник.Ссылка, 
									МетаданныеОбъекта.Движения);
	УстановитьПривилегированныйРежим(Ложь);
	
	РучнаяКорректировкаФакта         = бит_МеханизмДопИзмерений.ЕстьРучнаяКорректировкаФакта(Источник.Ссылка);
	ВозможнаРучнаяКорректировкаФакта = Ложь;
	
	Если НЕ МассивИменРегистров.Найти("бит_ОборотыПоБюджетам") = Неопределено 
		И НЕ МассивИменРегистров.Найти("бит_СоответствиеЗаписейТрансляции") = Неопределено Тогда
		ВозможнаРучнаяКорректировкаФакта = Истина;
	КонецЕсли; 
	
	Если НЕ ВозможнаРучнаяКорректировкаФакта ИЛИ НЕ РучнаяКорректировкаФакта Тогда
	     Возврат;	
	КонецЕсли; 

	ОборотыПоБюджетам			  = Новый ТаблицаЗначений();
	СоответствиеЗаписейТрансляции = Новый ТаблицаЗначений();
	
	// Соответствие Записей Трансляции.	
	СуществующийНабор = РегистрыСведений.бит_СоответствиеЗаписейТрансляции.СоздатьНаборЗаписей();
	СуществующийНабор.Отбор.Регистратор.Установить(Источник.Ссылка);
	СуществующийНабор.Прочитать();
		
	Отбор = Новый Структура();
	Отбор.Вставить("Приемник", бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам));
	НаборСоответствие = СуществующийНабор.Выгрузить();
	НаборСоответствие = НаборСоответствие.Скопировать(Отбор);
	НаборСоответствие.ЗаполнитьЗначения(Истина, "Активность");	
	
	// Обороты по бюджетам.
	СуществующийНабор = РегистрыНакопления.бит_ОборотыПоБюджетам.СоздатьНаборЗаписей();
	СуществующийНабор.Отбор.Регистратор.Установить(Источник.Ссылка);
	СуществующийНабор.Прочитать();
	НаборОбороты = СуществующийНабор.Выгрузить();
	НаборОбороты.ЗаполнитьЗначения(Истина, "Активность");
	
	Если НаборОбороты.Количество() = 0 ИЛИ НаборСоответствие.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;  

	ПараметрыПередачи = Новый Структура();
	ПараметрыПередачи.Вставить("бит_ОборотыПоБюджетам",            НаборОбороты);
	ПараметрыПередачи.Вставить("бит_СоответствиеЗаписейТрансляции",НаборСоответствие);
	
	Источник.ДополнительныеСвойства.Вставить("ПараметрыРучногоРедактированияФакта", ПараметрыПередачи);
	
КонецПроцедуры // ПередЗаписьюДокументаРучнаяКорректировкаФакта()

// Процедура выполняет действия для ручной корректировки факта при записи операции для целей трансляции.
// 
// Параметры:
//  Источник.
//
Процедура ПриЗаписиОперацииРучнаяКорректировкаФакта(Источник, Активность = Истина) Экспорт

	Движения = Источник.Движения;
	
	РучнаяКорректировкаФакта = бит_МеханизмДопИзмерений.ЕстьРучнаяКорректировкаФакта(Источник.Ссылка);
	Если НЕ РучнаяКорректировкаФакта Тогда
	     Возврат;	
	КонецЕсли; 

	ОбъектСистемыОборотыПобюджетам = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам);
	
	Если ТипЗнч(Источник) = Тип("ДокументОбъект.ОперацияБух") Тогда
		
		ОборотыПоБюджетам = Источник.Движения.бит_ОборотыПоБюджетам;
		НаборОбороты = ОборотыПоБюджетам.Выгрузить();
		
		СоотвествиеЗаписей = Источник.Движения.бит_СоответствиеЗаписейТрансляции;
		НаборСоответствие  = СоотвествиеЗаписей.Выгрузить();
		НаборСоответствие  = НаборСоответствие.Скопировать(Новый Структура("Приемник", ОбъектСистемыОборотыПобюджетам));
		
	ИначеЕсли ТипЗнч(Источник) = Тип("ДокументОбъект.РегламентнаяОперация") Тогда
		
		ОборотыПоБюджетам = РегистрыНакопления.бит_ОборотыПоБюджетам.СоздатьНаборЗаписей();
		ОборотыПоБюджетам.Отбор.Регистратор.Установить(Источник.Ссылка);
		ОборотыПоБюджетам.Прочитать();
		НаборОбороты = ОборотыПоБюджетам.Выгрузить();
		
		СоотвествиеЗаписей = РегистрыСведений.бит_СоответствиеЗаписейТрансляции.СоздатьНаборЗаписей();
		СоотвествиеЗаписей.Отбор.Регистратор.Установить(Источник.Ссылка);
		СоотвествиеЗаписей.Прочитать();
		НаборСоответствие = СоотвествиеЗаписей.Выгрузить();
		НаборСоответствие = НаборСоответствие.Скопировать( Новый Структура("Приемник", ОбъектСистемыОборотыПобюджетам));

	Иначе
		Возврат;
	КонецЕсли; 
	
	НаборОбороты.ЗаполнитьЗначения(Активность, "Активность");
	НаборСоответствие.ЗаполнитьЗначения(Активность, "Активность");
	
	ПараметрыПередачи = Новый Структура();
	ПараметрыПередачи.Вставить("бит_ОборотыПоБюджетам"            , НаборОбороты);
	ПараметрыПередачи.Вставить("бит_СоответствиеЗаписейТрансляции", НаборСоответствие);
	
	Если НаборОбороты.Количество() = 0 ИЛИ НаборСоответствие.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;  

	Источник.ДополнительныеСвойства.Вставить("ПараметрыРучногоРедактированияФакта", ПараметрыПередачи);

КонецПроцедуры // ПриЗаписиОперацииРучнаяКорректировкаФакта()
 
// Процедура изменяет активность в наборах записей при отмене проведения, если естьрчное редактирование фактических данных.
//
// Параметры:
//  Объект	            - ДокументОбъект.
//  МассивИменРегистров - Массив.
//
Процедура ПодготовитьНаборыЗаписейКОтменеПроведенияРучнаяКорректировкаФакта(Объект, МассивИменРегистров) Экспорт 

	РучнаяКоррФакта = бит_МеханизмДопИзмерений.ЕстьРучнаяКорректировкаФакта(Объект.Ссылка);
	Если МассивИменРегистров.Найти("бит_ОборотыПоБюджетам") <> Неопределено 
	   И РучнаяКоррФакта Тогда
	   
	    Объект.Движения.бит_ОборотыПоБюджетам.Прочитать();
		Объект.Движения.бит_ОборотыПоБюджетам.УстановитьАктивность(Ложь);
		
		Если МассивИменРегистров.Найти("бит_СоответствиеЗаписейТрансляции") <> Неопределено Тогда
		
			РегистрОбБюдж = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам);
			Объект.Движения.бит_СоответствиеЗаписейТрансляции.Прочитать();
			
			СуществующийНабор = Объект.Движения.бит_СоответствиеЗаписейТрансляции.Выгрузить();
			СуществующийНабор = СуществующийНабор.Скопировать(Новый Структура("Приемник", РегистрОбБюдж));
			Объект.Движения.бит_СоответствиеЗаписейТрансляции.Загрузить(СуществующийНабор);
			Объект.Движения.бит_СоответствиеЗаписейТрансляции.УстановитьАктивность(Ложь);
			
        КонецЕсли;
        
	КонецЕсли; 

КонецПроцедуры // ПодготовитьНаборыЗаписейКОтменеПроведенияРучнаяКорректировкаФакта()
 
#КонецОбласти

#Область ОбщиеПроцедурыИФункцииДляРаботыСДаннымиВБазе

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции // ЗначенияРеквизитовОбъекта()

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции // ЗначениеРеквизитаОбъекта()

// Возвращает значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа.
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие - где ключ - ссылка на объект, а Значение - структура, которая 
//		   		содержит список свойств, как список имен в строке.
//				ИменаРеквизитов, со значениям реквизитов, прочитанными из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если МассивСсылок.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции // ЗначенияРеквизитовОбъектов()

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа.
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита);
	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции // ЗначениеРеквизитаОбъектов()

// Функция показывает временную таблицу
//
// Параметры:
//  ЗапросИсточник.
//  ИмяВременнойТаблицы.
//
Функция ЛукВТ(ЗапросИсточник, ИмяВременнойТаблицы) Экспорт

	Если ЗапросИсточник.МенеджерВременныхТаблиц = Неопределено Тогда
		ВызватьИсключение "Не установлен менеджер временных таблиц";
	КонецЕсли; 
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	* 
	|ИЗ #ИмяВременнойТаблицы";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ИмяВременнойТаблицы", ИмяВременнойТаблицы);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = ЗапросИсточник.МенеджерВременныхТаблиц;
	
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции // ЛукВТ()

Функция Удалить(Ссылка) Экспорт

	НЗ = РегистрыНакопления.бит_ОборотыПоБюджетам.СоздатьНаборЗаписей();
	НЗ.Отбор.Регистратор.Установить(Ссылка);
	НЗ.Прочитать();
	Возврат НЗ.Количество();
	
КонецФункции // Удалить()
 
#КонецОбласти 

#Область ОбщегоНазначенияБПВызовСервера

// Функция получает структуру результата запроса.
// 
// Параметры:
//  РезультатЗапроса.
//
// Возвращаемое значение:
//  Структура.
//
Функция ПолучитьСтруктуруИзРезультатаЗапроса(РезультатЗапроса) Экспорт

	СтруктураПараметров = Новый Структура;

	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Для каждого КолонкаРезультата Из РезультатЗапроса.Колонки Цикл
		СтруктураПараметров.Вставить(КолонкаРезультата.Имя, Выборка[КолонкаРезультата.Имя]);
	КонецЦикла;

    Возврат СтруктураПараметров;

КонецФункции // ПолучитьСтруктуруИзРезультатаЗапроса()

// Функция получает текст разделителя запросов пакета.
//
// Возвращаемое значение:
//  Строка.
//
Функция ТекстРазделителяЗапросовПакета() Экспорт

	ТекстРазделителя =
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";

	Возврат ТекстРазделителя;

КонецФункции // ТекстРазделителяЗапросовПакета()
	
#КонецОбласти 

#Область РегламентныеЗаданияПереопределяемый

// Определяет следующие свойств регламентных заданий:
//  - зависимость от функциональных опций.
//  - возможность выполнения в различных режимах работы программы.
//  - прочие параметры.
//
// Параметры:
//  Настройки - ТаблицаЗначений - таблица значений с колонками:
//    * РегламентноеЗадание - ОбъектМетаданных:РегламентноеЗадание - регламентное задание.
//    * ФункциональнаяОпция - ОбъектМетаданных:ФункциональнаяОпция - функциональная опция,
//        от которой зависит регламентное задание.
//    * ЗависимостьПоИ      - Булево - если регламентное задание зависит более, чем
//        от одной функциональной опции и его необходимо включать только тогда,
//        когда все функциональные опции включены, то следует указывать Истина
//        для каждой зависимости.
//        По умолчанию Ложь - если хотя бы одна функциональная опция включена,
//        то регламентное задание тоже включено.
//    * ВключатьПриВключенииФункциональнойОпции - Булево, Неопределено - если Ложь, то при
//        включении функциональной опции регламентное задание не будет включаться. Значение
//        Неопределено соответствует значению Истина.
//        По умолчанию - неопределено.
//    * ДоступноВПодчиненномУзлеРИБ - Булево, Неопределено - Истина или Неопределено, если регламентное
//        задание доступно в РИБ.
//        По умолчанию - неопределено.
//    * ДоступноВАвтономномРабочемМесте - Булево, Неопределено - Истина или Неопределено, если регламентное
//        задание доступно в автономном рабочем месте.
//        По умолчанию - неопределено.
//    * ДоступноВМоделиСервиса      - Булево, Неопределено - Истина или Неопределено, если регламентное
//        задание доступно в модели сервиса.
//        По умолчанию - неопределено.
//    * РаботаетСВнешнимиРесурсами  - Булево - Истина, если регламентное задание модифицирует данные
//        во внешних источниках (получение почты, синхронизация данных и т.п.). Не следует устанавливать
//        значение Истина, для регламентных заданий, не модифицирующих данные во внешних источниках.
//        Например, регламентное задание ЗагрузкаКурсовВалют. Регламентные задания, работающие с внешними ресурсами,
//        автоматически отключаются в копии информационной базы. По умолчанию - Ложь.
//    * Параметризуется             - Булево - Истина, если регламентное задание параметризованное.
//        По умолчанию - Ложь.
//
// Пример:
//	Настройка = Настройки.Добавить();
//	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.ОбновлениеСтатусовДоставкиSMS;
//	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.ИспользоватьПочтовыйКлиент;
//	Настройка.ДоступноВМоделиСервиса = Ложь;
//
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Настройки) Экспорт
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_ук_СборОтправкаСтатистикиУправленияКачеством;
	Настройка.РаботаетСВнешнимиРесурсами = Истина;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ук_УчаствоватьВПрограммеУлучшенияКачества;
	Настройка.ДоступноВМоделиСервиса = Ложь;
	Настройка.ДоступноВАвтономномРабочемМесте = Ложь;
		
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_мдм_ВыполнениеОбмена;
	Настройка.РаботаетСВнешнимиРесурсами = Истина;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ИспользоватьПодключениеКВнешнимБазам;
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_мдм_ПодготовкаОбмена;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ИспользоватьПодключениеКВнешнимБазам;
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_фн_ОбработкаСобытийОповещений;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ИспользоватьМеханизмОповещений;
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_фн_ОтправкаОповещений;
	Настройка.РаботаетСВнешнимиРесурсами = Истина;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ИспользоватьМеханизмОповещений;
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_фн_УдалениеОбработанныхЗаписиРегистрацииОповещений;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ИспользоватьМеханизмОповещений;
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_фн_УдалениеОповещений;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ИспользоватьМеханизмОповещений;
		
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_ОповещенияТелеграм;
	Настройка.РаботаетСВнешнимиРесурсами = Истина;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ПолучатьИнформациюОтБотаТелеграм;
	
	Настройка = Настройки.Добавить();
	Настройка.РегламентноеЗадание = Метаданные.РегламентныеЗадания.бит_ВыгрузкаФайловPowerBI;
	Настройка.РаботаетСВнешнимиРесурсами = Истина;
	Настройка.ФункциональнаяОпция = Метаданные.ФункциональныеОпции.бит_ИспользоватьВыгрузкуПоРасписаниюPowerBI;
	
КонецПроцедуры

#КонецОбласти

#Область Стили

// Функция возвращает цвет текста первой ячейки табличного документа.
//
// Параметры:
//  ТабличныйДокументФормы - ТабличныйДокумент.
//
// Возвращаемое значение:
//  Цвет.
//
Функция ЦветТекстаЯчейкиТабличногоДокумента(ТабличныйДокументФормы) Экспорт
	
	Возврат ТабличныйДокументФормы.Область(1,1,1,1).ЦветТекста;
	
КонецФункции

#КонецОбласти

// Позволяет получить индекс картинки состояния документа из коллекции СостоянияДокумента
// по свойствам Проведен/ПометкаУдаления/РучнаяКорректировка.
// См. ОбщегоНазначенияБП.СостояниеДокумента()
//
// Параметры:
// Объект - основной реквизит формы документа, с типом ДанныеФормыСтруктура
//
Функция СостояниеДокумента(Объект) Экспорт
	
	РучнаяКорректировка = Неопределено;
	
	Если Объект.Свойство("РучнаяКорректировка", РучнаяКорректировка) Тогда
		Если Объект.РучнаяКорректировка Тогда
			Если Объект.ПометкаУдаления Тогда
				СостояниеДокумента = 10;
			ИначеЕсли НЕ Объект.Проведен Тогда
				СостояниеДокумента = 9;
			Иначе
				СостояниеДокумента = 8;
			КонецЕсли;
		Иначе
			Если Объект.ПометкаУдаления Тогда
				СостояниеДокумента = 2;
			ИначеЕсли Объект.Проведен Тогда
				СостояниеДокумента = 1;
			Иначе
				СостояниеДокумента = 0;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если Объект.ПометкаУдаления Тогда
			СостояниеДокумента = 2;
		ИначеЕсли Объект.Проведен Тогда
			СостояниеДокумента = 1;
		Иначе
			СостояниеДокумента = 0;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СостояниеДокумента;
	
КонецФункции

// Процедура - обработчик подписки "бит_ПриУстановкеНовогоНомераДокумента"
// Устанавливает префикс источника подписки. 
// 
// Параметры:
//  Источник 			 - Источник события подписки. (Документ).
//  СтандартнаяОбработка - Булево - флаг стандартной обработки подписки.
//  Префикс 			 - Строка - префикс объекта, который нужно изменить.
// 
Процедура УстановитьПрефиксНомераДокумента(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	Если Источник.Метаданные().Реквизиты.Найти("Организация") = Неопределено Тогда
		ПрефиксацияОбъектовСобытия.УстановитьПрефиксИнформационнойБазы(Источник, СтандартнаяОбработка, Префикс);                
	Иначе	
		// Есть реквизит "Организация".
		ПрефиксацияОбъектовСобытия.УстановитьПрефиксИнформационнойБазыИОрганизации(Источник, СтандартнаяОбработка, Префикс);                
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ПроверитьСоответствиеОрганизацииДоговоруВзаиморасчетов(Организация, ДоговорКонтрагента, ДоговорОрганизация, Отказ, Заголовок="") Экспорт
	
	Если ЗначениеЗаполнено(Организация) И ЗначениеЗаполнено(ДоговорКонтрагента)
		И ГоловнаяОрганизация(Организация) <> ДоговорОрганизация Тогда
		ТекстСообщения =  НСтр("ru = 'Выбран договор контрагента, не соответствующий организации, указанной в документе.'");
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения,,,,Отказ); 
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьЗначенияПоУмолчанию(Параметры)
	// ++ БП 
	Параметры.Вставить("бит_ПоказатьФормуКонстант",                       Ложь);
	Параметры.Вставить("бит_ПоказатьКонвертациюДокументовБюджетирования", Ложь);
	Параметры.Вставить("бит_ПоказатьКонвертациюОборотовПоБюджету",        Ложь);
	Параметры.Вставить("бит_ПоказатьПомощникКонвертацииКодаАлгоритмов",   Ложь);
	Параметры.Вставить("бит_ПоказатьРабочееМестоВизирования",             Ложь);
	Параметры.Вставить("бит_ПодключитьОжиданиеУведомленияОбУстановкеВиз", 0);
	Параметры.Вставить("бит_ПоказатьДополнительнуюИнформацию",            Ложь);
	// -- БП 
КонецПроцедуры

Функция ПоказатьФормуКонстант()
	// ++ БП 
	ПервыйЗапуск = бит_ПраваДоступа.ПроверитьПраваДляОбновления() 
		И (ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("Общие настройки/Первый запуск БИТ.ФИНАНС","",Ложь)
		ИЛИ бит_ОбновлениеСПредыдущейРедакцииБФ.ЭтоПереходСРедакции20());
		
	Возврат ПервыйЗапуск;
	// -- БП 
КонецФункции

Функция ПоказатьКонвертацию28()
	// ++ БП 
	ПоказатьКонвертацию = 
		ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("Общие настройки/Первый запуск БИТ.ФИНАНС","",Ложь)
		И бит_ОбновлениеСПредыдущейРедакцииБФ.ЭтоПереходСРедакции20();
		
	Возврат ПоказатьКонвертацию;
	// -- БП 
КонецФункции

// Процедура заполняет субконто в строке набора записей.
// 
// Параметры: 
//  Запись - Строка набора записей регистра бухгалтерии.
//  Строка - Структура, содержащая значения субконто.
// 
Процедура ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
	
	Для НомерСчета = 1 по 2 Цикл
		
		Если НомерСчета = 1 тогда 
			СчетДтКТ = "Дт"
		Иначе
			СчетДтКТ = "Кт"
		КонецЕсли;
		
		Для НомерСубконто = 1 по 3 цикл
			
			ЗначениеСубконто = Строка["Субконто" + СчетДтКТ + НомерСубконто];

			ВидСубконто = Строка["ВидСубконто" + СчетДтКТ + НомерСубконто];
			Если ВидСубконто.ТипЗначения <> Неопределено Тогда
				Запись["Субконто" + СчетДтКТ].Вставить(ВидСубконто, ЗначениеСубконто);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // ЗаполнитьСубконтоВНабореЗаписей

// Выполняет проверку заполнения объекта.
//
// Параметры:
//  ТекущийОбъект  - Объект проверки.
//  ВыводитьОшибки - Булево - необходимость вывода сообщения.
//  РежимЗаписи    - РежимЗаписиДокумента.
//
// Возвращаемое значение: 
//  Булево.
//
Функция ПроверитьЗаполнение(ТекущийОбъект, ВыводитьОшибки, РежимЗаписи)

	// ВАЖНО!!! Пока для документов.
	
	Успех = Истина;
	Если ТекущийОбъект.ОбменДанными.Загрузка Тогда
		// Тут нечего проверять.
		Возврат Успех;	
	КонецЕсли;
	
	Если ТекущийОбъект.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
		// Перед проведением вызываем проверку заполнения.
		Если РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
			Успех = ТекущийОбъект.ПроверитьЗаполнение();
		КонецЕсли; 
	Иначе	
		// Перед записью, если проведение не поддерживается, вызываем проверку заполнения.
		Успех = ТекущийОбъект.ПроверитьЗаполнение();
	КонецЕсли; 

	Если НЕ Успех И ВыводитьОшибки Тогда
		// Ошибка проверки заполнения признана некритической. Сообщение не выводим.
		ШаблонСоообщения = НСтр("ru = 'При проверке заполнения данных произошли ошибки ""%1%""'");
	    ТекстСообщения   = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ШаблонСоообщения, ТекущийОбъект.Ссылка);
		//бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
	КонецЕсли; 
	
	Возврат Успех;
	
КонецФункции // ПроверитьЗаполнение()

// Функция возвращает таблицу для вывода.
// Функция относится к процедуре "ПроверитьДублированиеЗначенийВТабличнойЧасти".
// 
// Параметры:
//  ТаблицаСДанными - ТаблицаЗначений. 
// 
Функция ПроставитьНомераСтрокДляЗначений(ТаблицаСДанными)
    
    ТаблицаДляПеребора = ТаблицаСДанными.Скопировать();
    ТаблицаДляПеребора.Свернуть("Значение");
    
    ТаблицаДляВывода = ТаблицаСДанными.Скопировать();
    ТаблицаДляВывода.Очистить();
    
    Для Каждого ТекЗначение ИЗ ТаблицаДляПеребора Цикл
        
        Отбор = Новый Структура;
        Отбор.Вставить("Значение", ТекЗначение.Значение);
        
        НайденныеСтроки = ТаблицаСДанными.НайтиСтроки(Отбор);
        
        Если ЗначениеЗаполнено(НайденныеСтроки) Тогда
            
            НомераСтрок = "№ ";
            
            Для Каждого ТекСтрока ИЗ НайденныеСтроки Цикл
                НомераСтрок = НомераСтрок + ?(НомераСтрок = "№ ", "", ", ") + ТекСтрока.НомераСтрок;
            КонецЦикла;
            
            НовСтрока = ТаблицаДляВывода.Добавить();
            НовСтрока.Значение    = ТекЗначение.Значение;
            НовСтрока.НомераСтрок = НомераСтрок;
            
        КонецЕсли;
        
    КонецЦикла;
    
    Возврат ТаблицаДляВывода;
    
КонецФункции // ПроставитьНомераСтрокДляЗначений()

// Функция определяет есть ли измерение "ХозяйственнаяОперация" 
// в регистре сведений "бит_НастройкиДоступностиЭлементовУправления".
//
// Возвращаемое значение:
// 	Булево - измерение есть.
//
Функция ЕстьИзмерениеХозОперация()

	Возврат Метаданные.РегистрыСведений.бит_НастройкиДоступностиЭлементовУправления.Измерения.Найти("ХозяйственнаяОперация") <> Неопределено;	

КонецФункции // ЕстьИзмерениеХозОперация()

// Функция определяет есть ли ресурс "Обязательное" в регистре сведений "бит_НастройкиДоступностиЭлементовУправления".
//
// Возвращаемое значение:
// 	Булево - ресур есть.
//
Функция ЕстьРесурсОбязательное()

	Возврат Метаданные.РегистрыСведений.бит_НастройкиДоступностиЭлементовУправления.Ресурсы.Найти("Обязательное") <> Неопределено;	

КонецФункции // ЕстьРесурсОбязательное()

// Процедура устанавливает доступность и видимость для конкретного элемента формы.
//
// Параметры:
//  ТекЭлемент  		- Элемент формы.
//  ФормаУправляемая  	- Булево.
//  Настройка 			- Структура.
//
Процедура УстановитьДоступностьВидимостьЭлемента(ТекЭлемент, ФормаУправляемая, Настройка)

	Если ТипЗнч(ТекЭлемент) = Тип("ПолеФормы") И ТекЭлемент.Вид = ВидПоляФормы.ПолеВвода Тогда	
		
		ТекЭлемент.ТолькоПросмотр = Не Настройка.Доступность; 
		ТекЭлемент.Видимость 	  = Настройка.Видимость; 			 
		
		Если ЕстьРесурсОбязательное() Тогда
			ТекЭлемент.АвтоОтметкаНезаполненного = Настройка.Обязательное;
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(ТекЭлемент) = Тип("ТаблицаФормы") Тогда 
		
		ТекЭлемент.ТолькоПросмотр = Не Настройка.Доступность; 
		ТекЭлемент.Видимость 	  = Настройка.Видимость;
		
	ИначеЕсли ТипЗнч(ТекЭлемент) = Тип("ПолеФормы") 
		И ТекЭлемент.Вид = ВидПоляФормы.ПолеФлажка Тогда	
		
		ТекЭлемент.ТолькоПросмотр 	= Не Настройка.Доступность; 
		ТекЭлемент.Видимость 	  	= Настройка.Видимость;
		ТекЭлемент.Доступность 		= Настройка.Доступность;
	Иначе
		ТекЭлемент.Доступность = Настройка.Доступность;
		ТекЭлемент.Видимость   = Настройка.Видимость;
	КонецЕсли;

	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-07-08 (#4242)
	Если (ТипЗнч(Настройка) = Тип("Структура")
			И Настройка.Свойство("ок_ПрименятьНастройкиКРодительскимЭлементам")
			ИЛИ
			ТипЗнч(Настройка) = Тип("СтрокаТаблицыЗначений")
			И Настройка.Владелец().Колонки.Найти("ок_ПрименятьНастройкиКРодительскимЭлементам") <> Неопределено)
		И Настройка.ок_ПрименятьНастройкиКРодительскимЭлементам
		И ТипЗнч(ТекЭлемент.Родитель) <> Тип("ФормаКлиентскогоПриложения") Тогда
	
		УстановитьДоступностьВидимостьЭлемента(ТекЭлемент.Родитель, ФормаУправляемая, Настройка);
	
	КонецЕсли; 
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-07-08 (#4242)
	
КонецПроцедуры // УстановитьДоступностьВидимостьЭлемента()

// Функция формирует массив ролей 
// в зависимости от типа элементов исходного массива РолиПользователя.
// 
// Параметры:
//  РолиПользователя - Массив.
//
// Возвращаемое значение: 
//  Массив.
// 
Функция СформироватьМассивРолей(РолиПользователя)
	
	МассивРолей = Новый Массив;
	
	Если ТипЗнч(РолиПользователя) = Тип("Массив") Тогда

		ЭтоТипСтрока 	   = Ложь;
		ЭтоТипСтрокаДерева = Ложь;
		
		Если РолиПользователя.Количество() <> 0 Тогда
			  Если ТипЗнч(РолиПользователя[0]) = Тип("Строка") Тогда
				ЭтоТипСтрока = Истина;
			ИначеЕсли ТипЗнч(РолиПользователя[0]) = Тип("СтрокаДереваЗначений") Тогда
				ЭтоТипСтрокаДерева = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если ЭтоТипСтрока Тогда
			
			Для Каждого СтрРоль Из РолиПользователя Цикл
				МассивРолей.Добавить(Метаданные.Роли.Найти(СтрРоль));
			КонецЦикла; 
			
		ИначеЕсли ЭтоТипСтрокаДерева Тогда
			
			Для Каждого СтрРоль Из РолиПользователя Цикл
				МассивРолей.Добавить(Метаданные.Роли.Найти(СтрРоль.Имя));
			КонецЦикла;
			
		Иначе
			
			МассивРолей = РолиПользователя;
			
		КонецЕсли;
		
	Иначе	
		
		Для каждого Роль Из РолиПользователя Цикл
			МассивРолей.Добавить(Роль);
		КонецЦикла; 
		
	КонецЕсли; 
	
	Возврат МассивРолей;

КонецФункции // СформироватьМассивРолей()

#КонецОбласти

#Если НЕ ТолстыйКлиентОбычноеПриложение И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
//izhtc-Kir 01.09.2015 ( это заглушка, чтобы проходил компиляцию код в справочнике "бит_ПользовательскиеФункции"
Функция ВосстановитьЗначение(Параметр1 = Неопределено) Экспорт
	Возврат ХранилищеОбщихНастроек.Загрузить("Заглушка", Параметр1);
КонецФункции

#КонецЕсли 
	
Функция УстановитьСубконто(Счет, Субконто, ИмяСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "", ВидыСубконтоСчета = Неопределено) Экспорт
	бит_БухгалтерияСервер.УстановитьСубконто(Счет, Субконто, ИмяСубконто, ЗначениеСубконто, Сообщать, Заголовок, ВидыСубконтоСчета);
	Возврат Неопределено;
КонецФункции

Функция ЗначениеСубконто(ЗаписьИсточник,ДтКт,ИмяСубконто) Экспорт
	Возврат бит_МеханизмТрансляции.ЗначениеСубконто(ЗаписьИсточник,ДтКт,ИмяСубконто);
КонецФункции

Функция ЗначениеРеквизита(ДокументОбъект, ИмяРеквизита) Экспорт
	Возврат бит_МеханизмТрансляции.ЗначениеРеквизита(ДокументОбъект,ИмяРеквизита);
КонецФункции

// Процедура изменяет данные формы.
// 
// Параметры:
//  ДанныеФормы			- ДанныеФормыСтруктура.
//  СтруктураПараметров - Структура.
// 
Процедура ИзменитьДанныеФормыСервер(ДанныеФормы, СтруктураПараметров, Отказ = Ложь) Экспорт
	
	Если Отказ 
		Или СтруктураПараметров = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ИмяДокумента   = ДанныеФормы.Ссылка.Метаданные().Имя;
	ДокументОбъект = ДанныеФормыВЗначение(ДанныеФормы, Тип("ДокументОбъект." + ИмяДокумента));
	
	// Установим значения реквизитов.
	Для Каждого КлючЗначение Из СтруктураПараметров Цикл
		ДокументОбъект[КлючЗначение.Ключ] = КлючЗначение.Значение;
	КонецЦикла;
	
	ЗначениеВДанныеФормы(ДокументОбъект, ДанныеФормы);
	
КонецПроцедуры // ИзменитьДанныеФормыСервер()
//izhtc-Kir 01.09.2015 )

// бит_Тртилек Функция проверяет наличие измерения с именем "ВидДвиженияМСФО" у регистра бухгалтерии.
// 22.05.2012
// Параметры:
//  ИмяРегистраБухгалтерии - Строка.
//
// Возвращаемое значение:
//  ЕстьРесурсСуммаМУ - Булево.
//
Функция ЕстьИзмерениеВидДвиженияМСФОРегистраБухгалтерии(ИмяРегистраБухгалтерии) Экспорт
	
	ЕстьИзмерениеВидДвиженияМСФО = Ложь;
	
	Если ЕстьМСФО() Тогда
		
		Если НЕ Метаданные.РегистрыБухгалтерии.Найти(ИмяРегистраБухгалтерии) = Неопределено Тогда
			
			// Проверим наличие измерения с именем "ВидДвиженияМСФО".
			ЕстьИзмерениеВидДвиженияМСФО = Не (Метаданные.РегистрыБухгалтерии[ИмяРегистраБухгалтерии].Измерения.Найти("ВидДвиженияМСФО") = Неопределено);
			
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат ЕстьИзмерениеВидДвиженияМСФО;
	
КонецФункции // ЕстьИзмерениеВидДвиженияМСФОРегистраБухгалтерии()
