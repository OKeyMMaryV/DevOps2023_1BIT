
#Область СлужебныйПрограммныйИнтерфейс

#Область РаботаСЗадачами

// Процедура устанавливает настройки полей.  
// 
// Параметры:
//  Элементы - ВсеЭлементыФормы.
//  НастройкиАдресации - Структура.
//  МаксКоличествоОбъектов - Число.
// 
Процедура НастроитьПоляОбъектовАдресации(Элементы, НастройкиАдресации, МаксКоличествоОбъектов) Экспорт
	
	НачалоИмени = "ОбъектАдресации_";
	Для  н = 1 по МаксКоличествоОбъектов Цикл
		
		Имя          = НачалоИмени+н;
		ТекНастройка = Неопределено;
		НастройкиАдресации.Свойство(Имя, ТекНастройка);
		
		флВидимость    = Ложь;
		флОбязательный = Ложь;
		ТекЗаголовок   = НСтр("ru='Объект адресации №';en='Addressing object #'")+н;
		Если НЕ ТекНастройка = Неопределено Тогда
			
			флВидимость    = Истина;
			ТекЗаголовок   = ТекНастройка.Синоним;
			флОбязательный = ТекНастройка.Обязательный;
			
		КонецЕсли; 
		
		Элементы[Имя].Видимость = флВидимость;
		Элементы[Имя].Заголовок = ТекЗаголовок;
		Элементы[Имя].ОтметкаНезаполненного     = Ложь;
		Элементы[Имя].АвтоОтметкаНезаполненного = флОбязательный;
		
	КонецЦикла; 
	
КонецПроцедуры // НастроитьПоляОбъектовАдресации()

// Процедура устанавливает типы объектов адресации.
// 
// Параметры:
//  Контейнер              - Произвольный.
//  НастройкиАдресации     - Структура.
//  МаксКоличествоОбъектов - Число;
// 
Процедура НазначитьТипыОбъектовАдресации(Контейнер, НастройкиАдресации, МаксКоличествоОбъектов) Экспорт
	
	// Присвоим типы объектам адресации
	НачалоИмени = "ОбъектАдресации_";
	Для  н = 1 по МаксКоличествоОбъектов Цикл
		
		Имя          = НачалоИмени+н;
		ТекНастройка = Неопределено;
		НастройкиАдресации.Свойство(Имя, ТекНастройка);
		
		Если НЕ ТекНастройка = Неопределено Тогда
			
			Контейнер[Имя] = ТекНастройка.Тип.ПривестиЗначение(Контейнер[Имя]);
			
		Иначе
			
			Контейнер[Имя] = Неопределено;
			
		КонецЕсли; 
		
	КонецЦикла; // МаксКоличествоОбъектов
	
КонецПроцедуры // НазначитьТипыОбъектовАдресации()

// Функция определяет максимально возможное количество объектов адресации задач.
// 
// Возвращаемое значение:
//  МаксКол - Число.
// 
Функция МаксимальноеКоличествоОбъектовАдресации() Экспорт
	
	МаксКол = 0;
	
	Для каждого МетаИзмер Из Метаданные.РегистрыСведений.бит_ИсполнителиЗадач.Измерения Цикл
		
		Если Найти(МетаИзмер.Имя, "ОбъектАдресации_") > 0 Тогда
			
			МаксКол = МаксКол+1;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	Возврат МаксКол;
	
КонецФункции // МаксимальноеКоличествоОбъектовАдресации()

// Процедура настраивает перечень реквизитов адресации, 
// подлежащих проверке при данных настройках. Перечень проверяемых реквизитов 
// зависит от СпособаАдресации и настройки адресации для данной роли.
// 
// Параметры:
//  ПроверяемыеРеквизиты - Массив.
//  НастройкиАдресации - Структура.
//  СпособАдресации - Число.
//  МаксКоличествоОбъектов.
// 
Процедура НастроитьПроверкуРеквизитовАдресации(ПроверяемыеРеквизиты
	                                           , НастройкиАдресации
											   , СпособАдресации
											   , МаксКоличествоОбъектов) Экспорт

	Если СпособАдресации = 0 Тогда
		
		// Адресация по исполнителю - РольИсполнителя не обязательна.
		ЗначениеНайдено =  ПроверяемыеРеквизиты.Найти("РольИсполнителя");
		
		Если ТипЗнч(ЗначениеНайдено) = Тип("Число") Тогда
		
			ПроверяемыеРеквизиты.Удалить(ЗначениеНайдено);
		
		КонецЕсли; 
		
		ПроверяемыеРеквизиты.Добавить("Исполнитель");
		
	ИначеЕсли СпособАдресации = 1 Тогда	
		
		// Адресация по роли - Исполнитель не обязательный.
		ЗначениеНайдено =  ПроверяемыеРеквизиты.Найти("Исполнитель");
		
		Если ТипЗнч(ЗначениеНайдено) = Тип("Число") Тогда
		
			ПроверяемыеРеквизиты.Удалить(ЗначениеНайдено);
		
		КонецЕсли; 
		
		ПроверяемыеРеквизиты.Добавить("РольИсполнителя");
		
		Для й = 1 По МаксКоличествоОбъектов Цикл
		
			ИмяРеквизита = "ОбъектАдресации_"+й;
			
			ТекНастройка = Неопределено;
			НастройкиАдресации.Свойство(ИмяРеквизита, ТекНастройка);
			
			Если НЕ ТекНастройка = Неопределено И ТекНастройка.Обязательный Тогда
			
				ПроверяемыеРеквизиты.Добавить(ИмяРеквизита);
			
			КонецЕсли; 
		
		КонецЦикла; 
		
	КонецЕсли; 

КонецПроцедуры // НастроитьПроверкуРеквизитовАдресации()

// Процедура проверяет заполнение параметров процесса. 
// 
// Параметры:
//  ПараметрыПроцесса - ТабличнаяЧасть, ТаблицаЗначений.
//  Отказ - Булево.
// 
Процедура ПроверитьЗаполнениеПараметровПроцесса(ПараметрыПроцесса, Отказ) Экспорт
	
	Для каждого СтрокаТаблицы Из ПараметрыПроцесса Цикл
		
		Если СтрокаТаблицы.Обязательный И НЕ ЗначениеЗаполнено(СтрокаТаблицы.Значение) Тогда
			
			ТекстСообщения = "Не заполнено значение обязательного параметра ""%1%"".";
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, СтрокаТаблицы.Имя);
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
			Отказ = Истина;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // ПроверитьЗаполнениеПараметровПроцесса()

 // Функция выполняет задачу. Используется для вызова в фоновом задании.
 //
 // Параметры:
 //   вхЗадача - ЗадачаСсылка.бит_уп_Задача.
 //
 // Возвращаемое значение:
 //  флВыполнено - Булево.
 //
 Функция ВыполнитьЗадачу(вхЗадача) Экспорт
 
	флВыполнено = Задачи.бит_уп_Задача.ОтметитьВыполнение(вхЗадача);
	
	Возврат флВыполнено;
 	
 КонецФункции // ВыполнитьЗадачу()
 
 // Процедура выполняет автоматические действия при создании задачи. 
 // Используется для вызова в фоновом задании. 
 //
 // Параметры:
 //   вхЗадача - ЗадачаСсылка.бит_уп_Задача.
 //
 Процедура ВыполнитьАвтоматическиеДействия(вхЗадача) Экспорт
 
 	 Справочники.бит_ПользовательскиеДействия.ВыполнитьАвтоматическиеДействия(вхЗадача);
 
 КонецПроцедуры // ВыполнитьАвтоматическиеДействия() 

#КонецОбласти

#Область ПроцедурыРаботыСТочкамиАлгоритма

// Функция выполняет поиск точек алгоритмов.
//
// Параметры:
//   Наименование - Строка
//   Алгоритм - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//
// Возвращаемое значение:
//  НайденнаяТочка - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//
Функция НайтиТочкуАлгоритма(Наименование, Алгоритм) Экспорт

	НайденнаяТочка = Справочники.бит_уп_ТочкиАлгоритмов.НайтиПоНаименованию(Наименование,Истина,,Алгоритм);

	Возврат НайденнаяТочка;
	
КонецФункции // НайтиТочкуАлгоритма()

// Функция добавляет точку в указанный алгоритм и привязывает ее к входящей точки.
// 
// Параметры:
//  Алгоритм  - СправочникСсылка.бит_уп_Алгоритмы
//  ТочкаВходящая - СправочникСсылка.бит_уп_ТочкиАлгоритмов
//  ВидТочки      - ПеречислениеСсылка.бит_уп_Направление
//  КоличествоТочек - Число
//  РежимСообщений  - Строка
//  СтрПар - Структура.
// 
// Возвращаемое значение:
//   НоваяТочка   - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
Функция ДобавитьТочкуАлгоритма(Алгоритм,ТочкаВходящая,Направление,ВидТочки,КоличествоТочек,РежимСообщений = "Ошибки", СтрПар = Неопределено) Экспорт

	НоваяТочка = Справочники.бит_уп_ТочкиАлгоритмов.ПустаяСсылка();
	
	ТочкаОб = Справочники.бит_уп_ТочкиАлгоритмов.СоздатьЭлемент();
	ТочкаОб.ВидТочки     = ВидТочки;
	ТочкаОб.Наименование = Строка(ВидТочки)+" "+КоличествоТочек;
	ТочкаОб.Владелец     = Алгоритм;
	
	Если ТипЗнч(СтрПар) = Тип("Структура") И СтрПар.Свойство("Реквизиты") Тогда
	
		Для каждого КиЗ Из СтрПар.Реквизиты Цикл
		
			ТочкаОб[КиЗ.Ключ] = КиЗ.Значение;
		
		КонецЦикла; 
	
	КонецЕсли; 	
	
	Если ЗначениеЗаполнено(ТочкаВходящая) Тогда
		
		НоваяСтрока = ТочкаОб.ВходящиеТочки.Добавить();
		НоваяСтрока.Точка       = ТочкаВходящая;
		НоваяСтрока.Направление = Направление;
		
	КонецЕсли; 
	
	флДействиеВыполнено = бит_ОбщегоНазначения.ЗаписатьСправочник(ТочкаОб,,РежимСообщений);
	Если флДействиеВыполнено  Тогда
	
		НоваяТочка = ТочкаОб.Ссылка;
		КоличествоТочек = КоличествоТочек+1;
		
		Если ЗначениеЗаполнено(ТочкаВходящая) Тогда
			
			ТочкаВхОб = ТочкаВходящая.ПолучитьОбъект();
			
			НоваяСтрока = ТочкаВхОб.ИсходящиеТочки.Добавить();
			НоваяСтрока.Точка = ТочкаОб.Ссылка;
			НоваяСтрока.Направление = Направление;
			
			бит_ОбщегоНазначения.ЗаписатьСправочник(ТочкаВхОб,,РежимСообщений);
			
		КонецЕсли; 

	КонецЕсли; 
	
	Возврат НоваяТочка;
	
КонецФункции // ДобавитьТочку()

// Функция отвязывает точку алгоритма.
// 
// Параметры:
//  ТекущаяТочка   - СправочникСсылка.бит_уп_ТочкиАлгоритмов -.
//  ТочкаДляОтвязки- СправочникСсылка.бит_уп_ТочкиАлгоритмов- .
// 
// 
// Возвращаемое значение:
//   флДействиеВыполнено   - Булево.
// 
Функция ОтвязатьТочкуАлгоритма(ТекущаяТочка,ТочкаДляОтвязки = Неопределено,РежимСообщений = "Ошибки")  Экспорт

	флДействиеВыполнено = Ложь;
	
	Если ТекущаяТочка.ВходящиеТочки.Количество()>0 Тогда
		
	     ТекущаяТочкаОб = ТекущаяТочка.ПолучитьОбъект();
		 
		 Если НЕ ЗначениеЗаполнено(ТочкаДляОтвязки)  Тогда
			 МаксИндекс     = ТекущаяТочкаОб.ВходящиеТочки.Количество()-1;
			 СтрокаТаблицы  = ТекущаяТочкаОб.ВходящиеТочки[МаксИндекс];
			 ТочкаСвязанная = СтрокаТаблицы.Точка;
		 Иначе	
			 СтрокаТаблицы  = ТекущаяТочкаОб.ВходящиеТочки.Найти(ТочкаДляОтвязки,"Точка");
			 ТочкаСвязанная = ТочкаДляОтвязки;
		 КонецЕсли; 
		 
		 Если СтрокаТаблицы = Неопределено Тогда
		 
		 	Возврат флДействиеВыполнено;
		 
		 КонецЕсли; 
		
		 Если НЕ ЗначениеЗаполнено(ТочкаСвязанная) Тогда
		 
		 	Возврат флДействиеВыполнено;
		 
		 КонецЕсли; 
		 
		 ТекущаяТочкаОб.ВходящиеТочки.Удалить(СтрокаТаблицы);
		 
		 флДействиеВыполнено = бит_ОбщегоНазначения.ЗаписатьСправочник(ТекущаяТочкаОб,,РежимСообщений);
		 
		 Если флДействиеВыполнено Тогда
		 
		 ТочкаСвязаннаяОб = ТочкаСвязанная.ПолучитьОбъект();
		 
		 НайденнаяСтрока = ТочкаСвязаннаяОб.ИсходящиеТочки.Найти(ТекущаяТочка,"Точка");
		 Если НЕ НайденнаяСтрока = Неопределено Тогда
			 
		 	ТочкаСвязаннаяОб.ИсходящиеТочки.Удалить(НайденнаяСтрока);
			
			флДействиеВыполнено = бит_ОбщегоНазначения.ЗаписатьСправочник(ТочкаСвязаннаяОб,,РежимСообщений);
			
		 КонецЕсли; 
		 
		 КонецЕсли; 
		 
	КонецЕсли; 

	Возврат флДействиеВыполнено;
	
КонецФункции // ОтвязатьТочкуАлгоритма()

// Процедура выполняет привязку точки алгоритма к другой точке.
// 
// Параметры:
//  ТекущаяТочка    - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//  ТочкаСвязанная  - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//  Направление     - ПеречислениеСсылка.бит_уп_Направление.
//  РежимСообщений  - Строка.
// 
// Возвращаемое значение:
//   флДействиеВыполнено   - Булево.
// 
Функция ПривязатьТочкуАлгоритма(ТекущаяТочка,ТочкаСвязанная,Направление,РежимСообщений = "Ошибки",РежимЗагрузки = Ложь) Экспорт
	
    флДействиеВыполнено = Ложь;	
	Отказ = Ложь;
	Если ТекущаяТочка = ТочкаСвязанная Тогда
		
		Отказ = Истина;
		
	КонецЕсли; 
	
	Если НЕ ЗначениеЗаполнено(ТекущаяТочка) Тогда
	
		Отказ = Истина;
	
	КонецЕсли; 
	
	Если НЕ ЗначениеЗаполнено(ТочкаСвязанная) Тогда
	
		Отказ = Истина;
	
	КонецЕсли; 
	
	Если НЕ Отказ Тогда
		
		ТекущаяТочкаОб = ТекущаяТочка.ПолучитьОбъект();
		
		НоваяСтрока = ТекущаяТочкаОб.ИсходящиеТочки.Добавить();
		НоваяСтрока.Точка = ТочкаСвязанная;
		НоваяСтрока.Направление = Направление;
		
		ТочкаСвязаннаяОб = ТочкаСвязанная.ПолучитьОбъект();
		
		НоваяСтрока = ТочкаСвязаннаяОб.ВходящиеТочки.Добавить();
		НоваяСтрока.Точка = ТекущаяТочка;
		НоваяСтрока.Направление = Направление;
		
		флДействиеВыполнено = бит_ОбщегоНазначения.ЗаписатьСправочник(ТекущаяТочкаОб,,РежимСообщений,РежимЗагрузки);
		Если флДействиеВыполнено Тогда
		
			флДействиеВыполнено = бит_ОбщегоНазначения.ЗаписатьСправочник(ТочкаСвязаннаяОб,,РежимСообщений,РежимЗагрузки);
		
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат флДействиеВыполнено;
	
КонецФункции // ПривязатьТочкуАлгоритма()

// Функция устанавливает пометку удаления точки алгоритма.
// 
// Параметры:
//  ТекущаяТочка   - СправочникСсылка.бит_уп_ТочкиАлгоритма.
//  Пометка        - Булево.
//  РежимСообщений - Строка.
// 
// Возвращаемое значение:
//   флДействиеВыполнено   - Булево.
// 
Функция УстановитьПометкуУдаленияТочки(ТекущаяТочка,Пометка,РежимСообщений = "Ошибки") Экспорт

	ТочкаОбъект = ТекущаяТочка.ПолучитьОбъект();
	ВыводитьОшибки     = ?(РежимСообщений="Все" ИЛИ РежимСообщений="Ошибки",Истина,Ложь);
	ВыводитьИнформацию = ?(РежимСообщений="Все",Истина,Ложь);
	
	Если Пометка Тогда
	     СтрВыполнено   = "Установлена";
	     СтрНеВыполнено = "установить";		 
	 Иначе	
	     СтрВыполнено   = "Снята";		 
	     СтрНеВыполнено = "снять";
	КонецЕсли; 
	
	Попытка
		
		ТочкаОбъект.УстановитьПометкуУдаления(Пометка);
		флДействиеВыполнено = Истина;
		
		Если ВыводитьИнформацию Тогда
			
			ТекстСообщения = НСтр("ru = '%СтрВыполнено% пометка удаления точки алгоритма ""%ТочкаАлгоритма%"".'");
			СтрЗамена      = Новый Структура("ТочкаАлгоритма,СтрВыполнено",Строка(ТекущаяТочка),СтрВыполнено);
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ЗаполнитьПараметрыСтроки(ТекстСообщения,СтрЗамена);
			
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецЕсли; 
		
	Исключение
		
		флДействиеВыполнено = Ложь; 
		Если ВыводитьОшибки Тогда
			
			ТекстСообщения = НСтр("ru = 'Не удалось %СтрНеВыполнено% пометку удаления точки алгоритма ""%ТочкаАлгоритма%"".'");
			СтрЗамена      = Новый Структура("ТочкаАлгоритма,СтрНеВыполнено",Строка(ТекущаяТочка),СтрНеВыполнено);
			ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ЗаполнитьПараметрыСтроки(ТекстСообщения,СтрЗамена);
			
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
			
		КонецЕсли; 
		
	КонецПопытки;
	
	Возврат флДействиеВыполнено;
	
КонецФункции // УстановитьПометкуУдаленияТочки()

// Функция помечает на удаление и разрывает все связи точки алгоритма.
// 
// Параметры:
//  ТекущаяТочка  - СправочникСсылка.бит_уп_ТочкиАлгоритма.
//  Отвязать      - Булево.
//  РежимСообщений- Строка.
// 
// Возвращаемое значение:
//   флДействиеВыполнено   - Булево.
// 
Функция ПометитьОтвязатьТочку(ТекущаяТочка,Отвязывать,РежимСообщений = "Ошибки") Экспорт

	флДействиеВыполнено = УстановитьПометкуУдаленияТочки(ТекущаяТочка,Истина);
	
	Если флДействиеВыполнено И Отвязывать Тогда
	
		Для каждого СтрокаТаблицы Из ТекущаяТочка.ВходящиеТочки Цикл
		
			  ОтвязатьТочкуАлгоритма(ТекущаяТочка,СтрокаТаблицы.Точка,РежимСообщений);
		
		КонецЦикла; 
		
		Для каждого СтрокаТаблицы Из ТекущаяТочка.ИсходящиеТочки Цикл
		
			  ОтвязатьТочкуАлгоритма(СтрокаТаблицы.Точка,ТекущаяТочка,РежимСообщений);
		
		КонецЦикла; 
		
	КонецЕсли; 
	

	Возврат флДействиеВыполнено;
	
КонецФункции // ПометитьОтвязатьТочку()

#КонецОбласти

#Область ПолучениеПреобразованиеКоординат

// Функция вычисляет координату лево для точки исходя из номера колонки.
// 
// Параметры:
//  НомерКолонки         - Число.
//  СтруктураПараметров  - Структура.
// 
// Возвращаемое значение:
//   Результат   - Число.
// 
Функция ВычислитьКоординатуЛево(НомерКолонки,СтруктураПараметров) Экспорт

	Результат = СтруктураПараметров.ПолеЛево
	            +(НомерКолонки-1)*(СтруктураПараметров.ИнтервалГоризонталь+СтруктураПараметров.Ширина);

	Возврат Результат;
	
КонецФункции // ВычислитьКоординатуЛево()

// Функция вычисляет координату верх для точки исходя из номера строки.
// 
// Параметры:
//  НомерСтроки  - Число.
//  СтруктураПараметров  - Структура.
// 
// Возвращаемое значение:
//   Результат   - Число.
// 
Функция ВычислитьКоординатуВерх(НомерСтроки,СтруктураПараметров) Экспорт

	Результат =  СтруктураПараметров.ПолеВерх
	             +(НомерСтроки-1)*(СтруктураПараметров.ИнтервалВертикаль+СтруктураПараметров.Высота);
	

	Возврат Результат;
	
КонецФункции // ВычислитьКоординатуВерх()

// Функция инициализирует структуру координат в представлении ХУ.
// 
// Параметры:
//  Х1  - Число
//  У1  - Число
//  Х2  - Число
//  У2  - Число
// 
// Возвращаемое значение:
//   Координаты   - Структура
// 
Функция КонструкторСтруктурыКоординат_ХУ(Х1=0,У1=0,Х2=0,У2=0) Экспорт

	Координаты = Новый Структура("Х1,У1,Х2,У2",Х1,У1,Х2,У2);

	Возврат Координаты;
	
КонецФункции // КонструкторСтруктурыКоординат_ХУ()

// Функция преобразует координаты из представления ЛевоВерх в ХУ.
// 
// Параметры:
//  Координаты  - Структура
// 
// Возвращаемое значение:
//  КоординатыРезультат   - Структура.
// 
Функция ПреобразоватьКоординаты(Координаты) Экспорт

	Если Координаты.Свойство("Лево") Тогда
		
		// Из ЛевоПраво преобразуем в ХУ
		КоординатыРезультат = КонструкторСтруктурыКоординат_ХУ();
		КоординатыРезультат.Х1 = Координаты.Лево;
		КоординатыРезультат.У1 = Координаты.Верх;
		КоординатыРезультат.Х2 = Координаты.Лево+Координаты.Ширина;
		КоординатыРезультат.У2 = Координаты.Верх+Координаты.Высота;
		
	Иначе	
		
		// Из ХУ в ЛевоВерх
		КоординатыРезультат = КонструкторСтруктурыКоординат_ЛевоВерх();
		КоординатыРезультат.Лево = Координаты.Х1;
		КоординатыРезультат.Верх = Координаты.У1;
		КоординатыРезультат.Ширина = Координаты.Х2-Координаты.Х1;
		КоординатыРезультат.Высота = Координаты.У2-Координаты.У1;
		
	КонецЕсли; 

	Возврат КоординатыРезультат;
	
КонецФункции // ПреобразоватьКоординаты()

#КонецОбласти

#Область ГрафическиеПроцедурыВыводаАлгоритма

// Функция добавляет рисунок в табличный документ.
// 
// Параметры:
//  ТД  - ТабличныйДокумент.
//  СтруктураПараметров - Структура.
//  Координаты          - Структура.
// 
// Возвращаемое значение:
//  РисунокТД.
// 
Функция ДобавитьРисунок(ТД,СтруктураПараметров,Координаты) Экспорт
	
	РисунокТД = ТД.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Текст);
	
	Если НЕ ПустаяСтрока(СтруктураПараметров.Имя) Тогда
		РисунокТД.Имя = СтруктураПараметров.Имя;
	КонецЕсли; 
	
	Если НЕ ПустаяСтрока(СтруктураПараметров.Наименование) Тогда
	
		РисунокТД.Текст = СтруктураПараметров.Наименование;
		
	Иначе
		
		РисунокТД.Текст = СтруктураПараметров.Точка.Наименование;
	
	КонецЕсли; 
	
	Если СтруктураПараметров.ПометкаУдаления Тогда
	
		РисунокТД.Текст = "(Х)"+РисунокТД.Текст;
	
	КонецЕсли; 
	
	РисунокТД.Лево   = Координаты.Лево;
	РисунокТД.Верх   = Координаты.Верх;
	РисунокТД.Ширина = Координаты.Ширина;
	РисунокТД.Высота = Координаты.Высота;
	
	РисунокТД.Линия         = СтруктураПараметров.ТипЛинии;
	РисунокТД.Защита        = Истина;
	РисунокТД.Гиперссылка   = НЕ СтруктураПараметров.ЭтоПроцесс;
	РисунокТД.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр;
	РисунокТД.ВертикальноеПоложение   = ВертикальноеПоложение.Центр;
	
	ПараметрыЛинии = Новый Структура("ТипЛинии",СтруктураПараметров.ТипЛинии);
	Оформление     = ПолучитьОформлениеТочки(СтруктураПараметров.Точка);
	
	Если ЭтоДействие(СтруктураПараметров.Точка.ВидТочки) Тогда
		
		// Изменение кода. Начало. 25.07.2017{{
		Если НЕ ЗначениеЗаполнено(СтруктураПараметров.Точка.ПользовательскоеДействие) Тогда
			
			Оформление.Удалить("ЦветЛинии");
			РисунокТД.Линия 	= Новый Линия(ТипЛинииРисункаТабличногоДокумента.Сплошная,2);
			РисунокТД.ЦветЛинии = Новый Цвет(255,0,0);
		КонецЕсли; 
		// Изменение кода. Конец. 25.07.2017}}
		
		Если СтруктураПараметров.ЭтоВизирование Тогда
			
			// Изменение кода. Начало. 25.07.2017{{
			// При визировании цветом текста отображается доступность точек
			// поэтому настройку цвета текста для визирования отключаем.
			//Оформление.Удалить("ЦветТекста");
			// Изменение кода. Конец. 25.07.2017}}
			
		КонецЕсли; 
		
		Если СтруктураПараметров.ЭтоПроцесс Тогда
		
			Если СтруктураПараметров.Выполнена Тогда
			
				РисунокТД.Узор = ТипУзораТабличногоДокумента.Узор8;
				РисунокТД.ЦветУзора = Новый Цвет(180, 180, 180);
			
			КонецЕсли; 
		
		КонецЕсли; 
		
		ОформитьРисунок(РисунокТД,Оформление);
		
		// Изменение кода. Начало. 25.07.2017{{
		Если СтруктураПараметров.Свойство("Доступность") Тогда
			Если НЕ СтруктураПараметров.Доступность Тогда
				РисунокТД.ЦветТекста = Новый Цвет(192,192,192);
			КонецЕсли; 
		КонецЕсли;	
		// Изменение кода. Конец. 25.07.2017}}
		
	Иначе	
		
		Если Оформление.Свойство("ЦветЛинии") Тогда
			
			ПараметрыЛинии.Вставить("ЦветЛинии",Оформление.ЦветЛинии);
			
		КонецЕсли; 
		// Точки, которые не являются точками действия, отрисовываются при помощи линий
		// если закрасить фон, он может выйти за границы линий, т.к. закрашивается прямоугольный РисунокТД.
		Оформление.Удалить("ЦветФона");
		ОформитьРисунок(РисунокТД,Оформление);
		
		
	КонецЕсли; 
	
	// Отрисовка границ для точек разного вида
	
	Если СтруктураПараметров.Точка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Условие Тогда
		
		РисунокТД.ГраницаСверху = Ложь;
		РисунокТД.ГраницаСлева  = Ложь;
		РисунокТД.ГраницаСнизу  = Ложь;
		РисунокТД.ГраницаСправа = Ложь;
		
		
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево+Координаты.Ширина/2
		                                                ,Координаты.Верх
													    ,Координаты.Лево+Координаты.Ширина
													    ,Координаты.Верх+Координаты.Высота/2);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево+Координаты.Ширина/2
		                                                ,Координаты.Верх+Координаты.Высота
													    ,Координаты.Лево+Координаты.Ширина
													    ,Координаты.Верх+Координаты.Высота/2);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);

		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх+Координаты.Высота/2
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх+Координаты.Высота);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх+Координаты.Высота/2
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
	ИначеЕсли СтруктураПараметров.Точка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт Тогда
		
		РисунокТД.ГраницаСверху = Истина;
		РисунокТД.ГраницаСлева  = Ложь;
		РисунокТД.ГраницаСнизу  = Ложь;
		РисунокТД.ГраницаСправа = Ложь;
		
		// Наклонная слева - вниз
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх+Координаты.Высота/2
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх+Координаты.Высота);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		// Наклонная справа - вниз
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево+Координаты.Ширина
		                                                ,Координаты.Верх+Координаты.Высота/2
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх+Координаты.Высота);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		// Вертикальная слева
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх
													    ,Координаты.Лево
													    ,Координаты.Верх+Координаты.Высота/2);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		// Вертикальная справа
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево+Координаты.Ширина
		                                                ,Координаты.Верх
													    ,Координаты.Лево+Координаты.Ширина
													    ,Координаты.Верх+Координаты.Высота/2);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
	ИначеЕсли СтруктураПараметров.Точка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Завершение Тогда
		
		РисунокТД.ГраницаСверху = Ложь;
		РисунокТД.ГраницаСлева  = Ложь;
		РисунокТД.ГраницаСнизу  = Истина;
		РисунокТД.ГраницаСправа = Ложь;
		
		// Наклонная слева - вверх
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх + Координаты.Высота/2
													    ,Координаты.Лево + Координаты.Ширина/2
													    ,Координаты.Верх);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		// Наклонная справа - вверх
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево + Координаты.Ширина
		                                                ,Координаты.Верх + Координаты.Высота/2
													    ,Координаты.Лево + Координаты.Ширина/2
													    ,Координаты.Верх);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		// Вертикальная слева
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх + Координаты.Высота/2
													    ,Координаты.Лево
													    ,Координаты.Верх + Координаты.Высота);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		// Вертикальная справа
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево + Координаты.Ширина
		                                                ,Координаты.Верх + Координаты.Высота/2
													    ,Координаты.Лево + Координаты.Ширина
													    ,Координаты.Верх + Координаты.Высота);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);

	ИначеЕсли СтруктураПараметров.Точка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение Тогда
		
		РисунокТД.ГраницаСверху = Ложь;
		РисунокТД.ГраницаСлева  = Ложь;
		РисунокТД.ГраницаСнизу  = Истина;
		РисунокТД.ГраницаСправа = Ложь;
		
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх+Координаты.Высота
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх);
														
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево+Координаты.Ширина
		                                                ,Координаты.Верх+Координаты.Высота
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		
		
	ИначеЕсли СтруктураПараметров.Точка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние Тогда
		
		РисунокТД.ГраницаСверху = Истина;
		РисунокТД.ГраницаСлева  = Ложь;
		РисунокТД.ГраницаСнизу  = Ложь;
		РисунокТД.ГраницаСправа = Ложь;
		
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево
		                                                ,Координаты.Верх
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх+Координаты.Высота);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
		
		КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево+Координаты.Ширина
		                                                ,Координаты.Верх
													    ,Координаты.Лево+Координаты.Ширина/2
													    ,Координаты.Верх+Координаты.Высота);
		ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
	
		
	Иначе	
		
		// Для точек действия
		
		РисунокТД.ГраницаСверху = Истина;
		РисунокТД.ГраницаСлева  = Истина;
		РисунокТД.ГраницаСнизу  = Истина;
		РисунокТД.ГраницаСправа = Истина;
		
		Если СтруктураПараметров.ЭтоПроцесс 
			 И НЕ СтруктураПараметров.Выполнена 
			 И НЕ СтруктураПараметров.Отложена
			 И СтруктураПараметров.ЕстьЗадача Тогда
			
			// Активные задачи выделяем рамкой
			НарисоватьГраницуАктивнойТочки(ТД, Координаты);
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат РисунокТД;

КонецФункции // ДобавитьРисунок()

// Функция добавляет линию в табличный документ.
// 
// Параметры:
//  ТД             - ТабличныйДокумент.
//  Координаты     - Структура - Ключи {Х1,У1,Х2,У2} либо {Лево,Верх,Ширина,Высота}.
//  ПараметрыЛинии - Структура.
// 
// Возвращаемое значение:
//   ЛинияТД   - РисунокТабличногоДокумента.
// 
Функция ДобавитьЛинию(ТД,Координаты,ПараметрыЛинии = Неопределено) Экспорт

	
	Если Координаты.Свойство("Х1") Тогда
	     КоординатыЛинии = ПреобразоватьКоординаты(Координаты);
	Иначе	
	     КоординатыЛинии = Координаты;
	КонецЕсли; 
	
	ЛинияТД = ТД.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Прямая);
	ЛинияТД.Лево   = КоординатыЛинии.Лево;
	ЛинияТД.Верх   = КоординатыЛинии.Верх;
	ЛинияТД.Ширина = КоординатыЛинии.Ширина;
	ЛинияТД.Высота = КоординатыЛинии.Высота;
	Если  ТипЗнч(ПараметрыЛинии) = Тип("Структура") Тогда
		
		Если ПараметрыЛинии.Свойство("ТипЛинии") Тогда
			
			ЛинияТД.Линия  = ПараметрыЛинии.ТипЛинии;
			
		КонецЕсли; 
		
		Если ПараметрыЛинии.Свойство("ЦветЛинии") Тогда
			
			ЛинияТД.ЦветЛинии = ПараметрыЛинии.ЦветЛинии;
			
		КонецЕсли; 
		// ++ NB Новый алгоритм 
		Если ПараметрыЛинии.Свойство("Расшифровка") Тогда
			 ЛинияТД.Расшифровка = ПараметрыЛинии.Расшифровка;
		 КонецЕсли;
		// -- NB Новый алгоритм 
	КонецЕсли; 

	Возврат ЛинияТД;
	
КонецФункции // ДобавитьЛинию()

// Процедура выводит алгоритм процесса в табличный документ.
// 
// Параметры:
//  ТД     - ТабличныйДокумент.
//  Объект - Структура - Структура с реквизитами объекта.
// 
Процедура НарисоватьМаршрутПроцесса(ТД,Объект)  Экспорт
	
	ПоказатьВсеТочки = ?(Объект.Свойство("ПоказатьВсеТочки"), Объект.ПоказатьВсеТочки, Ложь);
	ТаблицаТочек  	 = ПолучитьТаблицуТочек(Объект.Ссылка,,,, ПоказатьВсеТочки);
	
	ТД.Очистить();
	
	// Таблица для расположения точек алгоритма в порядке отрисовки.
	ТаблицаПозиций = Новый ТаблицаЗначений;
	// Соответсвие для хранения местаположения точек в ТаблицеПозиций.
	Позиции = Новый Соответствие;
	
	РазместитьТочкиАлгоритма(ТаблицаТочек,ТаблицаПозиций,Позиции,Объект.РазмещениеСвободныхТочек);		
	
	// Отрисовка точек алгоритма по ТаблицеПозиций.
	НарисоватьТочкиАлгоритма(ТД,Объект,ТаблицаТочек,ТаблицаПозиций,Позиции);
	
	ТД.ТолькоПросмотр = Истина;
	
КонецПроцедуры // НарисоватьМаршрутПроцесса()

// Процедура выводит алгоритм процесса в табличный документ.
// 
// Параметры:
//  ТД     - ТабличныйДокумент.
//  Объект - Структура - Структура с реквизитами объекта.
// 
Функция ПолучитьДанныеДляОтрисовки(Алгоритм, Режим = "")  Экспорт
	
	ДанныеОтрисовки = Новый Структура("Точки, Линии, Холст", Новый Массив, Новый Массив, );
	
	ТаблицаТочек  = ПолучитьТаблицуТочек(Алгоритм);
	
	// Таблица для расположения точек алгоритма в порядке отрисовки.
	ТаблицаПозиций = Новый ТаблицаЗначений;
	// Соответсвие для хранения местаположения точек в ТаблицеПозиций.
	Позиции = Новый Соответствие;
	
	// Разместим точки алгоритма в ТаблицеПозиций.
	РазместитьТочкиАлгоритма(ТаблицаТочек,ТаблицаПозиций,Позиции,Алгоритм.РазмещениеСвободныхТочек);		
	
	ПараметрыОтображения = ПолучитьПараметрыОтображенияАлгоритма(Алгоритм);
	
	ЭтоВизирование = ?(Режим = "Визирование", Истина, Ложь);
	ЭтоПроцесс     = ?(Режим = "Процесс"    , Истина, Ложь);
	
	КоличествоСтрок = ТаблицаПозиций.Количество();
	КоличествоКолонок = ТаблицаПозиций.Колонки.Количество();
	
	ВысотаХолста = ПараметрыОтображения.ПолеВерх+(ПараметрыОтображения.ИнтервалВертикаль+ПараметрыОтображения.Высота)*КоличествоСтрок;
	ШиринаХолста = ПараметрыОтображения.ПолеЛево+(ПараметрыОтображения.ИнтервалГоризонталь+ПараметрыОтображения.Ширина)*КоличествоКолонок;
	
	ДанныеОтрисовки.Холст = Новый Структура("Ширина,Высота",ШиринаХолста,ВысотаХолста);
	
	Для НомК = 1 По КоличествоКолонок Цикл
		
		ТекущаяКолонка = ТаблицаПозиций.Колонки[НомК-1];
		Для НомС = 1 По КоличествоСтрок Цикл
			
			ТекущаяСтрока   = ТаблицаПозиций[НомС-1];
			ДанныеКВыводу  = ТекущаяСтрока[ТекущаяКолонка.Имя];
			
			Если НЕ ДанныеКВыводу = Неопределено Тогда
				
				Если ТипЗнч(ДанныеКВыводу) = Тип("Структура") Тогда
					СтрокаТаблицыТочек = ТаблицаТочек.Найти(ДанныеКВыводу.ИД,"ИД");
					ТекущаяТочка = Справочники.бит_уп_ТочкиАлгоритмов.ПустаяСсылка();
				Иначе	
					ТекущаяТочка = ДанныеКВыводу;					
					СтрокаТаблицыТочек = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");	
				КонецЕсли; 
				
				Лево = ВычислитьКоординатуЛево(НомК,ПараметрыОтображения);		
				Верх = ВычислитьКоординатуВерх(НомС,ПараметрыОтображения);
				
				ТипЛинии = Новый Линия(ТипЛинииРисункаТабличногоДокумента.Сплошная,1);			
				
				Координаты = КонструкторСтруктурыКоординат_ЛевоВерх(Лево,Верх,ПараметрыОтображения.Ширина,ПараметрыОтображения.Высота);
				ПараметрыРисунка = Новый Структура("Точка,Имя,Наименование,ТипЛинии,ПометкаУдаления, Координаты");
				ПараметрыРисунка.Точка          = ТекущаяТочка;
				ПараметрыРисунка.Имя            = "";
				ПараметрыРисунка.ПометкаУдаления = ТекущаяТочка.ПометкаУдаления;
				ПараметрыРисунка.Координаты = Координаты;
				
				СтруктураПараметров             = Новый Структура;
				СтруктураПараметров.Вставить("Точка",ДанныеКВыводу.Наименование);
				Если ЭтоВизирование Тогда
				
					СтруктураПараметров.Вставить("Решение",Строка(СтрокаТаблицыТочек.Решение));
				
				КонецЕсли; 
				
				ПараметрыРисунка.Наименование   = бит_ОбщегоНазначенияКлиентСервер.СформироватьТекстТочки(СтруктураПараметров);
				ПараметрыРисунка.ТипЛинии       = ТипЛинии;
				
				Если ЭтоВизирование Тогда
				
					ПараметрыРисунка.Вставить("Доступность"   ,СтрокаТаблицыТочек.Доступность);
					ПараметрыРисунка.Вставить("Виза"          ,СтрокаТаблицыТочек.Виза);
					ПараметрыРисунка.Вставить("Установлена"   ,ЗначениеЗаполнено(СтрокаТаблицыТочек.Решение));
					
				ИначеЕсли ЭтоПроцесс Тогда	
					
					ПараметрыРисунка.Вставить("Доступность"   ,Истина);
					
					флВыполнена = ?(СтрокаТаблицыТочек.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Выполнена 
					                  ИЛИ СтрокаТаблицыТочек.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Отменена, Истина, Ложь);
					ПараметрыРисунка.Вставить("Выполнена", флВыполнена);
					
					флОтложена = ?(СтрокаТаблицыТочек.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Остановлена, Истина, Ложь);
					ПараметрыРисунка.Вставить("Отложена", флОтложена);
					
					флЕстьЗадача = ?(ЗначениеЗаполнено(СтрокаТаблицыТочек.Задача), Истина, Ложь);
					ПараметрыРисунка.Вставить("ЕстьЗадача", флЕстьЗадача);
				
				Иначе
					
					ПараметрыРисунка.Вставить("Доступность"   ,Истина);
				
				КонецЕсли; 
				
				ПараметрыРисунка.Вставить("ЭтоВизирование", ЭтоВизирование);				
				ПараметрыРисунка.Вставить("ЭтоПроцесс"    , ЭтоПроцесс);
				
				ДанныеОтрисовки.Точки.Добавить(ПараметрыРисунка);
				
				// Рисуем связи точек алгоритма
				Для каждого СтрокаВходящие Из ТекущаяТочка.ВходящиеТочки Цикл
					
					Лево = ВычислитьКоординатуЛево(НомК,ПараметрыОтображения);		
					Верх = ВычислитьКоординатуВерх(НомС,ПараметрыОтображения);		 
					ВходящаяТочка = СтрокаВходящие.Точка;
					
					ПозицияВх = Позиции[ВходящаяТочка];
					
					Если НЕ ПозицияВх = Неопределено Тогда
						
						НомВхС    = ТаблицаПозиций.Индекс(ПозицияВх.Строка)+1;
						КолонкаВх = ТаблицаПозиций.Колонки.Найти(ПозицияВх.ИмяКолонки);
						НомВхК    = ТаблицаПозиций.Колонки.Индекс(КолонкаВх)+1;
						
						ЛевоВх    = ВычислитьКоординатуЛево(НомВхК,ПараметрыОтображения);
						ВерхВх    = ВычислитьКоординатуВерх(НомВхС,ПараметрыОтображения);
						
						ПараметрыТочки   = Новый Структура("Лево,Верх,ВидТочки,Направление",Лево,Верх,ТекущаяТочка.ВидТочки,Неопределено);
						ПараметрыТочкиВх = Новый Структура("Лево,Верх,ВидТочки,Направление",ЛевоВх,ВерхВх,ВходящаяТочка.ВидТочки,СтрокаВходящие.Направление);		
						МассивКоординат = КоординатыСвязейТочекАлгоритма(ПараметрыОтображения,ПараметрыТочки,ПараметрыТочкиВх);
						
						Для каждого Коорд Из МассивКоординат Цикл
						
							ДанныеОтрисовки.Линии.Добавить(Коорд);
						
						КонецЦикла; 
						
					КонецЕсли; // Входящая точка есть
					
				КонецЦикла; // По входящим точкам
				
			КонецЕсли;  // Текущая точка заполнена
			
		КонецЦикла; // По строкам
		
	КонецЦикла; // По колонкам
	
	Возврат ДанныеОтрисовки;
	
КонецФункции // НарисоватьМаршрутПроцесса()

// Процедура выводит алгоритм визирования в табличный документ.
// 
// Параметры:
//  ТД     - ТабличныйДокумент.
//  Объект - Структура - Структура с реквизитами объекта.
// 
Процедура НарисоватьАлгоритмВизирования(ТД,Алгоритм,ТаблицаТочкиВизы)  Экспорт
	
	ТД.Очистить();
	
	// Таблица для расположения точек алгоритма в порядке отрисовки.
	ТаблицаПозиций = Новый ТаблицаЗначений;
	// Соответсвие для хранения местаположения точек в ТаблицеПозиций.
	Позиции = Новый Соответствие;
	
	// Разместим точки алгоритма в ТаблицеПозиций.
	РазместитьТочкиАлгоритма(ТаблицаТочкиВизы,ТаблицаПозиций,Позиции,Алгоритм.РазмещениеСвободныхТочек);		
	
	// Отрисовка точек алгоритма по ТаблицеПозиций.
	НарисоватьТочкиАлгоритма(ТД, Алгоритм,ТаблицаТочкиВизы,ТаблицаПозиций,Позиции, "Визирование");
	
	ТД.ТолькоПросмотр = Истина;
	
КонецПроцедуры // НарисоватьАлгоритмВизирования()

// Процедура выводит алгоритм процесса в табличный документ.
// 
// Параметры:
//  ТД       - ТабличныйДокумент.
//  Алгоритм - СправочникСсылка.бит_уп_АлгоритмыПроцессов.
//  Процесс  - БизнесПроцессСсылка.бит_уп_Процесс.
// 
Процедура НарисоватьАлгоритмПроцесса(ТД, Алгоритм, Процесс, ПоказыватьСрокиПроцесса = Ложь, ТаблицаТочек = Неопределено)  Экспорт
	
	ТД.Очистить();
	
	// Таблица для расположения точек алгоритма в порядке отрисовки.
	ТаблицаПозиций = Новый ТаблицаЗначений;
	// Соответсвие для хранения местаположения точек в ТаблицеПозиций.
	Позиции = Новый Соответствие;
	
	ТабЗадач = БизнесПроцессы.бит_уп_Процесс.ПолучитьЗадачиПроцесса(Процесс);
	ТаблицаТочек = ПолучитьТаблицуТочек(Алгоритм,,,ТабЗадач);
	
	// Разместим точки алгоритма в ТаблицеПозиций.
	РазместитьТочкиАлгоритма(ТаблицаТочек,ТаблицаПозиций,Позиции,Алгоритм.РазмещениеСвободныхТочек);		
	
	// Отрисовка точек алгоритма по ТаблицеПозиций.
	НарисоватьТочкиАлгоритма(ТД, Алгоритм, ТаблицаТочек, ТаблицаПозиций, Позиции, "Процесс", ПоказыватьСрокиПроцесса);
	
	ТД.ТолькоПросмотр = Истина;
	
КонецПроцедуры // НарисоватьАлгоритмПроцесса()

#КонецОбласти

#Область ВыводАлгоритмаВПолеHtml

// Функция готовит HTML страницы, отображающей алгоритм в веб-клиенте.
// 
// Возвращаемое значение:
//  ТекстШаблона - Строка.
// 
Функция ПодготовитьКодСтраницыОтображенияАлгоритма() Экспорт

	ТекстШаблона = Справочники.бит_уп_Алгоритмы.ПолучитьМакет("МакетСтраницы").ПолучитьТекст();
	ТекстСкрипта = Справочники.бит_уп_Алгоритмы.ПолучитьМакет("BlockScheme_js").ПолучитьТекст();
	ТекстШаблона = СтрЗаменить(ТекстШаблона,"//{%BlockScheme%}",ТекстСкрипта);

	Возврат ТекстШаблона;
	
КонецФункции // ПодготовитьКодСтраницыОтображенияАлгоритма()

// Процедура получает данные, необходимые 
// для вывода блок-схемы алгоритма в поле HTML документа. 
// 
// Параметры:
//  Алгоритм - СправочникСсылка.бит_уп_АлгоритмыПроцессов.
// 
Функция ПолучитьДанныеОтрисовкиХТМЛ(Алгоритм) Экспорт

	ДанныеОтрисовки = ПолучитьДанныеДляОтрисовки(Алгоритм);
	
	МассивТочек = Новый Массив;
	
	Для каждого ПараметрыТочки Из ДанныеОтрисовки.Точки Цикл
		
		СтрВид = ПреобразоватьВидТочки(ПараметрыТочки.Точка.ВидТочки);
		Координаты =  ПараметрыТочки.Координаты;
		СтруктТочки = КонструкторСтруктурыТочкиХТМЛ(ПараметрыТочки.Имя
		                                              , ПараметрыТочки.Наименование
		                                              , СтрВид
													  , Координаты.Лево
													  , Координаты.Верх
													  , Координаты.Ширина
													  , Координаты.Высота);
													  
													  
		МассивТочек.Добавить(СтруктТочки);											  
	
	КонецЦикла; 
	
	
	МассивЛиний = Новый Массив;
	Для каждого ПараметрыЛинии Из ДанныеОтрисовки.Линии Цикл
	
		СтруктЛинии = КонструкторСтруктурыЛинииХТМЛ(ПараметрыЛинии.Х1
		                                             , ПараметрыЛинии.У1
													 , ПараметрыЛинии.Х2
													 , ПараметрыЛинии.У2
													 ,"black"
													 ,2);
													 
		МассивЛиний.Добавить(СтруктЛинии);
													 
	КонецЦикла; 
	
	ПарамХолст = КонструкторСтруктурыХолстаХТМЛ(ДанныеОтрисовки.Холст.Ширина, ДанныеОтрисовки.Холст.Высота);
	
	СтрТочки = бит_ОбщегоНазначения.JSON_Stringify(МассивТочек);
	СтрЛинии = бит_ОбщегоНазначения.JSON_Stringify(МассивЛиний);
	СтрХолст = бит_ОбщегоНазначения.JSON_Stringify(ПарамХолст);
	
	СтрДанные = Новый Структура("Точки, Линии, Холст", СтрТочки, СтрЛинии, СтрХолст);
	
	Возврат СтрДанные;
	
КонецФункции // ПолучитьДанныеОтрисовки()

#КонецОбласти

#Область ПроцедурыПостроенияАлгоритма

// Функция вычисляет количество точек алгоритма определенного вида.
// 
// Параметры:
//  Алгоритм  - СправочникСсылка.бит_уп_Алгоритмы.
//  ВхВиды    - ПеречислениеСсылка.бит_уп_ВидыТочекАлгоритма,Массив.
// 
// Возвращаемое значение:
//   КоличествоТочек   - Число.
// 
Функция ПолучитьКоличествоТочекВида(Алгоритм,ВхВиды) Экспорт

	КоличествоТочек = 0;
	
	МассивВидов = Новый Массив;
	Если ТипЗнч(ВхВиды) = Тип("Массив") Тогда
		
		Для каждого Элемент Из ВхВиды Цикл
		
			МассивВидов.Добавить(Элемент)
		
		КонецЦикла; 
		
	Иначе	
		
		МассивВидов.Добавить(ВхВиды);
		
	КонецЕсли; 
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Алгоритм"   ,Алгоритм);
	Запрос.УстановитьПараметр("МассивВидов",МассивВидов);
	Запрос.Текст = "ВЫБРАТЬ
	               |	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ бит_уп_ТочкиАлгоритмов.Ссылка) КАК Количество
	               |ИЗ
	               |	Справочник.бит_уп_ТочкиАлгоритмов КАК бит_уп_ТочкиАлгоритмов
	               |ГДЕ
	               |	бит_уп_ТочкиАлгоритмов.ВидТочки В(&МассивВидов)
	               |	И бит_уп_ТочкиАлгоритмов.Владелец = &Алгоритм";
				   
    Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Если Выборка.Следующий() Тогда
	
		КоличествоТочек = Выборка.Количество;
	
	КонецЕсли; 
				   

	Возврат КоличествоТочек;
	
КонецФункции // ПолучитьКоличествоТочекВида()

// Функция получает таблицу точек алгоритма с количествами входящих и исходящих точек.
// 
// Параметры:
//  Алгоритм  - СправочникСсылка.бит_уп_Алгоритмы.
//  ПоказатьУдаленные  - Булево.
// 
// Возвращаемое значение:
//   ТаблицаТочки   - ТаблицаЗначений.
// 

//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
//Функция ПолучитьТочкиАлгоритма(Алгоритм, ПоказатьВсеТочки = Ложь) Экспорт

//	Запрос = Новый Запрос;
//	Запрос.УстановитьПараметр("Алгоритм",Алгоритм);
//	Запрос.Текст = 
//	"ВЫБРАТЬ
//	|	ВходящиеТочки.Ссылка КАК Точка,
//	|	СУММА(1) КАК Количество
//	|ПОМЕСТИТЬ ВТ_ВхТочки
//	|ИЗ
//	|	Справочник.бит_уп_ТочкиАлгоритмов.ВходящиеТочки КАК ВходящиеТочки
//	|ГДЕ
//	|	ВходящиеТочки.Ссылка.Владелец = &Алгоритм
//	|
//	|СГРУППИРОВАТЬ ПО
//	|	ВходящиеТочки.Ссылка
//	|;
//	|
//	|////////////////////////////////////////////////////////////////////////////////
//	|ВЫБРАТЬ
//	|	ИсходящиеТочки.Ссылка КАК Точка,
//	|	СУММА(1) КАК Количество
//	|ПОМЕСТИТЬ ВТ_ИсхТочки
//	|ИЗ
//	|	Справочник.бит_уп_ТочкиАлгоритмов.ИсходящиеТочки КАК ИсходящиеТочки
//	|ГДЕ
//	|	ИсходящиеТочки.Ссылка.Владелец = &Алгоритм
//	|
//	|СГРУППИРОВАТЬ ПО
//	|	ИсходящиеТочки.Ссылка
//	|;
//	|
//	|////////////////////////////////////////////////////////////////////////////////
//	|ВЫБРАТЬ
//	|	ЕСТЬNULL(ТочкиАлгоритмов.ВидТочки, ЗНАЧЕНИЕ(Перечисление.бит_уп_ВидыТочекАлгоритмов.Действие)) КАК ВидТочки,
//	|	ЕСТЬNULL(ВТ_ВхТочки.Количество, 0) КАК КоличествоВходящих,
//	|	ЕСТЬNULL(ВТ_ИсхТочки.Количество, 0) КАК КоличествоИсходящих,
//	|	ТочкиАлгоритмов.ИдентификаторТочки КАК ИдентификаторТочки,
//	|	ТочкиАлгоритмов.Ссылка КАК Точка,
//	|	ТочкиАлгоритмов.КодТочки КАК КодТочки
//	|ИЗ
//	|	Справочник.бит_уп_ТочкиАлгоритмов КАК ТочкиАлгоритмов
//	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ВхТочки КАК ВТ_ВхТочки
//	|		ПО ТочкиАлгоритмов.Ссылка = ВТ_ВхТочки.Точка
//	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ИсхТочки КАК ВТ_ИсхТочки
//	|		ПО ТочкиАлгоритмов.Ссылка = ВТ_ИсхТочки.Точка
//	|ГДЕ
//	|	ТочкиАлгоритмов.Владелец = &Алгоритм
//	|	И &ПоказатьВсеТочки";
//	
//	ЧтоЗаменить = "&ПоказатьВсеТочки";
//	Если ПоказатьВсеТочки Тогда
//		НаЧтоЗаменить = "ИСТИНА";
//	Иначе	
//		НаЧтоЗаменить = "НЕ ТочкиАлгоритмов.ПометкаУдаления";
//	КонецЕсли; 
//	
//	Запрос.Текст = СтрЗаменить(Запрос.Текст, ЧтоЗаменить, НаЧтоЗаменить);
//	
//	Результат = Запрос.Выполнить();
//	
//	ТаблицаТочки = Результат.Выгрузить();
//	
//	Возврат ТаблицаТочки;
//	Заменено на:
Функция ПолучитьТочкиАлгоритма(Алгоритм, ПоказатьВсеТочки = Ложь, Соответствие = Неопределено) Экспорт

	СтруктураВозврата = ОК_бит_ВизированиеПовтИсп.ПолучитьТочкиАлгоритма(Алгоритм, ПоказатьВсеТочки);
	
	Соответствие = СтруктураВозврата.СоответствиеТочек;
	
	Возврат СтруктураВозврата.ТаблицаТочки;	
КонецФункции

// Функция получает таблицу точек.
// 
// Параметры:
//  Алгоритм  -  СправочникСсылка.бит_уп_Алгоритмы.
//  ТабВизы   - ТаблицаЗначений.
//  ТабТочки  - ТаблицаЗначений.
//  ТабЗадачи - ТаблицаЗначений.
// 
// Возвращаемое значение:
//   ТаблицаТочкиВизы   - ТаблицаЗначений.
// 
Функция ПолучитьТаблицуТочек(Алгоритм, ТабВизы = Неопределено, ТабТочки = Неопределено , 
		ТабЗадачи = Неопределено, ПоказатьВсеТочки = Ложь, ЗаполнятьВходящиеИсходящие = Истина) Экспорт

	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
	СоответствиеТочкаВидТочки = Новый Соответствие;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
	
	Если ТабВизы = Неопределено Тогда
		ТаблицаВизы = КонструкторТаблицыВиз();
	Иначе
		ТаблицаВизы = ТабВизы;
	КонецЕсли; 
	
	Если ТабТочки = Неопределено Тогда
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
		//ТаблицаТочки = ПолучитьТочкиАлгоритма(Алгоритм, ПоказатьВсеТочки);
		//Заменено на:
		ТаблицаТочки = ПолучитьТочкиАлгоритма(Алгоритм, ПоказатьВсеТочки, СоответствиеТочкаВидТочки);
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
	Иначе	
		ТаблицаТочки = ТабТочки;
	КонецЕсли; 
	
	// Полное соединение выполняем с использованием ТаблицЗначений, 
	// т.к. это в несколько раз быстрее, чем при использовании запроса.
	ТаблицаТочкиВизы = КонструкторТаблицыТочкиВизы();
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
	////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
	////ПолноеСоединениеТочкиВизы(ТаблицаТочкиВизы,ТаблицаТочки,ТаблицаВизы);
	////Заменено на:
	////Таблицей виз не пользуюсь для поиска, т.к. соответствие быстрее
	//СоответствиеТочкаВидТочки = ПолноеСоединениеТочкиВизы(ТаблицаТочкиВизы,ТаблицаТочки,ТаблицаВизы);
	////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
	ПолноеСоединениеТочкиВизы(ТаблицаТочкиВизы,ТаблицаТочки,ТаблицаВизы);
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
	
	// Заполнение данных задач при необходимости.
	Если ТипЗнч(ТабЗадачи) = Тип("ТаблицаЗначений") Тогда
	
		ЗаполнитьДанныеЗадач(ТаблицаТочкиВизы, ТабЗадачи);
	
	КонецЕсли; 
	
	// Создадим колонки вручную, т.к. на Postgres запросом данные выбрать не удается.
	ТаблицаТочкиВизы.Колонки.Добавить("ВходящиеТочки", Новый ОписаниеТипов("ТаблицаЗначений"));
	ТаблицаТочкиВизы.Колонки.Добавить("ИсходящиеТочки", Новый ОписаниеТипов("ТаблицаЗначений"));
	
	Если ЗаполнятьВходящиеИсходящие Тогда
		// Если таблица исходящих/входящих NULL инициализируем ее пустой таблицей с необходимой структурой.
		Для каждого СтрокаТаблицы Из ТаблицаТочкиВизы Цикл
			
			// Т.к. запросом для Postgres выбрать необходимые данные нельзя заполним их при обходе.
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
			ДанныеТочки = СоответствиеТочкаВидТочки.Получить(СтрокаТаблицы.Точка);
			Если ДанныеТочки<>Неопределено Тогда 
				ВходящиеТочки = ДанныеТочки.ВходящиеТочки;
			Иначе 
				ВходящиеТочки = СтрокаТаблицы.Точка.ВходящиеТочки;
			КонецЕсли;
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)			
			
			Если НЕ ЗначениеЗаполнено(СтрокаТаблицы.ВходящиеТочки)  Тогда
				
				// Инициализируем таблицу связанных точек
				ТаблицаСвязанных = Новый ТаблицаЗначений;
				ТаблицаСвязанных.Колонки.Добавить("Точка"      ,Новый ОписаниеТипов("СправочникСсылка.бит_уп_ТочкиАлгоритмов"));
				ТаблицаСвязанных.Колонки.Добавить("ВидТочки"   ,Новый ОписаниеТипов("ПеречислениеСсылка.бит_уп_ВидыТочекАлгоритмов"));
				ТаблицаСвязанных.Колонки.Добавить("Направление",Новый ОписаниеТипов("ПеречислениеСсылка.бит_уп_Направление"));
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
				//Для Каждого СтрПодч ИЗ СтрокаТаблицы.Точка.ВходящиеТочки Цикл
				//Заменено на:
				Для Каждого СтрПодч ИЗ ВходящиеТочки Цикл
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
			
					СтрокаСв = ТаблицаСвязанных.Добавить();
					СтрокаСв.Точка       = СтрПодч.Точка;
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
					////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
					////СтрокаСв.ВидТочки    = СтрПодч.Точка.ВидТочки;
					////Заменено на:
					//СтрокаСв.ВидТочки = СоответствиеТочкаВидТочки.Получить(СтрПодч.Точка);
					////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
					//Заменено на:
					Если ДанныеТочки<>Неопределено Тогда 
						СтрокаСв.ВидТочки    = СтрПодч.ВидТочки;
					Иначе	
						СтрокаСв.ВидТочки    = СтрПодч.Точка.ВидТочки;
					КонецЕсли;
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
					СтрокаСв.Направление = СтрПодч.Направление;
					
				КонецЦикла;	
				
				СтрокаТаблицы.ВходящиеТочки = ТаблицаСвязанных;
				
			КонецЕсли; 
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
			Если ДанныеТочки<>Неопределено Тогда 
				ИсходящиеТочки = ДанныеТочки.ИсходящиеТочки;
			Иначе 
				ИсходящиеТочки = СтрокаТаблицы.Точка.ИсходящиеТочки;
			КонецЕсли;
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)			
			Если НЕ ЗначениеЗаполнено(СтрокаТаблицы.ИсходящиеТочки) Тогда
				
				// Инициализируем таблицу связанных точек
				ТаблицаСвязанных = Новый ТаблицаЗначений;
				ТаблицаСвязанных.Колонки.Добавить("Точка"      ,Новый ОписаниеТипов("СправочникСсылка.бит_уп_ТочкиАлгоритмов"));
				ТаблицаСвязанных.Колонки.Добавить("ВидТочки"   ,Новый ОписаниеТипов("ПеречислениеСсылка.бит_уп_ВидыТочекАлгоритмов"));
				ТаблицаСвязанных.Колонки.Добавить("Направление",Новый ОписаниеТипов("ПеречислениеСсылка.бит_уп_Направление"));
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
				//Для Каждого СтрПодч ИЗ СтрокаТаблицы.Точка.ИсходящиеТочки Цикл
				//Заменено на:
				Для Каждого СтрПодч ИЗ ИсходящиеТочки Цикл
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
				
					СтрокаСв = ТаблицаСвязанных.Добавить();
					СтрокаСв.Точка       = СтрПодч.Точка;
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
					////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
					////СтрокаСв.ВидТочки    = СтрПодч.Точка.ВидТочки;
					////Заменено на: 			
					//СтрокаСв.ВидТочки = СоответствиеТочкаВидТочки.Получить(СтрПодч.Точка);
					////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
					//Заменено на:
					Если ДанныеТочки<>Неопределено Тогда 
						СтрокаСв.ВидТочки    = СтрПодч.ВидТочки;
					Иначе	
						СтрокаСв.ВидТочки    = СтрПодч.Точка.ВидТочки;
					КонецЕсли;
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
					СтрокаСв.Направление = СтрПодч.Направление;
					
				КонецЦикла;	
				
				СтрокаТаблицы.ИсходящиеТочки = ТаблицаСвязанных;
				
			КонецЕсли; 
			
		КонецЦикла; // По строкам таблицы 
	КонецЕсли;
	
	ТаблицаТочкиВизы.Индексы.Добавить("Точка");
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-16 (#3393)	
	Если ТаблицаТочкиВизы.Колонки.Найти("НеОстанавливатьМаршрутПоОтклонено") = Неопределено Тогда 
		ТаблицаТочкиВизы.Колонки.Добавить("НеОстанавливатьМаршрутПоОтклонено", Новый ОписаниеТипов("Булево"));
	КонецЕсли;

	Если Алгоритм.ВидАлгоритма = ПредопределенноеЗначение("Перечисление.бит_уп_ВидыАлгоритмов.Визирование") 
	   И Алгоритм.ок_НоваяСхема
	Тогда 
		мТочекДействияДляПроверки = ТаблицаТочки.Скопировать(Новый Структура("ВидТочки",ПредопределенноеЗначение("Перечисление.бит_уп_ВидыТочекАлгоритмов.Действие")));
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
		|	бит_уп_ТочкиАлгоритмовПараметрыПроцесса.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.бит_уп_ТочкиАлгоритмов.ПараметрыПроцесса КАК бит_уп_ТочкиАлгоритмовПараметрыПроцесса
		|ГДЕ
		|	бит_уп_ТочкиАлгоритмовПараметрыПроцесса.Имя = &Имя
		|	И бит_уп_ТочкиАлгоритмовПараметрыПроцесса.Значение = ИСТИНА
		|	И бит_уп_ТочкиАлгоритмовПараметрыПроцесса.Ссылка В(&мТочек)";
		
		Запрос.УстановитьПараметр("Имя"		, "НеОстанавливатьМаршрутПоОтклонено");
		Запрос.УстановитьПараметр("мТочек"	, мТочекДействияДляПроверки);
		
		РезультатЗапроса = Запрос.Выполнить();
		
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
			мНайденныхСтрок = ТаблицаТочкиВизы.НайтиСтроки(Новый Структура("Точка", ВыборкаДетальныеЗаписи.Ссылка));
			Для Каждого стрНайденная Из мНайденныхСтрок Цикл 
				стрНайденная.НеОстанавливатьМаршрутПоОтклонено = Истина;
			КонецЦикла;
		КонецЦикла;	
	КонецЕсли;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-16 (#3393)	
	
	Возврат ТаблицаТочкиВизы;
	
КонецФункции

// Процедура размещает точки алгоритма в таблице позиций.
// 
// Параметры:
//  ТаблицаТочек  - ТаблицаЗначений.
//  ТаблицаПозиций- ТаблицаПозиций.
//  Позиции       - Соответствие.
//  РазмещениеСвободныхТочек - ПеречислениеСсылка.бит_уп_Направление.
// 
Процедура РазместитьТочкиАлгоритма(ТаблицаТочек,ТаблицаПозиций,Позиции,РазмещениеСвободныхТочек) Экспорт
	
	Ном = 1;
	ТекущаяТочка         = Неопределено;
	ТекущаяСтрокаПозиции = Неопределено;	
	
	КоличествоТочек             = ТаблицаТочек.Количество();
	КоличествоОбработанныхТочек = 0;
	
	// Разместим точки алгоритма для отрисовки 
	Пока КоличествоТочек > КоличествоОбработанныхТочек Цикл
		
		Если Ном = 1 Тогда
			
			ТекущаяТочка = РасположитьТочкуСтарта(ТаблицаТочек,ТаблицаПозиций,Позиции);
			Если НЕ ЗначениеЗаполнено(ТекущаяТочка) Тогда
				ВызватьИсключение НСтр("ru='Не найдена точка старта.';en='Found starting point.'"); 
			КонецЕсли; 
		Иначе	
			
			Если ТекущаяТочка = Неопределено Тогда
				
				// Найдем размещенные точки с необработанными связями.
				ТекущаяТочка = НайтиРазмещеннуюБезСвязей(ТаблицаТочек);
				
				// Размещенных точек с необработанными связями нет - найдем неразмещенные точки.
				Если ТекущаяТочка = Неопределено Тогда
					
					ТекущаяТочка = НайтиНеразмещенную(ТаблицаТочек,ТаблицаПозиций,Позиции,РазмещениеСвободныхТочек);
					
				КонецЕсли; 
				
			Иначе
				
				// Расположим исходящие точки по горизонтали.
				ТочкаИсходящаяГор  = РасположитьИсходящиеГоризонтальные(ТаблицаТочек,ТаблицаПозиций,Позиции,ТекущаяТочка);
				
				// Расположим исходящие точки по-вертикали
				ТочкаИсходящаяВерт = РасположитьИсходящиеВертикальные(ТаблицаТочек,ТаблицаПозиций,Позиции,ТекущаяТочка);
				
				ОтметитьСвязиОбработаны(ТаблицаТочек,ТекущаяТочка);
				
				Если НЕ ТочкаИсходящаяВерт = Неопределено Тогда
					
					ТекущаяТочка = ТочкаИсходящаяВерт;
					
				Иначе 	
					
					ТекущаяТочка = ТочкаИсходящаяГор;
					
				КонецЕсли; 
				
			КонецЕсли; // ТекущаяТочка = Неопределено
			
		КонецЕсли;  // Первая точка
		
		КоличествоОбработанныхТочек = ТаблицаТочек.Итог("Обработана");
		
		Если Ном >1000 Тогда
			
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение("Зацикливание при размещении точек алгоритма.");
			Прервать;
			
		КонецЕсли; 
		
		Ном = Ном+1;
		
	КонецЦикла;	// Размещение точек
	
	
КонецПроцедуры // РазместитьТочкиАлгоритма()

// Процедура определяет доступность точек визирования.
// 
// Параметры:
//  ТаблицаТочек      - ТаблицаЗначений.
//  ВыполнятьПоэтапно - Признак того, что алгоритм выполняется поэтапно.
// 
Процедура ОпределитьДоступностьТочек(ТаблицаТочек,ВыполнятьПоэтапно = Ложь) Экспорт
	
	// см. в 44. ОпределитьДоступностьТочекАлгоритма(ТаблицаТочек);
	ТекущаяТочка         = Неопределено;
	ТекущаяСтрокаПозиции = Неопределено;	
	Обработанные         = Новый Соответствие;
	СчетчикЗацикливания  = 1;
	
	КоличествоТочек             = ТаблицаТочек.Количество();
	КоличествоОбработанныхТочек = 0;
	
	СтрокаТаблицыТочек = ТаблицаТочек.Найти(Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт, "ВидТочки");
	Если СтрокаТаблицыТочек <> Неопределено Тогда
		ТекущаяТочка = СтрокаТаблицыТочек.Точка;
	КонецЕсли;
	
	// Разместим точки алгоритма для отрисовки 
	Пока КоличествоТочек > КоличествоОбработанныхТочек Цикл
		Если СтрокаТаблицыТочек = Неопределено Тогда
			СтрокаТаблицыТочек = ТаблицаТочек.Найти(0, "Обработана");
			Если СтрокаТаблицыТочек = Неопределено Тогда
				ОбщегоНазначения.СообщитьПользователю(НСтр("ru='Ошибка при определении доступности точек алгоритма';
															|en='Looping Algorithm in determining availability points'"));
				Прервать;
			КонецЕсли;
			ТекущаяТочка = СтрокаТаблицыТочек.Точка;
		КонецЕсли;
		
		Если СтрокаТаблицыТочек.КоличествоВходящих = 0 Тогда
			СтрокаТаблицыТочек.Доступность       = СтрокаТаблицыТочек.ЕстьПраво;			
			СтрокаТаблицыТочек.ВходящиеЗаполнены = Истина;
		Иначе
			флВходящиеЗаполнены = Истина;
			УровеньРекурсии = 0;
			Если ВыполнятьПоэтапно Тогда
				ВидУсловия = "ЗаполненоРешениеВиза";
			Иначе
				ВидУсловия = "Согласовано";
			КонецЕсли; 					
			ПроверитьВышестоящиеТочки(ТаблицаТочек,ТекущаяТочка,флВходящиеЗаполнены,ВидУсловия,УровеньРекурсии);
			
			Если ЗначениеЗаполнено(СтрокаТаблицыТочек.Решение) 
				И СтрокаТаблицыТочек.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие Тогда
				
				Если ТекущаяТочка.ВходящиеТочки.Количество()>0 Тогда
					ОтметитьВышестоящуюТочкуДействия(ТекущаяТочка.ВходящиеТочки[0].Точка,ТаблицаТочек);
				КонецЕсли; 
			КонецЕсли; 
			
			СтрокаТаблицыТочек.ВходящиеЗаполнены  = флВходящиеЗаполнены;
			СтрокаТаблицыТочек.Доступность = СтрокаТаблицыТочек.ЕстьПраво И флВходящиеЗаполнены;
		КонецЕсли; // По количеству входящих
		
		Обработанные.Вставить(ТекущаяТочка);
		СтрокаТаблицыТочек.Обработана = 1;
		
		ТочкаИсходящая = Неопределено;
		Для каждого СтрокаИсходящие Из ТекущаяТочка.ИсходящиеТочки Цикл
			ТочкаИсходящая = СтрокаИсходящие.Точка;
			Если Обработанные[ТочкаИсходящая] = Неопределено Тогда
				Прервать;
			Иначе
				ТочкаИсходящая = Неопределено;
			КонецЕсли; 
		КонецЦикла; 
		ТекущаяТочка       = ТочкаИсходящая;
		СтрокаТаблицыТочек = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");
		
		КоличествоОбработанныхТочек = ТаблицаТочек.Итог("Обработана");
		
		СчетчикЗацикливания = СчетчикЗацикливания + 1;
		Если СчетчикЗацикливания > 1000 Тогда
			ОбщегоНазначения.СообщитьПользователю(НСтр("ru='Зацикливание при определении доступности точек алгоритма';
														|en='Looping Algorithm in determining availability points'"));
			Прервать;
		КонецЕсли;
		
	КонецЦикла;	// Размещение точек
	
	Для каждого СтрокаТочки Из ТаблицаТочек Цикл
		СтрокаТочки.Доступность  = СтрокаТочки.ЕстьПраво И СтрокаТочки.ВходящиеЗаполнены И НЕ СтрокаТочки.ИсходящиеЗаполнены;
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-08-11 (#2873)
		//Вернул первоначальное
		////+СБ. Пискунова 31.03.2017 #2691
		////СтрокаТочки.Доступность = СтрокаТочки.ЕстьПраво И СтрокаТочки.ВходящиеЗаполнены И НЕ СтрокаТочки.ИсходящиеЗаполнены;		
		//СтрокаТочки.Доступность = СтрокаТочки.ЕстьПраво И СтрокаТочки.ВходящиеЗаполнены И НЕ СтрокаТочки.ИсходящиеЗаполнены и НЕ ЗначениеЗаполнено(СтрокаТочки.Решение);
		////-СБ. Пискунова 31.03.2017 #2691
		//Заменено на:
		СтрокаТочки.Доступность = СтрокаТочки.ДобавленаВручную ИЛИ СтрокаТочки.ЕстьПраво И СтрокаТочки.ВходящиеЗаполнены И НЕ СтрокаТочки.ИсходящиеЗаполнены;		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-08-11 (#2873)		
		СтрокаТочки.АктивнаяВиза = СтрокаТочки.ВходящиеЗаполнены И НЕ СтрокаТочки.ИсходящиеЗаполнены И НЕ ЗначениеЗаполнено(СтрокаТочки.Решение);
	КонецЦикла; 

КонецПроцедуры

// Процедура устанавливает в таблице доступность точек визирования.
// 
// Параметры:
//  ТаблицаТочек      - ТаблицаЗначений.
// 
Процедура ОпределитьДоступностьТочекАлгоритма(ТаблицаТочек) Экспорт
	
	Если (НЕ ТипЗнч(ТаблицаТочек) = Тип("ТаблицаЗначений")) ИЛИ ТаблицаТочек.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ПредставлениеАлгоритма = ПолучитьСокращенноеПредставлениеАлгоритма(ТаблицаТочек);
	КоличествоТочек = ПредставлениеАлгоритма.ИндексТочек.Количество();
	
	ДоступностьТочек = Новый Соответствие();
	
	Для Каждого Точка Из ПредставлениеАлгоритма.ИндексТочек Цикл
		ИндексТочки = ПредставлениеАлгоритма.ИндексТочек.Найти(Точка);
		
		// Проверяем предыдущие.
		Для Сч = 0 По КоличествоТочек-1 Цикл
			ВсеПредыдущиеПройдены = Истина;
			Если ПредставлениеАлгоритма.МатрицаСмежности[Сч][ИндексТочки] = 1 Тогда
				Если НЕ ПредставлениеАлгоритма.ПройденностьТочек[ПредставлениеАлгоритма.ИндексТочек[Сч]] Тогда
					ВсеПредыдущиеПройдены = Ложь;
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// Проверяем последующие.
		Для Сч = 0 По КоличествоТочек-1 Цикл
			ВсеПоследующиеНеПройдены = Истина;
			Если ПредставлениеАлгоритма.МатрицаСмежности[ИндексТочки][Сч] = 1 Тогда
				Если ПредставлениеАлгоритма.ПройденностьТочек[ПредставлениеАлгоритма.ИндексТочек[Сч]] Тогда
					ВсеПоследующиеНеПройдены = Ложь;
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если ВсеПредыдущиеПройдены И ВсеПоследующиеНеПройдены Тогда
			ДоступностьТочек.Вставить(Точка, Истина);
			
			// Добавляем все предыдущие от этой точки.
			Для Сч = 0 По КоличествоТочек-1 Цикл
				Если ПредставлениеАлгоритма.МатрицаСмежности[Сч][ИндексТочки] = 1 Тогда
					ДоступностьТочек.Вставить(ПредставлениеАлгоритма.ИндексТочек[Сч], Истина);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	// Убираем доступность у тех, у которых есть хотя бы одна нижележащая пройденная точка.
	Для Каждого ДоступностьТочки Из ДоступностьТочек Цикл
		// Проверяем последующие.
		Точка = ДоступностьТочки.Ключ;
		ИндексТочки = ПредставлениеАлгоритма.ИндексТочек.Найти(Точка);
		Для Сч = 0 По КоличествоТочек-1 Цикл
			Если ПредставлениеАлгоритма.МатрицаСмежности[ИндексТочки][Сч] = 1 Тогда
				Если ПредставлениеАлгоритма.ПройденностьТочек[ПредставлениеАлгоритма.ИндексТочек[Сч]] Тогда
					ДоступностьТочек.Вставить(Точка, Ложь);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// Для отклоненных - выключаем все выше- и нижележащие точки.
		Если ПредставлениеАлгоритма.ОтклоненностьТочек[Точка] Тогда
			Для Сч = 0 По КоличествоТочек-1 Цикл
				Если ПредставлениеАлгоритма.МатрицаСмежности[Сч][ИндексТочки] = 1 Тогда
					ДоступностьТочек.Вставить(ПредставлениеАлгоритма.ИндексТочек[Сч], Ложь);
				КонецЕсли;
			КонецЦикла;
			Для Сч = 0 По КоличествоТочек-1 Цикл
				Если ПредставлениеАлгоритма.МатрицаСмежности[ИндексТочки][Сч] = 1 Тогда
					ДоступностьТочек.Вставить(ПредставлениеАлгоритма.ИндексТочек[Сч], Ложь);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого ДоступностьТочки Из ДоступностьТочек Цикл
		Точка = ДоступностьТочки.Ключ;
		СтрокаТаблицы = ТаблицаТочек.Найти(Точка, "Точка");
		СтрокаТаблицы.Доступность = ДоступностьТочки.Значение И СтрокаТаблицы.ЕстьПраво;
	КонецЦикла;
	
КонецПроцедуры // ОпределитьДоступностьТочек()

// Процедура проверяет выполнение условия по нижестоящим точкам.
// 
// Параметры:
//  ТаблицаТочек    - ТаблицаЗначений.
//  ТочкаНачальная  - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//  Заполнены       - Булево.
//  Режим           - Строка.
//  УровеньРекурсии - Число.
// 
Процедура ПроверитьНижестоящиеТочки(ТаблицаТочек,ТочкаНачальная,УсловиеВыполнено,Режим,УровеньРекурсии) Экспорт
	
	Если УровеньРекурсии > 1000 Тогда
		
		ТекстСообщения = НСтр("ru = 'Превышен уровень рекурсии при проверке заполнения нижестоящих точек алгоритма.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		Возврат;
		
	КонецЕсли;	
	
	СтрокаТаблицыНачальная = ТаблицаТочек.Найти(ТочкаНачальная,"Точка");
	Если СтрокаТаблицыНачальная = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли; 
	ИсходящиеТочки   = СтрокаТаблицыНачальная.ИсходящиеТочки;
	
	флЕстьНеЗаполненныеРешения = Ложь;
	КолТочДействия       = 0;
	КолТочДействияБезВиз = 0;
	
	Для Каждого СтрокаИсходящие ИЗ ИсходящиеТочки Цикл
		
		Если ЭтоДействие(СтрокаИсходящие.ВидТочки) Тогда
			
			// Проверим принято решение в данной точке или нет.
			СтрокаТаблицы = ТаблицаТочек.Найти(СтрокаИсходящие.Точка,"Точка");
			Если НЕ СтрокаТаблицы = Неопределено Тогда
				
				Если  ВРег(Режим) = ВРег("ЗадачиВыполнены") Тогда
					
					Если СтрокаТаблицы.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Выполнена  Тогда
						
						УсловиеВыполнено = Истина;
						Прервать;
						
					КонецЕсли; 
					
				КонецЕсли; 
				
			КонецЕсли;	  
			
		Иначе
			
			ПроверитьНижестоящиеТочки(ТаблицаТочек,СтрокаИсходящие.Точка,УсловиеВыполнено,Режим,УровеньРекурсии);
			
		КонецЕсли;	// Точка действия
		
	КонецЦикла;	// По входящим точкам
	
КонецПроцедуры	// ПроверитьНижестоящиеТочки

// Функция проверяет наличие точкек действия выше по дереву алгоритма.
// 
// Параметры:
//  ТочкаНачальная - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//
// 
// Возвращаемое значение:
//   Булево.
// 
Функция ВышеНетТочекДействия(ТочкаНачальная, ДопПараметрыПроверкиУсловий) Экспорт
	
	Если ТочкаНачальная = Неопределено ИЛИ ТочкаНачальная.ВходящиеТочки.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
		
	Для каждого СтрокаВходящейТочки Из ТочкаНачальная.ВходящиеТочки Цикл
			
		ТочкаВерхняя = СтрокаВходящейТочки.Точка;
		Если ЭтоДействие(ТочкаВерхняя.ВидТочки) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТочкаВерхняя.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Условие Тогда
			Если ЗначениеЗаполнено(ТочкаВерхняя.ПользовательскоеУсловие) Тогда
				РезультатПроверки = ПроверитьПользовательскоеУсловие(ТочкаВерхняя.ПользовательскоеУсловие
				                                						,ДопПараметрыПроверкиУсловий);
				Если (РезультатПроверки = Истина
						И СтрокаВходящейТочки.Направление = Перечисления.бит_уп_Направление.Горизонталь)
						ИЛИ (РезультатПроверки = Ложь
						И СтрокаВходящейТочки.Направление = Перечисления.бит_уп_Направление.Вертикаль) Тогда
					//Условие не выполняется, по данной ветке не придет
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ВышеНетТочекДействия(ТочкаВерхняя, ДопПараметрыПроверкиУсловий) Тогда
				Возврат Истина;
			КонецЕсли;
		Иначе
			Если ТочкаВерхняя.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт
				ИЛИ ВышеНетТочекДействия(ТочкаВерхняя, ДопПараметрыПроверкиУсловий) Тогда
					Возврат Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь; 
	
КонецФункции

#КонецОбласти

#Область ВыполнениеАлгоритмов

// Процедура выполняет алгоритм процесса.
// 
// Параметры:
//  Алгоритм  - СправочникСсылка.бит_уп_АлгоритмыПроцессов.
//  СтруктураКонтекст  - Структура.
//  РежимСообщений - Строка: "Нет","Все","Ошибки".
//                 
// 
Функция ВыполнитьАлгоритм(Алгоритм,СтруктураКонтекст,РежимСообщений = "Ошибки") Экспорт

    ЗначенияРеквизитов = Новый Структура;
	
	Заголовок = "Выполнение алгоритма """+Алгоритм+"""";
	
	ВыводитьОшибки     = ?(РежимСообщений="Все" ИЛИ РежимСообщений="Ошибки",Истина,Ложь);
	ВыводитьИнформацию = ?(РежимСообщений="Все",Истина,Ложь);	
	
	Если ВыводитьИнформацию Тогда
	
		ТекстСообщения = "Начало выполнения: "+ТекущаяДатаСеанса();
		бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Информация);
	
	КонецЕсли; 
	
	флВыполнятьПоэтапно = ВыполнятьАлгоритмПоэтапно(Алгоритм);	
	ВидАлгоритма        = Алгоритм.ВидАлгоритма;
	
	// Получим точки данного алгоритма
	Если СтруктураКонтекст.Свойство("Визы") Тогда
		
		ТаблицаВизы  = СтруктураКонтекст.Визы.Выгрузить();
		ТаблицаВизы.Колонки.Добавить("ДоступностьВизы", Новый ОписаниеТипов("Булево"));
		ТаблицаТочек = ПолучитьТаблицуТочек(Алгоритм,ТаблицаВизы);
		
	ИначеЕсли СтруктураКонтекст.Свойство("ТабЗадачи") Тогда
		
		ТаблицаТочек = ПолучитьТаблицуТочек(Алгоритм,,,СтруктураКонтекст.ТабЗадачи);
		
	Иначе	
		
		ТаблицаТочек = ПолучитьТаблицуТочек(Алгоритм);
		
	КонецЕсли; 
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-22 (#3231)
	Если ТаблицаТочек.Колонки.Найти("ок_РасшифровкаУсловияОпределенияВизы") = Неопределено Тогда 
		ТаблицаТочек.Колонки.Добавить("ок_РасшифровкаУсловияОпределенияВизы", Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-22 (#3231)	
	
	// Найдем точку старта алгоритма
	НайденнаяСтрока = ТаблицаТочек.Найти(Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт,"ВидТочки");
	
	Если НайденнаяСтрока = Неопределено Тогда
		
		Если ВыводитьОшибки Тогда
			
			ТекстСообщения = "Не удалось найти точку старта.";
			бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
			
		КонецЕсли; 
		Возврат ЗначенияРеквизитов;
	
	КонецЕсли; 
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-08-15 (#2971)
	Если ВидАлгоритма = ПредопределенноеЗначение("Перечисление.бит_уп_ВидыАлгоритмов.Визирование") И 
		 Алгоритм.ок_НоваяСхема И
		 (ТипЗнч(СтруктураКонтекст.ТекущийОбъект) = Тип("ДокументСсылка.бит_ФормаВводаБюджета") 	
		 //ОКЕЙ Назаренко Д.В. (СофтЛаб) Начало 2021-01-18 (#3997) 
		 Или  ТипЗнч(СтруктураКонтекст.ТекущийОбъект) = Тип("ДокументСсылка.ЭлектронныйДокументВходящий"))
		 //ОКЕЙ Назаренко Д.В. (СофтЛаб) Конец 2021-01-18 (#3997) 
		 
		 //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-11 (#3393)
		 ИЛИ ТипЗнч(СтруктураКонтекст.ТекущийОбъект) = Тип("ДокументСсылка.бит_БК_КорректировкаКонтрольныхЗначенийИБюджета")
		     И ЗначениеЗаполнено(СтруктураКонтекст.ТекущийОбъект.ок_ВидКорректировки)
		 //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-11 (#3393)
	Тогда
		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-23 (#3314)
		//ДополнитьКэшДаннымиДляРасчетаУсловий(СтруктураКонтекст);	
		//Заменено на:
		ДополнитьКэшДаннымиДляРасчетаУсловий(СтруктураКонтекст, Алгоритм);	
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-23 (#3314)
		
	КонецЕсли;	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-08-15 (#2971)	
	
	ТекущаяТочка = НайденнаяСтрока.Точка;
	
	ном = 1;
	Пока НЕ ТекущаяТочка = Неопределено Цикл
		
		Если ВыводитьИнформацию Тогда
		
			ТекстСообщения = "Обработка точки """+ТекущаяТочка+""".";
			бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Информация);
		
		КонецЕсли; 
		
		СтрокаТаблицыТочек = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");
		
		// Определим исходящие точки для данной точки.
		СтрОтбор    = Новый Структура("Направление",Перечисления.бит_уп_Направление.Вертикаль);
		МассивСтрок = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтбор);
		
		Если МассивСтрок.Количество()>СтрокаТаблицыТочек.КоличествоОбработанныхСвязей Тогда
			ТочкаДа = МассивСтрок[СтрокаТаблицыТочек.КоличествоОбработанныхСвязей].Точка;
		Иначе	
			ТочкаДа = Неопределено;
		КонецЕсли; 
		
		СтрОтбор    = Новый Структура("Направление",Перечисления.бит_уп_Направление.Горизонталь);
		МассивСтрок = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтбор);
		
		Если МассивСтрок.Количество()>0 Тогда
			ТочкаНет = МассивСтрок[0].Точка;
		Иначе	
			ТочкаНет = Неопределено;
		КонецЕсли; 
		
		// Обработаем данную точку алгоритма в зависимости от вида точки.
		Если ЭтоДействие(ТекущаяТочка.ВидТочки) И СтрокаТаблицыТочек.Обработана = 0 
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-10-19 (#2921)
			И НЕ ТекущаяТочка.ПометкаУдаления
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-10-19 (#2921)
			Тогда
			Если ЗначениеЗаполнено(ТекущаяТочка.ПользовательскоеДействие) Тогда
			
			  // Определим необходимо ли выполнять текущее действие
			  // Это зависит от способа выполнения алгоритма:
			  // Сразу - выполняем все действия за один обход
			  // Поэтапно - выполняем действия постепенно, если выполнены действия 
			  // предыдущих уровней (используется при визировании).
			  
			  Если ВидАлгоритма = Перечисления.бит_уп_ВидыАлгоритмов.Прочее Тогда
				  
				  Если НЕ ЗначениеЗаполнено(СтрокаТаблицыТочек.Задача) Тогда
					  
					  флУсловиеВыполнено = Истина;
					  ПроверитьВышестоящиеТочки(ТаблицаТочек,ТекущаяТочка,флУсловиеВыполнено,"ЗадачиВыполнены",0);
					  
					  Если флУсловиеВыполнено Тогда
						  
						  СтрТочкаДействие = Новый Структура("Точка, Действие, Назначение"
						                                       , ТекущаяТочка
															   , ТекущаяТочка.ПользовательскоеДействие
															   , ТекущаяТочка.ПользовательскоеДействие.Назначение);
						  СтруктураКонтекст.ПользовательскиеДействия.Добавить(СтрТочкаДействие);
						  
					  КонецЕсли; 
					  
				  КонецЕсли; 
				  
			  Иначе	
				  
				  флВыполнятьДействие = Ложь;
				  Если флВыполнятьПоэтапно Тогда
					  флПринятоРешениеПоВышестоящим = Истина;
					  ПроверитьВышестоящиеТочки(ТаблицаТочек,ТекущаяТочка,флПринятоРешениеПоВышестоящим,"ЗаполненоРешение",0);
					  флВыполнятьДействие = флПринятоРешениеПоВышестоящим И НЕ ЗначениеЗаполнено(СтрокаТаблицыТочек.Виза);
				  Иначе	
					  флВыполнятьДействие = Истина;
				  КонецЕсли; 
				  
				  //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-22 (#3231)
				  Если СтруктураКонтекст.Свойство("РасшифровкаУсловияОпределенияВизы") Тогда 
					  Если СтрНайти(СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы,СтруктураКонтекст.РасшифровкаУсловияОпределенияВизы)=0 Тогда 
						  
						  СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы = СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы + 
						  ?(ЗначениеЗаполнено(СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы),Символы.ПС,
						  "") + СтруктураКонтекст.РасшифровкаУсловияОпределенияВизы;
						  
					  КонецЕсли;
					  СтруктураКонтекст.Вставить("РасшифровкаУсловияОпределенияВизы", СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы);
					  
					  Если СтруктураКонтекст.Свойство("Визы") Тогда
						  
						  Для Каждого ЗаписьНабораВиз Из СтруктураКонтекст.Визы Цикл 
							  Если ЗаписьНабораВиз.Виза = ТекущаяТочка.ПользовательскоеДействие.Виза 
								  //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2021-06-16 (#4223)
								 И СтрНайти(ЗаписьНабораВиз.ок_РасшифровкаУсловияОпределенияВизы, СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы) = 0
								 //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2021-06-16 (#4223)  
								  Тогда 
								  //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2021-06-16 (#4223)
								  //ЗаписьНабораВиз.ок_РасшифровкаУсловияОпределенияВизы = СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы;
								  //Заменено на:
								  ЗаписьНабораВиз.ок_РасшифровкаУсловияОпределенияВизы = ЗаписьНабораВиз.ок_РасшифровкаУсловияОпределенияВизы + "
								  														 |" + СтрокаТаблицыТочек.ок_РасшифровкаУсловияОпределенияВизы;
								  //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2021-06-16 (#4223)
							  КонецЕсли;
						  КонецЦикла;
						  
					  КонецЕсли;
					  
				  КонецЕсли;
				  //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-22 (#3231)				  
				  
				  Если флВыполнятьДействие Тогда
				  
				  	       ДействиеВыполнено = ВыполнитьПользовательскоеДействие(ТекущаяТочка.ПользовательскоеДействие
				                                                          ,СтруктураКонтекст
																		  ,ТекущаяТочка
																		  ,Заголовок
																		  ,РежимСообщений);
						  Если ДействиеВыполнено 
							  И ТекущаяТочка.ПользовательскоеДействие.Назначение = Перечисления.бит_НазначенияПользовательскихДействий.Визирование Тогда
							  
							  СтрокаТаблицыТочек.Виза = ТекущаяТочка.ПользовательскоеДействие.Виза;
							  
							  //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-05-15 (#2971)
							  Если СтруктураКонтекст.Свойство("ИнициированныеВизы") Тогда 
							      СтруктураКонтекст.ИнициированныеВизы.Вставить(СтрокаТаблицыТочек.Виза, Новый Массив); //Пустой массив интерпретируем как отсутствие отбора по строкам при заполнении сложных виз  
							  КонецЕсли;
							  //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-05-15 (#2971)
							  
						  КонецЕсли; // Действие выполнено
						  
						  //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-09-18 (#3393)
						  //Прервем выполнение процесса, если найдено свойство ЗакрытьЗаявку
						  Если СтруктураКонтекст.Свойство("ЗакрытьЗаявку")
							 И СтруктураКонтекст.ЗакрытьЗаявку = Истина
						  Тогда
						      Возврат ЗначенияРеквизитов;
					  	  КонецЕсли;
						  //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-09-18 (#3393)		
				  КонецЕсли; 				
				  
				  //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-23 (#3231)
				  СтруктураКонтекст.Удалить("РасшифровкаУсловияОпределенияВизы");							  
				  //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-23 (#3231)
				  
			  КонецЕсли; 
			  
		   Иначе
			  Если ВыводитьОшибки Тогда
			  
			  	 ТекстСообщения = "Не указано действие для точки """+ТекущаяТочка+""".";
				 бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
			  
			  КонецЕсли; 																			   

			КонецЕсли; 
			
			ТекущаяТочка = ТочкаДа;
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Условие И СтрокаТаблицыТочек.Обработана = 0 
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-10-19 (#2921)
			И НЕ ТекущаяТочка.ПометкаУдаления
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-10-19 (#2921)
			Тогда
			// Вычисляем условие
			Если ЗначениеЗаполнено(ТекущаяТочка.ПользовательскоеУсловие) Тогда
				ПараметрыУсловия   = Новый Структура("ТекущийОбъект",СтруктураКонтекст.ТекущийОбъект);
				Если СтруктураКонтекст.Свойство("ОплатаЗаявки") Тогда
				
					ПараметрыУсловия.Вставить("ОплатаЗаявки",СтруктураКонтекст.ОплатаЗаявки);
				
				КонецЕсли; 
				Если СтруктураКонтекст.Свойство("Визы") Тогда
				
					ПараметрыУсловия.Вставить("НаборВизы",СтруктураКонтекст.Визы);
				
				КонецЕсли; 
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-06-25 (#2971)
				пИменаПоказателей = "СуммаПредоплаты,СуммаЗаявки,ВалютаТолькоРуб,ФормаОплатыНаличные,ОбщаяСуммаСОтборомПоСтатье,ВДокументеЕстьСтатьиИнвест,ИнициированныеВизы";
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-03 (#3393)
				пИменаПоказателей = пИменаПоказателей + ",МаксЗнПроцентаПолугПревОпер";
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-03 (#3393)
				мИменаПоказателей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(пИменаПоказателей, ",");
				Для Каждого пИмяПоказателя Из мИменаПоказателей Цикл 
					Если СтруктураКонтекст.Свойство(пИмяПоказателя) Тогда
						
						ПараметрыУсловия.Вставить(пИмяПоказателя,СтруктураКонтекст[пИмяПоказателя]);
						
					КонецЕсли;				
				КонецЦикла;
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-06-25 (#2971)
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-02 (#3393)
				Если СтруктураКонтекст.Свойство("ПараметрыАлгоритма") Тогда 
					
					Для Каждого парАлгоритма Из СтруктураКонтекст.ПараметрыАлгоритма Цикл 
						ПараметрыУсловия.Вставить(парАлгоритма.Ключ, парАлгоритма.Значение);
					КонецЦикла;
					
				КонецЕсли;  
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-02 (#3393)
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2021-06-16 (#4223)
				Если ТипЗнч(ТочкаДа) = Тип("СправочникСсылка.бит_уп_ТочкиАлгоритмов") 
					И ЗначениеЗаполнено(ТочкаДа.ПользовательскоеДействие) Тогда 
					ПараметрыУсловия.Вставить("ВизаПриВыполненииУсловия", ТочкаДа.ПользовательскоеДействие.Виза); 
				 КонецЕсли;				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2021-06-16 (#4223)
				
				флУсловиеВыполнено = ПроверитьПользовательскоеУсловие(ТекущаяТочка.ПользовательскоеУсловие
				                                                                           ,ПараметрыУсловия
																						   ,
																						   ,Заголовок
																						   ,РежимСообщений);
																						   
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-23 (#3231)
			    Если ПараметрыУсловия.Свойство("РасшифровкаУсловияОпределенияВизы") Тогда 
				    СтруктураКонтекст.Вставить("РасшифровкаУсловияОпределенияВизы", ПараметрыУсловия.РасшифровкаУсловияОпределенияВизы);
			    КонецЕсли;					
			    //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-23 (#3231)   
			Иначе	
			  Если ВыводитьОшибки Тогда
			  
			  	 ТекстСообщения = "Не указано условие для точки """+ТекущаяТочка+""".";
				 бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
			  
			  КонецЕсли; 																			   
			  флУсловиеВыполнено = Ложь;
			КонецЕсли; 
			Если флУсловиеВыполнено Тогда
				ТекущаяТочка = ТочкаДа;
			Иначе	
				ТекущаяТочка = ТочкаНет;
			КонецЕсли; 
			
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт 
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-10-19 (#2921)
		И НЕ ТекущаяТочка.ПометкаУдаления
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-10-19 (#2921)
		Тогда
			ТекущаяТочка = ТочкаДа;
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение 
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-10-19 (#2921)
		И НЕ ТекущаяТочка.ПометкаУдаления
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-10-19 (#2921)
		Тогда
			ТекущаяТочка = ТочкаДа;
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние 
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-10-19 (#2921)
		И НЕ ТекущаяТочка.ПометкаУдаления
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-10-19 (#2921)
		Тогда		
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-06-25 (#2971)
			//ТекущаяТочка = ТочкаДа;			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-06-25 (#2971)
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-05-13 (#2971)
			Если СтрокаТаблицыТочек.ТочкаЦикла И
				 (СтруктураКонтекст.ЦФОСПоказателямиОпер.Количество()>0 ИЛИ
				 	 СтруктураКонтекст.ЦФОСПоказателямиИнвест.Количество()>0) И
				 ТекущаяТочка<>Неопределено И
				 ТочкаДа<>Неопределено
			Тогда 
			
			пТабТочекДляЦикла = ТаблицаТочек.Скопировать();
			пТекТочка = ТочкаДа;
			//обрабатываем по ЦФО
			мОбрТочек = Новый Массив;
			
			//Проходим дважды по строкам с разными видами статей (инвест/опер)
			Для Каждого ЦФОПоказатели Из СтруктураКонтекст.ЦФОСПоказателямиОпер Цикл		 
				пТекТочка = ТочкаДа;
				ВыполнитьЦиклПоАналитике(ЦФОПоказатели.Ключ, СтруктураКонтекст, ЦФОПоказатели.Значение, пТекТочка, СтрокаТаблицыТочек.Точка, ТаблицаТочек, мОбрТочек); 
			КонецЦикла;
			
			Для Каждого ЦФОПоказатели Из СтруктураКонтекст.ЦФОСПоказателямиИнвест Цикл
				пТекТочка = ТочкаДа;
				ВыполнитьЦиклПоАналитике(ЦФОПоказатели.Ключ, СтруктураКонтекст, ЦФОПоказатели.Значение, пТекТочка, СтрокаТаблицыТочек.Точка, ТаблицаТочек, мОбрТочек); 
			КонецЦикла;
			
			
			Для Каждого пОбрТочка Из мОбрТочек Цикл
				пНайденнаяСтрокаТочки = ТаблицаТочек.Найти(пОбрТочка,"Точка");
				пНайденнаяСтрокаТочки.Обработана = 1;
				пНайденнаяСтрокаТочки.КоличествоОбработанныхСвязей = пНайденнаяСтрокаТочки.КоличествоОбработанныхСвязей;
				пНайденнаяСтрокаТочки.СвязиОбработаны = 1;
			КонецЦикла; 
			
			//Все точки начала цикла обработаны
			СтрокаТаблицыТочек = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");
			Если НЕ СтрокаТаблицыТочек = Неопределено Тогда
				СтрокаТаблицыТочек.Обработана 	   = 1;
				СтрокаТаблицыТочек.СвязиОбработаны = 1;
				СтрокаТаблицыТочек.КоличествоОбработанныхСвязей = 1;
			КонецЕсли;
			
			//Все точки конца цикла обработаны
			СтрокаТаблицыТочек = ТаблицаТочек.Найти(пТекТочка,"Точка");
			
			// Определим исходящие точки для данной точки.
			СтрОтбор    = Новый Структура("Направление",Перечисления.бит_уп_Направление.Вертикаль);
			МассивСтрок = пТекТочка.ИсходящиеТочки.НайтиСтроки(СтрОтбор);
					
			ТочкаНет = Неопределено; //Слияние только вертикаль (точки Нет не должно быть)
			
			Если МассивСтрок.Количество()>СтрокаТаблицыТочек.КоличествоОбработанныхСвязей Тогда
				ТекущаяТочка = МассивСтрок[СтрокаТаблицыТочек.КоличествоОбработанныхСвязей].Точка;
			Иначе	
				ТекущаяТочка = Неопределено;
			КонецЕсли;
			
		Иначе
			
			ТекущаяТочка = ТочкаДа;
			
		КонецЕсли;	
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-05-13 (#2971)
		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-09-30 (#3393)
		ИначеЕсли СтрокаТаблицыТочек.СвязиОбработаны = 1 Тогда 
		   	СтрокаТаблицыТочек = Неопределено;
			ТекущаяТочка	   = Неопределено;
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-09-30 (#3393)
		
		КонецЕсли;
		
		Если НЕ СтрокаТаблицыТочек = Неопределено Тогда
			
			СтрокаТаблицыТочек.Обработана = 1;
			СтрокаТаблицыТочек.КоличествоОбработанныхСвязей = СтрокаТаблицыТочек.КоличествоОбработанныхСвязей+1;
			Если СтрокаТаблицыТочек.КоличествоОбработанныхСвязей >= СтрокаТаблицыТочек.КоличествоИсходящих Тогда
				
				СтрокаТаблицыТочек.СвязиОбработаны = 1;
				
			КонецЕсли; 
			
		КонецЕсли; 

		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-10-19 (#2921)
		Если ЗначениеЗаполнено(ТекущаяТочка) И
			 ТекущаяТочка.ПометкаУдаления
		Тогда 
			ТекущаяТочка = Неопределено;
		КонецЕсли;
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-10-19 (#2921)
		
		Если НЕ ЗначениеЗаполнено(ТекущаяТочка) Тогда
		
			Если ВидАлгоритма = Перечисления.бит_уп_ВидыАлгоритмов.Визирование 
				 ИЛИ ВидАлгоритма = Перечисления.бит_уп_ВидыАлгоритмов.Прочее Тогда
				
				// Не полностью отработанные точки разделения.
				СтрОтбор = Новый Структура;
				СтрОтбор.Вставить("ВидТочки",Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение);
				СтрОтбор.Вставить("Обработана",1);
				СтрОтбор.Вставить("СвязиОбработаны",0);				
				
				МассивСтрок = ТаблицаТочек.НайтиСтроки(СтрОтбор);
				
				Если МассивСтрок.Количество()>0 Тогда
					
					ТекущаяТочка = МассивСтрок[0].Точка;
					
				КонецЕсли; 
				
				Если НЕ ЗначениеЗаполнено(ТекущаяТочка) Тогда
					
					// Отвязанные точки
					СтрОтбор = Новый Структура;
					СтрОтбор.Вставить("Обработана"        ,0);
					СтрОтбор.Вставить("КоличествоВходящих",0);
					
					МассивСтрок = ТаблицаТочек.НайтиСтроки(СтрОтбор);
					Если МассивСтрок.Количество()>0 Тогда
						
						НайденнаяСтрока = МассивСтрок[0];
						ТекущаяТочка = НайденнаяСтрока.Точка;
						Если НЕ ЗначениеЗаполнено(ТекущаяТочка) Тогда
							
							// Если точка не указана - это независимая виза и обрабатывать здесь нечего.
							НайденнаяСтрока.Обработана         = 1;
							НайденнаяСтрока.КоличествоВходящих = 1;
						
						КонецЕсли; 
						
					Иначе
						
						ТекущаяТочка = Неопределено;
						
					КонецЕсли; 
					
				КонецЕсли; 
				
			КонецЕсли; 
		
		КонецЕсли; 
		
		ном = ном+1;
		// Защита от зацикливания
		Если ном >1000 Тогда
			Если ВыводитьОшибки Тогда
				ЗаголовокСообщения = "";
				Если НЕ ПустаяСтрока(Заголовок) Тогда
					ЗаголовокСообщения = Заголовок + Символы.ПС;
					Заголовок = "";	
				КонецЕсли; 
				ТекстСообщения = СтрШаблон(НСтр("ru='%1Произошло зацикливание алгоритма. Выполнение алгоритма прервано.';en='%1Looping algorithm. The algorithm is interrupted.'"), ЗаголовокСообщения);
				ОбщегоНазначения.СообщитьПользователю(ТекстСообщения); 			
			КонецЕсли; 
			Прервать;
		КонецЕсли; 
	КонецЦикла; // Обходим точки алгоритма
							
	ДатаИзмененияСтатуса = ТекущаяДатаСеанса();
	
	// Если в процессе выполнения алгоритма изменился статус - запишем новое значение.
	Если Алгоритм.ВидАлгоритма = Перечисления.бит_уп_ВидыАлгоритмов.ИзменениеСтатусовОбъектов Тогда 
		
		// ++ NB Отказ от экспортных свойств объектов со статусами.
		Если СтруктураКонтекст.ТекущийОбъект.ДополнительныеСвойства.Свойство("ТекущийСтатус") Тогда
			ТекущийСтатус = СтруктураКонтекст.ТекущийОбъект.ДополнительныеСвойства.ТекущийСтатус;
		Иначе
			//ОКЕЙ Назаренко Д.В. (СофтЛаб) Начало 2021-01-22 (#3997) 
			Если ТипЗнч(СтруктураКонтекст.ТекущийОбъект) = тип("ДокументОбъект.ЭлектронныйДокументВходящий") Тогда
				ТекущийСтатус = СтруктураКонтекст.ТекущийОбъект.ок_Статус;
			Иначе
			//ОКЕЙ Назаренко Д.В. (СофтЛаб) Конец 2021-01-22 (#3997) 	 
				ТекущийСтатус = СтруктураКонтекст.ТекущийОбъект.мТекущийСтатус;
			//ОКЕЙ Назаренко Д.В. (СофтЛаб) Начало 2021-01-22 (#3997) 
			КонецЕсли;
			//ОКЕЙ Назаренко Д.В. (СофтЛаб) Конец 2021-01-22 (#3997) 	 
		КонецЕсли; 
		//ТекущийСтатус = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(
		//					СтруктураКонтекст.ТекущийОбъект.ДополнительныеСвойства,
		//					"ТекущийСтатус", Неопределено);
		НовыйСтатус = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(
							СтруктураКонтекст.ТекущийОбъект.ДополнительныеСвойства,
							"бит_НовыйСтатус", Неопределено);

		Если НовыйСтатус <> Неопределено И ТекущийСтатус <> НовыйСтатус  Тогда
		 
			ДействиеВыполнено = бит_Визирование.УстановитьСтатусОбъекта(СтруктураКонтекст.ТекущийОбъект.Ссылка,
									Перечисления.бит_ВидыСтатусовОбъектов.Статус, НовыйСтатус, ТекущийСтатус,
									Пользователи.ТекущийПользователь(), ДатаИзмененияСтатуса);
			
			Если ДействиеВыполнено Тогда
				Если НЕ СтруктураКонтекст.ТекущийОбъект.ДополнительныеСвойства.Свойство("ТекущийСтатус") Тогда
					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Начало 2021-01-22 (#3997)
					Если ТипЗнч(СтруктураКонтекст.ТекущийОбъект) = Тип("ДокументОбъект.ЭлектронныйДокументВходящий") Тогда
						СтруктураКонтекст.ТекущийОбъект.ок_Статус = НовыйСтатус;
					Иначе
					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Конец 2021-01-22 (#3997) 
						СтруктураКонтекст.ТекущийОбъект.мТекущийСтатус = НовыйСтатус;
					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Начало 2021-01-22 (#3997)
					КонецЕсли;	
					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Конец 2021-01-22 (#3997) 	
				КонецЕсли; 							
				СтруктураКонтекст.ТекущийОбъект.ДополнительныеСвойства.Вставить("ТекущийСтатус", НовыйСтатус);
			КонецЕсли; 	
		КонецЕсли;
	КонецЕсли;	
	
	Если ВыводитьИнформацию Тогда
		ЗаголовокСообщения = "";
		Если НЕ ПустаяСтрока(Заголовок) Тогда
			ЗаголовокСообщения = Заголовок + Символы.ПС;
			Заголовок = "";	
		КонецЕсли; 
		ТекстСообщения = СтрШаблон(НСтр("ru='%1Выполнение закончено: %2';en='%1Vypolnenie it completed: %2'"), ЗаголовокСообщения,
							Формат(ДатаИзмененияСтатуса, "Л=ru_RU; ДЛФ=DT"));
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения); 
	КонецЕсли; 
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Функция определяет следует ли данный алгоритм выполнять поэтапно или нет.
// 
// Параметры:
//  Алгоритм  - СправочникСсылка.бит_уп_Алгоритмы.
// 
// Возвращаемое значение:
//   флВыполнятьПоэтапно   - Булево.
// 
Функция ВыполнятьАлгоритмПоэтапно(Алгоритм) Экспорт
	
	флВыполнятьПоэтапно = Ложь;
	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Алгоритм, "ВидАлгоритма, СпособВыполнения");
	
	Если Реквизиты.ВидАлгоритма = Перечисления.бит_уп_ВидыАлгоритмов.Визирование Тогда
		
		Если Реквизиты.СпособВыполнения = Перечисления.бит_уп_СпособыВыполненияАлгоритма.Поэтапно Тогда
			
			флВыполнятьПоэтапно = Истина;
			
		КонецЕсли; 
		
	ИначеЕсли Реквизиты.ВидАлгоритма = Перечисления.бит_уп_ВидыАлгоритмов.Прочее Тогда
		
		флВыполнятьПоэтапно = Истина;
		
	КонецЕсли; 
	
	Возврат флВыполнятьПоэтапно;
	
КонецФункции // ВыполнятьАлгоритмПоэтапно()

// Функция выполняет пользовательское действие.
// 
// Параметры:
//  ПользовательскоеДействие  - СправочникСсылка.бит_ПользовательскиеДействия.
//  СтруктураКонтекст  - Структура.
//  ЗначенияРеквизитов - Структура.
//  Заголовок      - Строка.
//  РежимСообщений - Строка: "Нет","Все","Ошибки".
// 
// Возвращаемое значение:
//   флДействиеВыполнено   - Булево.
// 
Функция ВыполнитьПользовательскоеДействие(ПользовательскоеДействие
	                                       ,СтруктураКонтекст
										   ,ТочкаАлгоритма = Неопределено
										   ,Заголовок=""
										   ,РежимСообщений="Ошибки") Экспорт

	флВыполнено = Справочники.бит_ПользовательскиеДействия.ВыполнитьПользовательскоеДействие(ПользовательскоеДействие
					                                                                             , СтруктураКонтекст
																								 , ТочкаАлгоритма
																								 , Заголовок
																								 , РежимСообщений);									   
										   
																				 
	Возврат флВыполнено;
																				 
																				 
КонецФункции										   

// Функция вычисляет значение пользовательского условия.
// 
// Параметры:
//  ПользовательскоеУсловие  - СправочникСсылка.бит_ПользовательскиеУсловия.
//  СтруктураКонтекст        - Структура.
//  ВыражениеКорректно       - Булево - признак того, что выражения условия корректно.
//  Заголовок      - Строка.
//  РежимСообщений - Строка: "Нет","Все","Ошибки".
// 
// Возвращаемое значение:
//   флРезультат   - Булево.
// 
Функция ПроверитьПользовательскоеУсловие(ПользовательскоеУсловие
	                                      ,СтруктураКонтекст
										  ,ВыражениеКорректно = Истина
										  ,Заголовок = ""
										  ,РежимСообщений  = "Ошибки") Экспорт

	флРезультат = Справочники.бит_ПользовательскиеУсловия.ПроверитьПользовательскоеУсловие(ПользовательскоеУсловие
	                                                                                        , СтруктураКонтекст
																							, ВыражениеКорректно
																							, Заголовок
																							, РежимСообщений); 
	
	Возврат флРезультат;
	
КонецФункции // ПроверитьПользовательскоеУсловие()

// Функция получает алгоритмы изменения статусов для текущего объекта.
// 
// Параметры:
//  ТекущийОбъект  - ДокументОбъект,ДокументСсылка.
//  ВидАлгоритма   - ПеречислениеСсылка.бит_уп_ВидыАлгоритмов, СписокЗначений.
// 
// Возвращаемое значение:
// РезСтруктура - Структура - Ключ: имя вида алгоритма, Значение: Алгоритм.
// 
Функция ПолучитьАлгоритмыОбъектаСистемы(ТекущийОбъект,ВидАлгоритма = Неопределено) Экспорт

	РезСтруктура = Новый Структура;
	
	// Инициализируем результирующую структуру
	Для каждого ЗначениеПеречисления Из Метаданные.Перечисления.бит_уп_ВидыАлгоритмов.ЗначенияПеречисления Цикл
	
		РезСтруктура.Вставить(ЗначениеПеречисления.Имя,Справочники.бит_уп_Алгоритмы.ПустаяСсылка())
	
	КонецЦикла;
		
	МетаданныеОбъекта = ТекущийОбъект.Метаданные();
	
	ОбъектСистемы = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(МетаданныеОбъекта);
	
	ТекущийПериод = ТекущийОбъект.Дата;
	Если Не ЗначениеЗаполнено(ТекущийПериод) Тогда
	
		ТекущийПериод = ТекущаяДата();
	
	КонецЕсли; 
	
	// Формируем список видов для отбора
	Если ТипЗнч(ВидАлгоритма) = Тип("СписокЗначений") Тогда
		
		СписокВидов = ВидАлгоритма;
		
	Иначе	
		
		СписокВидов = Новый СписокЗначений;
		СписокВидов.Добавить(ВидАлгоритма);
		
	КонецЕсли; 
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ОбъектСистемы",ОбъектСистемы);
	Запрос.УстановитьПараметр("Период"       ,ТекущийПериод);
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	бит_уп_НазначениеАлгоритмовСрезПоследних.Алгоритм,
	               |	бит_уп_НазначениеАлгоритмовСрезПоследних.ВидАлгоритма КАК ВидАлгоритма,
	               |	бит_уп_НазначениеАлгоритмовСрезПоследних.ПользовательскоеУсловие,
	               |	ВЫБОР
	               |		КОГДА бит_уп_НазначениеАлгоритмовСрезПоследних.ПользовательскоеУсловие = ЗНАЧЕНИЕ(Справочник.бит_ПользовательскиеУсловия.ПустаяСсылка)
	               |			ТОГДА 1
	               |		ИНАЧЕ 0
	               |	КОНЕЦ КАК Приоритер
	               |ИЗ
	               |	РегистрСведений.бит_уп_НазначениеАлгоритмов.СрезПоследних(
	               |			&Период,
	               |			ОбъектСистемы = &ОбъектСистемы
	               |				%УсловиеВидАлгоритма%				   				   
	               |				) КАК бит_уп_НазначениеАлгоритмовСрезПоследних
				   |ГДЕ
				   |   КонецПериода(бит_уп_НазначениеАлгоритмовСрезПоследних.ДатаОкончания,День) >=&Период 
				   |       ИЛИ бит_уп_НазначениеАлгоритмовСрезПоследних.ДатаОкончания = ДАТАВРЕМЯ(1, 1, 1) 
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Приоритер
	               |ИТОГИ ПО
	               |	ВидАлгоритма";
				   
				   
   // При необходимости добавляем условие на вид.
   Если НЕ ВидАлгоритма = Неопределено Тогда
	   
	   Запрос.УстановитьПараметр("СписокВидов"  ,СписокВидов);
	   Запрос.Текст = СтрЗаменить(Запрос.Текст,"%УсловиеВидАлгоритма%"," И ВидАлгоритма В (&СписокВидов)");
	   
   Иначе
	   
	   Запрос.Текст = СтрЗаменить(Запрос.Текст,"%УсловиеВидАлгоритма%","");
	   
   КонецЕсли; 			   
				   
    Результат = Запрос.Выполнить();
	
	ВыборкаВид = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	// Заполняем результат
	Пока ВыборкаВид.Следующий() Цикл
		
		ИмяЗначения               = бит_ОбщегоНазначения.ПолучитьИмяЗначенияПеречисления(Перечисления.бит_уп_ВидыАлгоритмов
		                                                                                 ,ВыборкаВид.ВидАлгоритма);		
		
		Выборка        = ВыборкаВид.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		МассивЗначений = Новый Массив;
		
		Пока Выборка.Следующий() Цикл
			
			
			 Если ЗначениеЗаполнено(Выборка.ПользовательскоеУсловие) Тогда
			 
			 	   ПараметрыУсловия   = Новый Структура("ТекущийОбъект",ТекущийОбъект);
				   флДобавлятьЗначение = ПроверитьПользовательскоеУсловие(Выборка.ПользовательскоеУсловие
				                                                                           ,ПараметрыУсловия
																						   ,
																						   ,""
																						   ,"Ошибки");

			 Иначе																			   
				 
				 флДобавлятьЗначение = Истина;
				 
			 КонецЕсли; 
			 
			 Если флДобавлятьЗначение Тогда
				 
				 МассивЗначений.Добавить(Выборка.Алгоритм);
				 
			 КонецЕсли; 
			 
		
		КонецЦикла; // ВыборкаДетали 
		
		Если МассивЗначений.Количество()= 1 Тогда
			
			РезСтруктура[ИмяЗначения] = МассивЗначений[0];			
			
		ИначеЕсли МассивЗначений.Количество() > 1 Тогда	
			
			РезСтруктура[ИмяЗначения] = МассивЗначений;
			
			
		КонецЕсли; 
		
	КонецЦикла; // ВыборкаВид 
	
					   
	Возврат РезСтруктура;
	

КонецФункции // ПолучитьАлгоритмыОбъектаСистемы()

// Процедура получает алгоритм визирования для данного объекта системы.
// 
// Параметры:
//  ТекущийОбъект  - ДокументОбъект,ДокументСсылка.
// 
Функция ПолучитьАлгоритмВизирования(ТекущийОбъект) Экспорт

	РезАлгоритмы        = ПолучитьАлгоритмыОбъектаСистемы(ТекущийОбъект,Перечисления.бит_уп_ВидыАлгоритмов.Визирование); 
	Если ТипЗнч(РезАлгоритмы.Визирование) = Тип("Массив") Тогда
		Алгоритм      = РезАлгоритмы.Визирование[0];
	Иначе	
		Алгоритм     = РезАлгоритмы.Визирование;
	КонецЕсли; 
	
	Возврат Алгоритм;

КонецФункции // ПолучитьАлгоритмВизирования()

// Определяет приняты ли решения по вышестоящим визам для объекта.
// 
// Параметры:
//  ТекущийОбъект - Произвольный.
//  Виза - СправочникСсылка.бит_Визы.
//  вхНаборВизы - РегистрСведенийНаборЗаписе.бит_УстановленныеВизы.
// 
// Возвращаемое значение:
//  флПринятыРешения - Булево.
// 
Функция ПринятыРешенияПоВышестоящимТочкам(ТекущийОбъект, вхНаборВизы = Неопределено, Виза) Экспорт
	
	флПринятыРешения = Ложь;
	
	Если вхНаборВизы = Неопределено Тогда
		
		СтруктураОтбор = Новый Структура;
		СтруктураОтбор.Вставить("Объект", ТекущийОбъект.Ссылка);
		НаборВизы = бит_Визирование.ПрочитатьНаборВиз(СтруктураОтбор);
		
	Иначе	
		
		НаборВизы = вхНаборВизы;
		
	КонецЕсли; 
	
	Алгоритм = Неопределено;
	Для каждого СтрокаВизы Из НаборВизы Цикл
		
		Если ЗначениеЗаполнено(СтрокаВизы.Алгоритм) Тогда
			
			Алгоритм = СтрокаВизы.Алгоритм;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	Если ЗначениеЗаполнено(Алгоритм) Тогда
		
		ТаблицаВизы  = НаборВизы.Выгрузить();
		ТаблицаВизы.Колонки.Добавить("ДоступностьВизы", Новый ОписаниеТипов("Булево"));
		ТаблицаТочек = ПолучитьТаблицуТочек(Алгоритм,ТаблицаВизы);
		
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("Виза", Виза);
		
		МассивСтрок = ТаблицаТочек.НайтиСтроки(СтрОтбор);
		
		Если МассивСтрок.Количество() > 0 Тогда
			
			СтрокаТаблицыТочек = МассивСтрок[0];
			
			Если ЗначениеЗаполнено(СтрокаТаблицыТочек.Точка) Тогда
				
				Если ЗначениеЗаполнено(СтрокаТаблицыТочек.Решение) Тогда
					
					// Если принято решение по самой визе, то по вышестоящим они точно приняты.
					флПринятыРешения = Истина;
					
				Иначе	
					
					// В данной ситуации нужно проверить приняты ли решения по вышестоящим.
					флПринятоРешениеПоВышестоящим = Истина;
					ПроверитьВышестоящиеТочки(ТаблицаТочек,СтрокаТаблицыТочек.Точка,флПринятоРешениеПоВышестоящим,"ЗаполненоРешение",0);
					
					флПринятыРешения = флПринятоРешениеПоВышестоящим;
					
				КонецЕсли; 
				
			Иначе
				
				// Свободная визы - значит вышестоящих нет
				флПринятыРешения = Истина
				
			КонецЕсли; 
			
		КонецЕсли; // МассивСтрок.Количество() > 0
		
	КонецЕсли; // ЗначениеЗаполнено(Алгоритм)
	
	Возврат флПринятыРешения;
	
КонецФункции // ПринятыРешенияПоВышестоящимТочкам()

//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-05-11 (#2971)

//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-23 (#3314)
//Процедура ДополнитьКэшДаннымиДляРасчетаУсловий(СтруктураКонтекст)
//Заменено на:
Процедура ДополнитьКэшДаннымиДляРасчетаУсловий(СтруктураКонтекст, Алгоритм)
//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-23 (#3314)

	
	Перем пТаблицаПревышенияПоОсобымЦФО, пТаблицаПревышенияПоЦФО;
	
	//Используется для поиска виз, которые необходимо единожды инициировать, например ГД
	СтруктураКонтекст.Вставить("ИнициированныеВизы", Новый Соответствие); 
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-26 (#3400)
	СтрПараметрыАлгоритма = Новый Структура;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-26 (#3400)

	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-23 (#3314)	
	Для Каждого СтрПараметр Из Алгоритм.ПараметрыАлгоритма Цикл 
		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-26 (#3400)
		//СтрПараметрыАлгоритма = Новый Структура;
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-26 (#3400)
		
		
		Если ЗначениеЗаполнено(СтрПараметр.ЗначениеПоУмолчанию) 
			 И СтрПараметр.СтрТип = "СправочникСсылка.бит_ИсточникиДанных"
			 //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-11-21 (#3393)
			 И СтрПараметр.Обязательный			
			 //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-11-21 (#3393)
			 
		Тогда 
			
			пСтандартныйПериод = Новый СтандартныйПериод;
			пСтандартныйПериод.ДатаНачала	 = СтруктураКонтекст.ТекущийОбъект.Дата;
			пСтандартныйПериод.ДатаОкончания = пСтандартныйПериод.ДатаНачала;
			
			пТаблицаПараметры = Новый ТаблицаЗначений;
			пТаблицаПараметры.Колонки.Добавить("ИмяПараметра");
			пТаблицаПараметры.Колонки.Добавить("ЗначениеПараметра");
			
			бит_МеханизмПолученияДанных.ОбновитьТаблицуПараметров(СтрПараметр.ЗначениеПоУмолчанию, пТаблицаПараметры, Ложь);
			
			СтрокиПараметров = пТаблицаПараметры.НайтиСтроки(Новый Структура("ИмяПараметра","Ссылка"));
			Если СтрокиПараметров.Количество()>0 Тогда 
				СтрокиПараметров[0].ЗначениеПараметра = СтруктураКонтекст.ТекущийОбъект;
			КонецЕсли;
					
			РезВыполнения = Обработки.бит_ПолучениеДанныхРегистровБухгалтерии.ПолучитьДанные(СтрПараметр.ЗначениеПоУмолчанию
																						   , пСтандартныйПериод
																						   , Новый ТаблицаЗначений
																						   , пТаблицаПараметры
																						   , ПредопределенноеЗначение("Справочник.бит_мпд_НастройкиПуловПодключений.ПустаяСсылка")); 
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-09-12 (#3393)
			Если ТипЗнч(РезВыполнения) = Тип("Структура") Тогда 
				//Поддержка старых алгоритмов
				Для Каждого КлЗн Из РезВыполнения Цикл 
					СтруктураКонтекст.Вставить(КлЗн.Ключ, КлЗн.Значение);
				КонецЦикла;
			Иначе				
				СтрПараметрыАлгоритма.Вставить(СтрПараметр.Имя, РезВыполнения);
			КонецЕсли;
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-09-12 (#3393)			
			
		Иначе			
			СтрПараметрыАлгоритма.Вставить(СтрПараметр.Имя, СтрПараметр.ЗначениеПоУмолчанию);
		КонецЕсли;
		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-26 (#3400)
		//СтруктураКонтекст.Вставить("ПараметрыАлгоритма", СтрПараметрыАлгоритма);		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-26 (#3400)                           		
		
	КонецЦикла;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-23 (#3314)
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-26 (#3400)
	СтруктураКонтекст.Вставить("ПараметрыАлгоритма", СтрПараметрыАлгоритма);		
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-26 (#3400)

	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-09-12 (#3393)
	Возврат; //Текст ниже не комментировался для выполнения задачи 3499
	//Перенесено в параметры Алгоритма
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка"					, СтруктураКонтекст.ТекущийОбъект);
	Запрос.УстановитьПараметр("ВалютаРуб"				, ОбщегоНазначенияБПВызовСервераПовтИсп.ПолучитьВалютуРегламентированногоУчета());
	Запрос.УстановитьПараметр("СтатьиДляОтбора"			, бит_БК_Общий.ПолучитьЗначениеНастройкиБК("Визирование", "Список статей для отбора" ,Новый СписокЗначений));
	Запрос.УстановитьПараметр("ЦФОДляОтбора"            , бит_БК_Общий.ПолучитьЗначениеНастройкиБК("Визирование", "Список ЦФО исключений"	,Новый СписокЗначений));
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	бит_ФормаВводаБюджетаБДДС.Ссылка.СБ_СуммаПредоплатыИтого КАК СуммаПредоплаты,
	|	бит_ФормаВводаБюджетаБДДС.Ссылка.Дата КАК Дата,
	|	бит_ФормаВводаБюджетаБДДС.Ссылка.бит_БК_НомерЗаявки КАК бит_БК_НомерЗаявки,
	|	СУММА(бит_ФормаВводаБюджетаБДДС.бит_БК_СуммаБезНДС) КАК СуммаЗаявки,
	|	МИНИМУМ(ВЫБОР
	|			КОГДА бит_ФормаВводаБюджетаБДДС.бит_БК_ВалютаДоговора = &ВалютаРуб
	|				ТОГДА ИСТИНА
	|			ИНАЧЕ ЛОЖЬ
	|		КОНЕЦ) КАК ВалютаТолькоРуб,
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА бит_ФормаВводаБюджетаБДДС.бит_БК_ФормаОплаты = ЗНАЧЕНИЕ(Перечисление.бит_ВидыДенежныхСредств.Наличные)
	|				ТОГДА ИСТИНА
	|			ИНАЧЕ ЛОЖЬ
	|		КОНЕЦ) КАК ФормаОплатыНаличные,
	|	СУММА(ВЫБОР
	|			КОГДА бит_ФормаВводаБюджетаБДДС.СтатьяОборотов В (&СтатьиДляОтбора)
	|				ТОГДА бит_ФормаВводаБюджетаБДДС.бит_БК_СуммаБезНДС
	|			ИНАЧЕ 0
	|		КОНЕЦ) КАК ОбщаяСуммаСОтборомПоСтатье,
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-07-11 (#2971)
	//|	бит_ФормаВводаБюджетаБДДС.СтатьяОборотов.ВидСтатьи КАК СтатьяОборотовВидСтатьи,
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-07-11 (#2971)                              	
	|	МАКСИМУМ(ВЫБОР
	|			КОГДА бит_ФормаВводаБюджетаБДДС.СтатьяОборотов.ВидСтатьи = ЗНАЧЕНИЕ(Справочник.бит_ВидыСтатейОборотов.ИнвестиционнаяДеятельность)
	|				ТОГДА ИСТИНА
	|			ИНАЧЕ ЛОЖЬ
	|		КОНЕЦ) КАК ВДокументеЕстьСтатьиИнвест
	|ИЗ
	|	Документ.бит_ФормаВводаБюджета.БДДС КАК бит_ФормаВводаБюджетаБДДС
	|ГДЕ
	|	бит_ФормаВводаБюджетаБДДС.Ссылка = &Ссылка
	|
	|СГРУППИРОВАТЬ ПО
	|	бит_ФормаВводаБюджетаБДДС.Ссылка.СБ_СуммаПредоплатыИтого,
	|	бит_ФормаВводаБюджетаБДДС.Ссылка.Дата,
	|	бит_ФормаВводаБюджетаБДДС.Ссылка.бит_БК_НомерЗаявки
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-07-11 (#2971)
	//|	,бит_ФормаВводаБюджетаБДДС.СтатьяОборотов.ВидСтатьи
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-07-11 (#2971) 	
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	бит_ФормаВводаБюджетаБДДС.ЦФО КАК ЦФО,
	|	бит_ФормаВводаБюджетаБДДС.НомерСтроки КАК НомерСтроки,
	|	ВЫБОР
	|		КОГДА бит_ФормаВводаБюджетаБДДС.СтатьяОборотов В (&СтатьиДляОтбора)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК СтрокаСОтборомПоСтатье,
	|	ВЫБОР
	|		КОГДА бит_ФормаВводаБюджетаБДДС.СтатьяОборотов.ВидСтатьи = ЗНАЧЕНИЕ(Справочник.бит_ВидыСтатейОборотов.Выручка)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК СтрокаОпер,
	|	ВЫБОР
	|		КОГДА бит_ФормаВводаБюджетаБДДС.СтатьяОборотов.ВидСтатьи = ЗНАЧЕНИЕ(Справочник.бит_ВидыСтатейОборотов.ИнвестиционнаяДеятельность)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК СтрокаИнвест,
	|	ЕСТЬNULL(ОбъектыСтроительства.Ссылка, ЗНАЧЕНИЕ(Справочник.ОбъектыСтроительства.ПустаяСсылка)) КАК ОбъектСтроительства,
	|	бит_ФормаВводаБюджетаБДДС.СтатьяОборотов КАК СтатьяОборотов,
	|	бит_ФормаВводаБюджетаБДДС.Период КАК Период,
	|	бит_ФормаВводаБюджетаБДДС.Проект КАК Проект,
	|	ВЫБОР
	|		КОГДА бит_ФормаВводаБюджетаБДДС.ОстатокПоБюджету > 0
	|			ТОГДА 0
	|		ИНАЧЕ -бит_ФормаВводаБюджетаБДДС.ОстатокПоБюджету
	|	КОНЕЦ КАК ОстатокПоБюджету,
	|	бит_ФормаВводаБюджетаБДДС.ИД КАК ИД,
	|	бит_ФормаВводаБюджетаБДДС.Ссылка КАК Ссылка,
	|	бит_ФормаВводаБюджетаБДДС.Контрагент КАК Контрагент,
	|	бит_ФормаВводаБюджетаБДДС.ДоговорКонтрагента КАК ДоговорКонтрагента,
	|	бит_ФормаВводаБюджетаБДДС.НоменклатурнаяГруппа КАК НоменклатурнаяГруппа,
	|	бит_ФормаВводаБюджетаБДДС.БанковскийСчет КАК БанковскийСчет,
	|	бит_ФормаВводаБюджетаБДДС.Аналитика_1 КАК Аналитика_1,
	|	бит_ФормаВводаБюджетаБДДС.Аналитика_2 КАК Аналитика_2,
	|	бит_ФормаВводаБюджетаБДДС.Аналитика_3 КАК Аналитика_3,
	|	бит_ФормаВводаБюджетаБДДС.Аналитика_4 КАК Аналитика_4,
	|	бит_ФормаВводаБюджетаБДДС.Аналитика_5 КАК Аналитика_5,
	|	бит_ФормаВводаБюджетаБДДС.Аналитика_6 КАК Аналитика_6,
	|	бит_ФормаВводаБюджетаБДДС.Аналитика_7 КАК Аналитика_7,
	|	бит_ФормаВводаБюджетаБДДС.Количество КАК Количество,
	|	бит_ФормаВводаБюджетаБДДС.Норма КАК Норма,
	|	бит_ФормаВводаБюджетаБДДС.Сумма КАК Сумма,
	|	бит_ФормаВводаБюджетаБДДС.Измерение КАК Измерение,
	|	бит_ФормаВводаБюджетаБДДС.Расчетная КАК Расчетная,
	|	бит_ФормаВводаБюджетаБДДС.Комментарий КАК Комментарий,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_Организация КАК бит_БК_Организация,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_НаименованиеОборудования КАК бит_БК_НаименованиеОборудования,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ПредпологаемыйКонтрагент КАК бит_БК_ПредпологаемыйКонтрагент,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ЕдиницаИзмерения КАК бит_БК_ЕдиницаИзмерения,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_СуммаПредоплаты КАК бит_БК_СуммаПредоплаты,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_НуженДоговор КАК бит_БК_НуженДоговор,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_УсловияОплаты КАК бит_БК_УсловияОплаты,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ФормаОплаты КАК бит_БК_ФормаОплаты,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_АдекватностьЦены КАК бит_БК_АдекватностьЦены,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_СуммаБезНДС КАК бит_БК_СуммаБезНДС,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_СуммаВВалютеСНДС КАК бит_БК_СуммаВВалютеСНДС,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ЦенаСНДС КАК бит_БК_ЦенаСНДС,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ОстатокПоБюджету КАК бит_БК_ОстатокПоБюджету,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ВалютаДоговора КАК бит_БК_ВалютаДоговора,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_Курс КАК бит_БК_Курс,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_Кратность КАК бит_БК_Кратность,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ЦенаВВалютеБезНДС КАК бит_БК_ЦенаВВалютеБезНДС,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ПревышениеБюджета КАК бит_БК_ПревышениеБюджета,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ЦенаВВалютеСНДС КАК бит_БК_ЦенаВВалютеСНДС,
	|	бит_ФормаВводаБюджетаБДДС.ПредставлениеПериода КАК ПредставлениеПериода,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_Расход КАК бит_БК_Расход,
	|	бит_ФормаВводаБюджетаБДДС.ОК_НоменклатураПроизв КАК ОК_НоменклатураПроизв,
	|	бит_ФормаВводаБюджетаБДДС.бит_СтавкаНДС КАК бит_СтавкаНДС,
	|	бит_ФормаВводаБюджетаБДДС.Сценарий КАК Сценарий,
	|	бит_ФормаВводаБюджетаБДДС.БИТ_СуммаСверхБюджета КАК БИТ_СуммаСверхБюджета,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_ПолнаяСуммаЛимита КАК бит_БК_ПолнаяСуммаЛимита,
	|	бит_ФормаВводаБюджетаБДДС.бит_БК_БлокировкиПолейФинансовогоКонтроллера КАК бит_БК_БлокировкиПолейФинансовогоКонтроллера,
	|	бит_ФормаВводаБюджетаБДДС.СБ_СуммаПредоплаты КАК СБ_СуммаПредоплаты,
	|	бит_ФормаВводаБюджетаБДДС.ОстатокПоБюджету КАК ОстатокПоБюджетуТЧ
	|ПОМЕСТИТЬ ВТ_ДанныеТЧ
	|ИЗ
	|	Документ.бит_ФормаВводаБюджета.БДДС КАК бит_ФормаВводаБюджетаБДДС
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ОбъектыСтроительства КАК ОбъектыСтроительства
	|		ПО ((ВЫРАЗИТЬ(бит_ФормаВводаБюджетаБДДС.Аналитика_2 КАК Справочник.ОбъектыСтроительства)) = ОбъектыСтроительства.Ссылка)
	|ГДЕ
	|	бит_ФормаВводаБюджетаБДДС.Ссылка = &Ссылка
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДанныеТЧ.ЦФО КАК ЦФО,
	|	ВТ_ДанныеТЧ.ОбъектСтроительства КАК ОбъектСтроительства,
	|	ВТ_ДанныеТЧ.СтатьяОборотов КАК СтатьяОборотов,
	|	ВТ_ДанныеТЧ.Период КАК Период,
	|	ВТ_ДанныеТЧ.Проект КАК Проект,
	|	МАКСИМУМ(ВТ_ДанныеТЧ.ОстатокПоБюджету) КАК ОстатокПоБюджету,
	|	ВТ_ДанныеТЧ.СтрокаОпер КАК Опер,
	|	ВТ_ДанныеТЧ.СтрокаИнвест КАК Инвест
	|ПОМЕСТИТЬ ВТ_ТаблицаДляРасчетаСверхбюджета
	|ИЗ
	|	ВТ_ДанныеТЧ КАК ВТ_ДанныеТЧ
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДанныеТЧ.Проект,
	|	ВТ_ДанныеТЧ.ЦФО,
	|	ВТ_ДанныеТЧ.ОбъектСтроительства,
	|	ВТ_ДанныеТЧ.СтатьяОборотов,
	|	ВТ_ДанныеТЧ.Период,
	|	ВТ_ДанныеТЧ.СтрокаОпер,
	|	ВТ_ДанныеТЧ.СтрокаИнвест
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Опер,
	|	ЦФО,
	|	ОстатокПоБюджету
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ТаблицаДляРасчетаСверхбюджета.ЦФО КАК ЦФО,
	|	СУММА(ВТ_ТаблицаДляРасчетаСверхбюджета.ОстатокПоБюджету) КАК ОстатокПоБюджету
	|ПОМЕСТИТЬ ВТ_СверхБюджетОпер
	|ИЗ
	|	ВТ_ТаблицаДляРасчетаСверхбюджета КАК ВТ_ТаблицаДляРасчетаСверхбюджета
	|ГДЕ
	|	ВТ_ТаблицаДляРасчетаСверхбюджета.Опер
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ТаблицаДляРасчетаСверхбюджета.ЦФО
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ТаблицаДляРасчетаСверхбюджета.ЦФО КАК ЦФО,
	|	СУММА(ВТ_ТаблицаДляРасчетаСверхбюджета.ОстатокПоБюджету) КАК ОстатокПоБюджету
	|ПОМЕСТИТЬ ВТ_СверхБюджетИнвест
	|ИЗ
	|	ВТ_ТаблицаДляРасчетаСверхбюджета КАК ВТ_ТаблицаДляРасчетаСверхбюджета
	|ГДЕ
	|	ВТ_ТаблицаДляРасчетаСверхбюджета.Инвест
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ТаблицаДляРасчетаСверхбюджета.ЦФО
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДанныеТЧ.ЦФО КАК ЦФО,
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ВТ_ДанныеТЧ.ОбъектСтроительства) КАК ОбъектСтроительства
	|ПОМЕСТИТЬ ВТ_ЦФО_ОбъектыСтроительства
	|ИЗ
	|	ВТ_ДанныеТЧ КАК ВТ_ДанныеТЧ
	|ГДЕ
	|	ВТ_ДанныеТЧ.ОбъектСтроительства <> ЗНАЧЕНИЕ(Справочник.ОбъектыСтроительства.ПустаяСсылка)
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДанныеТЧ.ЦФО
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ВТ_ДанныеТЧ.ЦФО КАК ЦФО,
	|	МАКСИМУМ(КОНЕЦПЕРИОДА(ВТ_ДанныеТЧ.Период, КВАРТАЛ)) КАК Период
	|ПОМЕСТИТЬ ВТ_ЦФО_Квартал
	|ИЗ
	|	ВТ_ДанныеТЧ КАК ВТ_ДанныеТЧ
	|ГДЕ
	|	ВТ_ДанныеТЧ.СтрокаОпер
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДанныеТЧ.ЦФО,
	|	НАЧАЛОПЕРИОДА(ВТ_ДанныеТЧ.Период, ГОД)
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО,
	|	Период
	|;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-20 (#3314)
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ВТ_ДанныеТЧ.ЦФО КАК ЦФО,
	|	МАКСИМУМ(КОНЕЦПЕРИОДА(ВТ_ДанныеТЧ.Период, ПОЛУГОДИЕ)) КАК Период
	|ПОМЕСТИТЬ ВТ_ЦФО_Полугодие
	|ИЗ
	|	ВТ_ДанныеТЧ КАК ВТ_ДанныеТЧ
	|ГДЕ
	|	ВТ_ДанныеТЧ.СтрокаОпер
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДанныеТЧ.ЦФО,
	|	НАЧАЛОПЕРИОДА(ВТ_ДанныеТЧ.Период, ГОД)
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО,
	|	Период
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВТ_ЦФО_Полугодие.Период КАК Период,
	|	ВТ_ЦФО_Полугодие.ЦФО КАК ЦФО,
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) КАК СуммаСценарийКонтроль,
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) КАК СуммаСценарийИсполнение,
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) - СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) КАК СуммаПревышения,
	|	ВЫБОР
	|		КОГДА СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) = 0
	|			ТОГДА 100
	|		ИНАЧЕ (СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) - СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль)) * 100 / СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль)
	|	КОНЕЦ КАК ПроцентПревышения
	|ПОМЕСТИТЬ ВТ_ДляВычисленияПроцента_Полугодие
	|ИЗ
	|	РегистрНакопления.бит_КонтрольныеЗначенияБюджетов КАК бит_КонтрольныеЗначенияБюджетов
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ЦФО_Полугодие КАК ВТ_ЦФО_Полугодие
	|		ПО (бит_КонтрольныеЗначенияБюджетов.Период >= НАЧАЛОПЕРИОДА(ВТ_ЦФО_Полугодие.Период, ГОД))
	|			И бит_КонтрольныеЗначенияБюджетов.Период <= ВТ_ЦФО_Полугодие.Период
	|			И бит_КонтрольныеЗначенияБюджетов.ЦФО = ВТ_ЦФО_Полугодие.ЦФО
	|ГДЕ
	|	бит_КонтрольныеЗначенияБюджетов.Сценарий = ЗНАЧЕНИЕ(Справочник.СценарииПланирования.Бюджет_У)
	|	И бит_КонтрольныеЗначенияБюджетов.СценарийКонтролируемый = ЗНАЧЕНИЕ(Справочник.СценарииПланирования.Заявка_У)
	|	И НЕ ВТ_ЦФО_Полугодие.Период ЕСТЬ NULL
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ЦФО_Полугодие.Период,
	|	ВТ_ЦФО_Полугодие.ЦФО
	|
	|ИМЕЮЩИЕ
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) - СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) < 0
	|;
	|
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-08-22 (#3231)
	//|////////////////////////////////////////////////////////////////////////////////
	//|ВЫБРАТЬ
	//|	МАКСИМУМ(ВТ_ДляВычисленияПроцента_Полугодие.ПроцентПревышения) КАК ПроцентПревышения,
	////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-20 (#3314)
	//|	МАКСИМУМ(ВТ_ДляВычисленияПроцента_Полугодие.СуммаПревышения) КАК СуммаПревышения,
	////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-20 (#3314)
	//|	ВТ_ДляВычисленияПроцента_Полугодие.ЦФО КАК ЦФО
	//|ПОМЕСТИТЬ ВТ_ПроцентыПревышенияОпер_Полугодие
	//|ИЗ	
	//|	ВТ_ДляВычисленияПроцента_Полугодие КАК ВТ_ДляВычисленияПроцента_Полугодие
	//|
	//|СГРУППИРОВАТЬ ПО
	//|	ВТ_ДляВычисленияПроцента_Полугодие.ЦФО
	//|
	//|ИНДЕКСИРОВАТЬ ПО
	//|	ЦФО
	//|;
	//|
	//Заменено на:
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МАКСИМУМ(ВТ_ДляВычисленияПроцента_Полугодие.ПроцентПревышения) КАК ПроцентПревышения,	
	|	ВТ_ДляВычисленияПроцента_Полугодие.ЦФО КАК ЦФО
	|ПОМЕСТИТЬ ВТ_ПроцентыПревышенияОперМаксимальныйПроцент_Полугодие
	|ИЗ
	|	ВТ_ДляВычисленияПроцента_Полугодие КАК ВТ_ДляВычисленияПроцента_Полугодие
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДляВычисленияПроцента_Полугодие.ЦФО
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;	
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МАКСИМУМ(ВТ_ДляВычисленияПроцента_Полугодие.ПроцентПревышения) КАК ПроцентПревышения,
	|	СУММА(ВТ_ДляВычисленияПроцента_Полугодие.СуммаПревышения) КАК СуммаПревышения,	
	|	ВТ_ДляВычисленияПроцента_Полугодие.ЦФО КАК ЦФО
	|ПОМЕСТИТЬ ВТ_ПроцентыПревышенияОпер_Полугодие
	|ИЗ	
	|   ВТ_ПроцентыПревышенияОперМаксимальныйПроцент_Полугодие
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_ДляВычисленияПроцента_Полугодие КАК ВТ_ДляВычисленияПроцента_Полугодие
	|	    ПО ВТ_ПроцентыПревышенияОперМаксимальныйПроцент_Полугодие.ЦФО = ВТ_ДляВычисленияПроцента_Полугодие.ЦФО
	|		 И ВТ_ПроцентыПревышенияОперМаксимальныйПроцент_Полугодие.ПроцентПревышения = ВТ_ДляВычисленияПроцента_Полугодие.ПроцентПревышения
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДляВычисленияПроцента_Полугодие.ЦФО
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;
	|
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-08-22 (#3231)
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-20 (#3314)
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВТ_ЦФО_Квартал.Период КАК Период,
	|	ВТ_ЦФО_Квартал.ЦФО КАК ЦФО,
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) КАК СуммаСценарийКонтроль,
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) КАК СуммаСценарийИсполнение,
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) - СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) КАК СуммаПревышения,
	|	ВЫБОР
	|		КОГДА СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) = 0
	|			ТОГДА 100
	|		ИНАЧЕ (СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) - СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль)) * 100 / СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль)
	|	КОНЕЦ КАК ПроцентПревышения
	|ПОМЕСТИТЬ ВТ_ДляВычисленияПроцента
	|ИЗ
	|	РегистрНакопления.бит_КонтрольныеЗначенияБюджетов КАК бит_КонтрольныеЗначенияБюджетов
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ЦФО_Квартал КАК ВТ_ЦФО_Квартал
	|		ПО (бит_КонтрольныеЗначенияБюджетов.Период >= НАЧАЛОПЕРИОДА(ВТ_ЦФО_Квартал.Период, ГОД))
	|			И бит_КонтрольныеЗначенияБюджетов.Период <= ВТ_ЦФО_Квартал.Период
	|			И бит_КонтрольныеЗначенияБюджетов.ЦФО = ВТ_ЦФО_Квартал.ЦФО
	|ГДЕ
	|	бит_КонтрольныеЗначенияБюджетов.Сценарий = ЗНАЧЕНИЕ(Справочник.СценарииПланирования.Бюджет_У)
	|	И бит_КонтрольныеЗначенияБюджетов.СценарийКонтролируемый = ЗНАЧЕНИЕ(Справочник.СценарииПланирования.Заявка_У)
	|	И НЕ ВТ_ЦФО_Квартал.Период ЕСТЬ NULL
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ЦФО_Квартал.Период,
	|	ВТ_ЦФО_Квартал.ЦФО
	|
	|ИМЕЮЩИЕ
	|	СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийКонтроль) - СУММА(бит_КонтрольныеЗначенияБюджетов.СуммаСценарийИсполнение) < 0
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МАКСИМУМ(ВТ_ДляВычисленияПроцента.ПроцентПревышения) КАК ПроцентПревышения,
	|	ВТ_ДляВычисленияПроцента.ЦФО КАК ЦФО
	|ПОМЕСТИТЬ ВТ_ПроцентыПревышенияОпер
	|ИЗ
	|	ВТ_ДляВычисленияПроцента КАК ВТ_ДляВычисленияПроцента
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДляВычисленияПроцента.ЦФО
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДанныеТЧ.ЦФО КАК ЦФО,
	|	СУММА(ВТ_ДанныеТЧ.бит_БК_СуммаБезНДС) КАК СуммаБезНДС
	|ПОМЕСТИТЬ ВТ_СуммаБезНДСПоЦФО
	|ИЗ
	|	ВТ_ДанныеТЧ КАК ВТ_ДанныеТЧ
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ДанныеТЧ.ЦФО
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	ЦФО
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДанныеТЧ.ЦФО КАК ЦФО,
	|	ВТ_ДанныеТЧ.НомерСтроки КАК НомерСтроки,
	|	ВТ_ДанныеТЧ.СтрокаСОтборомПоСтатье КАК СтрокаСОтборомПоСтатье,
	|	ВТ_ДанныеТЧ.СтрокаОпер КАК СтрокаОпер,
	|	ВТ_ДанныеТЧ.СтрокаИнвест КАК СтрокаИнвест,
	|	ВТ_ДанныеТЧ.ОбъектСтроительства КАК ОбъектСтроительства,
	|	ВТ_ДанныеТЧ.СтатьяОборотов КАК СтатьяОборотов,
	|	ВТ_ДанныеТЧ.Период КАК Период,
	|	ВТ_ДанныеТЧ.Проект КАК Проект,
	|	ЕСТЬNULL(ВТ_ЦФО_ОбъектыСтроительства.ОбъектСтроительства, 0) КАК КоличествоОбъектовСтроительства,
	|	ЕСТЬNULL(ВТ_СверхБюджетОпер.ОстатокПоБюджету, 0) КАК СуммаСверхБюджетаОпер,
	|	ЕСТЬNULL(ВТ_СверхБюджетИнвест.ОстатокПоБюджету, 0) КАК СуммаСверхБюджетаИнвест,
	|	ЕСТЬNULL(ВТ_ПроцентыПревышенияОпер.ПроцентПревышения, 0) КАК ПроцентКвартальногоПревышенияОпер,
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-20 (#3314)
	|	ЕСТЬNULL(ВТ_ПроцентыПревышенияОпер_Полугодие.ПроцентПревышения, 0) КАК ПроцентПолугодовогоПревышенияОпер,
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-20 (#3314)
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-24 (#3231)
	|	ЕСТЬNULL(ВТ_ПроцентыПревышенияОпер_Полугодие.СуммаПревышения, 0) КАК СуммаПолугодовогоПревышенияОпер,
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-24 (#3231)
	|	ВЫБОР
	|		КОГДА ВТ_ДанныеТЧ.ЦФО В (&ЦФОДляОтбора)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ОсобыйПорядокРасчетаПоказателяПревышения,
	|	ВТ_ДанныеТЧ.ИД КАК ИД,
	|	ВТ_ДанныеТЧ.Ссылка КАК Ссылка,
	|	ВТ_ДанныеТЧ.Контрагент КАК Контрагент,
	|	ВТ_ДанныеТЧ.ДоговорКонтрагента КАК ДоговорКонтрагента,
	|	ВТ_ДанныеТЧ.НоменклатурнаяГруппа КАК НоменклатурнаяГруппа,
	|	ВТ_ДанныеТЧ.БанковскийСчет КАК БанковскийСчет,
	|	ВТ_ДанныеТЧ.Аналитика_1 КАК Аналитика_1,
	|	ВТ_ДанныеТЧ.Аналитика_2 КАК Аналитика_2,
	|	ВТ_ДанныеТЧ.Аналитика_3 КАК Аналитика_3,
	|	ВТ_ДанныеТЧ.Аналитика_4 КАК Аналитика_4,
	|	ВТ_ДанныеТЧ.Аналитика_5 КАК Аналитика_5,
	|	ВТ_ДанныеТЧ.Аналитика_6 КАК Аналитика_6,
	|	ВТ_ДанныеТЧ.Аналитика_7 КАК Аналитика_7,
	|	ВТ_ДанныеТЧ.Количество КАК Количество,
	|	ВТ_ДанныеТЧ.Норма КАК Норма,
	|	ВТ_ДанныеТЧ.Сумма КАК Сумма,
	|	ВТ_ДанныеТЧ.Измерение КАК Измерение,
	|	ВТ_ДанныеТЧ.Расчетная КАК Расчетная,
	|	ВТ_ДанныеТЧ.Комментарий КАК Комментарий,
	|	ВТ_ДанныеТЧ.бит_БК_Организация КАК бит_БК_Организация,
	|	ВТ_ДанныеТЧ.бит_БК_НаименованиеОборудования КАК бит_БК_НаименованиеОборудования,
	|	ВТ_ДанныеТЧ.бит_БК_ПредпологаемыйКонтрагент КАК бит_БК_ПредпологаемыйКонтрагент,
	|	ВТ_ДанныеТЧ.бит_БК_ЕдиницаИзмерения КАК бит_БК_ЕдиницаИзмерения,
	|	ВТ_ДанныеТЧ.бит_БК_СуммаПредоплаты КАК бит_БК_СуммаПредоплаты,
	|	ВТ_ДанныеТЧ.бит_БК_НуженДоговор КАК бит_БК_НуженДоговор,
	|	ВТ_ДанныеТЧ.бит_БК_УсловияОплаты КАК бит_БК_УсловияОплаты,
	|	ВТ_ДанныеТЧ.бит_БК_ФормаОплаты КАК бит_БК_ФормаОплаты,
	|	ВТ_ДанныеТЧ.бит_БК_АдекватностьЦены КАК бит_БК_АдекватностьЦены,
	|	ВТ_ДанныеТЧ.бит_БК_СуммаБезНДС КАК бит_БК_СуммаБезНДС,
	|	ВТ_ДанныеТЧ.бит_БК_СуммаВВалютеСНДС КАК бит_БК_СуммаВВалютеСНДС,
	|	ВТ_ДанныеТЧ.бит_БК_ЦенаСНДС КАК бит_БК_ЦенаСНДС,
	|	ВТ_ДанныеТЧ.бит_БК_ОстатокПоБюджету КАК бит_БК_ОстатокПоБюджету,
	|	ВТ_ДанныеТЧ.бит_БК_ВалютаДоговора КАК бит_БК_ВалютаДоговора,
	|	ВТ_ДанныеТЧ.бит_БК_Курс КАК бит_БК_Курс,
	|	ВТ_ДанныеТЧ.бит_БК_Кратность КАК бит_БК_Кратность,
	|	ВТ_ДанныеТЧ.бит_БК_ЦенаВВалютеБезНДС КАК бит_БК_ЦенаВВалютеБезНДС,
	|	ВТ_ДанныеТЧ.бит_БК_ПревышениеБюджета КАК бит_БК_ПревышениеБюджета,
	|	ВТ_ДанныеТЧ.бит_БК_ЦенаВВалютеСНДС КАК бит_БК_ЦенаВВалютеСНДС,
	|	ВТ_ДанныеТЧ.ПредставлениеПериода КАК ПредставлениеПериода,
	|	ВТ_ДанныеТЧ.бит_БК_Расход КАК бит_БК_Расход,
	|	ВТ_ДанныеТЧ.ОК_НоменклатураПроизв КАК ОК_НоменклатураПроизв,
	|	ВТ_ДанныеТЧ.бит_СтавкаНДС КАК бит_СтавкаНДС,
	|	ВТ_ДанныеТЧ.Сценарий КАК Сценарий,
	|	ВТ_ДанныеТЧ.БИТ_СуммаСверхБюджета КАК БИТ_СуммаСверхБюджета,
	|	ВТ_ДанныеТЧ.бит_БК_ПолнаяСуммаЛимита КАК бит_БК_ПолнаяСуммаЛимита,
	|	ВТ_ДанныеТЧ.бит_БК_БлокировкиПолейФинансовогоКонтроллера КАК бит_БК_БлокировкиПолейФинансовогоКонтроллера,
	|	ВТ_ДанныеТЧ.СБ_СуммаПредоплаты КАК СБ_СуммаПредоплаты,
	|	ВТ_ДанныеТЧ.ОстатокПоБюджетуТЧ КАК ОстатокПоБюджету,
	|	ЕСТЬNULL(ВТ_СуммаБезНДСПоЦФО.СуммаБезНДС, 0) КАК СуммаБезНДСПоЦФО
	|ИЗ
	|	ВТ_ДанныеТЧ КАК ВТ_ДанныеТЧ
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ЦФО_ОбъектыСтроительства КАК ВТ_ЦФО_ОбъектыСтроительства
	|		ПО ВТ_ДанныеТЧ.ЦФО = ВТ_ЦФО_ОбъектыСтроительства.ЦФО
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_СверхБюджетОпер КАК ВТ_СверхБюджетОпер
	|		ПО ВТ_ДанныеТЧ.ЦФО = ВТ_СверхБюджетОпер.ЦФО
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_СверхБюджетИнвест КАК ВТ_СверхБюджетИнвест
	|		ПО ВТ_ДанныеТЧ.ЦФО = ВТ_СверхБюджетИнвест.ЦФО
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ПроцентыПревышенияОпер КАК ВТ_ПроцентыПревышенияОпер
	|		ПО ВТ_ДанныеТЧ.ЦФО = ВТ_ПроцентыПревышенияОпер.ЦФО
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-20 (#3314)
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_ПроцентыПревышенияОпер_Полугодие КАК ВТ_ПроцентыПревышенияОпер_Полугодие
	|		ПО ВТ_ДанныеТЧ.ЦФО = ВТ_ПроцентыПревышенияОпер_Полугодие.ЦФО
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-20 (#3314)
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_СуммаБезНДСПоЦФО КАК ВТ_СуммаБезНДСПоЦФО
	|		ПО ВТ_ДанныеТЧ.ЦФО = ВТ_СуммаБезНДСПоЦФО.ЦФО	
	|ИТОГИ
	|	МАКСИМУМ(СтрокаСОтборомПоСтатье),
	|	МАКСИМУМ(СтрокаОпер),
	|	МАКСИМУМ(СтрокаИнвест),
	|	МАКСИМУМ(КоличествоОбъектовСтроительства),
	|	МАКСИМУМ(СуммаСверхБюджетаОпер),
	|	МАКСИМУМ(СуммаСверхБюджетаИнвест),
	|	МАКСИМУМ(ПроцентКвартальногоПревышенияОпер),
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-20 (#3314)
	|	МАКСИМУМ(ПроцентПолугодовогоПревышенияОпер),
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-20 (#3314)
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-24 (#3231)
	|	МАКСИМУМ(СуммаПолугодовогоПревышенияОпер),
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-24 (#3231)
	|	МАКСИМУМ(ОсобыйПорядокРасчетаПоказателяПревышения),
	|	МАКСИМУМ(СуммаБезНДСПоЦФО)
	|ПО
	|	ЦФО";
	
	пРезультатПакет = Запрос.ВыполнитьПакет();
	
	пДанныеШапки = пРезультатПакет[0].Выбрать();
	Если пДанныеШапки.Следующий() Тогда
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-08-13 (#3231)
		//СтруктураКонтекст.Вставить("СуммаПредоплаты"		   , пДанныеШапки.СуммаПредоплаты);  //значение реквизита документа СБ_СуммаПредоплатыИтого
		//СтруктураКонтекст.Вставить("СуммаЗаявки"			   , пДанныеШапки.СуммаЗаявки); //сумма значений реквизита бит_БК_СуммаБезНДС ТЧ БДДС 
		//Заменено на:
		СтруктураКонтекст.Вставить("СуммаПредоплаты"		   , Окр(пДанныеШапки.СуммаПредоплаты,2));  //значение реквизита документа СБ_СуммаПредоплатыИтого
		СтруктураКонтекст.Вставить("СуммаЗаявки"			   , Окр(пДанныеШапки.СуммаЗаявки,2)); //сумма значений реквизита бит_БК_СуммаБезНДС ТЧ БДДС 
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-08-13 (#3231)		
		СтруктураКонтекст.Вставить("ВалютаТолькоРуб"		   , пДанныеШапки.ВалютаТолькоРуб);//истина, если во всех строках ТЧ БДДС значение реквизита бит_БК_ВалютаДоговора рубли
		СтруктураКонтекст.Вставить("ФормаОплатыНаличные"	   , пДанныеШапки.ФормаОплатыНаличные);//истина, если во всех строках ТЧ БДДС значение реквизита бит_БК_ФормаОплаты наличные 
		СтруктураКонтекст.Вставить("ОбщаяСуммаСОтборомПоСтатье", пДанныеШапки.ОбщаяСуммаСОтборомПоСтатье);//сумма значений реквизита бит_БК_СуммаБезНДС ТЧ БДДС в разрезе статей, указанных в настройке БК Список статей для отбора		
		СтруктураКонтекст.Вставить("ВДокументеЕстьСтатьиИнвест", пДанныеШапки.ВДокументеЕстьСтатьиИнвест);
		пДатаДок = пДанныеШапки.Дата;
	Иначе 
		пДатаДок = СтруктураКонтекст.ТекущийОбъект.Дата;		
		бит_БК_НомерЗаявки = СтруктураКонтекст.ТекущийОбъект.бит_БК_НомерЗаявки;		
	КонецЕсли;
	
	//Обработка общих показателей	
	
	ЦФОСПоказателямиИнвест = Новый Соответствие;	
	ЦФОСПоказателямиОпер   = Новый Соответствие;	
	
	//Для расчета суммы превышения
	пКопияТЧБДДСОсобыйРасчет = СтруктураКонтекст.ТекущийОбъект.БДДС.ВыгрузитьКолонки();
	пКопияТЧБДДС 			 = пКопияТЧБДДСОсобыйРасчет.СкопироватьКолонки();
		
	ВыборкаЦФО = пРезультатПакет[пРезультатПакет.Количество()-1].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаЦФО.Следующий() Цикл 
		
		Если Не ВыборкаЦФО.СтрокаОпер И НЕ ВыборкаЦФО.СтрокаИнвест Тогда 
			Продолжить;
		КонецЕсли;
		
		//Показатели, используемые при построении маршрута
		Если ВыборкаЦФО.СтрокаОпер Тогда 
			ЦФОСПоказателямиОпер.Вставить(ВыборкаЦФО.ЦФО, ПолучитьСтруктуруПолейПоказателей());
			ЗаполнитьЗначенияСвойств(ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО],ВыборкаЦФО,,"СуммаСверхБюджетаИнвест");
			ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО].ЕстьСтрокиОпер = ВыборкаЦФО.СтрокаОпер;
			ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО].ЕстьСтрокиСОтборомПоСтатье = ВыборкаЦФО.СтрокаСОтборомПоСтатье;
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-08-13 (#3231)
			Для Каждого СтрПоказатель Из ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО] Цикл 
				Если ТипЗнч(СтрПоказатель.Значение) = Тип("Число") Тогда 
					ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО].Вставить(СтрПоказатель.Ключ, Окр(СтрПоказатель.Значение, 2));
				КонецЕсли;
			КонецЦикла;
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-08-13 (#3231)
			
		КонецЕсли;
		
		Если ВыборкаЦФО.СтрокаИнвест Тогда 
			ЦФОСПоказателямиИнвест.Вставить(ВыборкаЦФО.ЦФО, ПолучитьСтруктуруПолейПоказателей());
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-20 (#3314)
			//ЗаполнитьЗначенияСвойств(ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО],ВыборкаЦФО,,"СуммаСверхБюджетаОпер,ПроцентКвартальногоПревышенияОпер");			
			//Заменено на:
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-24 (#3231)
			//ЗаполнитьЗначенияСвойств(ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО],ВыборкаЦФО,,"СуммаСверхБюджетаОпер,ПроцентКвартальногоПревышенияОпер,ПроцентПолугодовогоПревышенияОпер");						
			//Заменено на:
			ЗаполнитьЗначенияСвойств(ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО],ВыборкаЦФО,,"СуммаСверхБюджетаОпер,ПроцентКвартальногоПревышенияОпер,ПроцентПолугодовогоПревышенияОпер,СуммаПолугодовогоПревышенияОпер");						
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-24 (#3231)
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-20 (#3314)
			ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО].ЕстьСтрокиИнвест = ВыборкаЦФО.СтрокаИнвест;
			ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО].ЕстьСтрокиСОтборомПоСтатье = ВыборкаЦФО.СтрокаСОтборомПоСтатье;
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-08-13 (#3231)
			Для Каждого СтрПоказатель Из ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО] Цикл 
				Если ТипЗнч(СтрПоказатель.Значение) = Тип("Число") Тогда 
					ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО].Вставить(СтрПоказатель.Ключ, Окр(СтрПоказатель.Значение, 2));
				КонецЕсли;
			КонецЦикла;
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-08-13 (#3231)
			
		КонецЕсли;
	
		ВыборкаДетали = ВыборкаЦФО.Выбрать();
		Пока ВыборкаДетали.Следующий() Цикл 
					
			Если ВыборкаДетали.СтрокаОпер Тогда 
				
				ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО].НомераСтрокПоЦФО.Добавить(ВыборкаДетали.НомерСтроки);
				
				Если ВыборкаДетали.СтрокаСОтборомПоСтатье Тогда 
				
					ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО].НомераСтрокСОтборомПоСтатье.Добавить(ВыборкаДетали.НомерСтроки);
				  	
				КонецЕсли;
				
				Если ВыборкаДетали.ОстатокПоБюджету>=0 И
					 ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО].СуммаСверхБюджетаОпер <> 0
				Тогда 
					ЦФОСПоказателямиОпер[ВыборкаЦФО.ЦФО].НомераСтрокИсклСверхБюджета.Добавить(ВыборкаДетали.НомерСтроки);
				КонецЕсли;

			КонецЕсли;
			
			Если ВыборкаДетали.СтрокаИнвест Тогда 
				
				ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО].НомераСтрокПоЦФО.Добавить(ВыборкаДетали.НомерСтроки);
				
				Если ВыборкаДетали.СтрокаСОтборомПоСтатье Тогда 
				
					ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО].НомераСтрокСОтборомПоСтатье.Добавить(ВыборкаДетали.НомерСтроки);
					
				КонецЕсли;				
				
				Если ВыборкаДетали.ОстатокПоБюджету>=0 И
					 ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО].СуммаСверхБюджетаИнвест <> 0                               
				Тогда 
					ЦФОСПоказателямиИнвест[ВыборкаЦФО.ЦФО].НомераСтрокИсклСверхБюджета.Добавить(ВыборкаДетали.НомерСтроки);
				КонецЕсли;
				
				//Для расчета суммы превышения
				Если ВыборкаЦФО.ОсобыйПорядокРасчетаПоказателяПревышения Тогда 
					пСтрокаТЧДляРасчета = пКопияТЧБДДСОсобыйРасчет.Добавить();
				Иначе
					пСтрокаТЧДляРасчета = пКопияТЧБДДС.Добавить();
				КонецЕсли;
				
				ЗаполнитьЗначенияСвойств(пСтрокаТЧДляРасчета, ВыборкаДетали);
				
			КонецЕсли; 					
			
		КонецЦикла;
		
	КонецЦикла;
	
	ЗначенияПеречисления = Метаданные.Перечисления.бит_БК_ДопИзмеренияКонтроля.ЗначенияПеречисления;
	
	СписокАналитик = Новый СписокЗначений;	
	СтрокаАналитик = "ЦФО,Аналитика_2,Проект,ПериодГод";	
		
	Для Каждого ИмяАналитики Из СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаАналитик,",",Истина) Цикл 
		Если ЗначенияПеречисления.Найти(ИмяАналитики) <> Неопределено Тогда 
			СписокАналитик.Добавить(ПредопределенноеЗначение("Перечисление.бит_БК_ДопИзмеренияКонтроля."+ИмяАналитики));
		КонецЕсли;
	КонецЦикла;
	
	Если пКопияТЧБДДС.Количество()>0 Тогда 
		пТаблицаПревышенияПоЦФО = бит_БК_Общий.ПолучитьТаблицуСПревышениямиПоАналитикам(СписокАналитик, пКопияТЧБДДС			 , пДатаДок,  бит_БК_НомерЗаявки, СтруктураКонтекст.ТекущийОбъект.Ссылка);		
	КонецЕсли;
	
	Если пКопияТЧБДДСОсобыйРасчет.Количество()>0 Тогда 	
		
		Если ЗначенияПеречисления.Найти("ПериодГод") <> Неопределено Тогда 
			пНайденныйЭлемент = СписокАналитик.НайтиПоЗначению(ПредопределенноеЗначение("Перечисление.бит_БК_ДопИзмеренияКонтроля.ПериодГод"));
			Если пНайденныйЭлемент<>Неопределено Тогда 
				СписокАналитик.Удалить(пНайденныйЭлемент);
			КонецЕсли;
		КонецЕсли;
		
		пТаблицаПревышенияПоОсобымЦФО = бит_БК_Общий.ПолучитьТаблицуСПревышениямиПоАналитикам(СписокАналитик, пКопияТЧБДДСОсобыйРасчет, пДатаДок, бит_БК_НомерЗаявки, СтруктураКонтекст.ТекущийОбъект.Ссылка);
		
	КонецЕсли;
	
	//Расчет показателей суммы превышения и процента превышения только для инвест
	Для Каждого СоответствиеЦФО ИЗ ЦФОСПоказателямиИнвест Цикл 
		
		пМаксЗначениеПревышения = 0;					
		пСуммаКонтроль			= 0;
		
		Если пТаблицаПревышенияПоОсобымЦФО<>Неопределено Тогда 
			
			пНайденныеСтроки = пТаблицаПревышенияПоОсобымЦФО.НайтиСтроки(Новый Структура("ЦФО",СоответствиеЦФО.Ключ));
			Для Каждого пНайденнаяСтрока Из пНайденныеСтроки Цикл   
				пМаксЗначениеПревышения = Макс(пМаксЗначениеПревышения, пНайденнаяСтрока.СверхБюджетаПоКлючевым);
				пСуммаКонтроль	    = пНайденнаяСтрока.СуммаКонтроль;
			КонецЦикла;			
			
		КонецЕсли;
		
		Если пМаксЗначениеПревышения = 0 И
			пТаблицаПревышенияПоЦФО<>Неопределено
			Тогда 
			
			пНайденныеСтроки = пТаблицаПревышенияПоЦФО.НайтиСтроки(Новый Структура("ЦФО",СоответствиеЦФО.Ключ));
			Для Каждого пНайденнаяСтрока Из пНайденныеСтроки Цикл 
				пМаксЗначениеПревышения = Макс(пМаксЗначениеПревышения, пНайденнаяСтрока.СверхБюджетаПоКлючевым);
				пСуммаКонтроль	    = пНайденнаяСтрока.СуммаКонтроль;
			КонецЦикла;
			
		КонецЕсли;
	
		СоответствиеЦФО.Значение.Вставить("СуммаПревышенияБюджетаИнвест"	,	пМаксЗначениеПревышения);
		
		пПроцентПревышения = 0;
		Если пМаксЗначениеПревышения <> 0 И
			 пСуммаКонтроль = 0
		Тогда 
		    пПроцентПревышения = 100;
		ИначеЕсли пМаксЗначениеПревышения <> 0 И
			 	  пСуммаКонтроль <> 0 
		Тогда 
			пПроцентПревышения = Окр(пМаксЗначениеПревышения*100/пСуммаКонтроль,0);
		КонецЕсли;
		СоответствиеЦФО.Значение.Вставить("ПроцентПревышенияБюджетаИнвест"	,	пПроцентПревышения);
		
	КонецЦикла;
	
	СтруктураКонтекст.Вставить("ЦФОСПоказателямиИнвест", ЦФОСПоказателямиИнвест);
	СтруктураКонтекст.Вставить("ЦФОСПоказателямиОпер"  , ЦФОСПоказателямиОпер);
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-24 (#3231)
	СообщениеПользователюПоМаршрутуСогласования = "";
	//ОКЕЙ Рычаков А.С.(СофтЛаб)2019-10-07 Начало (#3499)
	СообщениеПользователюПоМаршрутуСогласованияНаАнглийскомЯзыке = "";
	ДопРеквизитНаименованиеПоАнглийски = СБ_КазначействоПовтИсп.ПолучитьЗначениеКонстанты("ДопРеквизитНаименованиеПоАнглийски",Неопределено);
	Если ТипЗнч(ДопРеквизитНаименованиеПоАнглийски) = Тип("ПланВидовХарактеристикСсылка.ДополнительныеРеквизитыИСведения")
		И ЗначениеЗаполнено(ДопРеквизитНаименованиеПоАнглийски) Тогда
		ЕстьНастрокаНаименованиеАнгл = Истина;
	Иначе 
		 ЕстьНастрокаНаименованиеАнгл = Ложь;
	КонецЕсли;
	//ОКЕЙ Рычаков А.С.(СофтЛаб)2019-10-07 Конец (#3499)
	
	Для Каждого СоотОпер Из ЦФОСПоказателямиОпер Цикл 
		
		Если СоотОпер.Значение.СуммаПолугодовогоПревышенияОпер = 0 Тогда 
			Продолжить;
		КонецЕсли;
		
		СообщениеПользователюПоМаршрутуСогласования = СообщениеПользователюПоМаршрутуСогласования + ?(ПустаяСтрока(СообщениеПользователюПоМаршрутуСогласования), "", "," + Символы.ПС)
													  + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 - %2 руб. без НДС (%3%)", СоотОпер.Ключ, ?(СоотОпер.Значение.СуммаПолугодовогоПревышенияОпер<0,-1,1)*СоотОпер.Значение.СуммаПолугодовогоПревышенияОпер,Окр(СоотОпер.Значение.ПроцентПолугодовогоПревышенияОпер,2));
													  
		//ОКЕЙ Рычаков А.С.(СофтЛаб)2019-10-07 Начало (#3499)
		Если ЕстьНастрокаНаименованиеАнгл Тогда 
			ЗначениеДопРеквизита = УправлениеСвойствами.ЗначениеСвойства(СоотОпер.Ключ,ДопРеквизитНаименованиеПоАнглийски);
			ЦФО_Анг = ?(ЗначениеЗаполнено(ЗначениеДопРеквизита),ЗначениеДопРеквизита,СоотОпер.Ключ);
		Иначе 
			ЦФО_Анг = СоотОпер.Ключ; 
		КонецЕсли;	
		
		СообщениеПользователюПоМаршрутуСогласованияНаАнглийскомЯзыке = СообщениеПользователюПоМаршрутуСогласованияНаАнглийскомЯзыке + ?(ПустаяСтрока(СообщениеПользователюПоМаршрутуСогласованияНаАнглийскомЯзыке), "", "," + Символы.ПС)
													  + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 - %2 RUB w/o VAT (%3%)", ЦФО_Анг, ?(СоотОпер.Значение.СуммаПолугодовогоПревышенияОпер<0,-1,1)*СоотОпер.Значение.СуммаПолугодовогоПревышенияОпер,Окр(СоотОпер.Значение.ПроцентПолугодовогоПревышенияОпер,2));
		//ОКЕЙ Рычаков А.С.(СофтЛаб)2019-10-07 Конец (#3499)
	КонецЦикла;
		
	Если Не ПустаяСтрока(СообщениеПользователюПоМаршрутуСогласования) Тогда 	
		СтруктураКонтекст.Вставить("СообщениеПользователюПоМаршрутуСогласования","Сумма превышения операционного бюджета по функции: "+ Символы.ПС
																				 + СообщениеПользователюПоМаршрутуСогласования);
	КонецЕсли;

	//ОКЕЙ Рычаков А.С.(СофтЛаб)2019-10-07 Начало (#3499)
	Если Не ПустаяСтрока(СообщениеПользователюПоМаршрутуСогласованияНаАнглийскомЯзыке) Тогда 	
		СтруктураКонтекст.Вставить("СообщениеПользователюПоМаршрутуСогласованияНаАнглийскомЯзыке","Amount of excess of the operating budget by function: "+ Символы.ПС
																				 + СообщениеПользователюПоМаршрутуСогласованияНаАнглийскомЯзыке);
	КонецЕсли;
	//ОКЕЙ Рычаков А.С.(СофтЛаб)2019-10-07 Конец (#3499)
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-24 (#3231)
		
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-09-12 (#3393)
	
КонецПроцедуры

//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-09-06 (#3393)
//Функция ПолучитьСтруктуруПолейПоказателей()
//Заменено на:
Функция ПолучитьСтруктуруПолейПоказателей() Экспорт
//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-09-06 (#3393)
	
	стрДанныеДляРасчета = Новый Структура;		
	стрДанныеДляРасчета.Вставить("ЕстьСтрокиСОтборомПоСтатье"	    , Ложь);
	стрДанныеДляРасчета.Вставить("ЕстьСтрокиОпер"			 	    , Ложь);					
	стрДанныеДляРасчета.Вставить("ЕстьСтрокиИнвест"				    , Ложь);
	стрДанныеДляРасчета.Вставить("КоличествоОбъектовСтроительства"  , 0);
	стрДанныеДляРасчета.Вставить("СуммаСверхБюджетаОпер" 		    , 0);                 
	стрДанныеДляРасчета.Вставить("СуммаСверхБюджетаИнвест" 		    , 0);                 
	стрДанныеДляРасчета.Вставить("ПроцентКвартальногоПревышенияОпер", 0);                 	
	стрДанныеДляРасчета.Вставить("СуммаПревышенияБюджетаИнвест"		, 0);		
	стрДанныеДляРасчета.Вставить("ПроцентПревышенияБюджетаИнвест"	, 0);
	стрДанныеДляРасчета.Вставить("СуммаБезНДСПоЦФО"					, 0);
	стрДанныеДляРасчета.Вставить("НомераСтрокСОтборомПоСтатье"		, Новый Массив);			
	стрДанныеДляРасчета.Вставить("НомераСтрокПоЦФО"					, Новый Массив);		
	стрДанныеДляРасчета.Вставить("НомераСтрокИсклСверхБюджета"		, Новый Массив);
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-05-20 (#3314)
	стрДанныеДляРасчета.Вставить("ПроцентПолугодовогоПревышенияОпер", 0);                 	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-05-20 (#3314)
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-24 (#3231)
	стрДанныеДляРасчета.Вставить("СуммаПолугодовогоПревышенияОпер", 0);                 	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-24 (#3231)	
	
	Возврат стрДанныеДляРасчета;
	
КонецФункции

Процедура ВыполнитьЦиклПоАналитике(ЦФО,СтруктураКонтекст, СтруктураКонтекстЦФО, ТекущаяТочка, НачальнаяТочкаЦикла, ТаблицаТочекИсх, мОбрТочки)
	
	мДобавляемыеСтроки = Новый Массив;
	
	ТаблицаТочек = ТаблицаТочекИсх.Скопировать();
	
	Заголовок		 = "";
	РежимСообщений   = "";
	ВыводитьОшибки	 = Ложь;
	
	Пока НЕ ТекущаяТочка = Неопределено Цикл  //конец маршрута
					
		СтрокаТаблицыТочек = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");
		
		Если СтрокаТаблицыТочек.ТочкаЦикла И 
			 НачальнаяТочкаЦикла<>ТекущаяТочка
		Тогда 
			Возврат;		   
		КонецЕсли;
		   
		// Определим исходящие точки для данной точки.
		СтрОтбор    = Новый Структура("Направление",Перечисления.бит_уп_Направление.Вертикаль);
		МассивСтрок = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтбор);
		
		Если МассивСтрок.Количество()>СтрокаТаблицыТочек.КоличествоОбработанныхСвязей Тогда
			ТочкаДа = МассивСтрок[СтрокаТаблицыТочек.КоличествоОбработанныхСвязей].Точка;
		Иначе	
			ТочкаДа = Неопределено;
		КонецЕсли; 
		
		СтрОтбор    = Новый Структура("Направление",Перечисления.бит_уп_Направление.Горизонталь);
		МассивСтрок = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтбор);
		
		Если МассивСтрок.Количество()>0 Тогда
			ТочкаНет = МассивСтрок[0].Точка;
		Иначе	
			ТочкаНет = Неопределено;
		КонецЕсли; 
		
		// Обработаем данную точку алгоритма в зависимости от вида точки.
		Если ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие И
			 НЕ ТекущаяТочка.ПометкаУдаления			
		Тогда
			
			Если ЗначениеЗаполнено(ТекущаяТочка.ПользовательскоеДействие) Тогда
			
			  // Определим необходимо ли выполнять текущее действие
			  // Это зависит от способа выполнения алгоритма:
			  // Сразу - выполняем все действия за один обход
			  // Поэтапно - выполняем действия постепенно, если выполнены действия 
			  // предыдущих уровней (используется при визировании).
			  пНеобходимоВыполнитьДействие = Истина;
			  пВиза = ТекущаяТочка.ПользовательскоеДействие.Виза;
			  Если ЗначениеЗаполнено(пВиза) И
				   СтруктураКонтекст.Свойство("ИнициированныеВизы") 
			  Тогда 
				 
				  ЭлСоответствия = СтруктураКонтекст.ИнициированныеВизы.Получить(пВиза);
				  Если ЭлСоответствия = Неопределено Тогда 
					  мДобСтроки = Новый Массив;
					  Для Каждого ДобСтрока Из мДобавляемыеСтроки Цикл 
						  Если СтруктураКонтекстЦФО.НомераСтрокИсклСверхБюджета.Найти(ДобСтрока) <> Неопределено Тогда 
							  Продолжить;
						  КонецЕсли;
						  мДобСтроки.Добавить(ДобСтрока);
					  КонецЦикла;
					  СтруктураКонтекст.ИнициированныеВизы.Вставить(пВиза, мДобСтроки);  						  
				  Иначе					  
					  Для Каждого ДобСтрока Из мДобавляемыеСтроки Цикл 
						  ЭлСоответствия.Добавить(ДобСтрока);
					  КонецЦикла;
					  пНеобходимоВыполнитьДействие = Ложь;
				  КонецЕсли;
				  мДобавляемыеСтроки.Очистить();	  
			  КонецЕсли; 
			  
			  //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-22 (#3231)
			  Если СтруктураКонтекст.Свойство("РасшифровкаУсловияОпределенияВизы") Тогда 
				  СтрокаТаблицыТочекИСХ = ТаблицаТочекИсх.Найти(ТекущаяТочка,"Точка");
				  Если НЕ СтрокаТаблицыТочекИСХ = Неопределено Тогда 
					  Если СтрНайти(СтрокаТаблицыТочекИСХ.ок_РасшифровкаУсловияОпределенияВизы,СтруктураКонтекст.РасшифровкаУсловияОпределенияВизы)=0 Тогда 
						  СтрокаТаблицыТочекИСХ.ок_РасшифровкаУсловияОпределенияВизы = СтрокаТаблицыТочекИСХ.ок_РасшифровкаУсловияОпределенияВизы + 
						  ?(ЗначениеЗаполнено(СтрокаТаблицыТочекИСХ.ок_РасшифровкаУсловияОпределенияВизы),Символы.ПС,
						  "") + СтруктураКонтекст.РасшифровкаУсловияОпределенияВизы;						 
					  КонецЕсли;
					  СтруктураКонтекст.Вставить("РасшифровкаУсловияОпределенияВизы", СтрокаТаблицыТочекИСХ.ок_РасшифровкаУсловияОпределенияВизы);
					  
					  
					  Если СтруктураКонтекст.Свойство("Визы") Тогда
						  
						  Для Каждого ЗаписьНабораВиз Из СтруктураКонтекст.Визы Цикл 
							  Если ЗаписьНабораВиз.Виза = ТекущаяТочка.ПользовательскоеДействие.Виза Тогда 
								  ЗаписьНабораВиз.ок_РасшифровкаУсловияОпределенияВизы = СтрокаТаблицыТочекИСХ.ок_РасшифровкаУсловияОпределенияВизы;
							  КонецЕсли;
						  КонецЦикла;
					  КонецЕсли;
					  
				  КонецЕсли;					  
			  КонецЕсли;
			  //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-22 (#3231)			 
			  		  
			  Если пНеобходимоВыполнитьДействие Тогда 
				  				  				  
				  флДействиеВыполнено = ВыполнитьПользовательскоеДействие(ТекущаяТочка.ПользовательскоеДействие
																		  ,СтруктураКонтекст
																		  ,ТекущаяТочка
																		  ,Заголовок
																		  ,РежимСообщений);
				  Если флДействиеВыполнено 
					  И ТекущаяТочка.ПользовательскоеДействие.Назначение = Перечисления.бит_НазначенияПользовательскихДействий.Визирование Тогда
					  
					  СтрокаТаблицыТочек.Виза = пВиза;					    
					  
					  
				  КонецЕсли; // Действие выполнено
				  
				 				  
			  КонецЕсли;    
			    			
		   Иначе
			  //Если ВыводитьОшибки Тогда
			  //
			  //	 ТекстСообщения = "Не указано действие для точки """+ТекущаяТочка+"""!";
			  //   бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
			  //
			  //КонецЕсли; 																			   

			КонецЕсли; 
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-02 (#3393)
			СтруктураКонтекст.Удалить("ОК_ВидРасхода");
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-02 (#3393)
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-23 (#3231)
			СтруктураКонтекст.Удалить("РасшифровкаУсловияОпределенияВизы");
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-23 (#3231)
			
			ТекущаяТочка = ТочкаДа;
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Условие И
		 		  НЕ ТекущаяТочка.ПометкаУдаления
		Тогда	
			// Вычисляем условие
			Если ЗначениеЗаполнено(ТекущаяТочка.ПользовательскоеУсловие) Тогда
				
				мДобавляемыеСтроки.Очистить();
				
				ПараметрыУсловия   = Новый Структура("ТекущийОбъект",СтруктураКонтекст.ТекущийОбъект);
				
				ПараметрыУсловия.Вставить("ЦФО"	,	ЦФО);
				
				Если СтруктураКонтекст.Свойство("ОплатаЗаявки") Тогда
				
					ПараметрыУсловия.Вставить("ОплатаЗаявки",СтруктураКонтекст.ОплатаЗаявки);
				
				КонецЕсли;
				
				Если СтруктураКонтекст.Свойство("Визы") Тогда
				
					ПараметрыУсловия.Вставить("НаборВизы",СтруктураКонтекст.Визы);							
				
				КонецЕсли; 
							
				Если СтруктураКонтекст.Свойство("ИнициированныеВизы") Тогда 
					ПараметрыУсловия.Вставить("ИнициированныеВизы"	,	СтруктураКонтекст.ИнициированныеВизы);
				КонецЕсли;
				
				Для Каждого КлючЗнач Из СтруктураКонтекстЦФО Цикл 
					ПараметрыУсловия.Вставить(КлючЗнач.Ключ, КлючЗнач.Значение);
				КонецЦикла;
				
				ПараметрыУсловия.Вставить("СуммаЗаявки"	    		   , СтруктураКонтекст.СуммаЗаявки);
				ПараметрыУсловия.Вставить("СуммаПредоплаты"	 		   , СтруктураКонтекст.СуммаПредоплаты);
				ПараметрыУсловия.Вставить("ВалютаТолькоРуб"			   , СтруктураКонтекст.ВалютаТолькоРуб);
				ПараметрыУсловия.Вставить("ФормаОплатыНаличные" 	   , СтруктураКонтекст.ФормаОплатыНаличные);
				ПараметрыУсловия.Вставить("ВДокументеЕстьСтатьиИнвест" , СтруктураКонтекст.ВДокументеЕстьСтатьиИнвест);
				
				//Сначала без условий по статям
				ПараметрыУсловия.Вставить("ЕстьСтрокиСОтборомПоСтатье", Ложь);				
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-06-05 (#3314)
				Если СтруктураКонтекст.Свойство("ПараметрыАлгоритма") Тогда 
					
					Для Каждого парАлгоритма Из СтруктураКонтекст.ПараметрыАлгоритма Цикл 
						ПараметрыУсловия.Вставить(парАлгоритма.Ключ, парАлгоритма.Значение);
					КонецЦикла;
					
				КонецЕсли;
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-06-05 (#3314)
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-23 (#3231)
				Если СтруктураКонтекст.Свойство("РасшифровкаУсловияОпределенияВизы") Тогда 
					ПараметрыУсловия.Вставить("РасшифровкаУсловияОпределенияВизы", СтруктураКонтекст.РасшифровкаУсловияОпределенияВизы);
				КонецЕсли;					
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-23 (#3231)
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2021-06-16 (#4223)
				Если ТипЗнч(ТочкаДа) = Тип("СправочникСсылка.бит_уп_ТочкиАлгоритмов") 
					И ЗначениеЗаполнено(ТочкаДа.ПользовательскоеДействие) Тогда 
					ПараметрыУсловия.Вставить("ВизаПриВыполненииУсловия", ТочкаДа.ПользовательскоеДействие.Виза); 
				 КонецЕсли;				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2021-06-16 (#4223)
				
				//Сначала проверяем строки по виду статьи: инвест/опер				
				флУсловиеВыполнено = бит_уп_Сервер.ПроверитьПользовательскоеУсловие(ТекущаяТочка.ПользовательскоеУсловие
				                                                                           ,ПараметрыУсловия
																						   ,
																						   ,Заголовок
																						   ,РежимСообщений);				
				Если НЕ флУсловиеВыполнено И СтруктураКонтекстЦФО.ЕстьСтрокиСОтборомПоСтатье Тогда 
					
					ПараметрыУсловия.Вставить("ЕстьСтрокиСОтборомПоСтатье", Истина);																		   
					ПараметрыУсловия.Вставить("ОбщаяСуммаСОтборомПоСтатье", СтруктураКонтекст.ОбщаяСуммаСОтборомПоСтатье);
					
					//Теперь выполним по статьям оборотов																		   
					флУсловиеВыполнено = бит_уп_Сервер.ПроверитьПользовательскоеУсловие(ТекущаяТочка.ПользовательскоеУсловие
				                                                                           ,ПараметрыУсловия
																						   ,
																						   ,Заголовок
																						   ,РежимСообщений);
				   Если флУсловиеВыполнено Тогда 
					   Для Каждого ЭлементМассиваСтрок Из СтруктураКонтекстЦФО.НомераСтрокСОтборомПоСтатье Цикл 
							мДобавляемыеСтроки.Добавить(ЭлементМассиваСтрок);
					   КонецЦикла;																		   
						
					   //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-23 (#3231)
					   Если ПараметрыУсловия.Свойство("РасшифровкаУсловияОпределенияВизы") Тогда 
						   СтруктураКонтекст.Вставить("РасшифровкаУсловияОпределенияВизы", ПараметрыУсловия.РасшифровкаУсловияОпределенияВизы);
					   КонецЕсли;					
					   //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-23 (#3231)
					   
					   //ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-02 (#3393)
					   Если ПараметрыУсловия.Свойство("ОК_ВидРасхода") Тогда 
						   СтруктураКонтекст.Вставить("ОК_ВидРасхода", ПараметрыУсловия.ОК_ВидРасхода);
					   КонецЕсли;					
					   //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-02 (#3393)
					   
				   КонецЕсли;
				   
				ИначеЕсли флУсловиеВыполнено Тогда 
					
					Для Каждого ЭлементМассиваСтрок Из СтруктураКонтекстЦФО.НомераСтрокПоЦФО Цикл 
						мДобавляемыеСтроки.Добавить(ЭлементМассиваСтрок);
					КонецЦикла;
					
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-07-23 (#3231)
					Если ПараметрыУсловия.Свойство("РасшифровкаУсловияОпределенияВизы") Тогда 
						СтруктураКонтекст.Вставить("РасшифровкаУсловияОпределенияВизы", ПараметрыУсловия.РасшифровкаУсловияОпределенияВизы);
					КонецЕсли;					
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-07-23 (#3231)
					
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-02 (#3393)
					   Если ПараметрыУсловия.Свойство("ОК_ВидРасхода") Тогда 
						   СтруктураКонтекст.Вставить("ОК_ВидРасхода", ПараметрыУсловия.ОК_ВидРасхода);
					   КонецЕсли;					
					   //ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-02 (#3393)
					
				КонецЕсли;	
																						  
			Иначе	
			  Если ВыводитьОшибки Тогда
			  
			  	 ТекстСообщения = "Не указано условие для точки """+ТекущаяТочка+"""!";
				 бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
			  
			  КонецЕсли; 																			   
			  флУсловиеВыполнено = Ложь;
			КонецЕсли; 
			Если флУсловиеВыполнено Тогда
				ТекущаяТочка = ТочкаДа;
			Иначе	
				ТекущаяТочка = ТочкаНет;
			КонецЕсли; 
			
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт И
		  		  НЕ ТекущаяТочка.ПометкаУдаления		
		Тогда
			ТекущаяТочка = ТочкаДа;
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение И
				  НЕ ТекущаяТочка.ПометкаУдаления			 
		Тогда
			ТекущаяТочка = ТочкаДа;
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние И
		      	  НЕ ТекущаяТочка.ПометкаУдаления		
		Тогда		
			ТекущаяТочка = ТочкаДа;
		КонецЕсли; 
		
		Если НЕ СтрокаТаблицыТочек = Неопределено Тогда
			
			СтрокаТаблицыТочек.Обработана = 1;
			СтрокаТаблицыТочек.КоличествоОбработанныхСвязей = СтрокаТаблицыТочек.КоличествоОбработанныхСвязей+1;
			Если СтрокаТаблицыТочек.КоличествоОбработанныхСвязей >= СтрокаТаблицыТочек.КоличествоИсходящих Тогда
				
				СтрокаТаблицыТочек.СвязиОбработаны = 1;
				
			КонецЕсли; 
			
			мОбрТочки.Добавить(СтрокаТаблицыТочек.Точка);
			
		КонецЕсли; 

		Если ЗначениеЗаполнено(ТекущаяТочка) И
			 ТекущаяТочка.ПометкаУдаления
		Тогда 
			ТекущаяТочка = Неопределено;
		КонецЕсли;						
		
	КонецЦикла; // Обходим точки цикла алгоритма
		
КонецПроцедуры
//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-05-11 (#2971)

#КонецОбласти

#Область Прочее

 // Функция используется при восстановлении JSON алгоритма по-умолчанию.
 //
 // Параметры:
 //    Свойство - Строка.
 //    Значение - Произвольный.
 //    ДополнительныеПараметры - Произвольный.
 //
 // Возвращаемое значение:
 //  Результат - Произвольный.
 //
 Функция ВосстановлениеДжейсон(Свойство, Значение, ДополнительныеПараметры) Экспорт
 
	Если ВРег(Значение) = ВРег("Истина") Тогда
	
		РезЗначение = Истина;
		
	ИначеЕсли ВРег(Значение) = ВРег("Ложь") Тогда
		
		РезЗначение = Ложь;
		
	Иначе
		
 	   РезЗначение = Значение;
	
	КонецЕсли; 
	
	Если ВРег(Свойство) = ВРег("ОбъектСистемы") Тогда
	
		 НайденныйОбъект = Справочники.бит_ОбъектыСистемы.НайтиПоРеквизиту("ИмяОбъектаПолное", Значение);
		 Если ЗначениеЗаполнено(НайденныйОбъект) Тогда
		 
		 	РезЗначение = НайденныйОбъект;
		 
		 КонецЕсли; 
		 
	ИначеЕсли ВРег(Свойство) = ВРег("ВидТочки") Тогда	 
		
		 РезЗначение = Перечисления.бит_уп_ВидыТочекАлгоритмов[Значение];
		 
	ИначеЕсли ВРег(Свойство) = ВРег("Направление") Тогда	 
		
		 РезЗначение = Перечисления.бит_уп_Направление[Значение];
		 
	КонецЕсли; 
	
 	Возврат РезЗначение;
 	
 КонецФункции // ВосстановлениеДжейсон()

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область РаботаСГрафами

// Функция получает сокращенное представление алгоритма, необходимое для проверки точек.
//
Функция ПолучитьСокращенноеПредставлениеАлгоритма(ТаблицаТочек)
	
	// Добавляем интересующие нас точки в массив и отмечаем их пройденность.
	// 0 - пройдено - старт, ветвления, условия, действия с установленными визами.
	// 1 - не пройдено - действия с неустановленными визами.
	ТочкаСтарта = неопределено;
	// Необходим для индексации точек и построения матрицы смежности.
	ИндексТочек = Новый Массив();
	// Доступен ли "проход" по пути до этой точки.
	// Все точки не-действия помечаем как пройденные - для удобства, те ветки условий, которые не отработали, для нас тут не важны.
	ПройденностьТочек = Новый Соответствие(); 
	ОтклоненностьТочек = Новый Соответствие();
	НезначимыеТочки = Новый Массив(); //все точки, не являющиеся точкой старта или действия
	Для Каждого СтрокаТаблицыТочек Из ТаблицаТочек Цикл
		ОтклоненностьТочек.Вставить(СтрокаТаблицыТочек.Точка, Ложь);
		ПройденностьТочек.Вставить(СтрокаТаблицыТочек.Точка, Ложь);
		Если СтрокаТаблицыТочек.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт Тогда
			ТочкаСтарта = СтрокаТаблицыТочек.Точка;
			ИндексТочек.Добавить(СтрокаТаблицыТочек.Точка);
			ПройденностьТочек.Вставить(СтрокаТаблицыТочек.Точка, Истина);
		ИначеЕсли ЭтоДействие(СтрокаТаблицыТочек.ВидТочки) Тогда
			Если ЗначениеЗаполнено(СтрокаТаблицыТочек.Виза) Тогда
				ИндексТочек.Добавить(СтрокаТаблицыТочек.Точка);
				Если СтрокаТаблицыТочек.Решение = Справочники.бит_ВидыРешенийСогласования.Согласовано Тогда
					ПройденностьТочек.Вставить(СтрокаТаблицыТочек.Точка, Истина);
				ИначеЕсли СтрокаТаблицыТочек.Решение = Справочники.бит_ВидыРешенийСогласования.Отклонено Тогда
					ОтклоненностьТочек.Вставить(СтрокаТаблицыТочек.Точка, Истина);
				КонецЕсли;
			КонецЕсли;
		Иначе
			ИндексТочек.Добавить(СтрокаТаблицыТочек.Точка);
			НезначимыеТочки.Добавить(СтрокаТаблицыТочек.Точка);
		КонецЕсли;
	КонецЦикла;
	
	КоличествоТочек = ИндексТочек.Количество();
	МатрицаСмежности = Новый Массив(КоличествоТочек, КоличествоТочек);
	
	// Получаем матрицу смежности.
	Для сч1 = 0 По КоличествоТочек-1 Цикл
		Для сч2 = 0 По КоличествоТочек-1 Цикл
			МатрицаСмежности[сч1][сч2] = 0;
		КонецЦикла;
	КонецЦикла;
	
	Запрос = Новый Запрос();
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	бит_уп_ТочкиАлгоритмовИсходящиеТочки.Ссылка КАК ТочкаИз,
	|	бит_уп_ТочкиАлгоритмовИсходящиеТочки.Точка КАК ТочкаВ
	|ИЗ
	|	Справочник.бит_уп_ТочкиАлгоритмов.ИсходящиеТочки КАК бит_уп_ТочкиАлгоритмовИсходящиеТочки
	|ГДЕ
	|	бит_уп_ТочкиАлгоритмовИсходящиеТочки.Точка В(&Точки)";
	
	Запрос.УстановитьПараметр("Точки", ИндексТочек);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		ИндексИз = ИндексТочек.Найти(Выборка.ТочкаИз);
		ИндексВ = ИндексТочек.Найти(Выборка.ТочкаВ);
		Если ИндексИз <> Неопределено И ИндексВ <> Неопределено Тогда
			МатрицаСмежности[ИндексИз][ИндексВ] = 1;
		КонецЕсли;
	КонецЦикла;
	
	// Последовательно удаляем незначимые точки, заменяя их прямыми ребрами.
	Для Каждого Точка Из НезначимыеТочки Цикл
		УдалитьВершину(ИндексТочек, МатрицаСмежности, Точка);
	КонецЦикла;
	
	ПредставлениеАлгоритма = Новый Структура();
	ПредставлениеАлгоритма.Вставить("ТочкаСтарта", ТочкаСтарта);
	ПредставлениеАлгоритма.Вставить("ИндексТочек", ИндексТочек);
	ПредставлениеАлгоритма.Вставить("ПройденностьТочек", ПройденностьТочек);
	ПредставлениеАлгоритма.Вставить("ОтклоненностьТочек", ОтклоненностьТочек);
	ПредставлениеАлгоритма.Вставить("МатрицаСмежности", МатрицаСмежности);
	
	Возврат ПредставлениеАлгоритма;
	
КонецФункции

Процедура УдалитьВершину(ИндексТочек, МатрицаСмежности, Точка)
	
	КоличествоТочек = ИндексТочек.Количество();
	ИндексТочки = ИндексТочек.Найти(Точка);
	ИндексыИсходящих = Новый Массив();
	ИндексыВходящих = Новый Массив();
	
	Для Сч = 0 По КоличествоТочек-1 Цикл
		Если МатрицаСмежности[ИндексТочки][Сч] = 1 Тогда
			ИндексыИсходящих.Добавить(Сч);
		КонецЕсли;
		Если МатрицаСмежности[Сч][ИндексТочки] = 1 Тогда
			ИндексыВходящих.Добавить(Сч);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ИндексВходящего Из ИндексыВходящих Цикл
		Для Каждого ИндексИсходящего Из ИндексыИсходящих Цикл
			МатрицаСмежности[ИндексВходящего][ИндексИсходящего] = 1;
		КонецЦикла;
	КонецЦикла;
	
	ИндексТочек.Удалить(ИндексТочки);
	Для Сч = 0 По КоличествоТочек-1 Цикл
		МатрицаСмежности[Сч].Удалить(ИндексТочки);
	КонецЦикла;
	МатрицаСмежности.Удалить(ИндексТочки);
	
КонецПроцедуры

#КонецОбласти

Функция ЭтоДействие(Значение)

	Возврат Значение = Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие
			ИЛИ Значение = Перечисления.бит_уп_ВидыТочекАлгоритмов.ПодчиненныйПроцесс;

КонецФункции
 
// Функция инициализирует структуру координат в представлении ЛевоВерх.
// 
// Параметры:
//  Лево   - Число
//  Верх   - Число
//  Ширина - Число
//  Высота - Число
// 
// Возвращаемое значение:
//   Координаты   - Структура
// 
Функция КонструкторСтруктурыКоординат_ЛевоВерх(Лево = 0,Верх = 0,Ширина = 0,Высота = 0)

	Координаты = Новый Структура("Лево,Верх,Ширина,Высота",Лево,Верх,Ширина,Высота);

	Возврат Координаты;
	
КонецФункции // КонструкторСтруктурыКоординат()

// Процедура рисует точечную красную рамку вокруг активной точки.
// 
// Параметры:
//  ТД - ТабличныйДокумент
//  Координаты - Структура
// 
Процедура НарисоватьГраницуАктивнойТочки(ТД, Координаты)

	ТипЛинии = Новый Линия(ТипЛинииРисункаТабличногоДокумента.Точечная,1);
	Сдвиг = 1;
	
	ПараметрыЛинии = Новый Структура;
	ПараметрыЛинии.Вставить("ТипЛинии" , ТипЛинии);
	ПараметрыЛинии.Вставить("ЦветЛинии", WebЦвета.Красный);
	
	// Левая граница
	КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево - Сдвиг
	                                                ,Координаты.Верх - Сдвиг
												    ,Координаты.Лево - Сдвиг
												    ,Координаты.Верх + Координаты.Высота + Сдвиг);
													
	ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
	
	// Правая граница
	КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево + Координаты.Ширина+Сдвиг
	                                                ,Координаты.Верх - Сдвиг
												    ,Координаты.Лево + Координаты.Ширина + Сдвиг
												    ,Координаты.Верх + Координаты.Высота + Сдвиг);
													
													
	ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
	
	// Верхняя граница
	КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево - Сдвиг
		                                                ,Координаты.Верх - Сдвиг
													    ,Координаты.Лево + Координаты.Ширина + Сдвиг
													    ,Координаты.Верх - Сдвиг);
													
													
	ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
	
	// Нижняя граница
	КоординатыЛинии = КонструкторСтруктурыКоординат_ХУ(Координаты.Лево - Сдвиг
		                                                ,Координаты.Верх + Координаты.Высота + Сдвиг
													    ,Координаты.Лево + Координаты.Ширина + Сдвиг
													    ,Координаты.Верх + Координаты.Высота + Сдвиг);
													
													
	ДобавитьЛинию(ТД,КоординатыЛинии,ПараметрыЛинии);
	

КонецПроцедуры // НарисоватьГраницуАктивнойТочки()

// Процедура применяет к рисунку оформление.
// 
// Параметры:
//  РисунокТД  - РисунокТабличногоДокумента.
//  Оформление - Структура.
// 
Процедура ОформитьРисунок(РисунокТД,Оформление)
	
	бит_ОбщегоНазначения.УстановитьСвойствоИзСтруктуры(РисунокТД,Оформление,"ЦветФона");
	бит_ОбщегоНазначения.УстановитьСвойствоИзСтруктуры(РисунокТД,Оформление,"ЦветЛинии");	
	бит_ОбщегоНазначения.УстановитьСвойствоИзСтруктуры(РисунокТД,Оформление,"ЦветТекста");
	бит_ОбщегоНазначения.УстановитьСвойствоИзСтруктуры(РисунокТД,Оформление,"Шрифт");
	бит_ОбщегоНазначения.УстановитьСвойствоИзСтруктуры(РисунокТД,Оформление,"ГоризонтальноеПоложение");
	бит_ОбщегоНазначения.УстановитьСвойствоИзСтруктуры(РисунокТД,Оформление,"ВертикальноеПоложение");
	
КонецПроцедуры // ОформитьРисунок()

// Функция получает оформление точки маршрута. 
// Если оформление точки не заполнено, выполняется инициализация по-умолчанию.
// 
// Параметры:
//  ТочкаМаршрута  - СправочникСсылка.бит_ТочкиМаршрута.
// 
// Возвращаемое значение:
//   Оформление   - Структура.
// 
Функция ПолучитьОформлениеТочки(ТочкаМаршрута)
	
	Оформление = ТочкаМаршрута.ОформлениеТочки.Получить();
	
	Если НЕ ТипЗнч(Оформление) = Тип("Структура") Тогда
		
		Оформление = Новый Структура("Шрифт,ЦветФона,ЦветЛинии,ЦветТекста,ГоризонтальноеПоложение,ВертикальноеПоложение");
		Если ТочкаМаршрута.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие Тогда
			Оформление.ЦветЛинии 	= Новый Цвет(255,255,255);
			Оформление.ЦветТекста 	= Новый Цвет(255,255,255);
		Иначе
			Оформление.ЦветЛинии 	= ЦветаСтиля.бит_ЦветТочекАлгоритма;
			Оформление.ЦветТекста 	= ЦветаСтиля.бит_ЦветТочекАлгоритма;
		КонецЕсли; 
		Оформление.ЦветФона = ЦветаСтиля.бит_ЦветТочекАлгоритма;
		
		Оформление.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр;
		Оформление.ВертикальноеПоложение   = ВертикальноеПоложение.Центр;
		Оформление.Шрифт                   = Новый Шрифт("Roboto",8,Ложь);
		
	КонецЕсли; 
	
	Возврат Оформление;
	
КонецФункции // ПолучитьОформлениеТочки()

// Функция заполняет расшифровку точки алгоритма.
// 
// Параметры:
//  СтрокаТаблицыТочек  - СтрокаТаблицыЗначений.
//  Режим      - Строка.
// 
// Возвращаемое значение:
//   Расшифровка   - Структура.
// 
Функция ЗаполнитьРасшифровкуТочкиАлгоритма(СтрокаТаблицыТочек, Режим = "")

	Расшифровка = Неопределено;
	
	Если НЕ СтрокаТаблицыТочек = Неопределено Тогда
		
		Расшифровка  = Новый Структура;
		
		ЭтоВизирование = ?(Режим = "Визирование", Истина, Ложь);
		ЭтоПроцесс     = ?(Режим = "Процесс"    , Истина, Ложь);
		
		ТекущаяТочка = СтрокаТаблицыТочек.Точка;
		Расшифровка.Вставить("Точка",СтрокаТаблицыТочек.Точка);
		Расшифровка.Вставить("ВидТочки",СтрокаТаблицыТочек.ВидТочки);
		Расшифровка.Вставить("ПользовательскоеДействие", СтрокаТаблицыТочек.Точка.ПользовательскоеДействие);
		Расшифровка.Вставить("ПользовательскоеУсловие", СтрокаТаблицыТочек.Точка.ПользовательскоеУсловие);
		
		Если ЭтоВизирование Тогда
			
			Расшифровка.Вставить("Виза"       ,СтрокаТаблицыТочек.Виза);
			Расшифровка.Вставить("ИД"         ,СтрокаТаблицыТочек.ИД);
			Расшифровка.Вставить("Решение"    ,СтрокаТаблицыТочек.Решение);
			Расшифровка.Вставить("Доступность",СтрокаТаблицыТочек.Доступность);
			
		ИначеЕсли ЭтоПроцесс Тогда
			
			Расшифровка.Вставить("Задача"   , СтрокаТаблицыТочек.Задача);
			Расшифровка.Вставить("Состояние", СтрокаТаблицыТочек.Состояние);
			
		Иначе		
			
			Расшифровка.Вставить("ВходящиеТочки"           ,Новый СписокЗначений);
			Расшифровка.Вставить("КоличествоСвязейВход"    ,СтрокаТаблицыТочек.КоличествоВходящих);
			Расшифровка.Вставить("КоличествоИсхГоризонталь",0);
			Расшифровка.Вставить("КоличествоИсхВертикаль"  ,0);
			Расшифровка.Вставить("ПометкаУдаления"         ,СтрокаТаблицыТочек.Точка.ПометкаУдаления);
			
			// Получим количество исходящих связей по-вертикали.
			СтрОтбора = Новый Структура;
			СтрОтбора.Вставить("Направление",Перечисления.бит_уп_Направление.Вертикаль);
			
			МассивСтрок = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтбора);
			Расшифровка.КоличествоИсхВертикаль = МассивСтрок.Количество();
			
			// Получим количество исходящих связей по-горизонтали.
			СтрОтбора = Новый Структура;
			СтрОтбора.Вставить("Направление",Перечисления.бит_уп_Направление.Горизонталь);
			
			МассивСтрок = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтбора);
			Расшифровка.КоличествоИсхГоризонталь = МассивСтрок.Количество();
			
			Если ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние Тогда
				
				Для каждого СтрокаВходящие Из ТекущаяТочка.ВходящиеТочки Цикл
					
					Расшифровка.ВходящиеТочки.Добавить(СтрокаВходящие.Точка,СтрокаВходящие.Точка.Наименование);
					
				КонецЦикла; 
				
			КонецЕсли; 
			
			
		КонецЕсли; 
		
		
	КонецЕсли; 
	
	
	Возврат Расшифровка;
	
КонецФункции // ЗаполнитьРасшифровкуТочкиАлгоритма()

// Функция получает параметры отображения алгоритма. Производится масштабирование 
// в зависимости от РежимаЗапускаКлиентскогоПриложения.
// 
// Параметры:
//  Алгоритм  - СправочникСсылка.бит_уп_Алгоритмы.
// 
// Возвращаемое значение:
//  ПараметрыОтображения   - Структура.
// 
Функция ПолучитьПараметрыОтображенияАлгоритма(Алгоритм)

	ПараметрыОтображения = Справочники.бит_уп_Алгоритмы.НовыеПараметрыОтображенияАлгоритма();

	Если ЗначениеЗаполнено(Алгоритм) Тогда
		ЗаполнитьЗначенияСвойств(ПараметрыОтображения, Алгоритм);
	КонецЕсли; 
	
	Возврат ПараметрыОтображения;
	
КонецФункции

// Процедура заполняет таблицу точек по алгоритму. Вызывается рекурсивно. 
//
// Параметры:
//  ТочкаСлияния - СтрокаТаблицыЗначений.
//  НоваяТаблицаТочек - ТаблицаЗначений.
//  СтараяТаблицаТочек - ТаблицаЗначений.
//
Процедура ЗаполнитьТаблицу(ТочкаАлгоритма, НоваяТаблицаТочек, СтараяТаблицаТочек, ТочкаСлияния)

	НоваяСтрока = НоваяТаблицаТочек.Добавить();
	ЗаполнитьЗначенияСвойств(НоваяСтрока, ТочкаАлгоритма);
	ЗаполнитьТаблицуПоПорядку(ТочкаАлгоритма.ИсходящиеТочки, НоваяТаблицаТочек, СтараяТаблицаТочек, ТочкаСлияния);
	
	Если ТочкаСлияния <> Неопределено Тогда
		
		ЗаполнитьТаблицу(ТочкаСлияния, НоваяТаблицаТочек, СтараяТаблицаТочек, Неопределено);
	
	КонецЕсли; 

КонецПроцедуры // ЗаполнитьТаблицу()

// Процедура сортирует таблицу точек по порядку алгоритма. Вызывается рекурсивно. 
//
// Параметры:
//  ИсходящиеТочки - ТаблицаЗначений.
//  НоваяТаблицаТочек - ТаблицаЗначений.
//  СтараяТаблицаТочек - ТаблицаЗначений.
//
Процедура ЗаполнитьТаблицуПоПорядку(ИсходящиеТочки, НоваяТаблицаТочек, СтараяТаблицаТочек, ТочкаСлияния)

	Для каждого СтрокаИсх Из ИсходящиеТочки Цикл
		
		стрОтбор = Новый Структура("Точка", СтрокаИсх.Точка);
		МассивСтрок = СтараяТаблицаТочек.НайтиСтроки(стрОтбор);
		
		Если МассивСтрок.Количество()>0 Тогда
			
			Если СтрокаИсх.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние Тогда
			
				ТочкаСлияния =  МассивСтрок[0];
				
			Иначе	
				
				НоваяСтрока = НоваяТаблицаТочек.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, МассивСтрок[0]);
				ЗаполнитьТаблицуПоПорядку(МассивСтрок[0].ИсходящиеТочки, НоваяТаблицаТочек, СтараяТаблицаТочек, ТочкаСлияния);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла; 

КонецПроцедуры // ЗаполнитьТаблицуПоПорядку()

// Функция строит таблицу примерных сроков выполнения польз. действий.
//
// Параметры:
// 		ТаблицаТочек - ТаблицаЗначений.
//
// Возвращаемое значение:
//  	нТаблицаТочек - ТаблицаЗначений.
//
Функция ПостроитьТаблицуПримерныхСроковВыполненияПроцессов(ТаблицаТочек, ПоказыватьСрокиПроцесса, ДатаСтарта)

	Если ТаблицаТочек.Количество() = 0 ИЛИ НЕ ПоказыватьСрокиПроцесса Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли; 
	
	ДатаОкончанияРазделения = Дата(1, 1, 1);
	ЕстьРазделение 			= Ложь;
	ДатаНачалаРазделения 	= Дата(1, 1, 1);
	нТаблицаТочек = ТаблицаТочек.Скопировать();
	//нТаблицаТочек.Колонки.Добавить("ДатаОкончания");
	нТаблицаТочек.Колонки.Добавить("Действие");
	
	Для каждого стрТТ Из нТаблицаТочек Цикл
		
		Если стрТТ.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт Тогда 
		
			стрТТ.ДатаОкончания = ДатаСтарта;
			
		ИначеЕсли стрТТ.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Условие
			ИЛИ стрТТ.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние
			ИЛИ стрТТ.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение Тогда
			
			ПредыдущаяСтрока = нТаблицаТочек[нТаблицаТочек.Индекс(стрТТ)-1];
			
			Если ПредыдущаяСтрока.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт
				И НЕ ЗначениеЗаполнено(ПредыдущаяСтрока.ДатаОкончания) Тогда
			
				ДатаНачала = ТекущаяДата();
			Иначе	
				ДатаНачала = ПредыдущаяСтрока.ДатаОкончания
			КонецЕсли; 
			
			стрТТ.ДатаОкончания = ДатаНачала;
			
		ИначеЕсли ЭтоДействие(стрТТ.ВидТочки) Тогда
		
			Действие = стрТТ.Точка.ПользовательскоеДействие;
			стрТТ.Действие = Действие;
			
			ПредыдущаяСтрока = нТаблицаТочек[нТаблицаТочек.Индекс(стрТТ)-1];
			ДатаНачала = ПредыдущаяСтрока.ДатаОкончания;
			
			// Обработка подчиненного процесса. Вызывается рекурсивно.
			Если Действие.Назначение = Перечисления.бит_НазначенияПользовательскихДействий.ПодчиненныйПроцесс Тогда
				
				ПодчиненныйПроцесс = Задачи.бит_уп_Задача.НайтиПодчиненныйПроцесс(стрТТ.Задача);
				ТабЗадачПодчиненного = БизнесПроцессы.бит_уп_Процесс.ПолучитьЗадачиПроцесса(ПодчиненныйПроцесс);
				ТаблицаТочекПодчиненного = ПолучитьТаблицуТочек(Действие.АлгоритмПодчиненный,,,ТабЗадачПодчиненного);
				нТаблицаТочекПодчиненного = ПостроитьТаблицуПримерныхСроковВыполненияПроцессов(ТаблицаТочекПодчиненного, ПоказыватьСрокиПроцесса, ДатаНачала);
				
				Если нТаблицаТочекПодчиненного.Количество()=0 Тогда
					ДатаНовая = ДатаНачала;
				Иначе
					ДатаНовая = нТаблицаТочекПодчиненного[нТаблицаТочекПодчиненного.Количество()-1].ДатаОкончания;
				КонецЕсли; 
				
			// конец Обработка подчиненного процесса.
			ИначеЕсли ПредыдущаяСтрока.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт Тогда 	
				
				Если ЗначениеЗаполнено(стрТТ.Задача)
					И стрТТ.Задача.Выполнена Тогда
					
					дСтарта = ?(ЗначениеЗаполнено(ДатаСтарта), ДатаСтарта, ТекущаяДата());
					ДатаНовая = ?(ЗначениеЗаполнено(стрТТ.Задача.ДатаОкончанияИсполнения), стрТТ.Задача.ДатаОкончанияИсполнения, дСтарта);
				ИначеЕсли ЗначениеЗаполнено(ДатаСтарта) Тогда
					ДатаНовая = ДатаСтарта + Действие.ВремяНаУстановку*60;  
				// Изменение кода. Начало. 22.06.2018{{	
				ИначеЕсли ЗначениеЗаполнено(стрТТ.Задача) Тогда 
					Если ЗначениеЗаполнено(стрТТ.Задача.СрокИсполнения) Тогда
						ДатаНовая = стрТТ.Задача.СрокИсполнения;     
					Иначе
						ДатаНовая = стрТТ.Задача.Дата;     
					КонецЕсли; 
				// Изменение кода. Конец. 22.06.2018}}
				Иначе	
					ДатаНовая = ТекущаяДата() + Действие.ВремяНаУстановку*60;     
				КонецЕсли;
				
			Иначе	
				
				Если ЕстьРазделение Тогда 	
					ДатаНовая = ДатаНачалаРазделения;
				Иначе	
					ДатаНовая = ДатаНачала;
				КонецЕсли; 
				
				Если ЗначениеЗаполнено(стрТТ.Задача)
					И стрТТ.Задача.Выполнена Тогда
					
					Если ЗначениеЗаполнено(стрТТ.Задача.ДатаОкончанияИсполнения) Тогда
					
						ДатаНовая = стрТТ.Задача.ДатаОкончанияИсполнения;
					
					КонецЕсли; 
				// Изменение кода. Начало. 22.06.2018{{	
				ИначеЕсли ЗначениеЗаполнено(стрТТ.Задача) Тогда 
					Если ЗначениеЗаполнено(стрТТ.Задача.СрокИсполнения) Тогда
						ДатаНовая = стрТТ.Задача.СрокИсполнения;     
					Иначе
						ДатаНовая = стрТТ.Задача.Дата;     
					КонецЕсли; 
				// Изменение кода. Конец. 22.06.2018}}
				Иначе
					ДатаНовая = ДатаНовая + Действие.ВремяНаУстановку*60;
				КонецЕсли; 
				
			КонецЕсли;	
			
			стрТТ.ДатаОкончания = ДатаНовая;
			
			Если ЕстьРазделение Тогда 
				
				Если ((ЗначениеЗаполнено(стрТТ.Задача) И НЕ стрТТ.Задача.Выполнена)
					ИЛИ НЕ ЗначениеЗаполнено(стрТТ.Задача))
					И ДатаНовая > ДатаОкончанияРазделения Тогда
					
					ДатаОкончанияРазделения = ДатаНовая;
				КонецЕсли; 
				
			ИначеЕсли НЕ ЕстьРазделение 
				И ЗначениеЗаполнено(ДатаОкончанияРазделения) Тогда 
				
				стрТТ.ДатаОкончания = ДатаОкончанияРазделения + Действие.ВремяНаУстановку*60;
				ДатаОкончанияРазделения = Дата(1, 1, 1);
				
			КонецЕсли;
		КонецЕсли;
			
		Если стрТТ.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение Тогда
			ЕстьРазделение = Истина;
			ДатаНачалаРазделения = стрТТ.ДатаОкончания;
		ИначеЕсли стрТТ.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние Тогда 	
			ЕстьРазделение = Ложь;
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат нТаблицаТочек;
	
КонецФункции // ПостроитьТаблицуПримерныхСроковВыполненияПроцессов()

// Процедура выводит точки алгоритма в табличный документ.
// 
// Параметры:
//  ТД              - ТабличныйДокумент.
//  Объект          - .
//  ТаблицаПозиций  - ТаблицаЗначений.
//  Позиции         - Соответсвие.
//  Режим         	- Строка.
//  ПоказыватьСрокиПроцесса - Булево.
// 
Процедура НарисоватьТочкиАлгоритма(ТД,Алгоритм,ТаблицаТочек,ТаблицаПозиций,Позиции, Режим = "", ПоказыватьСрокиПроцесса = Ложь)	
	
	ПараметрыОтображения = ПолучитьПараметрыОтображенияАлгоритма(Алгоритм);
	
	ЭтоВизирование = ?(Режим = "Визирование", Истина, Ложь);
	ЭтоПроцесс     = ?(Режим = "Процесс"    , Истина, Ложь);
	нТаблицаТочек  = Новый ТаблицаЗначений(); 
	
	ОформлениеТочкиСтарт = Неопределено;
	стрОтбор = Новый Структура("ВидТочки", Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт);
	МассивСтрок = ТаблицаТочек.НайтиСтроки(стрОтбор);
	Если МассивСтрок.Количество()>0 Тогда
		ОформлениеТочкиСтарт = МассивСтрок[0].Точка.ОформлениеТочки.Получить();
	КонецЕсли; 

	Если ЭтоПроцесс Тогда
		
		// Для построения планируемых дат выполнения процессов, необходимо
		// чтобы процессы шли по порядку, как они записаны в алгоритме.
		нТаблицаТочкиВизы = ТаблицаТочек.Скопировать();
		нТаблицаТочкиВизы.Очистить();
		
		ТочкаСлияния = Неопределено;
		
		Если МассивСтрок.Количество()>0 Тогда
			ЗаполнитьТаблицу(МассивСтрок[0], нТаблицаТочкиВизы, ТаблицаТочек, ТочкаСлияния);
		КонецЕсли; 
			
		нТаблицаТочек = ПостроитьТаблицуПримерныхСроковВыполненияПроцессов(нТаблицаТочкиВизы, ПоказыватьСрокиПроцесса, Дата(1, 1, 1));
		Если ТаблицаТочек.Колонки.Найти("ДатаОкончания") <> Неопределено Тогда
			Для каждого СтрокаТаблицы Из нТаблицаТочек Цикл
				Если СтрокаТаблицы.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие Тогда
					РезультатПоиска = ТаблицаТочек.Найти(СтрокаТаблицы.Точка, "Точка");
					Если РезультатПоиска <> Неопределено Тогда
						РезультатПоиска.ДатаОкончания = СтрокаТаблицы.ДатаОкончания;
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла; 
		КонецЕсли; 
	КонецЕсли; 
	
	КоличествоСтрок = ТаблицаПозиций.Количество();
	КоличествоКолонок = ТаблицаПозиций.Колонки.Количество();
	
	Для НомК = 1 По КоличествоКолонок Цикл
		
		ТекущаяКолонка = ТаблицаПозиций.Колонки[НомК-1];
		Для НомС = 1 По КоличествоСтрок Цикл
			
			ТекущаяСтрока   = ТаблицаПозиций[НомС-1];
			ДанныеКВыводу  = ТекущаяСтрока[ТекущаяКолонка.Имя];
			
			Если НЕ ДанныеКВыводу = Неопределено Тогда
				
				Если ТипЗнч(ДанныеКВыводу) = Тип("Структура") Тогда
					СтрокаТаблицыТочек = ТаблицаТочек.Найти(ДанныеКВыводу.ИД,"ИД");
					ТекущаяТочка = Справочники.бит_уп_ТочкиАлгоритмов.ПустаяСсылка();
				Иначе	
					ТекущаяТочка = ДанныеКВыводу;					
					СтрокаТаблицыТочек = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");	
				КонецЕсли; 
				
				Лево = ВычислитьКоординатуЛево(НомК,ПараметрыОтображения);		
				Верх = ВычислитьКоординатуВерх(НомС,ПараметрыОтображения);
				
				ТипЛинии = Новый Линия(ТипЛинииРисункаТабличногоДокумента.Сплошная,1);			
				
				Координаты = КонструкторСтруктурыКоординат_ЛевоВерх(Лево,Верх,ПараметрыОтображения.Ширина,ПараметрыОтображения.Высота);
				ПараметрыРисунка = Новый Структура("Точка,Имя,Наименование,ТипЛинии,ПометкаУдаления");
				ПараметрыРисунка.Точка          = ТекущаяТочка;
				ПараметрыРисунка.Имя            = "";
				ПараметрыРисунка.ПометкаУдаления = ТекущаяТочка.ПометкаУдаления;
				
				СтруктураПараметров             = Новый Структура;
				СтруктураПараметров.Вставить("Точка",ДанныеКВыводу.Наименование);
				Если ЭтоВизирование Тогда
				
					СтруктураПараметров.Вставить("Решение",Строка(СтрокаТаблицыТочек.Решение));
				
				КонецЕсли; 
				
				ПараметрыРисунка.Наименование   = бит_ОбщегоНазначенияКлиентСервер.СформироватьТекстТочки(СтруктураПараметров);
				ПараметрыРисунка.ТипЛинии       = ТипЛинии;
				
				Если ЭтоВизирование Тогда
				
					ПараметрыРисунка.Вставить("Доступность"   ,СтрокаТаблицыТочек.Доступность);
					ПараметрыРисунка.Вставить("Виза"          ,СтрокаТаблицыТочек.Виза);
					ПараметрыРисунка.Вставить("Установлена"   ,ЗначениеЗаполнено(СтрокаТаблицыТочек.Решение));
					
				ИначеЕсли ЭтоПроцесс Тогда	
					
					ПараметрыРисунка.Вставить("Доступность"   ,Истина);
					
					флВыполнена = ?(СтрокаТаблицыТочек.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Выполнена 
					                  ИЛИ СтрокаТаблицыТочек.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Отменена, Истина, Ложь);
					ПараметрыРисунка.Вставить("Выполнена", флВыполнена);
					
					флОтложена = ?(СтрокаТаблицыТочек.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Остановлена, Истина, Ложь);
					ПараметрыРисунка.Вставить("Отложена", флОтложена);
					
					флЕстьЗадача = ?(ЗначениеЗаполнено(СтрокаТаблицыТочек.Задача), Истина, Ложь);
					ПараметрыРисунка.Вставить("ЕстьЗадача", флЕстьЗадача);
					
					// Изменение кода. Начало. 10.01.2017{{
					// Заполнение примерных сроков выполнения пользовательских действий.
					Если ЗначениеЗаполнено(ПараметрыРисунка.Точка.ПользовательскоеДействие)
						И нТаблицаТочек.Количество()>0 Тогда
						
						СтрОтбор = Новый Структура("Действие", ПараметрыРисунка.Точка.ПользовательскоеДействие);
						мСтрок = нТаблицаТочек.НайтиСтроки(СтрОтбор);
						Если мСтрок.Количество()>0 Тогда
						
							ПараметрыРисунка.Наименование = ПараметрыРисунка.Наименование + Символы.ПС + мСтрок[0].ДатаОкончания;
						
						КонецЕсли; 
					КонецЕсли;
					// Изменение кода. Конец. 10.01.2017}}
					
				Иначе
					ПараметрыРисунка.Вставить("Доступность"   ,Истина);
				КонецЕсли; 
				
				ПараметрыРисунка.Вставить("ЭтоВизирование", ЭтоВизирование);				
				ПараметрыРисунка.Вставить("ЭтоПроцесс"    , ЭтоПроцесс);
				
				НовыйРисунок = ДобавитьРисунок(ТД
															,ПараметрыРисунка
															,Координаты);
															
				Расшифровка = ЗаполнитьРасшифровкуТочкиАлгоритма(СтрокаТаблицыТочек, Режим);											
				НовыйРисунок.Расшифровка = Расшифровка;
				
				// Рисуем связи точек алгоритма
				Для каждого СтрокаВходящие Из ТекущаяТочка.ВходящиеТочки Цикл
					
					Лево = ВычислитьКоординатуЛево(НомК,ПараметрыОтображения);		
					Верх = ВычислитьКоординатуВерх(НомС,ПараметрыОтображения);		 
					ВходящаяТочка = СтрокаВходящие.Точка;
					
					ПозицияВх = Позиции[ВходящаяТочка];
					
					Если НЕ ПозицияВх = Неопределено Тогда
						
						НомВхС    = ТаблицаПозиций.Индекс(ПозицияВх.Строка)+1;
						КолонкаВх = ТаблицаПозиций.Колонки.Найти(ПозицияВх.ИмяКолонки);
						НомВхК    = ТаблицаПозиций.Колонки.Индекс(КолонкаВх)+1;
						
						ЛевоВх    = ВычислитьКоординатуЛево(НомВхК,ПараметрыОтображения);
						ВерхВх    = ВычислитьКоординатуВерх(НомВхС,ПараметрыОтображения);
						
						ПараметрыТочки   = Новый Структура("Лево,Верх,ВидТочки,Направление",Лево,Верх,ТекущаяТочка.ВидТочки,Неопределено);
						ПараметрыТочкиВх = Новый Структура("Лево,Верх,ВидТочки,Направление",ЛевоВх,ВерхВх,ВходящаяТочка.ВидТочки,СтрокаВходящие.Направление);		
						
						// ++ NB Новый алгоритм 
						ПараметрыТочки.Вставить("Точка",  ВходящаяТочка);
						ПараметрыТочкиВх.Вставить("Точка",ТекущаяТочка);
						// -- NB Новый алгоритм 
						НарисоватьСвязиТочекАлгоритма(ТД,ПараметрыОтображения,ПараметрыТочки,ПараметрыТочкиВх,ОформлениеТочкиСтарт);
						
					КонецЕсли; // Входящая точка есть
				КонецЦикла; // По входящим точкам
			КонецЕсли;  // Текущая точка заполнена
		КонецЦикла; // По строкам
	КонецЦикла; // По колонкам

КонецПроцедуры

// Процедура выводит линии, связывающие две точки алгоритма.
// 
// Параметры:
// ТД        - ТабличныйДокумент
// Объект    - Структура
// ПараметрыТочки   - Структура
// ПараметрыТочкиВх - Структура
// 
Процедура НарисоватьСвязиТочекАлгоритма(ТД,Объект,ПараметрыТочки,ПараметрыТочкиВх,ОформлениеТочкиСтарт)

	МассивКоординат = КоординатыСвязейТочекАлгоритма(Объект, ПараметрыТочки, ПараметрыТочкиВх);
	
	Если ТипЗнч(МассивКоординат) = Тип("Массив") Тогда
		
		Для каждого Координаты Из МассивКоординат Цикл
			// Изменение кода. Начало. 04.07.2017{{
			ТипЛинии 	= Новый Линия(ТипЛинииРисункаТабличногоДокумента.Сплошная,1);	
			Если ОформлениеТочкиСтарт<>Неопределено Тогда
			
				ЦветЛинии = ОформлениеТочкиСтарт.ЦветЛинии;
			Иначе	
				ЦветЛинии 	= Новый Цвет(0,0,0);
			КонецЕсли; 
			
			ПараметрыЛинии = Новый Структура("ТипЛинии, ЦветЛинии",ТипЛинии,ЦветЛинии);
			// ++ NB Новый алгоритм
			ПараметрыЛинии.Вставить("Расшифровка", Новый Структура("Начало, Конец, Направление", 
				ПараметрыТочки.Точка, ПараметрыТочкиВх.Точка, ПараметрыТочкиВх.Направление));
			// -- NB Новый алгоритм  
			ДобавитьЛинию(ТД,Координаты,ПараметрыЛинии); 
			// Изменение кода. Конец. 04.07.2017}}
		КонецЦикла; 
		
	КонецЕсли; 

КонецПроцедуры // НарисоватьСвязиТочекАлгоритма()

// Определяет координаты линий, связывающие две точки алгоритма.
// 
// Параметры:
// ТД        - ТабличныйДокумент
// Объект    - Структура
// ПараметрыТочки   - Структура
// ПараметрыТочкиВх - Структура
// 
Функция КоординатыСвязейТочекАлгоритма(Объект,ПараметрыТочки,ПараметрыТочкиВх)

	МассивКоординат = Новый Массив;
	
	Направление = ПараметрыТочкиВх.Направление;
	Лево = ПараметрыТочки.Лево;
	Верх = ПараметрыТочки.Верх;
	ЛевоВх = ПараметрыТочкиВх.Лево;
	ВерхВх = ПараметрыТочкиВх.Верх;
	
	Если Направление = Перечисления.бит_уп_Направление.Вертикаль Тогда
		
		Если ПараметрыТочки.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние Тогда
			
			
			МассивКоординат = КоординатыСвязейТочкиСлияния(Объект,Лево,Верх,ЛевоВх,ВерхВх);
			
		Иначе
			
			Если ПараметрыТочкиВх.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение Тогда
				
				МассивКоординат = КоординатыСвязейТочкиРазделения(Объект,Лево,Верх,ЛевоВх,ВерхВх);
				
			Иначе	
				
				// Простая линия вниз
				МассивКоординат = КоординатыСвязиВертикаль(Объект,Лево,Верх,ЛевоВх,ВерхВх);
				
			КонецЕсли; 
			
			
		КонецЕсли; 
		
	ИначеЕсли Направление = Перечисления.бит_уп_Направление.Горизонталь Тогда	
		
		// Горизонтальная связь - всегда просто линия вправо.
		МассивКоординат = КоординатыСвязиГоризонталь(Объект,Лево,Верх,ЛевоВх,ВерхВх);											
		
	КонецЕсли; 

	Возврат МассивКоординат;

КонецФункции // КоординатыСвязейТочекАлгоритма()

// Определяет координаты вертикальной связи двух точек алгоритма.
// 
// Параметры:
// Объект    - Структура
// Лево      - Число - Координата лево текущей точки.
// Верх      - Число - Координата верх текущей точки.
// ЛевоВх    - Число - Координата лево входящей точки.
// ВерхВх    - Число - Координата верх входящей точки.
// 
// Возвращаемое значение:
// МассивКоординат - Массив
// 
Функция КоординатыСвязиВертикаль(Объект,Лево,Верх,ЛевоВх,ВерхВх)

	МассивКоординат = Новый Массив;
	
	// ++ NB 
	// Линия вниз
	Координаты = КонструкторСтруктурыКоординат_ХУ(ЛевоВх + ОКР(Объект.Ширина/2,0)
												,ВерхВх+Объект.Высота
												,Лево + Окр(Объект.Ширина/2, 0)
												,Верх);
	// -- NB 
	МассивКоординат.Добавить(Координаты);

	Возврат МассивКоординат;
	
КонецФункции // КоординатыСвязиВертикаль() 

// Определяет координаты горизонтальной связи двух точек алгоритма.
// 
// Параметры:
// Объект    - Структура
// Лево      - Число - Координата лево текущей точки.
// Верх      - Число - Координата верх текущей точки.
// ЛевоВх    - Число - Координата лево входящей точки.
// ВерхВх    - Число - Координата верх входящей точки.
// 
// Возвращаемое значение:
// МассивКоординат - Массив
// 
Функция КоординатыСвязиГоризонталь(Объект,Лево,Верх,ЛевоВх,ВерхВх)

	МассивКоординат = Новый Массив;	
	
	// Линия вправо
	Координаты = КонструкторСтруктурыКоординат_ХУ(ЛевоВх+Объект.Ширина
												,ВерхВх+Объект.Высота/2
												,Лево
												,Верх+Объект.Высота/2);
	
	МассивКоординат.Добавить(Координаты);

	Возврат МассивКоординат;

КонецФункции // КоординатыСвязиГоризонталь()

// Определяет координаты связей точки алгоритма с точкой разделения.
// 
// Параметры:
// Объект    - Структура.
// Лево      - Число - Координата лево текущей точки.
// Верх      - Число - Координата верх текущей точки.
// ЛевоВх    - Число - Координата лево входящей точки (точка разделения).
// ВерхВх    - Число - Координата верх входящей точки (точка разделения).
// 
// Возвращаемое значение:
// МассивКоординат - Массив.
// 
Функция КоординатыСвязейТочкиРазделения(Объект,Лево,Верх,ЛевоВх,ВерхВх)

	МассивКоординат = Новый Массив;
	
	Координаты = КонструкторСтруктурыКоординат_ХУ(ЛевоВх+Объект.Ширина/2
					,ВерхВх+Объект.Высота
					,ЛевоВх+Объект.Ширина/2
					,ВерхВх+Объект.Высота+Объект.ИнтервалВертикаль/2);			

	МассивКоординат.Добавить(Координаты);				
					
	Координаты = КонструкторСтруктурыКоординат_ХУ(Координаты.Х2
					,Координаты.У2
					,Лево+Объект.Ширина/2
					,Координаты.У2);			
					
	МассивКоординат.Добавить(Координаты);				
					
	Координаты = КонструкторСтруктурыКоординат_ХУ(Координаты.Х2
					,Координаты.У2
					,Координаты.Х2
					,Координаты.У2+Объект.ИнтервалВертикаль/2);			
					
	МассивКоординат.Добавить(Координаты);				
					
	Возврат МассивКоординат;
					
КонецФункции // КоординатыСвязейТочкиРазделения()

// Определяет координаты связей точки слияния с точкой алгоритма.
// 
// Параметры:
// Объект    - Структура.
// Лево      - Число - Координата лево текущей точки (точка слияния).
// Верх      - Число - Координата верх текущей точки (точка слияния).
// ЛевоВх    - Число - Координата лево входящей точки.
// ВерхВх    - Число - Координата верх входящей точки.
// 
// Возвращаемое значение:
// МассивКоординат - Массив.
// 
Функция КоординатыСвязейТочкиСлияния(Объект,Лево,Верх,ЛевоВх,ВерхВх)

    МассивКоординат = Новый Массив;	

    // Вниз из входящей точки
	Координаты = КонструкторСтруктурыКоординат_ХУ(ЛевоВх+Объект.Ширина/2
					,ВерхВх+Объект.Высота
					,ЛевоВх+Объект.Ширина/2
					,ВерхВх+Объект.Высота+Объект.ИнтервалВертикаль/2);			

    МассивКоординат.Добавить(Координаты);										
	
	Направление = бит_ОбщегоНазначения.ЗнакЧисла(Лево-ЛевоВх);
	
	// Вправо или влево в зависимости от положения точки слияния.
	Координаты = КонструкторСтруктурыКоординат_ХУ(Координаты.Х2
					,Координаты.У2
					,Координаты.Х2+Направление*(Объект.Ширина/2+Объект.ИнтервалГоризонталь/2)
					,Координаты.У2);			

    МассивКоординат.Добавить(Координаты);				
					
					
	// До уровня точки слияния по вертикали
	Координаты = КонструкторСтруктурыКоординат_ХУ(Координаты.Х2
					,Координаты.У2
					,Координаты.Х2
					,Верх-Объект.ИнтервалВертикаль/2);			

    МассивКоординат.Добавить(Координаты);				
					
	
	// До уровня точки слияния по горизонтали
	Координаты = КонструкторСтруктурыКоординат_ХУ(Координаты.Х2
					,Координаты.У2
					,Лево+Объект.Ширина/2
					,Координаты.У2);			

	МассивКоординат.Добавить(Координаты);				

	
	// Вверх из точки слияния
	Координаты = КонструкторСтруктурыКоординат_ХУ(Лево+Объект.Ширина/2
					,Верх
					,Лево+Объект.Ширина/2
					,Верх-Объект.ИнтервалВертикаль/2);			

	МассивКоординат.Добавить(Координаты);				

	Возврат МассивКоординат;	
	
КонецФункции // КоординатыСвязейТочкиСлияния()

// Возвращает коэффициент масштабирования алгоритма при выводе в поле HTML.
// 
// Возвращаемое значение:
//  к - Число.
// 
Функция КоэффициентМасштабированияХТМЛ()

	коэфф = 5;

	Возврат коэфф;
	
КонецФункции // КоэффициентМасштабированияХТМЛ()

// Функция-конструктор структуры, описывающей параметры SVG-области, 
// используемой для отрисовки алгоритма.
// 
// Параметры:
//  Ширина - Число
//  Высота - Число
// 
// Возвращаемое значение:
//  Структ - Строка.
// 
Функция КонструкторСтруктурыХолстаХТМЛ(Ширина, Высота)

	коэфф = КоэффициентМасштабированияХТМЛ();
	Структ = Новый Структура("width, height",коэфф*Ширина, коэфф*Высота); 

	Возврат Структ;
	
КонецФункции // КонструкторСтруктурыХолстаХТМЛ()

// Функция-конструктор структуры, описывающей 
// параметры точки для отрисовки в поле HTML.
// 
// Параметры:
//  ИД - Строка
//  ТипТочки - Строка
//  Лево - Число
//  Верх - Число
//  Ширина - Число
//  Высота - Число
// 
// Возвращаемое значение:
//  Структ - Структура.
// 
Функция КонструкторСтруктурыТочкиХТМЛ(Ид, Наименование, ТипТочки, Лево, Верх, Ширина, Высота) 

	коэфф = КоэффициентМасштабированияХТМЛ();
	
	Структ = Новый Структура("id, title, type, left, top, width, height",
	                          ИД,
							  Наименование,
							  ТипТочки, 
							  Лево*коэфф, 
							  Верх*коэфф, 
							  Ширина*коэфф, 
							  Высота*коэфф);

	Возврат Структ;
	
КонецФункции // КонструкторСтруктурыТочкиХТМЛ()

// Функция-конструктор структуры, описывающей 
// параметры линии для отрисовки в поле HTML документа.
// 
// Параметры:
//  x1 - Число - Координата по Х начальной точки.
//  y1 - Число - Координата по У начальной точки.
//  x2 - Число - Координата по Х конечной  точки.
//  y2 - Число - Координата по У конечной  точки.
//  color - Строка - Цвет линии.
//  width - Число - Толщина линии.
// 
// Возвращаемое значение:
//  Структ - Структура.
// 
Функция КонструкторСтруктурыЛинииХТМЛ(x1,y1,x2,y2,color = "black", width=2)

	коэфф = КоэффициентМасштабированияХТМЛ();
	
	Структ = Новый Структура("x1,y1,x2,y2,color,width",x1*коэфф,y1*коэфф,x2*коэфф,y2*коэфф,color,width);

	Возврат Структ;
	
КонецФункции // КонструкторСтруктурыЛинииХТМЛ()

// Функция преобразует вид точки алгоритма в строковое значение, 
// используемое в JavaScript при построении схемы алгоритма.
// 
// Параметры:
//  ВидТочки - ПеречислениеСсылка.бит_уп_ВидыТочекАлгоритмов.
// 
// Возвращаемое значение:
//  СтрВид - Строка.
// 
Функция ПреобразоватьВидТочки(ВидТочки)
	
	Соотв = Новый Соответствие;
	Соотв.Вставить(Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт     ,"StartPoint");
	Соотв.Вставить(Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие  ,"ActionPoint");
	Соотв.Вставить(Перечисления.бит_уп_ВидыТочекАлгоритмов.ПодчиненныйПроцесс  ,"ActionPoint");
	Соотв.Вставить(Перечисления.бит_уп_ВидыТочекАлгоритмов.Условие   ,"ConditionPoint");
	Соотв.Вставить(Перечисления.бит_уп_ВидыТочекАлгоритмов.Разделение,"SeparationPoint");
	Соотв.Вставить(Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние   ,"JoinPoint");
	
	СтрВид = Соотв[ВидТочки];
	
	Если НЕ ЗначениеЗаполнено(СтрВид)  Тогда
		
		СтрВид = "ActionPoint";
		
	КонецЕсли;

	Возврат СтрВид;
	
КонецФункции // ПреобразоватьТипТочки()

// Функция инициализирует таблицу виз. 
// Используется в процедуре ПолучитьТаблицуТочек.
// 
// Возвращаемое значение:
//   ТаблицаВиз   - ТаблицаЗначений.
// 
Функция КонструкторТаблицыВиз()

	ТаблицаВизы = Новый ТаблицаЗначений;
	ТаблицаВизы.Колонки.Добавить("Виза"           ,Новый ОписаниеТипов("СправочникСсылка.бит_Визы"));
	ТаблицаВизы.Колонки.Добавить("ИД"             ,Новый ОписаниеТипов("Строка"));
	ТаблицаВизы.Колонки.Добавить("ТочкаАлгоритма" ,Новый ОписаниеТипов("СправочникСсылка.бит_уп_ТочкиАлгоритмов"));
	ТаблицаВизы.Колонки.Добавить("Решение"        ,Новый ОписаниеТипов("СправочникСсылка.бит_ВидыРешенийСогласования"));
	ТаблицаВизы.Колонки.Добавить("АктивнаяВиза"   ,Новый ОписаниеТипов("Булево"));
	ТаблицаВизы.Колонки.Добавить("ДоступностьВизы",Новый ОписаниеТипов("Булево"));

	Возврат ТаблицаВизы;
	
КонецФункции // КонструкторТаблицыВиз()

// Функция инициализирует таблицу, содержащую информацию об точках алогоритма, визах и задачах.
// Используется в процедуре ПолучитьТаблицуТочек.
// 
// Возвращаемое значение:
//   ТаблицаТочек   - ТаблицаЗначений.
// 
Функция КонструкторТаблицыТочкиВизы()
	
	ОписаниеЧисло = Новый ОписаниеТипов("Число");
	ОписаниеБулево = Новый ОписаниеТипов("Булево");
	
	ТаблицаТочкиВизы = Новый ТаблицаЗначений;
	ТаблицаТочкиВизы.Колонки.Добавить("Точка"                       ,Новый ОписаниеТипов("СправочникСсылка.бит_уп_ТочкиАлгоритмов"));
	ТаблицаТочкиВизы.Колонки.Добавить("ВидТочки"                    ,Новый ОписаниеТипов("ПеречислениеСсылка.бит_уп_ВидыТочекАлгоритмов"));
	ТаблицаТочкиВизы.Колонки.Добавить("Обработана"                  ,ОписаниеЧисло);
	ТаблицаТочкиВизы.Колонки.Добавить("СвязиОбработаны"             ,ОписаниеЧисло);
	ТаблицаТочкиВизы.Колонки.Добавить("КоличествоОбработанныхСвязей",ОписаниеЧисло);
	ТаблицаТочкиВизы.Колонки.Добавить("КоличествоВходящих"          ,ОписаниеЧисло);
	ТаблицаТочкиВизы.Колонки.Добавить("КоличествоИсходящих"         ,ОписаниеЧисло);
	ТаблицаТочкиВизы.Колонки.Добавить("ИдентификаторТочки",			 ОбщегоНазначения.ОписаниеТипаСтрока(10));
	ТаблицаТочкиВизы.Колонки.Добавить("КодТочки",					 ОбщегоНазначения.ОписаниеТипаСтрока(50));
	
	ТаблицаТочкиВизы.Колонки.Добавить("Виза"              ,Новый ОписаниеТипов("СправочникСсылка.бит_Визы"));
	ТаблицаТочкиВизы.Колонки.Добавить("ИД"                ,Новый ОписаниеТипов("Строка"));
	ТаблицаТочкиВизы.Колонки.Добавить("Решение"           ,Новый ОписаниеТипов("СправочникСсылка.бит_ВидыРешенийСогласования"));
	ТаблицаТочкиВизы.Колонки.Добавить("ЕстьПраво"         ,ОписаниеБулево);
	ТаблицаТочкиВизы.Колонки.Добавить("ВходящиеЗаполнены" ,ОписаниеБулево);
	ТаблицаТочкиВизы.Колонки.Добавить("ИсходящиеЗаполнены",ОписаниеБулево);
	ТаблицаТочкиВизы.Колонки.Добавить("АктивнаяВиза"      ,ОписаниеБулево);
	ТаблицаТочкиВизы.Колонки.Добавить("Доступность"       ,ОписаниеБулево);
	
	НовОписание = бит_ОбщегоНазначенияКлиентСервер.ПолучитьОписаниеИзСтроки("ЗадачаСсылка.бит_уп_Задача/БизнесПроцессСсылка.бит_уп_Процесс");
	ТаблицаТочкиВизы.Колонки.Добавить("Задача"   , НовОписание);
	ТаблицаТочкиВизы.Колонки.Добавить("Состояние", Новый ОписаниеТипов("СправочникСсылка.бит_СтатусыОбъектов"));
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-09-01 (#2873)
	ТаблицаТочкиВизы.Колонки.Добавить("СложнаяВиза"     	, Новый ОписаниеТипов("Булево"));
	ТаблицаТочкиВизы.Колонки.Добавить("РешениеПоСложнойВизе", Новый ОписаниеТипов("СправочникСсылка.бит_ВидыРешенийСогласования"));
	ТаблицаТочкиВизы.Колонки.Добавить("ДобавленаВручную"	, Новый ОписаниеТипов("Булево"));
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-09-01 (#2873)	
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-05-10 (#2971)
	ТаблицаТочкиВизы.Колонки.Добавить("ТочкаЦикла"			, Новый ОписаниеТипов("Булево"));
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-05-10 (#2971)
		
	ТаблицаТочкиВизы.Колонки.Добавить("ДатаОкончания", ОбщегоНазначения.ОписаниеТипаДата(ЧастиДаты.ДатаВремя));
	
	Возврат ТаблицаТочкиВизы;
	
КонецФункции // КонструкторТаблицыТочкиВизы()

// Процедура выполняет "Полное соединение" таблицы точек и таблицы виз. 
// Реализация посредством таблиц значений выполняется в несколько раз быстрее чем посредством запроса.
// Скорость критична при групповом выполнении в обработке бит_РабочееМестоВизирования.
// 
// Параметры:
//  ТаблицаТочкиВизы     - ТаблицаЗначений.
//  ТаблицаТочки         - ТаблицаЗначений.
//  ТаблицаВизы          - ТаблицаВизы.
// 
//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
////Процедура ПолноеСоединениеТочкиВизы(ТаблицаТочкиВизы,ТаблицаТочки,ТаблицаВизы)
////Заменено на:
////Заменил на функцию возвращающую соответствие точка - вид точки для ускорения записи видов исходящих и входящих точек
//Функция ПолноеСоединениеТочкиВизы(ТаблицаТочкиВизы,ТаблицаТочки,ТаблицаВизы)
////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
Процедура ПолноеСоединениеТочкиВизы(ТаблицаТочкиВизы,ТаблицаТочки,ТаблицаВизы)
//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)

	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-09-01 (#2873)
	////+СБ Пискунова 15.02.2016 #2691  Определим доступность для всех физ.лиц на одной визе
	////Заменяю колонку Решение. Виза считается согласованной только в том случае, если все установили визу согласовано	
	//Запрос = Новый Запрос;
	//Запрос.Текст = 
	//"ВЫБРАТЬ
	//|	ВТ_ТаблицаВиз.Виза,
	//|	ВТ_ТаблицаВиз.Решение
	//|ПОМЕСТИТЬ ВТ_РешенияПовизамИсходные
	//|ИЗ
	//|	&ВТ_ТаблицаВиз КАК ВТ_ТаблицаВиз
	//|;
	//|
	//|////////////////////////////////////////////////////////////////////////////////
	//|ВЫБРАТЬ
	//|	ВТ_РешенияПовизамИсходные.Виза,
	//|	ВЫБОР
	//|		КОГДА ВТ_РешенияПовизамИсходные.Решение = ЗНАЧЕНИЕ(Справочник.бит_ВидыРешенийСогласования.Согласовано) 
	//|			ТОГДА 1
	//|		ИНАЧЕ 2
	//|	КОНЕЦ КАК Решение,
	//|	ВТ_РешенияПовизамИсходные.Решение КАК РешениеЗначение
	//|ПОМЕСТИТЬ ВТ_РешенияПоВизамГруппировка
	//|ИЗ
	//|	ВТ_РешенияПовизамИсходные КАК ВТ_РешенияПовизамИсходные
	//|;
	//|
	//|////////////////////////////////////////////////////////////////////////////////
	//|ВЫБРАТЬ
	//|	ВТ_РешенияПоВизамГруппировка.Виза,
	//|	МАКСИМУМ(ВТ_РешенияПоВизамГруппировка.Решение) КАК Решение
	//|ПОМЕСТИТЬ МаксимумПоВизе
	//|ИЗ
	//|	ВТ_РешенияПоВизамГруппировка КАК ВТ_РешенияПоВизамГруппировка
	//|
	//|СГРУППИРОВАТЬ ПО
	//|	ВТ_РешенияПоВизамГруппировка.Виза
	//|;
	//|
	//|////////////////////////////////////////////////////////////////////////////////
	//|ВЫБРАТЬ
	//|	МаксимумПоВизе.Виза,
	//|	ВТ_РешенияПоВизамГруппировка.РешениеЗначение
	//|ИЗ
	//|	МаксимумПоВизе КАК МаксимумПоВизе
	//|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_РешенияПоВизамГруппировка КАК ВТ_РешенияПоВизамГруппировка
	//|		ПО МаксимумПоВизе.Виза = ВТ_РешенияПоВизамГруппировка.Виза
	//|			И МаксимумПоВизе.Решение = ВТ_РешенияПоВизамГруппировка.Решение";
	//
	//Запрос.УстановитьПараметр("ВТ_ТаблицаВиз",ТаблицаВизы);	
	//РезультатЗапроса = Запрос.Выполнить();
	//
	//ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	//
	//Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
	//	
	//	Отбор = Новый Структура();
	//	Отбор.Вставить("Виза",ВыборкаДетальныеЗаписи.Виза);
	//	Строки = ТаблицаВизы.НайтиСтроки(Отбор);
	//	Если Строки.Количество() >0 Тогда 
	//		Для каждого элемент из Строки Цикл 
	//			Элемент.Решение = ВыборкаДетальныеЗаписи.РешениеЗначение; 
	//		КонецЦикла;
	//		
	//	КонецЕсли;
	//КонецЦикла;
	//
	////-СБ Пискунова 15.02.2016 #2691  Определим доступность для всех физ.лиц на одной визе
	//Заменено на:	
	Если ТаблицаВизы.Колонки.Найти("СложнаяВиза") = Неопределено Тогда 
		ТаблицаВизы.Колонки.Добавить("СложнаяВиза", Новый ОписаниеТипов("Булево"));
	Иначе 
		ТаблицаВизы.ЗаполнитьЗначения(Ложь,"СложнаяВиза");
	КонецЕсли;
	
	Если ТаблицаВизы.Колонки.Найти("РешениеПоСложнойВизе") = Неопределено Тогда 
		ТаблицаВизы.Колонки.Добавить("РешениеПоСложнойВизе", Новый ОписаниеТипов("СправочникСсылка.бит_ВидыРешенийСогласования"));
	Иначе 
		ТаблицаВизы.ЗаполнитьЗначения(ПредопределенноеЗначение("Справочник.бит_ВидыРешенийСогласования.ПустаяСсылка"),"РешениеПоСложнойВизе");
	КонецЕсли;
	
	Если ТаблицаВизы.Колонки.Найти("ДобавленаВручную") = Неопределено Тогда 
		ТаблицаВизы.Колонки.Добавить("ДобавленаВручную", Новый ОписаниеТипов("Булево"));
	КонецЕсли;

	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВТ_ТаблицаВиз.Виза,
	|	ВТ_ТаблицаВиз.ТочкаАлгоритма,
	|	ВТ_ТаблицаВиз.Решение,
	|	ВТ_ТаблицаВиз.ДобавленаВручную
	|ПОМЕСТИТЬ ВТ_РешенияПовизамИсходные
	|ИЗ
	|	&ВТ_ТаблицаВиз КАК ВТ_ТаблицаВиз
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ТаблицаВиз.Точка
	|ПОМЕСТИТЬ ВТ_ТочкиАлгоритма
	|ИЗ
	|	&ВТ_ТаблицаТочки КАК ВТ_ТаблицаВиз
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_РешенияПовизамИсходные.Виза,
	|	ВЫБОР
	|		КОГДА ВТ_РешенияПовизамИсходные.Решение = ЗНАЧЕНИЕ(Справочник.бит_ВидыРешенийСогласования.Согласовано)
	|			ТОГДА 1
	|		ИНАЧЕ 2
	|	КОНЕЦ КАК Решение,
	|	ВТ_РешенияПовизамИсходные.Решение КАК РешениеЗначение
	|ПОМЕСТИТЬ ВТ_РешенияПоВизамГруппировка
	|ИЗ
	|	ВТ_РешенияПовизамИсходные КАК ВТ_РешенияПовизамИсходные
	|ГДЕ
	|	НЕ ВТ_РешенияПовизамИсходные.ДобавленаВручную
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_РешенияПоВизамГруппировка.Виза,
	|	МАКСИМУМ(ВТ_РешенияПоВизамГруппировка.Решение) КАК Решение
	|ПОМЕСТИТЬ МаксимумПоВизе
	|ИЗ
	|	ВТ_РешенияПоВизамГруппировка КАК ВТ_РешенияПоВизамГруппировка
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_РешенияПоВизамГруппировка.Виза
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МаксимумПоВизе.Виза,
	|	ВТ_РешенияПоВизамГруппировка.РешениеЗначение
	|ПОМЕСТИТЬ РешенияПоВизам
	|ИЗ
	|	МаксимумПоВизе КАК МаксимумПоВизе
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_РешенияПоВизамГруппировка КАК ВТ_РешенияПоВизамГруппировка
	|		ПО МаксимумПоВизе.Виза = ВТ_РешенияПоВизамГруппировка.Виза
	|			И МаксимумПоВизе.Решение = ВТ_РешенияПоВизамГруппировка.Решение
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_РешенияПовизамИсходные.Виза,
	|	ВТ_РешенияПовизамИсходные.ТочкаАлгоритма КАК Точка,
	|	КОЛИЧЕСТВО(ВТ_РешенияПовизамИсходные.Виза) КАК КоличествоВиз
	|ПОМЕСТИТЬ ВТ_РешенияПоВизамГруппировкаТочка
	|ИЗ
	|	ВТ_РешенияПовизамИсходные КАК ВТ_РешенияПовизамИсходные
	|ГДЕ
	|	НЕ ВТ_РешенияПовизамИсходные.ДобавленаВручную
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_РешенияПовизамИсходные.Виза,
	|	ВТ_РешенияПовизамИсходные.ТочкаАлгоритма
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Точка,
	|	КоличествоВиз
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ТочкиАлгоритма.Точка КАК Точка,
	|	КОЛИЧЕСТВО(ВТ_ТочкиАлгоритма.Точка) КАК КоличествоТочек
	|ПОМЕСТИТЬ ВТ_СгруппированныеТочки
	|ИЗ
	|	ВТ_ТочкиАлгоритма КАК ВТ_ТочкиАлгоритма
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_ТочкиАлгоритма.Точка
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Точка,
	|	КоличествоТочек
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_РешенияПоВизамГруппировкаТочка.Виза,
	|	ВТ_РешенияПоВизамГруппировкаТочка.Точка КАК ТочкаАлгоритма,
	|	РешенияПоВизам.РешениеЗначение
	|ИЗ
	|	ВТ_РешенияПоВизамГруппировкаТочка КАК ВТ_РешенияПоВизамГруппировкаТочка
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_СгруппированныеТочки КАК ВТ_СгруппированныеТочки
	|		ПО ВТ_РешенияПоВизамГруппировкаТочка.Точка = ВТ_СгруппированныеТочки.Точка
	|			И ВТ_РешенияПоВизамГруппировкаТочка.КоличествоВиз = ВТ_СгруппированныеТочки.КоличествоТочек
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РешенияПоВизам КАК РешенияПоВизам
	|		ПО ВТ_РешенияПоВизамГруппировкаТочка.Виза = РешенияПоВизам.Виза
	|ГДЕ
	|	ВТ_СгруппированныеТочки.Точка ЕСТЬ NULL
	|
	|СГРУППИРОВАТЬ ПО
	|	ВТ_РешенияПоВизамГруппировкаТочка.Виза,
	|	ВТ_РешенияПоВизамГруппировкаТочка.Точка,
	|	РешенияПоВизам.РешениеЗначение";
	
	Запрос.УстановитьПараметр("ВТ_ТаблицаВиз"	,ТаблицаВизы);	
	Запрос.УстановитьПараметр("ВТ_ТаблицаТочки"	,ТаблицаТочки);	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Отбор = Новый Структура("Виза,ТочкаАлгоритма");	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		
		ЗаполнитьЗначенияСвойств(Отбор,ВыборкаДетальныеЗаписи);
		
		Строки = ТаблицаВизы.НайтиСтроки(Отбор);
		Если Строки.Количество() >0 Тогда 
			Для каждого элемент из Строки Цикл 
				Элемент.СложнаяВиза = Истина; 
				Элемент.РешениеПоСложнойВизе = ВыборкаДетальныеЗаписи.РешениеЗначение;
			КонецЦикла;
			
		КонецЕсли;
	КонецЦикла;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-09-01 (#2873)

	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
	////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
	//СоответсвиеТочкаВидТочки = Новый Соответствие;
	////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
	
	ТаблицаВизы.Колонки.Добавить("Обработана",Новый ОписаниеТипов("Булево"));
	
	Для каждого СтрокаТочки Из ТаблицаТочки Цикл
	
		НоваяСтрока = ТаблицаТочкиВизы.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаТочки);
		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
		////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
		//СоответсвиеТочкаВидТочки.Вставить(СтрокаТочки.Точка, СтрокаТочки.ВидТочки);
		////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
		
		Для каждого СтрокаВизы Из ТаблицаВизы Цикл
		     // ++ NB Есть мнение, что строки нужно удалять, а не маркировать.
			 // 	  Тогда чисто строк во втором цикле уменьшится.
			 Если СтрокаВизы.ТочкаАлгоритма = СтрокаТочки.Точка И НЕ СтрокаВизы.Обработана Тогда
			 
			 	СтрокаВизы.Обработана = Истина;
				НоваяСтрока.Виза      = СтрокаВизы.Виза;
				НоваяСтрока.ИД        = СтрокаВизы.ИД;
				НоваяСтрока.Решение   = СтрокаВизы.Решение;
				НоваяСтрока.ЕстьПраво = СтрокаВизы.ДоступностьВизы;
				
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-09-01 (#2873)
				НоваяСтрока.СложнаяВиза		     = СтрокаВизы.СложнаяВиза;
				НоваяСтрока.РешениеПоСложнойВизе = СтрокаВизы.РешениеПоСложнойВизе;
				НоваяСтрока.ДобавленаВручную	 = СтрокаВизы.ДобавленаВручную;
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-09-01 (#2873)
				
			 КонецЕсли; 
		
		КонецЦикла; 
	
	КонецЦикла; 

	Для каждого СтрокаВизы Из ТаблицаВизы Цикл
	
		Если НЕ СтрокаВизы.Обработана Тогда
		
			НоваяСтрока = ТаблицаТочкиВизы.Добавить();
			СтрокаВизы.Обработана = Истина;
			НоваяСтрока.Виза      = СтрокаВизы.Виза;
			НоваяСтрока.ИД        = СтрокаВизы.ИД;
			НоваяСтрока.Решение   = СтрокаВизы.Решение;
			НоваяСтрока.ЕстьПраво = СтрокаВизы.ДоступностьВизы;
			НоваяСтрока.ВидТочки  = Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие;
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-09-01 (#2873)
			НоваяСтрока.СложнаяВиза			 = СтрокаВизы.СложнаяВиза;
			НоваяСтрока.РешениеПоСложнойВизе = СтрокаВизы.РешениеПоСложнойВизе;
			НоваяСтрока.ДобавленаВручную 	 = СтрокаВизы.ДобавленаВручную;
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-09-01 (#2873)  
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
			////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
			//СоответсвиеТочкаВидТочки.Вставить(СтрокаВизы.ТочкаАлгоритма, НоваяСтрока.ВидТочки);
			////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-29 (#2942)
					
		КонецЕсли; 
	
	КонецЦикла; 

//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-29 (#2942)
////ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-12-08 (#2931)
////КонецПроцедуры // ПолноеСоединениеТочкиВизы()
////Заменено на:

//Возврат СоответсвиеТочкаВидТочки;

//КонецФункции
////ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-12-08 (#2931)
КонецПроцедуры

// Процедура заполняет в общей таблице ТаблицаТочкиВизы данные по задачам алгоритма. 
// 
// Параметры:
//  ТаблицаТочкиВизы - ТаблицаЗначений.
//  ТабЗадач         - ТаблицаЗначений.
// 
Процедура ЗаполнитьДанныеЗадач(ТаблицаТочкиВизы, ТабЗадач)
	
	Для каждого СтрокаЗадачи Из ТабЗадач Цикл
		
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("Точка", СтрокаЗадачи.Точка);
		
		МассивСтрок = ТаблицаТочкиВизы.НайтиСтроки(СтрОтбор);
		
		Для каждого СтрокаТаблицы Из МассивСтрок Цикл
			
			СтрокаТаблицы.Задача    = СтрокаЗадачи.Задача;
			СтрокаТаблицы.Состояние = СтрокаЗадачи.Состояние;
			
		КонецЦикла; 
		
	КонецЦикла; 	
	
КонецПроцедуры // ЗаполнитьДанныеЗадач() 

// Функция формирует структуру описывающую позицию точки в таблице позиций.
// 
// Параметры:
//  ИмяКолонки     - Строка.
//  СтрокаТаблицы  - СтрокаТабличнойЧасти.
// 
// Возвращаемое значение:
//  РезСтруктура   - Структура.
// 
Функция СформироватьСтруктуруПозиция(ИмяКолонки,СтрокаТаблицы)

	РезСтруктура = Новый Структура("ИмяКолонки,Строка");
	
	РезСтруктура.ИмяКолонки   = ИмяКолонки;
	РезСтруктура.Строка       = СтрокаТаблицы;

	Возврат РезСтруктура;
	
КонецФункции // СформироватьСтруктуруПозиция()

// Процедура устанавливает в ТаблицеТочек признак Обработана для данной точки.
// 
// Параметры:
//  ТаблицаТочек  - ТаблицаЗначений
//  ТекущаяТочка  - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
Процедура ОтметитьТочкаОбработана(ТаблицаТочек,ТекущаяТочка)
	
	ТекущаяСтрокаТочки = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");
	Если НЕ ТекущаяСтрокаТочки = Неопределено Тогда
		
		ТекущаяСтрокаТочки.Обработана = 1;
		
	КонецЕсли; 

КонецПроцедуры // ОтметитьТочкаОбработана()

// Процедура устанавливает в ТаблицеТочек признак СвязиОбработаны для данной точки.
// 
// Параметры:
//  ТаблицаТочек  - ТаблицаЗначений.
//  ТекущаяТочка  - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
Процедура ОтметитьСвязиОбработаны(ТаблицаТочек,ТекущаяТочка)
	
	ТекущаяСтрокаТочки = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");
	Если НЕ ТекущаяСтрокаТочки = Неопределено Тогда
		
		ТекущаяСтрокаТочки.СвязиОбработаны = 1;
		
	КонецЕсли; 

КонецПроцедуры // ОтметитьТочкаОбработана()

// Функция формирует имя колонки ТаблицыПозиций.
// 
// Параметры:
//  Префикс  - Строка
//  Номер    - Число
// 
// Возвращаемое значение:
//   ИмяКолонки   - Строка
// 
Функция СформироватьИмяКолонкиПозиций(Префикс,Номер)

	ИмяКолонки = Префикс+"_"+Формат(Номер,"ЧГ=");

	Возврат ИмяКолонки;
	
КонецФункции // СформироватьИмяКолонкиПозиций()

// Процедура размещает ТочкуСтарта в ТаблицеПозиций.
// 
// Параметры:
//  ТаблицаТочек    - ТаблицаЗначений.
//  ТаблицаПозиций  - ТаблицаЗначений.
//  Позиции         - Соответствие.
// 
Функция РасположитьТочкуСтарта(ТаблицаТочек,ТаблицаПозиций,Позиции)

	ТекущаяТочка = Неопределено;
	
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("ВидТочки",Перечисления.бит_уп_ВидыТочекАлгоритмов.Старт);
	
	МассивСтрок = ТаблицаТочек.НайтиСтроки(СтрОтбор);
	
	Если МассивСтрок.Количество()>0 Тогда
		
		ТекущаяСтрокаТочки = МассивСтрок[0];
		
		ТекущаяТочка       = ТекущаяСтрокаТочки.Точка;
		
		ИмяКолонки = СформироватьИмяКолонкиПозиций("П",ТаблицаПозиций.Колонки.Количество());
		ТаблицаПозиций.Колонки.Добавить(ИмяКолонки);
		ТекущаяСтрокаПозиции             = ТаблицаПозиций.Добавить();
		ТекущаяСтрокаПозиции[ИмяКолонки] = ТекущаяТочка; 
		
		ТекущаяСтрокаТочки.Обработана = 1;
		
		Позиция = СформироватьСтруктуруПозиция(ИмяКолонки,ТекущаяСтрокаПозиции);
		Позиции.Вставить(ТекущаяТочка,Позиция);
		
	КонецЕсли; 
	
	Возврат ТекущаяТочка;

КонецФункции // РасположитьТочкуСтарта()

// Функция размещает исходящие горизонтальные точки для данной точки алгоритма.
// 
// Параметры:
//  ТаблицаТочек    - ТаблицаЗначений.
//  ТаблицаПозиций  - ТаблицаЗначений.
//  Позиции         - Соответствие.
//  ТекущаяТочка    - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
// Возвращаемое значение:
//   ТочкаИсходящаяГор   - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
Функция РасположитьИсходящиеГоризонтальные(ТаблицаТочек,ТаблицаПозиций,Позиции,ТекущаяТочка)

	ТочкаИсходящаяГор = Неопределено;
	
	СтрОтборИсходящие = Новый Структура;
	СтрОтборИсходящие.Вставить("Направление",Перечисления.бит_уп_Направление.Горизонталь);
	
	МассивСтрокИсходящие = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтборИсходящие);
	
	Если МассивСтрокИсходящие.Количество()>0 Тогда
		
		// Исходящая по горизонтали может быть только одна.
		ТочкаИсходящаяГор = МассивСтрокИсходящие[0].Точка;
		
		// Проверим, что ТочкаИсходящаяГор не отрисована.
		Если Позиции[ТочкаИсходящаяГор] = Неопределено Тогда
			
			ПозицияТекущаяТочка  = Позиции[ТекущаяТочка];
			// Проверим, что ТекущаяТочка отрисована
			Если НЕ ПозицияТекущаяТочка  = Неопределено Тогда
				
				КолонкиПозиции            = ТаблицаПозиций.Колонки;
				КолонкаТекущаяТочка       = КолонкиПозиции[ПозицияТекущаяТочка.ИмяКолонки];
				ИндексКолонкиТекущаяТочка = КолонкиПозиции.Индекс(КолонкаТекущаяТочка);
				
				КоличествоКолонокПозиции  = КолонкиПозиции.Количество();				
				ИмяКолонки   = СформироватьИмяКолонкиПозиций("П",КоличествоКолонокПозиции);
				
				// Если колонка последняя - добавляем, иначе вставляем в следующую позицию.
				Если ИндексКолонкиТекущаяТочка = КоличествоКолонокПозиции-1  Тогда
					НоваяКолонка = ТаблицаПозиций.Колонки.Добавить(ИмяКолонки);
				Иначе	
					НоваяКолонка = ТаблицаПозиций.Колонки.Вставить(ИндексКолонкиТекущаяТочка+1,ИмяКолонки);
				КонецЕсли; 
				
				ТекущаяСтрокаПозиции = ПозицияТекущаяТочка.Строка;
				
				ТекущаяСтрокаПозиции[ИмяКолонки] = ТочкаИсходящаяГор;
				
				Позиция = СформироватьСтруктуруПозиция(ИмяКолонки,ТекущаяСтрокаПозиции);
				Позиции.Вставить(ТочкаИсходящаяГор,Позиция);
				
				ОтметитьТочкаОбработана(ТаблицаТочек,ТочкаИсходящаяГор);
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЕсли; // Нашли исходящие точки по горизонтали
	
	Возврат ТочкаИсходящаяГор;
	
КонецФункции // РасположитьИсходящиеГоризонтальные()

// Функция размещает исходящие вертикальные точки для данной точки алгоритма.
// 
// Параметры:
//  ТаблицаТочек    - ТаблицаЗначений.
//  ТаблицаПозиций  - ТаблицаЗначений.
//  Позиции         - Соответствие.
//  ТекущаяТочка    - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
// Возвращаемое значение:
//   ТочкаИсходящаяГор   - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
Функция РасположитьИсходящиеВертикальные(ТаблицаТочек,ТаблицаПозиций,Позиции,ТекущаяТочка)
	
	ТочкаИсходящаяВертПервая = Неопределено;
	
	СтрОтборИсходящие = Новый Структура;
	СтрОтборИсходящие.Вставить("Направление",Перечисления.бит_уп_Направление.Вертикаль);
	
	МассивСтрокИсходящие = ТекущаяТочка.ИсходящиеТочки.НайтиСтроки(СтрОтборИсходящие);
	Если МассивСтрокИсходящие.Количество()>0 Тогда
		
		Ном = 1;
		ТочкаИсходящаяПред = Неопределено;		
		Для каждого СтрокаИсходящие Из МассивСтрокИсходящие Цикл
			
			ТочкаИсходящаяВерт = СтрокаИсходящие.Точка;
			
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-07-17 (#2971)
			//Позиция точки слияния должна определяться по самому длинному пути
			Если ТочкаИсходящаяВерт<>Неопределено Тогда 
				Если ТочкаИсходящаяВерт.ВидТочки = ПредопределенноеЗначение("Перечисление.бит_уп_ВидыТочекАлгоритмов.Слияние") Тогда 
					ЕстьНеобработанные = Ложь;
					
					Для Каждого пВхТочка Из ТочкаИсходящаяВерт.ВходящиеТочки Цикл 
						пНайденныеСтроки = ТаблицаТочек.НайтиСтроки(Новый Структура("Точка",пВхТочка.Точка));
						Если пНайденныеСтроки.Количество()>0 Тогда
							Если пНайденныеСтроки[0].Обработана = 0 Тогда 
								ЕстьНеобработанные = Истина;
							КонецЕсли;
						КонецЕсли;
							
					КонецЦикла;
					
					Если ЕстьНеобработанные Тогда 
						Продолжить;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-07-17 (#2971)
			
			ТекПозиция = Позиции[ТочкаИсходящаяВерт];
			
			Если ТекПозиция = Неопределено Тогда
				
				Если Ном = 1 Тогда
					
					ТочкаИсходящаяВертПервая = ТочкаИсходящаяВерт;
					// Первая - вертикально
					ПозицияТекущаяТочка = Позиции[ТекущаяТочка];
					Если НЕ ПозицияТекущаяТочка = Неопределено Тогда
						
						КоличествоСтрокПозиции = ТаблицаПозиций.Количество();
						ИндексТекТочка         = ТаблицаПозиций.Индекс(ПозицияТекущаяТочка.Строка);
						Если ИндексТекТочка = КоличествоСтрокПозиции-1 Тогда
							
							// Последняя строка
							ТекущаяСтрокаПозиции = ТаблицаПозиций.Добавить();
							
							
						Иначе	
							
							ТекущаяСтрокаПозиции = ТаблицаПозиций[ИндексТекТочка+1];	
							
						КонецЕсли; 
						
						ТекущаяСтрокаПозиции[ПозицияТекущаяТочка.ИмяКолонки] = ТочкаИсходящаяВерт;
						
						Позиция = СформироватьСтруктуруПозиция(ПозицияТекущаяТочка.ИмяКолонки,ТекущаяСтрокаПозиции);
						Позиции.Вставить(ТочкаИсходящаяВерт,Позиция);
						
						ОтметитьТочкаОбработана(ТаблицаТочек,ТочкаИсходящаяВерт);
						
					КонецЕсли; 
					
					
				Иначе	
					
					// Остальные в той же строке в других колонках.
					ПозицияПред = Позиции[ТочкаИсходящаяПред];
					
					КолонкиПозиции      = ТаблицаПозиций.Колонки;
					КолонкаТекущаяТочка = КолонкиПозиции[ПозицияПред.ИмяКолонки];
					
					КоличествоКолонокПозиции  = КолонкиПозиции.Количество();
					ИндексКолонкиТекущаяТочка = КолонкиПозиции.Индекс(КолонкаТекущаяТочка);
					
					КолКолонок   = КоличествоКолонокПозиции;
					ИмяКолонки   = "П_"+(КолКолонок);
					
					Если ИндексКолонкиТекущаяТочка = КоличествоКолонокПозиции-1  Тогда
						НоваяКолонка = ТаблицаПозиций.Колонки.Добавить(ИмяКолонки);
					Иначе	
						НоваяКолонка = ТаблицаПозиций.Колонки.Вставить(ИндексКолонкиТекущаяТочка+1,ИмяКолонки);
					КонецЕсли; 
					
					Если ТекущаяСтрокаПозиции = Неопределено Тогда
					
						ТекущаяСтрокаПозиции = ТаблицаПозиций.Добавить();
					
					КонецЕсли; 					
					
					ТекущаяСтрокаПозиции[ИмяКолонки] = ТочкаИсходящаяВерт;
					
					Позиция = СформироватьСтруктуруПозиция(ИмяКолонки,ТекущаяСтрокаПозиции);
					Позиции.Вставить(ТочкаИсходящаяВерт,Позиция);
					
					ОтметитьТочкаОбработана(ТаблицаТочек,ТочкаИсходящаяВерт);
					
					
				КонецЕсли; 
				
			КонецЕсли; 
			
			ТочкаИсходящаяПред = ТочкаИсходящаяВерт;
			Ном = Ном+1;
		КонецЦикла; // По исходящим точкам
		
		
	КонецЕсли; // Есть исходящие вертикальные
	
	Возврат ТочкаИсходящаяВертПервая;
	
КонецФункции // РасположитьИсходящиеВертикальные()

// Функция выполняет поиск в ТаблицеТочек размещенную точку с необработанными связями.
// 
// Параметры:
//  ТаблицаТочек    - ТаблицаЗначений.
// 
// Возвращаемое значение:
//   ТекущаяТочка   - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
Функция НайтиРазмещеннуюБезСвязей(ТаблицаТочек)

	ТекущаяТочка = Неопределено;
	
	// Найдем размещенные точки с необработанными связями.
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("Обработана",1);
	СтрОтбор.Вставить("СвязиОбработаны",0);
	
	МассивСтрок = ТаблицаТочек.НайтиСтроки(СтрОтбор);
	
	Если МассивСтрок.Количество()>0 Тогда
		
		ТекущаяТочка       = МассивСтрок[0].Точка;
		
	КонецЕсли; 

	Возврат ТекущаяТочка;
	
КонецФункции // НайтиРазмещеннуюНеотрисованную()

// Функция выполняет поиск в ТаблицеТочек неразмещенных точек.
// 
// Параметры:
//  ТаблицаТочек    - ТаблицаЗначений.
//  ТаблицаПозиций  - ТаблицаЗначений.
//  Позиции         - Соответствие.
//  РасположениеНеразмещенных - Строка - "Вертикальное","Горизонтальное".
// 
// Возвращаемое значение:
//   ТекущаяТочка   - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
// 
Функция НайтиНеразмещенную(ТаблицаТочек,ТаблицаПозиций,Позиции,РазмещениеСвободныхТочек)

	ТекущаяТочка = Неопределено;
	
	СтрОтбор = Новый Структура;
	СтрОтбор.Вставить("Обработана"        ,0);
	СтрОтбор.Вставить("КоличествоВходящих",0);
	
	МассивСтрок = ТаблицаТочек.НайтиСтроки(СтрОтбор);
	
	Если МассивСтрок.Количество() = 0 Тогда
		
		СтрОтбор = Новый Структура;
		СтрОтбор.Вставить("Обработана",0);
		
		МассивСтрок = ТаблицаТочек.НайтиСтроки(СтрОтбор);
		
	КонецЕсли; 
	
	Если МассивСтрок.Количество()>0 Тогда
		
		ТекущаяСтрока      = МассивСтрок[0];
		ТекущаяТочка       = ТекущаяСтрока.Точка;
		
		Если РазмещениеСвободныхТочек = Перечисления.бит_уп_Направление.Горизонталь Тогда
			ТекущаяСтрокаПозиции = ТаблицаПозиций[0];
			ИмяКолонки           = СформироватьИмяКолонкиПозиций("П",ТаблицаПозиций.Колонки.Количество());
			ТекущаяКолонкаПозици = ТаблицаПозиций.Колонки.Добавить(ИмяКолонки);
		Иначе
			ТекущаяСтрокаПозиции = ТаблицаПозиций.Добавить();			
			Если ТаблицаПозиций.Колонки.Количество() >0 Тогда
				ТекущаяКолонкаПозици = ТаблицаПозиций.Колонки[0];
			Иначе	
				ИмяКолонки           = СформироватьИмяКолонкиПозиций("П",ТаблицаПозиций.Колонки.Количество());
				ТекущаяКолонкаПозици = ТаблицаПозиций.Колонки.Добавить(ИмяКолонки);
			КонецЕсли; 
		КонецЕсли; 
		
		
		Если ЗначениеЗаполнено(ТекущаяТочка) Тогда
			
			ТекущаяСтрокаПозиции[ТекущаяКолонкаПозици.Имя] = ТекущаяТочка;			
			
			Позиция = СформироватьСтруктуруПозиция(ТекущаяКолонкаПозици.Имя,ТекущаяСтрокаПозиции);
			Позиции.Вставить(ТекущаяТочка,Позиция);
			
			ОтметитьТочкаОбработана(ТаблицаТочек,ТекущаяТочка);
			
		Иначе	
			
			// Точка алгоритма может быть не заполнена в случае визирования,
			// когда выводится виза не включенная в алгоритм.
			// В этом случае эмулируем структурой точку алгоритма.
			Эмулятор = Новый Структура;
			Эмулятор.Вставить("Ссылка"      ,Справочники.бит_уп_ТочкиАлгоритмов.ПустаяСсылка());
			Эмулятор.Вставить("Наименование",Строка(ТекущаяСтрока.Виза));
			Эмулятор.Вставить("Решение"     ,ТекущаяСтрока.Решение);			 
			Эмулятор.Вставить("ВидТочки"    ,Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие);
			Эмулятор.Вставить("ИД"          ,ТекущаяСтрока.ИД);
			
			ТекущаяСтрокаПозиции[ТекущаяКолонкаПозици.Имя] = Эмулятор;			
			
			Позиция = СформироватьСтруктуруПозиция(ТекущаяКолонкаПозици.Имя,ТекущаяСтрокаПозиции);
			Позиции.Вставить(Эмулятор,Позиция);
			
			ТекущаяСтрокаТочки = ТаблицаТочек.Найти(ТекущаяСтрока.ИД,"ИД");
			Если НЕ ТекущаяСтрокаТочки = Неопределено Тогда
				
				ТекущаяСтрокаТочки.Обработана = 1;
				ТекущаяСтрокаТочки.СвязиОбработаны = 1;
				
			КонецЕсли; 
			ТекущаяТочка = Неопределено;
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат ТекущаяТочка;
	
КонецФункции // НайтиНеразмещенную()

// Процедура проверяет приняты ли решения по вышестоящим точкам действия. Рекурсивный вызов.
// 
// Параметры:
//  ТаблицаТочек    - ТаблицаЗначений.
//  ТочкаНачальная  - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//  Заполнены       - Булево.
//  Режим           - Строка.
//  УровеньРекурсии - Число.
// 
Процедура ПроверитьВышестоящиеТочки(ТаблицаТочек,ТочкаНачальная,УсловиеВыполнено,Режим,УровеньРекурсии)
	
	Если УровеньРекурсии > 1000 Тогда
		
		ТекстСообщения = НСтр("ru = 'Превышен уровень рекурсии при проверке заполнения вышестоящих точек алгоритма.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		Возврат;
		
	КонецЕсли;	
	
	СтрокаТаблицыНачальная = ТаблицаТочек.Найти(ТочкаНачальная,"Точка");
	Если СтрокаТаблицыНачальная = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ВходящиеТочки = СтрокаТаблицыНачальная.ВходящиеТочки;
	
	флЕстьНеЗаполненныеРешения = Ложь;
	КолТочДействия       = 0;
	КолТочДействияБезВиз = 0;
	
	РешениеСогласовано = Справочники.бит_ВидыРешенийСогласования.Согласовано;
	
	Для Каждого СтрокаВходящие ИЗ ВходящиеТочки Цикл
		
		Если ЭтоДействие(СтрокаВходящие.ВидТочки) Тогда
			
			// Проверим принято решение в данной точке или нет.
			СтрокаТаблицы = ТаблицаТочек.Найти(СтрокаВходящие.Точка,"Точка");
			Если НЕ СтрокаТаблицы = Неопределено Тогда
				
				Если ВРег(Режим) = ВРег("ЗаполненоРешение") ИЛИ ВРег(Режим) = ВРег("ЗаполненоРешениеВиза") Тогда
					
					КолТочДействия = КолТочДействия + 1;
					
					Если НЕ ЗначениеЗаполнено(СтрокаТаблицы.Виза) Тогда
						
						флЕстьТочкиБезВиз = Истина;
						
						КолТочДействияБезВиз = КолТочДействияБезВиз+1;
						
					КонецЕсли; 
					
					Если НЕ ЗначениеЗаполнено(СтрокаТаблицы.Решение) И ЗначениеЗаполнено(СтрокаТаблицы.Виза) Тогда
						флЕстьНеЗаполненныеРешения = Истина;
					КонецЕсли; 
					
				ИначеЕсли ВРег(Режим) = ВРег("Согласовано") Тогда	
					
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-09-13 (#2873)
					//Если НЕ(СтрокаТаблицы.Решение = РешениеСогласовано) И ЗначениеЗаполнено(СтрокаТаблицы.Виза) Тогда
					//Заменено на:					
					ЕстьКолонкиПоСложнойВизе = ТаблицаТочек.Колонки.Найти("СложнаяВиза")<>Неопределено И 
											   ТаблицаТочек.Колонки.Найти("РешениеПоСложнойВизе")<>Неопределено;
											   
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-16 (#3393)
					ЕстьКолонкаНеОстанавливатьМаршрутПоОтклонено = ТаблицаТочек.Колонки.Найти("НеОстанавливатьМаршрутПоОтклонено")<>Неопределено;
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-16 (#3393)
											   
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-10-16 (#3393)
					//Если ((ЕстьКолонкиПоСложнойВизе И СтрокаТаблицы.СложнаяВиза И СтрокаТаблицы.РешениеПоСложнойВизе <> Справочники.бит_ВидыРешенийСогласования.Согласовано) ИЛИ
					//		СтрокаТаблицы.Решение <> Справочники.бит_ВидыРешенийСогласования.Согласовано) И 
					//Заменено на:
					Если ((ЕстьКолонкиПоСложнойВизе И 
								СтрокаТаблицы.СложнаяВиза И 
									СтрокаТаблицы.РешениеПоСложнойВизе <> Справочники.бит_ВидыРешенийСогласования.Согласовано И
									(НЕ ЕстьКолонкаНеОстанавливатьМаршрутПоОтклонено ИЛИ
										НЕ СтрокаТаблицы.НеОстанавливатьМаршрутПоОтклонено ИЛИ
								 			СтрокаТаблицы.РешениеПоСложнойВизе <> Справочники.бит_ВидыРешенийСогласования.Отклонено) 
						
						  ) ИЛИ
							СтрокаТаблицы.Решение <> Справочники.бит_ВидыРешенийСогласования.Согласовано
							И
							(НЕ ЕстьКолонкаНеОстанавливатьМаршрутПоОтклонено ИЛИ
								НЕ СтрокаТаблицы.НеОстанавливатьМаршрутПоОтклонено ИЛИ
								 СтрокаТаблицы.Решение <> Справочники.бит_ВидыРешенийСогласования.Отклонено)
						 ) И 						
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-10-16 (#3393)
							(ТаблицаТочек.Колонки.Найти("ДобавленаВручную")<>Неопределено И НЕ СтрокаТаблицы.ДобавленаВручную) И
						 	ЗначениеЗаполнено(СтрокаТаблицы.Виза) 
					Тогда
					//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-09-13 (#2873)							
						УсловиеВыполнено = Ложь;
						Прервать;
					КонецЕсли;
					
				ИначеЕсли ВРег(Режим) = ВРег("ЗадачиВыполнены") Тогда
					
					Если НЕ СтрокаТаблицы.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Выполнена 
						 И НЕ СтрокаТаблицы.Состояние = Справочники.бит_СтатусыОбъектов.Задача_Отменена Тогда
						
						УсловиеВыполнено = Ложь;
						Прервать;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли;	  
			
		Иначе
			
			ПроверитьВышестоящиеТочки(ТаблицаТочек,СтрокаВходящие.Точка,УсловиеВыполнено,Режим,УровеньРекурсии);
			
		КонецЕсли;	// Точка действия
	КонецЦикла;	// По входящим точкам
	
	Если УсловиеВыполнено Тогда
	
		Если ВРег(Режим) = ВРег("ЗаполненоРешение") ИЛИ ВРег(Режим) = ВРег("ЗаполненоРешениеВиза") Тогда
			Если флЕстьНеЗаполненныеРешения Тогда
				УсловиеВыполнено = Ложь;
			КонецЕсли;
			
			Если КолТочДействия > 0 И КолТочДействия = КолТочДействияБезВиз Тогда
				УсловиеВыполнено = Ложь;
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры	

// Процедура устанавливает признак ИсходящиеЗаполнены для вышестоящих точек.
// 
// Параметры:
//  ТочкаНачальная  - СправочникСсылка.бит_уп_ТочкиАлгоритмов.
//  ТаблицаТочек    - ТаблицаЗначений.
// 
Процедура ОтметитьВышестоящуюТочкуДействия(ТочкаНачальная,ТаблицаТочек)
	
	ТекущаяТочка = ТочкаНачальная;
	
	Пока НЕ ТекущаяТочка = Неопределено Цикл
		
		Если ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Действие
			ИЛИ ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.ПодчиненныйПроцесс Тогда
			
			СтрокаТаблицыТочек = ТаблицаТочек.Найти(ТекущаяТочка,"Точка");
			
			Если НЕ СтрокаТаблицыТочек = Неопределено Тогда
				
				СтрокаТаблицыТочек.ИсходящиеЗаполнены = Истина;
				
			КонецЕсли; 
			Прервать;
			
		ИначеЕсли ТекущаяТочка.ВидТочки = Перечисления.бит_уп_ВидыТочекАлгоритмов.Слияние Тогда
			
			Для каждого СтрокаВходящие Из ТекущаяТочка.ВходящиеТочки Цикл
				
				ОтметитьВышестоящуюТочкуДействия(СтрокаВходящие.Точка,ТаблицаТочек);
				
			КонецЦикла;  
			Прервать;
			
		Иначе
			
			Если ТекущаяТочка.ВходящиеТочки.Количество()>0 Тогда
				
				ТекущаяТочка = ТекущаяТочка.ВходящиеТочки[0].Точка;
				
			Иначе
				
				ТекущаяТочка = Неопределено;
				
			КонецЕсли;  
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	
КонецПроцедуры // ОтметитьВышестоящуюТочкуДействия()

#КонецОбласти
