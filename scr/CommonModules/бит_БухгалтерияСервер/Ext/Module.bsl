
#Область ПрограммныйИнтерфейс

#Область СвязиПолей

// Процедура устанавливает связи параметров выбора и связи по типу для субконто.
//  Вызов имеет смысл только в управляемых формах.
//
// Параметры:
//  Элементы			 - ВсеЭлементыФормы	 - Коллекция элементов настраиваемой формы.
//  ИмяСчета			 - Строка			 - Имя счета.
//  ИмяСубконто			 - Строка			 - Имя субконто.
//  КоличествоСубконто	 - Число			 - Количество субконто.
//  НачалоИмениЭлемента	 - Строка			 - Начало имени элемента управления,
//  			используется для установки связей в табличной части
//  ПутьТекущиеДанные	 - Строка			 - Путь к текущим данным.
//
Процедура УстановитьСвязиСубконто(Элементы
	                              ,ИмяСчета
								  ,ИмяСубконто
								  ,КоличествоСубконто
								  ,НачалоИмениЭлемента = ""
								  ,ПутьТекущиеДанные = "Объект")  Экспорт

	 Для Н = 1 По КоличествоСубконто Цикл
	 
	 	Имя     = НачалоИмениЭлемента+ИмяСубконто+Н;
		ИмяПред = ИмяСубконто+(Н-1);
		
		// Связи параметров выбора по владельцу между организацией и первым субконто, вторым субконто и первым субконто итд.
		Если Н = 1 Тогда
			
		Иначе
			
		  ПутьРеквизит = ПутьТекущиеДанные+"."+ИмяПред;	
		  бит_ОбщегоНазначенияКлиентСервер.УстановитьСвязьПараметраВыбораЭлемента(Элементы[Имя]
		                                                                         ,"Отбор.Владелец"
																				 ,ПутьРеквизит
																				 ,РежимИзмененияСвязанногоЗначения.НеИзменять);

		
		КонецЕсли; 
		
		// Связи по типу между счетом и субконто.
		ПутьСвязьПоТипу = ПутьТекущиеДанные+"."+ИмяСчета;
		Элементы[Имя].СвязьПоТипу = Новый СвязьПоТипу(ПутьСвязьПоТипу,Н)
	 
	 КонецЦикла; 
	

 КонецПроцедуры // УстановитьСвязиСубконто()
       
#КонецОбласти

// Процедура устанавливает оформление для полей субконто в строках табличной части.
//
// Параметры:
//  УсловноеОформление					 - УсловноеОформление	 - Условное оформление табличной части.
//  ИмяТабЧасти							 - Строка				 - ИмяТабличнойЧаси и ИмяТабличногоПоля, если имена совпадают.
//  ИмяСубконто							 - Строка				 - Имя полей субконто.
//  ИмяРеквизитаКоличество				 - Строка				 - имя реквизита таблицы, содержащего количество активных субконто.
//  КоличествоСубконто					 - Число				 - Количество субконто.
//  ЦветНеопределено					 - Цвет					 - цвет, устанавливаемый для недоступных субконто.
//  ЦветТекстаНеопределено				 - Цвет					 - цвет текста, устанавливаемый для недоступных субконто.
//  ТекстНеопределено					 - Строка				 - текст, устанавливаемый для недоступных субконто.
//  ИмяТабличногоПоля					 - Строка				 - ИмяТабличногоПоля, если оно отличается от имени табличной части.
//  ЕстьСоответствующийРеквизитОбъекта	 - Булево				 - Есть реквизит объекта.
//  СкрыватьСубконто					 - Булево				 - Скрывать субконто.
//
Процедура УстановитьОформлениеСубконтоТаблицы(УсловноеОформление
	                                            , ИмяТабЧасти
	                                            , ИмяСубконто
												, ИмяРеквизитаКоличество
												, КоличествоСубконто
												, Знач ЦветНеопределено       = Неопределено
												, Знач ЦветТекстаНеопределено = Неопределено
												, ТекстНеопределено           = "недоступно"
												, ИмяТабличногоПоля           = ""
												, ЕстьСоответствующийРеквизитОбъекта = Истина
												, СкрыватьСубконто = Ложь)  Экспорт
												
	Если ЦветНеопределено = Неопределено Тогда
		 
	   	// В обычном приложении цвета стиля устанавливаются некорретно на данной версии платформы	 
	   	// установим вручную.
	   	// ЦветНеопределено  = ЦветаСтиля.бит_ЦветНедоступногоПоля.
	   	ЦветНеопределено    = Новый Цвет(225,225,225);  	   
	 
	КонецЕсли; 											
	 
	Если ЦветТекстаНеопределено = Неопределено Тогда
		 
	   	// В обычном приложении цвета стиля устанавливаются некорретно на данной версии платформы	 
	   	// установим вручную. 
	   	// ЦветТекстаНеопределено = ЦветаСтиля.бит_ТекстНедоступнойНадписи.
		ЦветТекстаНеопределено = Новый Цвет(150,150,150); 	
	 
	КонецЕсли; 
	
	Счетчик = 0;
	
	Для Н = 1 По КоличествоСубконто Цикл
		 
		ЭлементУсловногоОформления = УсловноеОформление.Элементы.Вставить(Счетчик);
		Счетчик = Счетчик + 1;
		
		ЭлементУсловногоОформления.Представление = "Оформление субконто таблицы";
			 
		// Установим отбор для оформления.
		НачалоИмениПоОбъекту = ?(ЕстьСоответствующийРеквизитОбъекта, "Объект.", "");
		ИмяПоляКомпоновки = НачалоИмениПоОбъекту + ИмяТабЧасти + "." + ИмяРеквизитаКоличество;
		бит_ОбщегоНазначенияКлиентСервер.УстановитьОтборУСписка(ЭлементУсловногоОформления.Отбор
															   ,Новый ПолеКомпоновкиДанных(ИмяПоляКомпоновки)
															   ,Н
															   ,ВидСравненияКомпоновкиДанных.Меньше);
		
		
		ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона"  , ЦветНеопределено);
		ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветТекстаНеопределено);
		Если НЕ ПустаяСтрока(ТекстНеопределено) Тогда			
			ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", ТекстНеопределено);			
		КонецЕсли; 
		ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ТолькоПросмотр", Истина);
		
		Если СкрыватьСубконто Тогда
		 	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Видимость", Ложь);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ИмяТабличногоПоля) Тогда
			ИмяОформляемогоПоля = ИмяТабличногоПоля + ИмяСубконто + Н;
		Иначе	
			ИмяОформляемогоПоля = ИмяТабЧасти + ИмяСубконто + Н;
		КонецЕсли; 
		ПолеУсловногоОформления               = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
		ПолеУсловногоОформления.Поле 		  = Новый ПолеКомпоновкиДанных(ИмяОформляемогоПоля);
		ПолеУсловногоОформления.Использование = Истина;
	 
	КонецЦикла;    	
 
КонецПроцедуры // УстановитьОформлениеСубконтоТаблицы()

// Функция получает настройки субконто в зависимости от выбранного счета.
//
// Параметры:
//  Счет				 - ПланСчетовСсылка	 - План счетов.
//  КоличествоСубконто	 - Число			 - Количество субконто.
// 
// Возвращаемое значение:
//  НастройкиСубконто - СписокЗначений - Настройки субконто.
//
Функция ПолучитьНастройкиСубконто(Счет,КоличествоСубконто) Экспорт
	                             								   
	СтруктураЭлементы = Новый Структура; 	               
	НастройкиСубконто = Новый СписокЗначений;
	
	Если Счет <> Неопределено Тогда
        
        СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);	
		ЧислоАктивныхСубконто = СвСч.КоличествоСубконто;
	
		Для Сч = 1 По КоличествоСубконто Цикл
			                     			
			ЭлементНастроек = НастройкиСубконто.Добавить();
			
			Если Сч <= ЧислоАктивныхСубконто Тогда
				
				// Субконто используется
                ТипСубк = СвСч["ВидСубконто" + Сч + "ТипЗначения"];
				
				ЭлементНастроек.Значение      = ТипСубк;
                ЭлементНастроек.Представление = СвСч["ВидСубконто" + Сч + "Наименование"];
				ЭлементНастроек.Пометка       = Истина;
				
			Иначе
				
				// Субконто не используется на данном счете
				ЭлементНастроек.Значение      = Неопределено;
				ЭлементНастроек.Представление = " ";
				ЭлементНастроек.Пометка       = Ложь;
				
			КонецЕсли; 			
			
		КонецЦикла; // По субконто
	
	КонецЕсли;

	Возврат НастройкиСубконто;
	
КонецФункции // ПолучитьНастройкиСубконто()

// Процедура обрабатывает изменение субконто.
//
// Параметры:
//  Контейнер			 - Объект, СтрокаТабличнойЧасти	 - Контейнер для заполнения.
//  ИмяРеквизита		 - Строка						 - Имя реквизита без номера, для перебора (Например: "Субконто" + i).
//  ЗначениеСубконто	 - Ссылка						 - Ссылка на значение субконто.
//  КоличествоСубконто	 - Число						 - Количество субконто для перебора, по умолчанию 4.
//
Процедура ОбработатьИзменениеСубконто(Контейнер
									 ,ИмяРеквизита
									 ,ЗначениеСубконто									 
									 ,КоличествоСубконто) Экспорт
									 
	
	Если ТипЗнч(ЗначениеСубконто) = Тип("СправочникСсылка.Контрагенты") Тогда

        ТипДоговор = Тип("СправочникСсылка.ДоговорыКонтрагентов");
        
        Для Ном = 1 ПО КоличествоСубконто Цикл
            
            ПолноеИмяРеквизита = ИмяРеквизита + Ном;
            ТекЗначение  	   = Контейнер[ПолноеИмяРеквизита];
            
            Если ТипЗнч(ТекЗначение) = ТипДоговор Тогда
                
                Если ЗначениеЗаполнено(ТекЗначение) Тогда
                    
                    // Если владельца изменили, очищаем договор
                    Если НЕ (ТекЗначение.Владелец = ЗначениеСубконто) Тогда
                        Контейнер[ПолноеИмяРеквизита] = Справочники.ДоговорыКонтрагентов.ПустаяСсылка();
                    КонецЕсли;
                    
                КонецЕсли;
                
            КонецЕсли;
            
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(ЗначениеСубконто) = Тип("СправочникСсылка.ДоговорыКонтрагентов") Тогда    
		
		// Если договор контрагента заполнен
		Если ЗначениеЗаполнено(ЗначениеСубконто) 
			// И не заполнен контрагент, тогда
			И Не ЗначениеЗаполнено(ПолучитьЗначениеСубконтоПоТипуВСтрокеТЧ(Контейнер, ИмяРеквизита, "Контрагенты")) Тогда
			
			ТипКонтрагент = Тип("СправочникСсылка.Контрагенты");
			
			Для Ном = 1 ПО КоличествоСубконто Цикл
				
				ПолноеИмяРеквизита = ИмяРеквизита + Ном;
				ТекЗначение  	   = Контейнер[ПолноеИмяРеквизита];
				
				Если ТипЗнч(ТекЗначение) = ТипКонтрагент Тогда
					Контейнер[ПолноеИмяРеквизита] = ЗначениеСубконто.Владелец;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
    КонецЕсли;
	
КонецПроцедуры // ОбработатьИзменениеСубконто()

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область УсловноеОформление

// Процедура устанавливает оформление для реквизитов в строках табличной части.
// 
// Параметры:
//  УсловноеОформление      - УсловноеОформление.
//  ИмяТабЧасти 		    - Строка.
//  ИмяПризнака    			- Строка.
//  СтруктураОформления     - Структура.
//  МассивОформляемыхПолей 	- Массив.
//  Представление			- Строка.
// 
Процедура УстановитьОформлениеПолейПоПризнаку(УсловноеОформление 
											 ,ИмяТабЧасти 
											 ,ИмяПризнака 
											 ,СтруктураОформления 
											 ,МассивОформляемыхПолей
											 ,Представление
											 ,ЕстьСоответствующийРеквизитОбъекта = Истина)  Экспорт
												
	// Структура условия		
	НачалоИмениПоОбъекту = ?(ЕстьСоответствующийРеквизитОбъекта, "Объект.", "");
	ИмяПоляКомпоновки = НачалоИмениПоОбъекту + ИмяТабЧасти + "." + ИмяПризнака;
	СтруктураУсловия = Новый Структура("УсловиеЛевое, УсловиеПравое"
										,Новый ПолеКомпоновкиДанных(ИмяПоляКомпоновки)
										,Ложь);
										
	// Структура условного оформления	
	СтруктураУО = Новый Структура("СтруктураОформления, СтруктураУсловия, МассивОформляемыхПолей" 
									,СтруктураОформления 
									,СтруктураУсловия
									,МассивОформляемыхПолей);	
									
	бит_РаботаСДиалогамиСервер.ДобавитьЭлементУсловногоОформления(УсловноеОформление, Представление, СтруктураУО, 0);
 
КонецПроцедуры // УстановитьОформлениеПолейПоПризнаку() 

// Процедура устанавливает оформление для реквизитов в строках табличной части.
// 
// Параметры:
//  ИмяТабЧасти 		    			- Строка - ИмяТабличнойЧаси и ИмяТабличногоПоля, если имена совпадают.
//  Постфикс                			- Строка.
//  ИмяТабличногоПоля       			- Строка - ИмяТабличногоПоля, если оно отличается от имени табличной части.
//  СтруктураПризнаков      			- Структура.
//  ЕстьСоответствующийРеквизитОбъекта  - Булево.
// 
Процедура УстановитьОформлениеПолейПоСчету(УсловноеОформление
											,ИмяТабЧасти 
											,Постфикс = "" 
											,ИмяТабличногоПоля = ""
											,СтруктураПризнаков = Неопределено
											,ЕстьСоответствующийРеквизитОбъекта = Истина)  Экспорт
												
	// Представление
	Представление = "Оформление полей по счету";
		    		
	ПрефексИмени = ?(ЗначениеЗаполнено(ИмяТабличногоПоля), ИмяТабличногоПоля, ИмяТабЧасти);
	ИмяСчета 	 = "Счет" + Постфикс;
	
	// Структура оформления
	СтруктураОформления = Новый Структура("ТолькоПросмотр", Истина);
										
	// Структура признаков и массивов оформляемых полей.
	Если СтруктураПризнаков = Неопределено Тогда
											
		СтруктураПризнаков = Новый Структура;
		
		// По валютному признаку
		МассивОформляемыхПолей = Новый Массив;
		МассивОформляемыхПолей.Добавить(ПрефексИмени + "Валюта" + Постфикс);
		МассивОформляемыхПолей.Добавить(ПрефексИмени + "ВалютнаяСумма" + Постфикс);
		СтруктураПризнаков.Вставить(ИмяСчета + "Валютный", МассивОформляемыхПолей);
		
		// По количественному признаку
		МассивОформляемыхПолей = Новый Массив;
		МассивОформляемыхПолей.Добавить(ПрефексИмени + "Количество" + Постфикс);
		СтруктураПризнаков.Вставить(ИмяСчета + "Количественный", МассивОформляемыхПолей);
		
		// По признаку учета по подразделениям.  			
		МассивОформляемыхПолей = Новый Массив;
		МассивОформляемыхПолей.Добавить(ПрефексИмени + "Подразделение" + Постфикс);
		СтруктураПризнаков.Вставить(ИмяСчета + "УчетПоПодразделениям", МассивОформляемыхПолей);

	КонецЕсли; 								
	
	Для каждого КлЗнч Из СтруктураПризнаков Цикл
		ИмяПризнака 		   = КлЗнч.Ключ;
		МассивОформляемыхПолей = КлЗнч.Значение;
	    // Установка оформления.
		УстановитьОформлениеПолейПоПризнаку(УсловноеОформление 
											,ИмяТабЧасти 
											,ИмяПризнака 
											,СтруктураОформления 
											,МассивОформляемыхПолей
											,Представление
											,ЕстьСоответствующийРеквизитОбъекта);
	КонецЦикла;

КонецПроцедуры // УстановитьОформлениеПолейПоСчету()

#КонецОбласти

#Область ПрочиеМетоды

// Функция проверяет возможность использования счета в проводках.
// 
// Параметры:
//  Счет     - Проверяемый счет.
//  Сообщать - признак вывода сообщений.
// 
// Возвращаемое значение:
//  Булево - возможность использования счета в проводках.
//  
Функция СчетМожноИспользоватьВПроводках(Счет, Сообщать = Истина) Экспорт

	Если ТипЗнч(Счет) <> Тип("ПланСчетовСсылка.Хозрасчетный") Тогда
		Возврат Ложь; // Неправильный тип
	КонецЕсли;

	Если Счет = ПланыСчетов.Хозрасчетный.ПустаяСсылка() Тогда
		Возврат Истина; // Пустая ссылка может использоваться
	КонецЕсли;

    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
	Если СвСч.ЗапретитьИспользоватьВПроводках Тогда

		Если Сообщать Тогда
			ТекстСообщения = "Счет " + СокрЛП(Счет)+" """ + СвСч.Наименование + """ нельзя использовать в проводках.";
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
		КонецЕсли;

		Возврат Ложь; // Счет использовать в проводках нельзя

	КонецЕсли;

	Возврат Истина; // Счет можно использовать в проводках 

КонецФункции // СчетМожноИспользоватьВПроводках()

// Функция получает значение субконто в текущей строке по типу.
// 
// Параметры:
//  ТекущаяСтрока - СтрокаТабличнойЧасти.
//  ИмяРеквизита  - Строка, имя реквизита без номера, для перебора (Например: "Субконто" + i).
//  ИмяОбъекта    - Строка, имя объекта конфигурации, к которому относиться элемент.
// 
//  КоличествоСубконто - Номер , количество субконто для перебора, по умолчанию 4.
//  ПрефиксТипа	  	   - Строка, по умолчанию "СправочникСсылка".
// 
//  ВозвратитьНомер - Булево, признак возврата значения и номера субконто, по умолчанию Ложь.
// 
Функция ПолучитьЗначениеСубконтоПоТипуВСтрокеТЧ(ТекущаяСтрока
											   ,ИмяРеквизита
											   ,ИмяОбъекта
											   ,КоличествоСубконто = 4
											   ,ПрефиксТипа = "СправочникСсылка"
											   ,ВозвратитьНомер = Ложь) Экспорт

    ТипЗначения = Тип(ПрефиксТипа + "." + ИмяОбъекта);
    
    Для Ном = 1 ПО КоличествоСубконто Цикл
        
        ТекЗначение = ТекущаяСтрока[ИмяРеквизита + Ном];
        
		Если ТипЗнч(ТекЗначение) = ТипЗначения Тогда
			
			Если ВозвратитьНомер Тогда
				Возврат Новый Структура("Значение, Номер", ТекЗначение, Ном);
			Иначе
				Возврат ТекЗначение;
			КонецЕсли;
			
        КонецЕсли;
        
    КонецЦикла;
	
	Если ВозвратитьНомер Тогда
		Возврат Новый Структура("Значение, Номер");
	Иначе
		Возврат Неопределено;
	КонецЕсли;
		
КонецФункции // ПолучитьЗначениеСубконтоПоТипуВСтрокеТЧ()

// Процедура устанавливает субконто на счете. Если такое субконто на счете отсутствует, 
// то ничего не делается. 
// 
// Параметры:
// 	Счет - Счет, к которому относится субконто.
//  Субконто          - набор субконто.
// 	ИмяСубконто       - Номер или имя установливаемого субконто.
//  Значение субконто - значение устанавливаемого субконто.
// 
Процедура УстановитьСубконто(Счет
	                         , Субконто
							 , ИмяСубконто
							 , ЗначениеСубконто
							 , Сообщать = Ложь
							 , Заголовок = ""
							 , ВидыСубконтоСчета = Неопределено) Экспорт

	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;

    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
    //Если ВидыСубконтоСчета = Неопределено Тогда
    //     ВидыСубконтоСчета = Счет.ВидыСубконто;
    //КонецЕсли; 
	
	Если ТипЗнч(ИмяСубконто) = Тип("Число") Тогда

		//Если ИмяСубконто > ВидыСубконтоСчета.Количество() Тогда
        Если ИмяСубконто > СвСч.КоличествоСубконто Тогда
			Возврат;
		КонецЕсли;

		//ВидСубк = ВидыСубконтоСчета[ИмяСубконто - 1].ВидСубконто;
        ВидСубк = СвСч["ВидСубконто" + ИмяСубконто];

	Иначе

        Если ВидыСубконтоСчета = Неопределено Тогда
	        ВидыСубконтоСчета = Счет.ВидыСубконто;
	    КонецЕсли;
		ВидСубк = ПланыВидовХарактеристик[Счет.Метаданные().ВидыСубконто.Имя][ИмяСубконто];

		Если ВидыСубконтоСчета.Найти(ВидСубк) = Неопределено Тогда
			Если Сообщать тогда
				бит_ОбщегоНазначения.СообщитьОбОшибке("Вид субконто <" + ВидСубк + "> для счета """+СвСч.Код +" ("+СвСч.Наименование+")"" не определен.",, Заголовок );
			КонецЕсли;
			Возврат;
		КонецЕсли;

	КонецЕсли;

	Если ВидСубк.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубк, ЗначениеСубконто);
	ИначеЕсли Сообщать тогда
		бит_ОбщегоНазначения.СообщитьОбОшибке("Неверное значение """ + ЗначениеСубконто + """ для вида субконто <" + ВидСубк + ">",, Заголовок);
	КонецЕсли;

КонецПроцедуры // УстановитьСубконто()

// Процедура устанавливает настройки элементов управления шапки связанных с субконто.
// 
// Параметры:
//  Элементы           - ВсеЭлементыФормы.
//  НастройкиСубконто  - СписокЗначений.
//  ИмяЭлемента        - Строка.
// 
Процедура УстановитьНастройкиЭлементов(Элементы, НастройкиСубконто, ИмяЭлемента, ОграничиватьТип = Ложь) Экспорт
	
	Ном = 1;
	Для каждого ЭлементНастроек Из НастройкиСубконто Цикл
		
		ТекИмяЭлемента = ИмяЭлемента+Ном;
		
		Элементы[ТекИмяЭлемента].Видимость      = ЭлементНастроек.Пометка;
		Элементы[ТекИмяЭлемента].Заголовок      = ЭлементНастроек.Представление;
		
		Если ОграничиватьТип И ТипЗнч(ЭлементНастроек.Значение) = Тип("ОписаниеТипов") Тогда
			
			Элементы[ТекИмяЭлемента].ОграничениеТипа  = ЭлементНастроек.Значение;
			
		КонецЕсли; 
		
		Ном = Ном+1;
	КонецЦикла; 

КонецПроцедуры // УстановитьНастройкиЭлементов()

// Процедура проверять соотвествие аналитики установленной организации.
// 
// Параметры:
//  Контейнер   - Произвольный.
//  ИмяСубконто - Строка.
//  КоличествоСубконто - Число.
//  ТекстМестоположение- Строка.
// 
Процедура ПроверитьСоответствиеОрганизации(Контейнер,ИмяСубконто,КоличествоСубконто,ТекстМестоположение = "В документе") Экспорт

	МассивКонтроля = Новый Массив;
	
	Для Н = 1 По КоличествоСубконто Цикл
		МассивКонтроля.Добавить(ИмяСубконто + Н);
	КонецЦикла;
	
	Текст_ИзменениеОрганизации = "Изменение значения реквизита Организация";
	
	Для Каждого ТекИмяРеквизита Из МассивКонтроля Цикл
		
		Если Метаданные.Справочники.Найти("ПодразделенияОрганизаций") <> Неопределено Тогда
			бит_ОбщегоНазначения.ПроверитьПринадлежностьАналитики(Контейнер
															 ,
															 , ТекИмяРеквизита
															 , "Владелец"
															 , "Организация"
															 , "СправочникСсылка.ПодразделенияОрганизаций"
															 , ТекстМестоположение
															 , Текст_ИзменениеОрганизации);
		КонецЕсли;
															 
		Если Метаданные.Справочники.Найти("БанковскиеСчета") <> Неопределено Тогда
			бит_ОбщегоНазначения.ПроверитьПринадлежностьАналитики(Контейнер
															 ,
															 ,ТекИмяРеквизита
															 , "Владелец"
															 , "Организация"
															 , "СправочникСсылка.БанковскиеСчета"
															 , ТекстМестоположение
															 , Текст_ИзменениеОрганизации);
		КонецЕсли;
		Если Метаданные.Справочники.Найти("БанковскиеСчетаОрганизаций") <> Неопределено Тогда
			бит_ОбщегоНазначения.ПроверитьПринадлежностьАналитики(Контейнер
															 ,
															 , ТекИмяРеквизита
															 , "Владелец"
															 , "Организация"
															 , "СправочникСсылка.БанковскиеСчетаОрганизаций"
															 , ТекстМестоположение
															 , Текст_ИзменениеОрганизации);
		КонецЕсли;												 
														 
		Если Метаданные.Справочники.Найти("ДоговорыКонтрагентов") <> Неопределено Тогда
			бит_ОбщегоНазначения.ПроверитьПринадлежностьАналитики(Контейнер
															 ,
															 , ТекИмяРеквизита
															 , "Организация"
															 , "Организация"
															 , "СправочникСсылка.ДоговорыКонтрагентов"
															 , ТекстМестоположение
															 , Текст_ИзменениеОрганизации);
		КонецЕсли;												 
															 
	КонецЦикла;

КонецПроцедуры // ПроверитьСоответствиеОрганизации()

// Процедура заполняет запись хозрасчетного регистра бухгалтерии.
// 
// Параметры:
//  Запись  		    - Запись регистра бухгалтерии.
//  СтруктураПараметров - Структура.
// 
Процедура ЗаполнитьЗаписьРегистраБУ(Запись, СтруктураПараметров) Экспорт
   		
	Запись.Организация = СтруктураПараметров.Организация;
	Запись.Период      = СтруктураПараметров.Период;
	
	Если СтруктураПараметров.Свойство("Активность") Тогда
		Запись.Активность  = СтруктураПараметров.Активность;
	Иначе
		Запись.Активность = Истина;
	КонецЕсли; 

	Если СтруктураПараметров.Свойство("Содержание") Тогда
		 Запись.Содержание = СтруктураПараметров.Содержание;
	КонецЕсли; 
	
	Запись.СчетДт = СтруктураПараметров.СчетДт;
	Запись.СчетКт = СтруктураПараметров.СчетКт;
	    
    СвСчДт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Запись.СчетДт);
    СвСчКт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Запись.СчетКт);
    
    Запись.Сумма  = СтруктураПараметров.Сумма;
    
	Если СвСчДт.Валютный И СтруктураПараметров.Свойство("Валюта") Тогда
		Запись.ВалютаДт        = СтруктураПараметров.Валюта;
		Запись.ВалютнаяСуммаДт = СтруктураПараметров.Сумма;
	КонецЕсли; 
	
	Если СвСчКт.Валютный И СтруктураПараметров.Свойство("Валюта") Тогда
		Запись.ВалютаКт        = СтруктураПараметров.Валюта;
		Запись.ВалютнаяСуммаКт = СтруктураПараметров.Сумма;
	КонецЕсли; 

	Если СвСчДт.Количественный И СтруктураПараметров.Свойство("Количество")  Тогда
		Запись.КоличествоДт = СтруктураПараметров.Количество;
	КонецЕсли;
	
	Если СвСчКт.Количественный И СтруктураПараметров.Свойство("Количество")  Тогда
		Запись.КоличествоКт = СтруктураПараметров.Количество;
	КонецЕсли; 

КонецПроцедуры // ЗаполнитьЗаписьРегистраБУ()

// Процедура очищает движения по регистрам БИТ при копировании. 
//
// Параметры:
//  ТекущаяФорма - Управляемая форма.
//
Процедура ОперацияОчиститьДвиженияБит(ТекущаяФорма) Экспорт
	
	// Операция скопирована - необходимо удалить движения в регистрах БИТ.
	МассивРеквизитыФормы = ТекущаяФорма.ПолучитьРеквизиты();
	Для каждого ТекРеквизит Из МассивРеквизитыФормы Цикл
		
		Если бит_ОбщегоНазначенияКлиентСервер.ЭтоОбъектБИТ(ТекРеквизит.Имя) 
			И ТипЗнч(ТекущаяФорма[ТекРеквизит.Имя]) = Тип("ДанныеФормыСтруктураСКоллекцией") Тогда
			
			ТекущаяФорма[ТекРеквизит.Имя].Очистить();
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // ОперацияОчиститьДвиженияБит()

#КонецОбласти

#Область РегистрыБухгалтерии

// Заменяет пустые значения субконто, если это необходимо.
//
// Параметры:
//  ПроводкаСубконто 	  - РегистрБухгалтерииСубконто.
//  ВидыСоставныхСубконто - Соответствие.
//
Процедура КорректировкаПустыхЗначенийСубконто(ПроводкаСубконто, ВидыСоставныхСубконто) Экспорт

	// Приведение пустых значений субконто.
	Для Каждого Субконто Из ПроводкаСубконто Цикл
        
        // Кэширование: вид субконто + признак Состовной.
		Составной = ВидыСоставныхСубконто.Получить(Субконто.Ключ);           
		Если Составной = Неопределено Тогда                                   
			Составной = Субконто.Ключ.ТипЗначения.Типы().Количество() > 1;  
			ВидыСоставныхСубконто.Вставить(Субконто.Ключ,Составной);         
		КонецЕсли;                                                          
		 
		Если Составной Тогда
			// Приведение пустых значений субконто составного типа.
			Если НЕ ЗначениеЗаполнено(Субконто.Значение) И Субконто.Значение <> Неопределено Тогда
				ПроводкаСубконто.Вставить(Субконто.Ключ, Неопределено);
			КонецЕсли;
			
		// Добавление кода. Начало. 26.09.2016{{
		ИначеЕсли Субконто.Значение = Неопределено Тогда
			
			// Если тип не составной, то значение субконто не должно быть равно Неопределено
			ПустоеЗначение = Субконто.Ключ.ТипЗначения.ПривестиЗначение(Субконто.Значение);
			ПроводкаСубконто.Вставить(Субконто.Ключ, ПустоеЗначение);
		// Добавление кода. Конец. 26.09.2016}}
		
		КонецЕсли;
		
	КонецЦикла; 

КонецПроцедуры // КорректировкаПустыхЗначенийСубконто()

#КонецОбласти

#Область ЗаполнениеПлановСчетов

// Процедура заполняет план счетов по умолчанию.
// 
// Параметры:
//  ИмяПланаСчетов - Строка.
// 
Процедура ЗаполнитьПланСчетовПоУмолчанию(ИмяПланаСчетов, МассивСтрокИзЭксель=Неопределено) Экспорт

	СтруктураПараметров = ПолучитьДанныеПараметраКоманды(ИмяПланаСчетов);
	
	Если Не СтруктураПараметров.КомандаДоступна Тогда
	 	Возврат;	
	КонецЕсли;
		             	
	СинонимОбъекта  = СтруктураПараметров.СинонимОбъекта;
	ИмяВидаСубконто = СтруктураПараметров.ИмяВидаСубконто;
	
	Если бит_му_ОбщегоНазначения.ЭтоМеждународныйПланСчетовИлиРегистр(ИмяПланаСчетов) Тогда
		ИмяМакета = "СчетаПоУмолчаниюМСФО";	
	Иначе
		ИмяМакета = "СчетаПоУмолчанию";
	КонецЕсли;
	
	НачатьТранзакцию();
	
	// Заполним план счетов значениями из макета.
	Отказ = Ложь;
	ЗаполнитьПланСчетовИзМакета(ИмяПланаСчетов, ИмяВидаСубконто, ИмяМакета, "Ошибки", , , Отказ, СинонимОбъекта, МассивСтрокИзЭксель);														
	
	Если Отказ Тогда
		// Отменим транзакцию.
		ОтменитьТранзакцию();
	Иначе		
		// Зафиксируем транзакцию.
		ЗафиксироватьТранзакцию();
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьПланСчетовПоУмолчанию()

// Функция проверяет исторические курсы. 
//
Функция ЕстьИсторическиеКурсы(ИмяПланаСчетов) Экспорт

	ЕстьИстКурсы = Метаданные.ПланыСчетов[ИмяПланаСчетов].Реквизиты.Найти("ИспользоватьИсторическиеКурсы") <> Неопределено;
	Возврат ЕстьИстКурсы;	

КонецФункции // ЕстьИсторическиеКурсы()

// Функция получает данные по плану счетов. 
//
// Параметры:
//  ИмяПланаСчетов - Строка.
//
// Возвращаемое значение:
//   Массив.
// 
Функция ПолучитьДанныеПланаСчетов(ИмяПланаСчетов) Экспорт 

	ЕстьИстКурсы = ЕстьИсторическиеКурсы(ИмяПланаСчетов);
	
	Запрос = Новый Запрос;
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	ПланСчетов.Родитель.Код,
	|	ПланСчетов.Код,
	|	ПланСчетов.Порядок,
	|	ПланСчетов.Наименование,
	|	ПланСчетов.НаименованиеПолное,
	|	ПланСчетов.Вид,
	|	ВЫБОР
	|		КОГДА ПланСчетов.ЗапретитьИспользоватьВПроводках = ИСТИНА
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ НЕОПРЕДЕЛЕНО
	|	КОНЕЦ КАК Группа,
	|	ВЫБОР
	|		КОГДА ПланСчетов.Забалансовый = ИСТИНА
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ НЕОПРЕДЕЛЕНО
	|	КОНЕЦ КАК Забалансовый,
	|	ВЫБОР
	|		КОГДА ПланСчетов.Валютный = ИСТИНА
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ НЕОПРЕДЕЛЕНО
	|	КОНЕЦ КАК Валютный,
	|	ВЫБОР
	|		КОГДА ПланСчетов.Количественный = ИСТИНА
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ НЕОПРЕДЕЛЕНО
	|	КОНЕЦ КАК Количественный,
	|	ПланСчетов.ВидыСубконто.(
	|		ЕСТЬNULL(ПланСчетов.ВидыСубконто.НомерСтроки, НЕОПРЕДЕЛЕНО) КАК НомерСтроки,
	|		ЕСТЬNULL(ПланСчетов.ВидыСубконто.ТолькоОбороты, ЛОЖЬ) КАК ОбСубконто,
    //|		ВЫБОР
    //|			КОГДА ПланСчетов.ВидыСубконто.ВидСубконто.Предопределенный
    //|				ТОГДА ЕСТЬNULL(ПланСчетов.ВидыСубконто.ВидСубконто.ИмяПредопределенныхДанных, """")
    //|			ИНАЧЕ ЕСТЬNULL(ПланСчетов.ВидыСубконто.ВидСубконто.Наименование, """")
    //|		КОНЕЦ КАК Субконто
    |		ПланСчетов.ВидыСубконто.ВидСубконто.Наименование КАК Субконто
	|	)
	|ИЗ
	|	ПланСчетов.бит_Бюджетирование КАК ПланСчетов
	|
    |АВТОУПОРЯДОЧИВАНИЕ
	//|УПОРЯДОЧИТЬ ПО
	//|	ПланСчетов.Порядок
	|";
				                               
	Схема = Новый СхемаЗапроса;
	Схема.УстановитьТекстЗапроса(ТекстЗапроса);
	
	// Заменим имя плана счетов.
	ТаблицаСхемы = Схема.ПакетЗапросов[0].ДоступныеТаблицы.Найти("ПланСчетов." + ИмяПланаСчетов);
	схПакетЗапросов  = Схема.ПакетЗапросов[0];
	схОператоры 	 = схПакетЗапросов.Операторы[0];
	схКолонки 		 = схПакетЗапросов.Колонки;
	схВыбираемыеПоля = схОператоры.ВыбираемыеПоля;
	
	схОператоры.Источники.Заменить(0, ТаблицаСхемы);
	
	// Поле ИспользоватьИсторическиеКурсы
	Если ЕстьИстКурсы Тогда
		схВыбираемыеПоля.Добавить("ВЫБОР 
								  |		КОГДА " + ИмяПланаСчетов + ".ИспользоватьИсторическиеКурсы = ИСТИНА 
								  |			ТОГДА ИСТИНА 
							 	  |		ИНАЧЕ НЕОПРЕДЕЛЕНО 
								  |КОНЕЦ");
		схКолонка = схКолонки.Найти("Поле1");
		схКолонка.Псевдоним = "ИспользоватьИсторическиеКурсы";	
	КонецЕсли;
	
	Запрос.Текст = Схема.ПолучитьТекстЗапроса();
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	ПоляСтруктуры = бит_БухгалтерияКлиентСервер.ОпределитьСтрокуПолейПланаСчетов(ИмяПланаСчетов); 
    МассивДанных = Новый Массив;
	
	Пока Выборка.Следующий() Цикл
	
		СтруктураПолей = Новый Структура(ПоляСтруктуры);
		
		ТаблицаСубконто = Выборка.ВидыСубконто.Выгрузить();
		
		Для каждого стр Из ТаблицаСубконто Цикл
			
			Если стр.НомерСтроки <> Неопределено Тогда
			
				СтруктураПолей["Субконто"+стр.НомерСтроки] = стр.Субконто;
				
				Если стр.ОбСубконто Тогда
				
					СтруктураПолей["ОбСубконто"+стр.НомерСтроки] = стр.ОбСубконто;
				
				КонецЕсли; 
				
			КонецЕсли; 
			
		КонецЦикла; 
		
		ЗаполнитьЗначенияСвойств(СтруктураПолей, Выборка);
		Если СтруктураПолей.Вид = ВидСчета.Активный Тогда
			СтруктураПолей.Вид = "А";
		ИначеЕсли СтруктураПолей.Вид = ВидСчета.Пассивный Тогда
			СтруктураПолей.Вид = "П";
		Иначе	
			СтруктураПолей.Вид = "АП";
		КонецЕсли; 
		
		МассивДанных.Добавить(СтруктураПолей);
		
	КонецЦикла;
	
	Возврат МассивДанных;
	
КонецФункции // ПолучитьДанныеПланаСчетов()

// Функция формирует списки для выбора в Excel
//  для выгрузки планов счетов.
//
// Параметры:
//  ИмяПланаСчетов - строка.
//
// Возвращаемое значение:
//  Списки - Структура.
//
Функция СформироватьСпискиДляВыгрузкиПланаСчетов(ИмяПланаСчетов) Экспорт

	Списки = Новый Структура;
    
    Если ИмяПланаСчетов = "бит_Бюджетирование" Тогда
        ИмяПВХ = "бит_ВидыСубконтоБюджетирования";
    Иначе	
        ИмяПВХ = СтрЗаменить(ИмяПланаСчетов, "бит_Дополнительный", "бит_ВидыСубконтоДополнительные");
    КонецЕсли;
  
	
	МассивДаНет = Новый Массив;
	МассивДаНет.Добавить("Да");
	МассивДаНет.Добавить("Нет");
	Списки.Вставить("СписокДаНет", МассивДаНет);
	
	МассивВидСчета = Новый Массив;
	МассивВидСчета.Добавить("А");
	МассивВидСчета.Добавить("П");
	МассивВидСчета.Добавить("АП");
	Списки.Вставить("СписокВидСчета", МассивВидСчета);
	
	ИмяСубконто = Метаданные.ПланыСчетов[ИмяПланаСчетов].ВидыСубконто.Имя;
	
	Запрос = Новый Запрос;
	ТекстЗапроса = "
	|ВЫБРАТЬ
    //|	ВЫБОР
    //|		КОГДА ВидыСубконто.Предопределенный
    //|			ТОГДА ВидыСубконто.ИмяПредопределенныхДанных
    //|		ИНАЧЕ ВидыСубконто.Наименование
    //|	КОНЕЦ КАК Наименование,
    |	ВидыСубконто.Ссылка,
    |	ВидыСубконто.Код,
    |	ВидыСубконто.Наименование
	|ИЗ
	|	ПланВидовХарактеристик.бит_ВидыСубконтоБюджетирования КАК ВидыСубконто
	|";
	
	Схема = Новый СхемаЗапроса;
	Схема.УстановитьТекстЗапроса(ТекстЗапроса);
	
	// Заменим имя плана счетов.
	ТаблицаСхемы = Схема.ПакетЗапросов[0].ДоступныеТаблицы.Найти("ПланВидовХарактеристик."+ИмяСубконто);
	Схема.ПакетЗапросов[0].Операторы[0].Источники.Заменить(0, ТаблицаСхемы); 
	
	Запрос.Текст = Схема.ПолучитьТекстЗапроса();
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	//МассивСубконто = Новый Массив;
	//Пока Выборка.Следующий() Цикл	
	//	МассивСубконто.Добавить(Выборка.Наименование); 	
	//КонецЦикла;	
	//Списки.Вставить("СписокВидыСубконто", МассивСубконто);
    
    СписокВидыСубконто = Новый СписокЗначений;
    Пока Выборка.Следующий() Цикл
        СтрСсылка = "ПланВидовХарактеристик." + ИмяПВХ + "/" + Строка(Выборка.Ссылка.УникальныйИдентификатор());
		СписокВидыСубконто.Добавить(СтрСсылка, Выборка.Наименование); 	
	КонецЦикла;	
	Списки.Вставить("СписокВидыСубконто", СписокВидыСубконто);
	
	Возврат Списки;
	
КонецФункции // СформироватьСпискиДляВыгрузкиПланаСчетов()

#КонецОбласти

#Область ИнтерфейсыКМетодамТиповыхКонфигураций

// Получает счета расчетов с контрагентом.
// 
// Параметры:
//  Организация - СправочникСсылка.Организации.
//  Контрагент - СправочникСсылка.Контрагенты.
//  Договор - СправочникСсылка.ДоговорыКонтрагентов.
// 
// Возвращаемое значение:
//  СчетаУчета - Структура.
// 
Функция ПолучитьСчетаРасчетовСКонтрагентом(Организация, Контрагент, Договор) Экспорт

	СчетаУчета = Неопределено;
	
	Если бит_ОбщегоНазначения.ЭтоБухгалтерияПредприятия() 
		ИЛИ бит_ОбщегоНазначения.ЭтоERP()
		ИЛИ бит_ОбщегоНазначения.ЭтоКомплекснаяАвтоматизация()Тогда	
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("БухгалтерскийУчетПереопределяемый");
		СчетаУчета = Модуль.ПолучитьСчетаРасчетовСКонтрагентом(Организация, Контрагент, Договор);
		
	 ИначеЕсли бит_ОбщегоНазначения.ЭтоУТ() Тогда
		 
		 // Нет аналогов.
		
	КонецЕсли; 

	Возврат СчетаУчета;
	
КонецФункции // ПолучитьСчетаРасчетовСКонтрагентом()

// Производит замену субконто НУ на субконто БУ, если у них одинаковые типы.
// 
Процедура ЗаменитьСубконтоНУ(СчетБУ, СчетНУ, НомерСубконто, СубконтоБУ, СубконтоНУ) Экспорт
	
	Если бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
		
		Если НЕ ЗначениеЗаполнено(СчетБУ) ИЛИ НЕ ЗначениеЗаполнено(СчетНУ) Тогда			
			Возврат;			
		КонецЕсли;
        
        СвСчБУ = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетБУ);
	    СвСчНУ = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетНУ);
        
		Если СвСчНУ.КоличествоСубконто >= НомерСубконто Тогда
            
            Если СвСчБУ["ВидСубконто" + НомерСубконто + "ТипЗначения"] = 
				СвСчНУ["ВидСубконто" + НомерСубконто + "ТипЗначения"] Тогда
				
				СубконтоНУ = СубконтоБУ;
				
            КонецЕсли;
            
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ЗаменитьСубконтоНУ()

// Определяет применяется ли упрощенная система налогообложения.
// 
Функция ПрименяетсяУСН(Организация, Период) Экспорт
	
	Результат = Ложь;
	
	Если бит_ОбщегоНазначения.ЭтоСемействоБП() 
		ИЛИ бит_ОбщегоНазначения.ЭтоERP()
		ИЛИ бит_ОбщегоНазначения.ЭтоКомплекснаяАвтоматизация()Тогда	
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("УчетнаяПолитика");
		Результат = Модуль.ПрименяетсяУСН(Организация, Период);                
		
	ИначеЕсли бит_ОбщегоНазначения.ЭтоУТ() Тогда
		
	   // Нет НУ и УСН соответственно.
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПрименяетсяУСН()

// Определяет применяется ли упрощенная система налогообложения.
// 
Функция ПрименяетсяУСНДоходы(Организация, Период) Экспорт
	
	Результат = Ложь;
	
	Если бит_ОбщегоНазначения.ЭтоСемействоБП() 
		ИЛИ бит_ОбщегоНазначения.ЭтоERP()
		ИЛИ бит_ОбщегоНазначения.ЭтоКомплекснаяАвтоматизация()Тогда	
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("УчетнаяПолитика");
		Результат = Модуль.ПрименяетсяУСНДоходы(Организация, Период);                
		
	ИначеЕсли бит_ОбщегоНазначения.ЭтоУТ() Тогда
		
	   // Нет НУ и УСН соответственно.
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПрименяетсяУСНДоходы()

// Определяет, установлена ли поддержка ПБУ 18/02.
// 
// Параметры:
//  Организация  - Справочник.Ссылка - Организация, по которой
//                 определяется поддержка ПБУ 18/02.
//  Дата         - Дата - Дата, на которую получаются сведения.
// 
// Возвращаемое значение:
//  Булево.
// 
Функция ПоддержкаПБУ18(Организация, Период) Экспорт
	
	Результат = Ложь;
	
	Если бит_ОбщегоНазначения.ЭтоСемействоБП() 
		ИЛИ бит_ОбщегоНазначения.ЭтоERP()
		ИЛИ бит_ОбщегоНазначения.ЭтоКомплекснаяАвтоматизация()Тогда	
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("УчетнаяПолитика");
		Результат = Модуль.ПоддержкаПБУ18(Организация, Период);                
		
	ИначеЕсли бит_ОбщегоНазначения.ЭтоУТ() Тогда
		
	   // Нет НУ и ПБУ18 соответственно.		
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПоддержкаПБУ18()

// Возвращает числовое значение ставки НДС.
// 
// Параметры:
// СтавкаНДС - ПеречислениеСсылка.СтавкиНДС.
// 
// Возвращаемое значение:
// Результат - Число.
// 
Функция ПолучитьСтавкуНДС(СтавкаНДС) Экспорт

	// ++ БП 
	Результат = УчетНДСВызовСервераПовтИсп.ПолучитьСтавкуНДС(СтавкаНДС);
	// -- БП 
	
	Возврат Результат;
	
КонецФункции

// Функция выполняет проверку необходимости проведения документа по разделам учета.
// 
Функция ПроводитьДокументПоРазделуУчета(Организация, РазделУчета, Дата) Экспорт
	
	// Устарела. Удалить.
	Возврат Ложь;
	
КонецФункции

// Процедура выполняет общие действия при изменении контрагента.
// 
// Параметры:
//  ДокументОбъект - объект редактируемого документа.
// 
Процедура ПриИзмененииЗначенияКонтрагента(ДокументОбъект,СписокВидовДоговоров = Неопределено,СтруктураДополнительныхПараметров = Неопределено,
	                                      НаименованиеРеквизитаДоговора = "", НаименованиеРеквизитаКонтрагента = "") Экспорт

	// ++ БП 	
	ЗаполнениеДокументов.ПриИзмененииЗначенияКонтрагента(ДокументОбъект, СписокВидовДоговоров, 
			СтруктураДополнительныхПараметров, НаименованиеРеквизитаДоговора, НаименованиеРеквизитаКонтрагента);
	// -- БП 
										  
КонецПроцедуры

// Функция формирует сведения об указанном ЮрФизЛице. К сведениям относятся -
// наименование, адрес, номер телефона, банковские реквизиты.
// 
// Параметры: 
//  ЮрФизЛицо   - организация или физическое лицо, о котором собираются сведения.
//  ДатаПериода - дата, на которую выбираются сведения о ЮрФизЛице.
//  ДляФизЛицаТолькоИнициалы - Для физ. лица выводить только инициалы имени и отчества.
// 
// Возвращаемое значение:
//  Сведения - собранные сведения.
// 
Функция СведенияОЮрФизЛице(ЮрФизЛицо, ДатаПериода = '20200101', ДляФизЛицаТолькоИнициалы = Истина, БанковскийСчет = Неопределено) Экспорт
	
	// ++ БП 	
	//1c-izhtc spawn 06.08.15 (
	// ошибка типовой
	//Результат = БухгалтерскийУчетПереопределяемый.СведенияОЮрФизЛице(ЮрФизЛицо, ДатаПериода, ДляФизЛицаТолькоИнициалы, БанковскийСчет);                
	Результат = БухгалтерскийУчетПереопределяемый.СведенияОЮрФизЛице(ЮрФизЛицо, ДатаПериода, БанковскийСчет);                
	//1c-izhtc spawn 06.08.15 )	
	// -- БП 
	
	Возврат Результат;
	
КонецФункции

// Функция возвращает совокупность данных о физическом лице в виде структуры.
// В совокупность данных входит ФИО, должность в заданной организации,
// паспортные данные и др.
// 
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника.
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
//                 по которому возвращается совокупность данных.
//  ДатаСреза    - Дата - дата, на которую считываются данные.
//  ФИОКратко    - Булево (если Истина (по умолчанию), Представление физ.лица включает фамилию и инициал,
// 					если Ложь - фамилию и полностью имя и отчество).
// 
// Возвращаемое значение:
//  Структура    - Структура с совокупностью данных о физическом лице:
//                 - Фамилия.
//                 - Имя.
//                 - Отчество.
//                 - Представление (Фамилия И.О.).
//                 - Подразделение.
//                 - ВидДокумента.
//                 - Серия.
//                 - Номер.
//                 - ДатаВыдачи.
//                 - КемВыдан.
//                 - КодПодразделения.
// 
Функция ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза, ФИОКратко = Истина) Экспорт
	
	// ++ БП 
	Результат = ОбщегоНазначенияБПВызовСервера.ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза, ФИОКратко);
	// -- БП 
	
	Возврат Результат;
	
КонецФункции

// Функция возвращает вид расчетов по договору.
//
// Параметры
// 		ДоговорКонтрагента - СправочникСсылка.ДоговорыКонтрагентов.
// 
// Возвращаемое значение
//      ПеречислениеСсылка.ВидыРасчетовПоДоговорам.
// 
Функция ОпределениеВидаРасчетовПоПараметрамДоговора(ДоговорКонтрагента) Экспорт
	
	// ++ БП 
	Результат = БухгалтерскийУчетПереопределяемый.ОпределениеВидаРасчетовПоПараметрамДоговора(ДоговорКонтрагента);                
	// -- БП 
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция формирует структуру дополнительных параметров по метаданным плана счетов.
// 
// Параметры:
//  ПараметрКоманды  - ПланСчетовСсылка.
//  
// Возвращаемое значение:
//   Структура.
// 
Функция ПолучитьДанныеПараметраКоманды(ИмяПланаСчетов)

	СтруктураПараметров = Новый Структура;
	
	МетаданныеПС  = Метаданные.ПланыСчетов[ИмяПланаСчетов];
	
	Международный = бит_му_ОбщегоНазначения.ЭтоМеждународныйПланСчетовИлиРегистр(ИмяПланаСчетов);
	
	// Проверка доступности выполнения операции.
	Если РольДоступна(Метаданные.Роли.ПолныеПрава)
		 Или Международный И бит_му_ОбщегоНазначения.ДоступнаРольМуПолныеПрава()
		 Или Не Международный И РольДоступна(Метаданные.Роли.бит_ФинансистПолныеПрава) Тогда
		 		
		СтруктураПараметров.Вставить("КомандаДоступна", Истина);
		СтруктураПараметров.Вставить("ИмяПланаСчетов" , МетаданныеПС.Имя);
		СтруктураПараметров.Вставить("СинонимОбъекта" , бит_ПраваДоступа.ПолучитьСинонимОбъектаСистемы(МетаданныеПС));
		СтруктураПараметров.Вставить("ИмяВидаСубконто", МетаданныеПС.ВидыСубконто.Имя);
		
	Иначе     		
		                         		
		// Выполнение действия не доступно.
		СтруктураПараметров.Вставить("КомандаДоступна", Ложь);
		ТекстСообщения = Нстр("ru = 'Недостаточно прав.'");
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
					
	КонецЕсли;
	
	Возврат СтруктураПараметров;
	
КонецФункции // ПолучитьДанныеПараметраКоманды()

// Процедура заполняет план счетов по макету.
// 
// Параметры:
//  ИмяПланаСчетов  	 - Строка.
//  ИмяВидовСубконто	 - Строка.
//  ИмяМакета			 - Строка.
//  РежимСообщений		 - Строка: "Нет","Все","Ошибки".
//  РежимЗаполнения		 - Строка: "ИзменитьТолькоВидСчета", по умолчанию "".
//  УстанавливатьПометку - Булево - помечать на удаление счета, которых нет в макете.
//  Отказ				 - Булево (По умолчанию =Ложь).
//  СинонимПС			 - Строка - синоним плана счетов (По умолчанию = "").
//  МассивСтрокИзЭксель - Массив с данными для заполнения.
// 
Процедура ЗаполнитьПланСчетовИзМакета(ИмяПланаСчетов
									 , ИмяВидовСубконто
									 , ИмяМакета
									 , РежимСообщений = "Все"
									 , РежимЗаполнения = ""
									 , УстанавливатьПометку = ЛОЖЬ
									 , Отказ
									 , СинонимПС = ""
									 , МассивСтрокИзЭксель)
	
	// Проверки.
	Если Метаданные.ПланыСчетов.Найти(ИмяПланаСчетов) = Неопределено Тогда
		НачалоСообщения = Нстр("ru = 'В системе не обнаружен план счетов'");
		ТекстСообщения  = НачалоСообщения + " """ + ИмяПланаСчетов + """!";
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения, , , Отказ);
	КонецЕсли;
	Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяВидовСубконто) = Неопределено Тогда
		НачалоСообщения = Нстр("ru = 'В системе не обнаружен план видов характеристик'");
		ТекстСообщения  = НачалоСообщения + " """ + ИмяВидовСубконто + """!";
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения, , , Отказ);
	КонецЕсли;
	Если Метаданные.ПланыСчетов[ИмяПланаСчетов].Макеты.Найти(ИмяМакета) = Неопределено Тогда
		ТекстСообщения = Нстр("ru = 'У плана счетов %1% не обнаружен макет %2%!'");
		ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ИмяПланаСчетов, ИмяМакета);
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения, , , Отказ);
	КонецЕсли;
	
	Если Отказ Тогда
		Возврат;
	КонецЕсли; 
	
	Если ПустаяСтрока(СинонимПС) Тогда
		// Получим синоним объекта.
		СинонимПС = бит_ПраваДоступа.ПолучитьСинонимОбъектаСистемы(Метаданные.ПланыСчетов[ИмяПланаСчетов]);
	КонецЕсли;
	
	ВыводитьОшибки     = ?(ВРег(РежимСообщений) = ВРег("Все") ИЛИ ВРег(РежимСообщений) = ВРег("Ошибки"), Истина, Ложь);
	ВыводитьИнформацию = ?(ВРег(РежимСообщений) = ВРег("Все"), Истина, Ложь);
	
	ПланСчетовМенеджер   = ПланыСчетов[ИмяПланаСчетов];
	ВидыСубконтоМенеджер = ПланыВидовХарактеристик[ИмяВидовСубконто];
	
	// Служит для хранения ссылок найденных/записанных счетов.
	МассивСчетов         = Новый Массив;
	
	МассивСтрокДляЗаполнения = Новый Массив;
	
    // Проверим наличие реквизита "КодБыстрогоВыбора".
    ЕстьКодБыстрогоВыбора = Не Метаданные.ПланыСчетов[ИмяПланаСчетов].Реквизиты.Найти("КодБыстрогоВыбора") = Неопределено;
	
	// Добавление кода. Начало. 17.10.2011{{
	// Текущая маска кода из регистра сведений.
	МаскаКода 			     = РегистрыСведений.бит_МаскиКодов.ПолучитьМаскуКодаПланаСчетов(ИмяПланаСчетов);
	МаскаСодержитРазделители = ?(бит_БухгалтерияКлиентСервер.ПолучитьКоличествоРазделителейМаски(МаскаКода) = 0, Ложь, Истина);
	// Добавление кода. Конец. 17.10.2011}}
	
	КоличествоСубконто = 4;
	
	// Если массив не заполнен, значит заполнение счетов из макета.
	Если МассивСтрокИзЭксель = Неопределено Тогда
	
		Макет = ПланСчетовМенеджер.ПолучитьМакет(ИмяМакета);
		
		ВидыСчета = Новый Соответствие;
		ВидыСчета.Вставить("А" , ВидСчета.Активный);
		ВидыСчета.Вставить("П" , ВидСчета.Пассивный);
		ВидыСчета.Вставить("АП", ВидСчета.АктивноПассивный);
		
		ПоляСтруктуры = бит_БухгалтерияКлиентСервер.ОпределитьСтрокуПолейПланаСчетов(ИмяПланаСчетов, Ложь, Истина); 
		
		НСтрока = 2;
		
		ТестовоеЗначение = СокрЛП(Макет.Область(НСтрока, 2, НСтрока, 2).Текст);
		Дальше = ЗначениеЗаполнено(ТестовоеЗначение);
		Пока Дальше Цикл
			
			// Считываем данные из макета
			Данные = Новый Структура(ПоляСтруктуры);
			Сч = 1;
			Для каждого КлючИЗначение Из Данные Цикл
				
				ИмяПоля  = КлючИЗначение.Ключ;
				Значение = СокрЛП(Макет.Область(НСтрока, Сч, НСтрока, Сч).Текст);
				Если ИмяПоля = "Вид" Тогда
				   ТекущийВид      = ВидыСчета[Значение];	
				   Данные[ИмяПоля] = ?(ТекущийВид = Неопределено, ВидСчета.АктивноПассивный, ТекущийВид);
				ИначеЕсли ИмяПоля  = "Забалансовый" 
					      ИЛИ ИмяПоля = "Валютный" 
						  ИЛИ ИмяПоля = "Количественный"
						  ИЛИ ИмяПоля = "ОбСубконто1"
						  ИЛИ ИмяПоля = "ОбСубконто2"
						  ИЛИ ИмяПоля = "ОбСубконто3"
						  ИЛИ ИмяПоля = "ОбСубконто4" Тогда	
				   Данные[ИмяПоля] = ?(Значение = "1", Истина, Ложь);	  
				Иначе
				   Данные[ИмяПоля] = Значение;
				КонецЕсли; 
				
				Сч = Сч + 1;
			КонецЦикла; 
			
			ДополнитьДанныеДляЗаполненияПланаСчетов(Данные, ПланСчетовМенеджер, МаскаСодержитРазделители, МаскаКода);
			
			Если ЗначениеЗаполнено(Данные.ТекущийЭлемент) 
				И Данные.ТекущийЭлемент.Предопределенный  Тогда
				
				НСтрока = НСтрока + 1;				
				ТестовоеЗначение = СокрЛП(Макет.Область(НСтрока, 2, НСтрока, 2).Текст);
				Дальше = ЗначениеЗаполнено(ТестовоеЗначение);
				Продолжить;
			КонецЕсли; 
			
	        НСтрока 		 = НСтрока + 1;				
	        ТестовоеЗначение = СокрЛП(Макет.Область(НСтрока, 2, НСтрока, 2).Текст);
	        Дальше 			 = ЗначениеЗаполнено(ТестовоеЗначение);
			
			МассивСтрокДляЗаполнения.Добавить(Данные);
			
		КонецЦикла;	
		
	Иначе
		
		// Загрузка из файла Excel
		Для каждого Данные Из МассивСтрокИзЭксель Цикл
			
			ДополнитьДанныеДляЗаполненияПланаСчетов(Данные, ПланСчетовМенеджер, МаскаСодержитРазделители, МаскаКода, Истина);
			
			Если ЗначениеЗаполнено(Данные.ТекущийЭлемент) 
				И Данные.ТекущийЭлемент.Предопределенный  Тогда
				
				Продолжить;
				
			КонецЕсли; 
			
			МассивСтрокДляЗаполнения.Добавить(Данные);
			
		КонецЦикла; 
		
	КонецЕсли;	
		
	Для каждого Данные Из МассивСтрокДляЗаполнения Цикл
	
		// Заполняем реквизиты счета
		Если ЗначениеЗаполнено(Данные.ТекущийЭлемент) Тогда
			СчетОбъект = Данные.ТекущийЭлемент.ПолучитьОбъект();
		Иначе	
			СчетОбъект = ПланСчетовМенеджер.СоздатьСчет();
        КонецЕсли; 
        
        ЗаписатьТекСчет = Истина;
        
        // Если необходимо изменить только вид счета, тогда.
        Если РежимЗаполнения = "ИзменитьТолькоВидСчета" Тогда
            
            // Если вид счета не изменился, тогда
            Если СчетОбъект.Вид = Данные.Вид Тогда
                
                СчетОбъект		= Неопределено;
                ЗаписатьТекСчет = Ложь;
                
            Иначе
                СчетОбъект.Вид = Данные.Вид;
            КонецЕсли;
            
        // Иначе если не указан режим заполнения, тогда.
        ИначеЕсли РежимЗаполнения = "" Тогда
        
    		ЗаполнитьЗначенияСвойств(СчетОбъект,Данные);
			// Изменение кода. Начало. 05.05.2016{{
			СчетОбъект.Родитель = ПланСчетовМенеджер.НайтиПоКоду(Данные.РодительКод);
			// Изменение кода. Конец. 05.05.2016}}
			
			СчетОбъект.ЗапретитьИспользоватьВПроводках = Данные.Группа;
			
			МетаПланаСчетов			 		= Метаданные.ПланыСчетов[ИмяПланаСчетов];
			ПризнакиУчетаСубконто 	 		= МетаПланаСчетов.ПризнакиУчетаСубконто;
			ЕстьСуммовойУчетСубконто 		= ?(ПризнакиУчетаСубконто.Найти("Суммовой") 		= Неопределено, Ложь, Истина);
			ЕстьВалютныйУчетСубконто 		= ?(ПризнакиУчетаСубконто.Найти("Валютный") 		= Неопределено, Ложь, Истина);
			ЕстьКоличественныйУчетСубконто 	= ?(ПризнакиУчетаСубконто.Найти("Количественный") 	= Неопределено, Ложь, Истина);
			СчетВалютный			 		= ?(МетаПланаСчетов.ПризнакиУчета.Найти("Валютный") = Неопределено, Ложь, СчетОбъект.Валютный);
			СчетКоличественный			 	= ?(МетаПланаСчетов.ПризнакиУчета.Найти("Количественный") = Неопределено, Ложь, СчетОбъект.Количественный);
			
    		// Заполняем субконто.
            СчетОбъект.ВидыСубконто.Очистить();
            Для Сч = 1 По КоличествоСубконто Цикл
                
                Имя           = "Субконто" + Сч;
                ТолькоОбороты = Данные["ОбСубконто" + Сч];
                
                Если ТипЗнч(Данные[Имя]) = Тип("Строка") Тогда
                    // При загрузке из макета приходит строка.
                    ИмяСубконто        = Данные[Имя];	
                    ТекущийВидСубконто = Неопределено;
                    Если НЕ ПустаяСтрока(ИмяСубконто) Тогда					
                    	Попытка
                            ТекущийВидСубконто = ВидыСубконтоМенеджер[ИмяСубконто];
    					Исключение	
                        КонецПопытки;    					
    					Если ТекущийВидСубконто = Неопределено Тогда    					
    	                	ТекущийВидСубконто = ВидыСубконтоМенеджер.НайтиПоНаименованию(ИмяСубконто);    						
    					КонецЕсли;     					
    					Если НЕ ЗначениеЗаполнено(ТекущийВидСубконто) И ВыводитьОшибки Тогда    					
    						ТекстСообщения = Нстр("ru = 'В плане видов характеристик %1% не удалось найти субконто по имени %2%!'");
    						ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ИмяВидовСубконто, ИмяСубконто);
    						бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);    					
                        КонецЕсли;
                    КонецЕсли;
                Иначе
                    // При загрузке из excel приходит ссылка.
                    ТекущийВидСубконто = Данные[Имя];
                КонецЕсли;               
				                					
                Если ЗначениеЗаполнено(ТекущийВидСубконто) Тогда
                    
                    НовыйВидСубконто = СчетОбъект.ВидыСубконто.Добавить();
                    НовыйВидСубконто.ВидСубконто = ТекущийВидСубконто;
                    
                    Если ЕстьСуммовойУчетСубконто Тогда
                        НовыйВидСубконто.Суммовой = Истина;
                    КонецЕсли;
                    
                    Если ЕстьВалютныйУчетСубконто
                        И СчетВалютный Тогда
                        НовыйВидСубконто.Валютный = Истина;
                    КонецЕсли;
                    
                    Если ЕстьКоличественныйУчетСубконто
                        И СчетКоличественный Тогда
                        НовыйВидСубконто.Количественный = Истина;
                    КонецЕсли;
                    
                    НовыйВидСубконто.ТолькоОбороты = ТолькоОбороты;
                    
                КонецЕсли; 
                                
            КонецЦикла; // По видам субконто
            
            // Если есть реквизит "КодБыстрогоВыбора", тогда
            // заполним код быстрого выбора значением кода счета.
            Если ЕстьКодБыстрогоВыбора Тогда
                СчетОбъект.КодБыстрогоВыбора = бит_БухгалтерияКлиентСервер.ПолучитьКодБыстрогоДоступа(СчетОбъект.Код);
            КонецЕсли;
			
	        СчетОбъект.Порядок   = РегистрыСведений.бит_МаскиКодов.ПолучитьПорядокКодаПоМаскеКода(МаскаКода, СчетОбъект.Код);
			
        КонецЕсли; // Если РежимЗаполнения = "ИзменитьТолькоВидСчета" Тогда.
        
        Если ЗаписатьТекСчет Тогда
			
			// Проверка на дубли в видах субконто.
			ТабВидовСубконто = СчетОбъект.ВидыСубконто.Выгрузить();
			КолСубконто = СчетОбъект.ВидыСубконто.Количество();
			ТабВидовСубконто.Свернуть("ВидСубконто");
			Если КолСубконто <> ТабВидовСубконто.Количество() Тогда
				Дубли = Истина;
			Иначе	
				Дубли = Ложь;
			КонецЕсли; 
			
            // Записываем счет.
			Если Дубли Тогда
				
				ТекстСообщения = Нстр("ru = 'По счету %1% дублируется субконто! Счет не загружен! Исправьте и повторите загрузку.'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%1%", СчетОбъект.Код);
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
				Продолжить;
			
			ИначеЕсли бит_ОбщегоНазначения.ЗаписатьСчет(СчетОбъект, СинонимПС, , РежимСообщений, Истина) Тогда
				МассивСчетов.Добавить(СчетОбъект.Ссылка);
			Иначе
				// Не удалось записать счет.
				Отказ = Истина;
			КонецЕсли;
			
        КонецЕсли;
        
	КонецЦикла;  // По строкам макета
	
	// Помечаем на удаление счета, которых нет в макете.
	
	Если УстанавливатьПометку Тогда
		
		ВыборкаСчетов = ПланСчетовМенеджер.Выбрать();
		
		Пока ВыборкаСчетов.Следующий() Цикл
			
			ТекущийСчет = ВыборкаСчетов.Ссылка;
			Если ТекущийСчет.Предопределенный Тогда
			
				Продолжить;
			
			КонецЕсли; 
			
			Если МассивСчетов.Найти(ТекущийСчет) = Неопределено Тогда
				
				СчетОбъект = ТекущийСчет.ПолучитьОбъект();
				
				Попытка     					
					СчетОбъект.УстановитьПометкуУдаления(Истина);
					Если ВыводитьИнформацию Тогда
						НачалоСообщения = Нстр("ru = 'Помечен на удаление счет'");
						ТекстСообщения  = НачалоСообщения + " """ + ТекущийСчет.Код + """. План счетов """ + СинонимПС + """.";
						бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения, , , Отказ);
					КонецЕсли; 
				Исключение
					Если ВыводитьОшибки Тогда
						НачалоСообщения = Нстр("ru = 'Не удалось пометить на удаление счет'");
						ТекстСообщения  = НачалоСообщения + " """ + ТекущийСчет.Код + """!";
						бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения, , , Отказ);
					КонецЕсли; 
				КонецПопытки;
				
			КонецЕсли; // Нет счета в макете
			
		КонецЦикла; // По выборке счетов
		
	КонецЕсли; // Устанавливать пометку
	
	ТекстСообщения = Нстр("ru = 'Загрузка завершена.'");
	бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
        
КонецПроцедуры // ЗаполнитьПланСчетовИзМакета()

// Процедура дополняет данные для заполнения.
//
// Параметры:
//  Данные.
//  ПланСчетовМенеджер.
//  МаскаСодержитРазделители.
//  МаскаКода.
//  ЭтоЗагрузкаИзExcel - Булево (По умолчанию = Ложь).
//
Процедура ДополнитьДанныеДляЗаполненияПланаСчетов(Данные, ПланСчетовМенеджер, МаскаСодержитРазделители, МаскаКода, ЭтоЗагрузкаИзExcel = Ложь)

	// Преобразование кода, кода родителя и порядка по маске		
	Если МаскаСодержитРазделители Тогда
		РегистрыСведений.бит_МаскиКодов.ПреобразоватьДанныеПоМаскеКода(Данные, МаскаКода);			
	КонецЕсли;  		
	
	Данные.Вставить("Родитель");
	Данные.Вставить("ТекущийЭлемент"				 , ПланСчетовМенеджер.НайтиПоКоду(Данные.Код));	
	Данные.Вставить("ЗапретитьИспользоватьВПроводках", ?(Данные.Группа = "1", Истина, Ложь));
	
	Если НЕ ЭтоЗагрузкаИзExcel Тогда
	 	Данные.Вставить("НаименованиеПолное", Данные.Наименование);	
	КонецЕсли;

КонецПроцедуры // ДополнитьДанныеДляЗаполненияПланаСчетов()

#КонецОбласти