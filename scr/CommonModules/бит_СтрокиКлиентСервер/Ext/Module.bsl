////////////////////////////////////////////////////////////////////////////////
// Модуль содержит методы работы со строками.
//  
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

#Область ТиповыеПроцедурыИФункции

// Формирует строку повторяющихся символов заданной длины.
// 
// Параметры:
//  Символ      - Строка - символ, из которого будет формироваться строка.
//  ДлинаСтроки - Число  - требуемая длина результирующей строки.
// 
// Возвращаемое значение:
//  Строка - строка, состоящая из повторяющихся символов.
// 
Функция СформироватьСтрокуСимволов(Знач Символ, Знач ДлинаСтроки) Экспорт
	
	Результат = "";
	Для Счетчик = 1 По ДлинаСтроки Цикл
		Результат = Результат + Символ;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // СформироватьСтрокуСимволов()

// Дополняет строку символами слева или справа до заданной длины и возвращает ее.
// Незначащие символы слева и справа удаляются. По умолчанию функция дополняет строку символами "0" (ноль) слева.
// 
// Параметры:
//  Строка      - Строка - исходная строка, которую необходимо дополнить символами;
//  ДлинаСтроки - Число  - требуемая результирующая длина строки;
//  Символ      - Строка - символ, которым необходимо дополнить строку;
//  Режим       - Строка - "Слева" или "Справа" - режим добавления символов к исходной строке.
// 
// Возвращаемое значение:
//  Строка - строка, дополненная символами.
// 
// Пример 1:
// Строка = "1234"; ДлинаСтроки = 10; Символ = "0"; Режим = "Слева".
// Возврат: "0000001234".
// 
// Пример 2:
// Строка = " 1234  "; ДлинаСтроки = 10; Символ = "#"; Режим = "Справа".
// Возврат: "1234######".
// 
Функция ДополнитьСтрокуСимволами(Знач Строка, Знач ДлинаСтроки, Знач Символ = "0", Знач Режим = "Слева") Экспорт
	
	// Длина символа не должна превышать единицы.
	Символ = Лев(Символ, 1);	
	// Удаляем крайние пробелы слева и справа строки.
	Строка = СокрЛП(Строка); 
	
	КоличествоСимволовНадоДобавить = ДлинаСтроки - СтрДлина(Строка);
	
	Если КоличествоСимволовНадоДобавить > 0 Тогда
		
		СтрокаДляДобавления = СформироватьСтрокуСимволов(Символ, КоличествоСимволовНадоДобавить);
		
		Если ВРег(Режим) = "СЛЕВА" Тогда			
			Строка = СтрокаДляДобавления + Строка;			
		ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда 			
			Строка = Строка + СтрокаДляДобавления; 			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции // ДополнитьСтрокуСимволами()

#КонецОбласти

#Область РаботаСоСложнымиСтроками

// Устаревшая. Используй "бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями".
// 
// 	Параметры: 
// 		Стр - 			строка, которую необходимо разложить на подстроки. 
// 						Параметр передается по значению.
// 		Разделитель - 	строка-разделитель, по умолчанию - запятая.
// 
// 
// 	Возвращаемое значение:
// 		массив значений, элементы которого - подстроки.
// 
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(Стр, Разделитель);
	
	//МассивСтрок = Новый Массив();
	//Если Разделитель = " " Тогда
	//	
	//	Стр = СокрЛП(Стр);
	//	
	//	Пока 1 = 1 Цикл
	//		
	//		Поз = Найти(Стр,Разделитель);
	//		Если Поз = 0 Тогда
	//			МассивСтрок.Добавить(Стр);
	//			Возврат МассивСтрок;
	//		КонецЕсли;
	//		
	//		МассивСтрок.Добавить(Лев(Стр, Поз - 1));
	//		Стр = СокрЛ(Сред(Стр, Поз));
	//		
	//	КонецЦикла;
	//	
	//Иначе
	//	
	//	ДлинаРазделителя = СтрДлина(Разделитель);
	//	
	//	Пока 1 = 1 Цикл
	//		
	//		Поз = Найти(Стр,Разделитель);
	//		Если Поз = 0 Тогда
	//			МассивСтрок.Добавить(Стр);
	//			Возврат МассивСтрок;
	//		КонецЕсли;
	//		
	//		МассивСтрок.Добавить(Лев(Стр, Поз - 1));
	//		Стр = Сред(Стр, Поз + ДлинаРазделителя);
	//		
	//	КонецЦикла;
	//	
	//КонецЕсли;
	
КонецФункции // РазложитьСтрокуВМассивПодстрок()

// Процедура разбирает строку с разделителями и упаковывает значения в массив.
// 
// Параметры:
//  ИсходнаяСтрока  - Строка
//  Разделитель     - Строка
//  ПоНарастающей   - Булево (По умолчанию = Ложь) .
//
// ВозвращаемоеЗначение:
//  Массив
// 
Функция РазобратьСтрокуСРазделителями(ИсходнаяСтрока, Разделитель, ПоНарастающей = Ложь) Экспорт
	
	РезМассив = Новый Массив;

	Список = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИсходнаяСтрока, Разделитель);
	Если ПоНарастающей Тогда
	     НарастающаяСтрока = "";
		 Для каждого СтрокаСписка Из Список Цикл
		 	 НарастающаяСтрока = ?(ПустаяСтрока(НарастающаяСтрока), СтрокаСписка, НарастающаяСтрока + "." + СтрокаСписка);
			 РезМассив.Добавить(НарастающаяСтрока);
		 КонецЦикла; 
	Иначе
		РезМассив = Список; 
	КонецЕсли;
	
	Возврат РезМассив;
	
КонецФункции // РазобратьСтрокуСРазделителями()

// Процедура разбирает строку с разделителями и упаковывает значения в массив.
// 
// Параметры:
//  ИсходнаяСтрока - Строка
//  Разделитель    - Массив
// 
Функция РазобратьСтрокуСМассивомРазделителей(ИсходнаяСтрока, МассивРазделителей) Экспорт
	
	РезМассив = Новый Массив;
	
	// Функция возвращает строки, разделенные различными разделителями.
	// Возможные разделители передаются в виде массива. 
	// На пример: есть Строка "(П1)(П2)" - получаем массив с элементами "П1", "П2". 
	// Теперь такую штуку умеет делать 1С.
	РезМассив = СтрРазделить(ИсходнаяСтрока, СтрСоединить(МассивРазделителей), Ложь);
	
	Возврат РезМассив;
	
КонецФункции // РазобратьСтрокуСРазделителями()

// Формирует из исходной строки СтрокаПоиска строку для поиска данных в запросе.
// 
// Параметры:
// 	СтрокаПоиска - Строка - исходная строка, содержащая запрещенные символы.
// 
// Возвращаемое значение:
//  Строка - строка подготовленная для поиска данных в запросе.
// 
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции // СформироватьСтрокуДляПоискаВЗапросе()

#КонецОбласти

#Область РаботаСШаблонамиТекста

// Функция определяет параметры, используемые в данном шаблоне.
// 
// Параметры:
//  ШаблонСообщения    - Строка
//  ПараметрыТекста    - Соответствие.
// 
// Возвращаемое значение:
//   ПараметрыТекста   - Соответствие.
// 
Процедура ОпределитьПараметрыТекста(ШаблонТекста,ПараметрыТекста = Неопределено,СтрОткрытие="{{",СтрЗакрытие="}}") Экспорт
	
	Если ПараметрыТекста = Неопределено Тогда 		
		ПараметрыТекста = Новый Соответствие; 		
	КонецЕсли; 
	
	Стр = ШаблонТекста;	
	ЧислоШаблонов = СтрЧислоВхождений(Стр, СтрОткрытие);
	Для н = 1 По ЧислоШаблонов Цикл
		
		НомерСимволаОткрытие = Найти(Стр, СтрОткрытие);
		Если НомерСимволаОткрытие > 0 Тогда
			
			Стр = Сред(Стр,НомерСимволаОткрытие + 2);
			НомерСимволаЗакрытие = Найти(Стр, СтрЗакрытие);
			Если НомерСимволаЗакрытие > 0 Тогда
				
				ИмяПараметра = СокрЛП(Лев(Стр, НомерСимволаЗакрытие - 1));							
				Если ПараметрыТекста[ИмяПараметра] = Неопределено Тогда
					ПараметрыТекста.Вставить(ИмяПараметра);
				КонецЕсли; 
				Стр = Сред(Стр,НомерСимволаЗакрытие + 2);
				
			КонецЕсли; // Нашли закрытие
			
		КонецЕсли; // Нашли открытие
		
	КонецЦикла; // По количеству параметров в тексте
	
КонецПроцедуры // ОпределитьПараметрыТекста()

// Процедура преобразует текст шаблона в сообщение.
// 
Функция ОбработатьТекстШаблона(ТекстШаблона, СтруктураКонтекст, СтруктураПараметров=Неопределено) Экспорт
	
	// Дополним в случае необходимости структуру параметров.
	ОбработатьСтруктуруПараметров(СтруктураПараметров);
	
	// Результат обработки текста шаблона, происходит постепенное преобразование.
	РезультатОбработки = ТекстШаблона;
	
	// Заполним параметры шаблона
	ЗаполнитьПараметрыШаблона(РезультатОбработки, СтруктураКонтекст, СтруктураПараметров);
	
	// Сформируем массив управляющих конструкций.
	МассивСинтаксическихКонструкций = ПолучитьМассивСинтаксическихКонструкций(РезультатОбработки, СтруктураКонтекст, СтруктураПараметров);
	
	ИсполняемыйКод = ПолучитьПрограммныйКодИзШаблона(РезультатОбработки, МассивСинтаксическихКонструкций, СтруктураПараметров);
	
	ТекстПодстановки = ВыполнитьПрограммныйКодШаблона(ИсполняемыйКод, СтруктураКонтекст, СтруктураПараметров);
	
	Если НЕ ТекстПодстановки = Неопределено Тогда
		
		НомерНач = МассивСинтаксическихКонструкций[0].НомерПозиции;
		НомерКон = МассивСинтаксическихКонструкций[МассивСинтаксическихКонструкций.ВГраница()].НомерПозицииКонец-НомерНач+1;
		
		ЗаменяемыйТекст = Сред(РезультатОбработки, НомерНач, НомерКон);
		
		РезультатОбработки = СтрЗаменить(РезультатОбработки, ЗаменяемыйТекст, ТекстПодстановки);
		
	КонецЕсли;
	
	// Возможно в тексте шаблона присутствуют операторы встроенного языка вне управляющих конструкций.
	ЗаполнитьВыраженияШаблона(РезультатОбработки, СтруктураПараметров, Ложь, СтруктураКонтекст);
	
	Возврат РезультатОбработки;
	
КонецФункции // ОбработатьТекстШаблона()

#КонецОбласти

// Функция возвращает текст с добавлением/удаление разделителя "|".
// 
// Параметры:
//  Текст    - Строка.
//  Добавить - Булево.
// 
// Возвращаемое значение:
//  ТекстНов - Строка.
// 
Функция УбратьДобавитьПалки(Текст, Добавить = Ложь) Экспорт
	
	ТекстДок = Новый ТекстовыйДокумент;
	ТекстДок.УстановитьТекст(Текст);
	КолСтрок = ТекстДок.КоличествоСтрок();
	
	Если Добавить Тогда
		
		Для н = 1 По КолСтрок Цикл
		
			ТекСтр = ТекстДок.ПолучитьСтроку(н);
			
			Если н = 1 Тогда
				
				ТекСтр = """"+ТекСтр;
				
			Иначе	
				
				// Для строковых литералов делаем двойные кавычки.
				ТекСтр = СтрЗаменить(ТекСтр,"""","""""");
				
				// Добавляем переносы строк
				ТекСтр = "|"+ТекСтр;
				
				Если н = КолСтрок Тогда
				
					ТекСтр = ТекСтр + """";
				
				КонецЕсли; 
				
			КонецЕсли; 
			
			ТекстДок.ЗаменитьСтроку(н, ТекСтр);			
			
		КонецЦикла; 
		
	Иначе	
		
		Для н = 1 По КолСтрок Цикл
		
			ТекСтр = ТекстДок.ПолучитьСтроку(н);
			
			Если н = 1 Тогда
				
				// Убираем первую кавычку
				ТекСтр = Сред(ТекСтр,2);
				
			ИначеЕсли н = КолСтрок Тогда	
				
				// Убираем последнюю кавычку
				ТекСтр = Сред(ТекСтр,1, СтрДлина(ТекСтр)-1);
				
			КонецЕсли; 
			
				// Для строковых литералов заменям двойную кавычку на одинарную.
				ТекСтр = СтрЗаменить(ТекСтр,"""""","""");
			
			ТекСтр = СтрЗаменить(ТекСтр,"|","");
			
			ТекстДок.ЗаменитьСтроку(н, ТекСтр);
			
		КонецЦикла; 
		
	КонецЕсли;
	
	ТекстНов = ТекстДок.ПолучитьТекст();
	// Убираем перенос последней строки
	ТекстНов = Сред(ТекстНов,1,СтрДлина(ТекстНов)-1);
	
	Возврат ТекстНов;
	
КонецФункции	

// Дополняет текстовую строку
// 
// Параметры:
//  ИсходнаяСтрока    - Строка
//  ФиксированныйТекст- Строка
//  СтрокаДополнение  - Строка
// 
// ВозвращаемоеЗначение:
//  РезСтрока - Строка
// 
Функция ДополнитьСтроку(ИсходнаяСтрока,ФиксированныйТекст = "",СтрокаДополнение) Экспорт
	
	РезСтрока = ИсходнаяСтрока;
	Если Не ПустаяСтрока(СтрокаДополнение) Тогда
		РезСтрока = РезСтрока+ФиксированныйТекст+СтрокаДополнение;
	КонецЕсли; 
	
	Возврат РезСтрока;
	
КонецФункции // ДополнитьСтроку()

// Функция добавляет новую строку к строке. Если исходная строка не пуста, вставляется разделитель.
// 
// Параметры:
//  ИсходнаяСтрока    - Строка
//  СтрокаДополнение  - Строка
//  Разделитель       - Строка
// 
// ВозвращаемоеЗначение:
//  РезСтрока - Строка
// 
Функция ДобавитьСтрокуСРазделителем(ИсходнаяСтрока,СтрокаДополнение,Разделитель = "") Экспорт

	РезСтрока = ИсходнаяСтрока+?(ПустаяСтрока(ИсходнаяСтрока),"",Разделитель)+СтрокаДополнение;
	
    Возврат РезСтрока;
	
КонецФункции // ДобавитьСтрокуСРазделителем()

// Функция выделяет из строки формулы имена аргументов.
// 
// Параметры:
//  Формула  - Строка.
// 
// Возвращаемое значение:
//   РезМассив   - Массив - значения массива: имена реквизитов.
// 
Функция РазобратьФормулу(Формула) Экспорт
	
	РезМассив = Новый Массив;
	
	ТекСтрока = Формула;
	
	КоличествоПараметров = СтрЧислоВхождений(ТекСтрока,"[");
	
	Для й = 1 По КоличествоПараметров Цикл
		
		НомерСимволаОткрытие = Найти(ТекСтрока,"[");
		НомерСимволаЗакрытие = Найти(ТекСтрока,"]");
		
		ИмяОбласти = Сред(ТекСтрока,НомерСимволаОткрытие+1,НомерСимволаЗакрытие-НомерСимволаОткрытие-1);
		РезМассив.Добавить(ИмяОбласти);
		
		ТекСтрока = Сред(ТекСтрока,НомерСимволаЗакрытие+1);
		
	КонецЦикла; 
	
	бит_РаботаСКоллекциямиКлиентСервер.УдалитьПовторяющиесяЭлементыМассива(РезМассив);
	
	Возврат РезМассив;
	
КонецФункции // РазобратьФормулу()

// Функция проверяет кооректность формул. Выполняется проверка на завершенность, 
// допустимые символы и количество открывающихся и закрывающихся скобок.
// 
// Параметры:
//  Формула - Строка
//  ВыводитьСообщения - Булево
// 
// Возвращаемое значение:
//  ФлКорректна - Булево.
// 
Функция ФормулаКорректна(Формула, ВыводитьСообщения = Ложь) Экспорт
	
	ФлКорректна = Истина;
	ТекстСообщения =  НСтр("ru = 'Формула некорректна:'");
	
	// Совпадение количества открытых и закрытых квадратных и круглых скобок.
	КолОткр = СтрЧислоВхождений(Формула, "[");
	КолЗакр = СтрЧислоВхождений(Формула, "]");
	Если НЕ КолОткр = КолЗакр Тогда
	
		ТекстСообщения = ДобавитьСтрокуСРазделителем(ТекстСообщения,  НСтр("ru = 'Обнаружены незакрытые квадратные скобки!'"), Символы.ПС);
		флКорректна = Ложь;
	
	КонецЕсли; 
	
	КолОткр = СтрЧислоВхождений(Формула, "(");
	КолЗакр = СтрЧислоВхождений(Формула, ")");
	Если НЕ КолОткр = КолЗакр Тогда
	
		ТекстСообщения = ДобавитьСтрокуСРазделителем(ТекстСообщения,  НСтр("ru = 'Обнаружены незакрытые круглые скобки!'"), Символы.ПС);
		флКорректна = Ложь;
	
	КонецЕсли; 
	
	// Операнды в конце строки
	СтрВрем = СокрЛП(Формула);
	ДопустимыеПоследниеСимволы = "1234567890)]";
	ПоследнийСимвол = Прав(СтрВрем,1);
	Если Найти(ДопустимыеПоследниеСимволы, ПоследнийСимвол) = 0 Тогда
	
		ТекстСообщения = ДобавитьСтрокуСРазделителем(ТекстСообщения,  НСтр("ru = 'Формула не завершена!'"), Символы.ПС);
		флКорректна = Ложь;
	
	КонецЕсли; 
	
	// Недопустимые символы 
	// необходимо убрать аргументы, т.к. в GUID могут встречаться буквенные символы.
	МассивАргументов = РазобратьФормулу(Формула);
	СтрВрем = Формула;
	Для каждого Аргумент Из МассивАргументов Цикл
	
		СтрВрем = СтрЗаменить(СтрВрем, "["+Аргумент+"]"," ");
	
	КонецЦикла; 
	
	// Убираем функции встроенного языка, которые могут использоваться в формулах.
	ПереченьФункций = Новый Массив;
	ПереченьФункций.Добавить("Мин");
	ПереченьФункций.Добавить("Макс");
	ПереченьФункций.Добавить("Sqrt");
	ПереченьФункций.Добавить("Окр");
	ПереченьФункций.Добавить("Цел");
	
	Для каждого ТекФункция Из ПереченьФункций Цикл
	
		СтрВрем = СтрЗаменить(СтрВрем, ТекФункция+"(","("); 
	
	КонецЦикла; 
	
	// Теперь во временной строке должны остатья только операнды и константы, 
	// проверим оставщуюся строку на допустимые символы.
	ДопустимыеСимволы = " 1234567890+-*/%()?.,=<>";
	НедопустимыеСимволы = "";
	Для ном = 1 По СтрДлина(СтрВрем) Цикл
		ТекСимв = Сред(СтрВрем, Ном, 1);
		Если Найти(ДопустимыеСимволы, ТекСимв) = 0 Тогда
			
			НедопустимыеСимволы = НедопустимыеСимволы + ТекСимв;
			
		КонецЕсли;	
	КонецЦикла;
	
	Если СтрДлина(НедопустимыеСимволы) > 0 Тогда
		
		ТекстСообщения = ДобавитьСтрокуСРазделителем(ТекстСообщения,  НСтр("ru = 'Формула содержит недопустимые символы ""%1%""!'"), Символы.ПС);
		ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, НедопустимыеСимволы);
		флКорректна = Ложь;			
		
	КонецЕсли; 
	
	Если НЕ ФлКорректна И ВыводитьСообщения Тогда
	
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ТекстСообщения);
	
	КонецЕсли; 
	
	Возврат ФлКорректна;
	
КонецФункции // ФормулаКорректна()

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Процедура проверяет наличие в структуре параметров обязательных значений.
// 
// Параметры:
// 	СтруктураПараметров - структура - дополнительные настройки влияющие на обработку текста шаблона.
// 
Процедура ОбработатьСтруктуруПараметров(СтруктураПараметров)
	
	Если СтруктураПараметров = Неопределено Тогда
		СтруктураПараметров = Новый Структура;
	КонецЕсли;
	
	// Определим синтаксис шаблона
	
	// Выделение в тексте выражений - текст который воспринимается как программный код 1С.
	Если НЕ СтруктураПараметров.Свойство("НачалоВстроенныйЯзык") Тогда
		СтруктураПараметров.Вставить("НачалоВстроенныйЯзык", "{%");
	КонецЕсли;
	Если НЕ СтруктураПараметров.Свойство("КонецВстроенныйЯзык") Тогда
		СтруктураПараметров.Вставить("КонецВстроенныйЯзык", "%}");
	КонецЕсли;
	
	// Выделение в тексте параметров - подстановка осуществляется из СтруктураКонтекст.
	Если НЕ СтруктураПараметров.Свойство("НачалоПараметр") Тогда
		СтруктураПараметров.Вставить("НачалоПараметр", "{{");
	КонецЕсли;
	Если НЕ СтруктураПараметров.Свойство("КонецПараметр") Тогда
		СтруктураПараметров.Вставить("КонецПараметр", "}}");
	КонецЕсли;
	
КонецПроцедуры

// Процедура заполняет параметры в тексте шаблона.
// 
// Параметры:
// 	ТекстШаблона - строка - текст шаблона.
// 	СтруктураКонтекст - структура - содержит параметры для подстановки.
// 	СтруктураПараметров - структура - дополнительные настройки влияющие на обработку текста шаблона.
// 
Процедура ЗаполнитьПараметрыШаблона(ТекстШаблона, СтруктураКонтекст, СтруктураПараметров)
	
	// Получим символы выделения параметров в тексте шаблона.
	СтрОткрытие = СтруктураПараметров.НачалоПараметр;
	СтрЗакрытие = СтруктураПараметров.КонецПараметр;
	
	ПараметрыТекста = Новый Соответствие;
	
	// Определим параметры шаблона
	ОпределитьПараметрыТекста(ТекстШаблона,ПараметрыТекста, СтрОткрытие, СтрЗакрытие);
	
	Для Каждого КиЗ Из ПараметрыТекста Цикл
		
		СтрШаблон = СтрОткрытие + КиЗ.Ключ + СтрЗакрытие;
		
		// Вычислим значения параметров шаблона
		Выражение = "СтруктураКонтекст." + КиЗ.Ключ;
		Попытка			
			ЗначениеШаблона = Строка(Вычислить(Выражение));  			
		Исключение			
			ЗначениеШаблона = СтрШаблон; 			
		КонецПопытки;
		
		// Подставим вычисленные значения параметров в шаблон.
		ТекстШаблона = СтрЗаменить(ТекстШаблона, СтрШаблон, ЗначениеШаблона);
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьПараметрыШаблона()

// Процедура заполняет выражения в тексте шаблона.
// 
// Параметры:
// 	ТекстШаблона - строка - текст шаблона
// 	СтруктураПараметров - структура - дополнительные настройки влияющие на обработку текста шаблона
// 	КонкатенацияСтрок - булево - Истина - 
// 
Процедура ЗаполнитьВыраженияШаблона(ТекстШаблона, СтруктураПараметров, КонкатенацияСтрок = Истина, СтруктураКонтекст = Неопределено)
	
	// Получим символы выделения выражений в тексте шаблона.
	СтрОткрытие = СтруктураПараметров.НачалоВстроенныйЯзык;
	СтрЗакрытие = СтруктураПараметров.КонецВстроенныйЯзык;
	
	ПараметрыТекста = Новый Соответствие;
	
	ОпределитьПараметрыТекста(ТекстШаблона, ПараметрыТекста, СтрОткрытие,СтрЗакрытие);
	
	Для Каждого КиЗ Из ПараметрыТекста Цикл
		
		СтрШаблон = СтрОткрытие + КиЗ.Ключ + СтрЗакрытие;
		
		Если КонкатенацияСтрок Тогда
			ТекстВыражения = """+" + КиЗ.Ключ + "+""";
		Иначе
			Попытка
				ТекстВыражения = Строка(Вычислить(КиЗ.Ключ));
			Исключение
				ТекстВыражения = СтрШаблон;
			КонецПопытки;
		КонецЕсли;
		
		ТекстШаблона = СтрЗаменить(ТекстШаблона, СтрШаблон, ТекстВыражения);
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьВыраженияШаблона()

// Процедура получает управляющие конструкции из текста шаблона.
// 
// Параметры:
// 	ТекстШаблона - строка - текст шаблона.
// 	СтруктураКонтекст - структура - содержит параметры для подстановки.
// 	СтруктураПараметров - структура - дополнительные настройки влияющие на обработку текста шаблона.
// 
Функция ПолучитьМассивСинтаксическихКонструкций(ТекстШаблона, СтруктураКонтекст, СтруктураПараметров)
	
	МассивКонструкций = Новый Массив;
	
	// Получим символы, которыми выделяются границы управляющих конструкций в шаблоне.
	НачалоВстроенныйЯзык = СтруктураПараметров.НачалоВстроенныйЯзык;
	КонецВстроенныйЯзык  = СтруктураПараметров.КонецВстроенныйЯзык;
	
	// Предполагаемое число конструкций
	ЧислоВхождений = СтрЧислоВхождений(ТекстШаблона, НачалоВстроенныйЯзык);
	
	// Хранит номер первого символа конструкции в тексте шаблона.
	НомерПозиции = 0;
	
	Стр = ТекстШаблона;
	
	Для Ном = 0 По ЧислоВхождений Цикл
		
		НомерСимволаНачало = Найти(Стр, НачалоВстроенныйЯзык);
		
		НомерПозиции = НомерПозиции + НомерСимволаНачало;
		
		Если НомерСимволаНачало > 0 Тогда
			
			Стр = Сред(Стр, НомерСимволаНачало + 2);
			
			НомерСимволаКонец = Найти(Стр, КонецВстроенныйЯзык);
			
			Если НомерСимволаКонец > 0 Тогда
				
				// Текст конструкции
				Конструкция = СокрЛП(Лев(Стр, НомерСимволаКонец - 1));
				
				ВидКонструкции = ОпределитьВидКонструкции(Конструкция);
				
				Если НЕ ВидКонструкции = Неопределено Тогда
					
					ИнфоКонструкции = Новый Структура;
					
					ИнфоКонструкции.Вставить("Конструкция"		, Конструкция);
					ИнфоКонструкции.Вставить("ВидКонструкции"	, ВидКонструкции);
					ИнфоКонструкции.Вставить("НомерПозиции"		, НомерПозиции);
					ИнфоКонструкции.Вставить("НомерПозицииКонец", НомерПозиции + (НомерСимволаКонец+2));
					
					МассивКонструкций.Добавить(ИнфоКонструкции);
					
				КонецЕсли;
				
				Стр = Сред(Стр, НомерСимволаКонец + 2);
				
				НомерПозиции = НомерПозиции + НомерСимволаКонец;
			КонецЕсли;
			
			НомерПозиции = НомерПозиции + 2;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МассивКонструкций;
	
КонецФункции // ПолучитьМассивСинтаксическихКонструкций()

// Функция обрабатывает текст шаблона для поиска исполняемого кода
// 	Исполняемый код предназначен для динамического формирования текста.
// 
// Параметры:
// 	ТекстШаблона - строка - текст шаблона.
// 	МассивКонструкций - массив - содержит информацию по используемым в шаблоне управляющих конструкций.
// 	СтруктураПараметров - структура - дополнительные настройки.
// 
// Возвращаемое значение:
// 	ИсполняемыйКод - строка - программный код на встроенном языке 1С.
// 
Функция ПолучитьПрограммныйКодИзШаблона(ТекстШаблона, МассивКонструкций, СтруктураПараметров)
	
	ИсполняемыйКод   = "";
	ПовторяемыйТекст = "";
	
	ПозицияПредКонец = Неопределено;
	
	Для Каждого ТекущаяКонструкция Из МассивКонструкций Цикл 
		
		Если НЕ ПозицияПредКонец = Неопределено Тогда
			// Текст между окончанием предыдущей конструкции и началом следующей будет повторяться.
			ПовторяемыйТекст = Сред(ТекстШаблона, ПозицияПредКонец+1, ТекущаяКонструкция.НомерПозиции-ПозицияПредКонец-1);
			
			ПовторяемыйТекст = СтрЗаменить(СокрЛ(ПовторяемыйТекст), Символы.ПС, Символы.ПС+"|");
			
			ЗаполнитьВыраженияШаблона(ПовторяемыйТекст, СтруктураПараметров);
		КонецЕсли;
		
		Если ТекущаяКонструкция.ВидКонструкции = "ЦИКЛ" Тогда
			
			УправляющаяКонструкция = ЗаполнитьВыражениеВКонструкции(ТекущаяКонструкция);
			
			ИсполняемыйКод = ИсполняемыйКод + ?(ПустаяСтрока(ИсполняемыйКод),"",Символы.ПС)
			+"РезультирующийТекст = РезультирующийТекст + """+ПовторяемыйТекст+""";
			|"+УправляющаяКонструкция;
			
		ИначеЕсли ТекущаяКонструкция.ВидКонструкции = "КОНЕЦЦИКЛА" Тогда
			
			ИсполняемыйКод = ИсполняемыйКод + ?(ПустаяСтрока(ИсполняемыйКод),"",Символы.ПС)
			+"РезультирующийТекст = РезультирующийТекст + """+ПовторяемыйТекст+""";
			|"+ТекущаяКонструкция.Конструкция+";";
			
		КонецЕсли;
		
		ПозицияПредКонец = ТекущаяКонструкция.НомерПозицииКонец;
		
	КонецЦикла;
	
	Возврат ИсполняемыйКод;
	
КонецФункции // ПолучитьПрограммныйКодИзШаблона()	

// Функция заполняет выражение в конструкции.
// 
// Параметры:
// 	Конструкция - структура
// 
Функция ЗаполнитьВыражениеВКонструкции(ОписаниеКонструкции)
	
	Результат = ОписаниеКонструкции.Конструкция;
	
	Если ОписаниеКонструкции.ВидКонструкции = "ЦИКЛ" Тогда
		
		ДлинаСтроки = СтрДлина(ОписаниеКонструкции.Конструкция);
		
		Если ВРег(Лев(ОписаниеКонструкции.Конструкция,4))="ДЛЯ " Тогда
			
			НачалоИз = Найти(ВРег(ОписаниеКонструкции.Конструкция), " ИЗ ");
			
			Если НЕ НачалоИз = 0 Тогда
				// Получим имя коллекции которую собираемся обходить в цикле.
				ИмяКоллекции = Сред(ОписаниеКонструкции.Конструкция, НачалоИз+4, ДлинаСтроки-НачалоИз-8);
				
				// Саму коллекцию берем из переданной структуры.
				ТекстЗамены = " СтруктураКонтекст."+ИмяКоллекции+" ";
				
				Результат = СтрЗаменить(ОписаниеКонструкции.Конструкция, " "+ИмяКоллекции+" ", ТекстЗамены);
			КонецЕсли;
			
		ИначеЕсли ВРег(Лев(ОписаниеКонструкции.Конструкция,5))="ПОКА " Тогда
			// Для данного вида цикла ничего сами подставлять не будем.
			
			// ЭтоВыборка = Найти(ВРег(ОписаниеКонструкции.Конструкция), ".СЛЕДУЮЩИЙ() ");
			// 
			// Если НЕ ЭтоВыборка = 0 Тогда
			// 	//  получим имя коллекции которую собираемся обходить в цикле
			// 	ИмяКоллекции = Сред(ОписаниеКонструкции.Конструкция, 6, ДлинаСтроки-10);
			// 	
			// 	//  саму коллекцию берем из переданной структуры
			// 	ТекстЗамены = " СтруктураКонтекст."+ИмяКоллекции+" ";
			// 	
			// 	Результат = СтрЗаменить(ОписаниеКонструкции.Конструкция, " "+ИмяКоллекции+" ", ТекстЗамены);
			// КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ЗаполнитьВыражениеВКонструкции()

// Функция исполняет программный код полученный из шаблона.
// 
// Параметры:
// 	ИсполняемыйКод - строка - программный код на встроенном языке 1С.
// 	СтруктураКонтекст - структура - содержит параметры для подстановки.
// 	СтруктураПараметров - структура - дополнительные параметры.
// 
// Возвращаемое значение:
// 	РезультирующийТекст - строка - .
// 
Функция ВыполнитьПрограммныйКодШаблона(ИсполняемыйКод, СтруктураКонтекст, СтруктураПараметров)
	
	Если НЕ ЗначениеЗаполнено(ИсполняемыйКод) Тогда
		РезультирующийТекст = Неопределено;
	Иначе
		РезультирующийТекст = "";
	КонецЕсли;
	
	ЕстьОшибки = Ложь;
	
	Попытка
		Выполнить(ИсполняемыйКод);
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		// Сообщить(ТекстОшибки);
		
		ЕстьОшибки = Истина;
		
		РезультирующийТекст = Неопределено;
	КонецПопытки;
	
	Возврат РезультирующийТекст;
	
КонецФункции // ВыполнитьПрограммныйКодШаблона()

// Функция определяет вид переданной конструкции.
// 
// Параметры:
// 	УправляющаяКонструкция - структура - информация по конструкции.
// 
// Возвращаемое значение:
// 	ВидКонструкции - строка, Неопределено.
// 
Функция ОпределитьВидКонструкции(УправляющаяКонструкция)
	
	ВидКонструкции = Неопределено;
	
	Стр = СокрЛП(УправляющаяКонструкция);
	
	Если ВРег(Лев(Стр,4))="ДЛЯ "
		И ВРег(Прав(Стр,5))=" ЦИКЛ" Тогда
		
		ВидКонструкции = "ЦИКЛ";
		
	ИначеЕсли ВРег(Лев(Стр,5))="ПОКА "	
		И ВРег(Прав(Стр,5))=" ЦИКЛ" Тогда
		
		ВидКонструкции = "ЦИКЛ";
		
	ИначеЕсли ВРег(Стр)="КОНЕЦЦИКЛА" Тогда
		
		ВидКонструкции = "КОНЕЦЦИКЛА";
		
	КонецЕсли;
	
	
	Возврат ВидКонструкции;
	
КонецФункции // ОпределитьВидКонструкции()

#КонецОбласти
