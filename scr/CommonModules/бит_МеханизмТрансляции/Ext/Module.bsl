
#Область СлужебныйПрограммныйИнтерфейс

#Область ПроцедурыИФункцииВызываемыеВСгенерированномКоде

// Функция извлекает значение дополнительного реквизита.
// 
// Параметры:
//   ТекущаяСсылка - ДокументСсылка, СправочникСсылка.
//   ВидРеквизита - Строка.
//   ИмяРеквизита - Строка.
// 
// Возвращаемое значение:
//  Результат - Произвольный.
// 
Функция ЗначениеДопРеквизита(Источник, ВидРеквизита, ИмяРеквизита) Экспорт

	ЗначениеДопРеквизита = Неопределено;
	
	Свойство = ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(ИмяРеквизита);
	Если ЗначениеЗаполнено(Свойство) Тогда
		Если ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Свойство, "ТипЗначения") = Новый ОписаниеТипов("Булево") Тогда
			ЗначениеДопРеквизита = Ложь;
		КонецЕсли;
	Иначе
		ЗначениеДопРеквизита = Неопределено;
	КонецЕсли; 
	
	Если Источник = Неопределено ИЛИ НЕ ЗначениеЗаполнено(Свойство) Тогда
		Возврат ЗначениеДопРеквизита;
	КонецЕсли; 
	
	ТекущаяСсылка = Источник.Ссылка;
	
	ТекстЗапроса = "";
	Если ВидРеквизита = "ДополнительныйРеквизит" Тогда
		
		МетаОбъект = ТекущаяСсылка.Метаданные();
		Если НЕ МетаОбъект.ТабличныеЧасти.Найти("ДополнительныеРеквизиты") = Неопределено Тогда
			
			ИмяТаблицы = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(МетаОбъект).ПолноеИмя;
			ТекстЗапроса = 
			"ВЫБРАТЬ
			|	ТабДополнительныеРеквизиты.Значение
			|ИЗ
			|	%ИмяТаблицы%.ДополнительныеРеквизиты КАК ТабДополнительныеРеквизиты
			|ГДЕ
			|	ТабДополнительныеРеквизиты.Ссылка = &Объект
			|	И ТабДополнительныеРеквизиты.Свойство = &Свойство";
			
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "%ИмяТаблицы%", ИмяТаблицы);			   
		КонецЕсли;
		
	ИначеЕсли ВидРеквизита = "ДополнительноеСвойство" Тогда	
		
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ДополнительныеСведения.Значение
		|ИЗ
		|	РегистрСведений.ДополнительныеСведения КАК ДополнительныеСведения
		|ГДЕ
		|	ДополнительныеСведения.Объект = &Объект
		|	И ДополнительныеСведения.Свойство = &Свойство";
		
	КонецЕсли; 

	Если НЕ ПустаяСтрока(ТекстЗапроса) Тогда
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Свойство", Свойство);
		Запрос.УстановитьПараметр("Объект", ТекущаяСсылка);
		
		Результат 	 = Запрос.Выполнить();
		Выборка	  	 = Результат.Выбрать();
		
		Если Выборка.Следующий() Тогда
			ЗначениеДопРеквизита = Выборка.Значение;
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат ЗначениеДопРеквизита;
	
КонецФункции // ЗначениеДопРеквизита()

// Процедура получает значение субконто по номеру субконто или по имени субконто. 
// Возможно получение реквизитов субконто по имени. Имя субконто должно иметь следующий формат
// Субконто.[ИмяСубконто].[ИмяРеквизита].[ИмяРеквизита].
// Возможен вызов в сгенерированом коде условия трансляции.
// 
// Параметры:
//  ЗаписьИсточник 		 - РегистрБухгалтерииЗапись,РегистрНакопленияЗапись.
//  ДтКт           		 - Строка(2) - "Дт","Кт".
//  ИмяСубконто    		 - Число,Строка,ПланВидовХарактеристикСсылка.
// 
Функция ЗначениеСубконто(ЗаписьИсточник, ДтКт, ИмяСубконто) Экспорт

	РезЗначение = Неопределено;
	
	Счет = ЗаписьИсточник["Счет"+ДтКт];
	
	Если ТипЗнч(ИмяСубконто) = Тип("Число") Тогда
		
		// Получение значения субконто по номеру
        СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
	
		// +БИТ Тртилек 24.11.11
		//Если ИмяСубконто <= Счет.ВидыСубконто.Количество() Тогда
		Если ТипЗнч(Счет) = Тип("Строка") Тогда
			Если ЗаписьИсточник["Субконто1С"+ДтКт + ИмяСубконто] = Неопределено Тогда
				РезЗначение = ЗаписьИсточник["СубконтоАксапта"+ДтКт + ИмяСубконто];
			Иначе 
				РезЗначение = ЗаписьИсточник["Субконто1С"+ДтКт + ИмяСубконто];
			КонецЕсли;
		ИначеЕсли ИмяСубконто <= Счет.ВидыСубконто.Количество() Тогда
		/// -БИТ Тртилек
		
            //ВидСубконто = Счет.ВидыСубконто[ИмяСубконто-1].ВидСубконто;
            ВидСубконто = СвСч["ВидСубконто" + ИмяСубконто];
			
			РезЗначение = ЗаписьИсточник["Субконто"+ДтКт][ВидСубконто];
					
		КонецЕсли; 
		
	ИначеЕсли ТипЗнч(ИмяСубконто) = Тип("Строка") Тогда
		
		// Получение субконто и реквизитов субконто
		МассивИмен = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИмяСубконто,".");
		Если МассивИмен.Количество()>1 Тогда
			
			// Первое имя - имя вида субконто
			//***БИТ***Теплова***(2012.15.08 добавлено условие: если Счет = строка
			//ИмяВидаСубконто = Счет.Метаданные().ВидыСубконто.Имя;
			//ВидСубконто = НайтиВидСубконто(ИмяВидаСубконто,МассивИмен[1]);
			//РезЗначение = ЗаписьИсточник["Субконто"+ДтКт][ВидСубконто];			
			Если ТипЗнч(Счет) = Тип("Строка") Тогда
				РезЗначение = ЗаписьИсточник[МассивИмен[1]] ;
			Иначе //получаем субконто из метаданных счета
			//***БИТ***Теплова***)
				ИмяВидаСубконто = Счет.Метаданные().ВидыСубконто.Имя;
				ВидСубконто = НайтиВидСубконто(ИмяВидаСубконто,МассивИмен[1]);
				РезЗначение = ЗаписьИсточник["Субконто"+ДтКт][ВидСубконто];
			КонецЕсли;  //***БИТ***Теплова***
			
			 // Остальные - имена реквизитов
			 Для й=2 По МассивИмен.Количество()-1 Цикл
				 
				 Если РезЗначение <> Неопределено Тогда
					 
					 ИмяРеквизита = МассивИмен[й];
					 
					 Если ЭтоДопРеквизит(ИмяРеквизита) Тогда
						 
						 // Извлечение дополнительных реквизитов/свойств.
						 ИменаДоп = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИмяРеквизита,"_");
						 РезЗначение = ЗначениеДопРеквизита(РезЗначение, ИменаДоп[0], ИменаДоп[1]);
						 
					 Иначе	
						 
						 // Извлечение обычного реквизита
						 Попытка
							 
							 РезЗначение = РезЗначение[ИмяРеквизита];
							 
						 Исключение
							 
							 РезЗначение = Неопределено;
							 
						 КонецПопытки;
						 
					 КонецЕсли; 
					 
				 КонецЕсли; 
				 
			 КонецЦикла;// По именам реквизитов 
			 
			 // БИТ_YK_н
			 // Есть ситуации, где передается только строковое имя реквизита
		 ИначеЕсли МассивИмен.Количество()=1 Тогда
			 Попытка
				 РезЗначение = ЗаписьИсточник[МассивИмен[0]];
			 Исключение
			 КонецПопытки;
		// БИТ_YK_к			 
			 
		КонецЕсли; // МассивИмен.Количество()>0
		
	Иначе
		
		ИмяПВХ  = Счет.Метаданные().ВидыСубконто.Имя;

		Если ТипЗнч(ИмяСубконто) = ТипЗнч(ПланыВидовХарактеристик[ИмяПВХ].ПустаяСсылка()) Тогда
		
			// В качестве имени указано непосредственно ссылка на ПВХ.
			РезЗначение = ЗаписьИсточник["Субконто"+ДтКт][ИмяСубконто];
		
		КонецЕсли; 
		
	КонецЕсли; // Условие по типу имени

	Возврат РезЗначение;
	
КонецФункции // ЗначениеСубконто()

// Функция получает значение параметра из кэша реквизитов.
// Возможен вызов в сгенерированом коде условия трансляции.
// 
// Параметры:
//  ИДСтроки  - Строка.
//  ИмяКолонки- Строка.
//  КэшРеквизитов - ТаблицаЗначений.
// 
// Возвращаемое значение:
//   РезЗначение   - Произвольный.
// 
Функция ЗначениеПараметра(ИДСтроки,ИмяКолонки,КэшРеквизитов) Экспорт
	
	РезЗначение = Неопределено;
	
	Если ТипЗнч(КэшРеквизитов) = Тип("ТаблицаЗначений") Тогда
		
		СтрОтбор = Новый Структура("ИД,ИмяКолонки",ИДСтроки,ИмяКолонки);
		МассивСтрок = КэшРеквизитов.НайтиСтроки(СтрОтбор);
		Если МассивСтрок.Количество()>0 Тогда
			
			РезЗначение = МассивСтрок[0].Значение;
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат РезЗначение;
	
КонецФункции // ЗначениеРеквизита()

// Функция получает значения реквизитов документа-регистратороа.
// 
// Параметры:
//  ДокументОбъект  - ДокументОбъект.
//  ИмяРеквизита    - Строка -имя реквизита имеет формат Регистратор.<ИмяРегистратора>.<Реквизит1>.<Реквизит2>.
// 
// Возвращаемое значение:
//   РезЗначение   - Произвольный.
// 
Функция ЗначениеРеквизита(ДокументОбъект,ИмяРеквизита)   Экспорт

	РезЗначение = Неопределено;
	
	МассивИмен = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИмяРеквизита,".");

	Если МассивИмен.Количество()>2 Тогда
		
		РезЗначение = ДокументОбъект;
		
		// Остальные - имена реквизитов
		Для й=2 По МассивИмен.Количество()-1 Цикл
			
			Если РезЗначение <> Неопределено Тогда
				
				ИмяРеквизита = МассивИмен[й];
				
				Если ЭтоДопРеквизит(ИмяРеквизита) Тогда
					
					// Извлечение дополнительных реквизитов/свойств.
					ИменаДоп = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИмяРеквизита,"_");
					РезЗначение = ЗначениеДопРеквизита(РезЗначение, ИменаДоп[0], ИменаДоп[1]);
					
				Иначе	
					
					// Извлечение обычного реквизита
					Попытка
						
						РезЗначение = РезЗначение[ИмяРеквизита];
						
					Исключение
						
						РезЗначение = Неопределено;
						
					КонецПопытки;
					
				КонецЕсли; 
				
			КонецЕсли; 
			
		КонецЦикла;// По именам реквизитов 
		
	ИначеЕсли МассивИмен.Количество() = 2 Тогда
		
		РезЗначение = ДокументОбъект.Ссылка;
		
	КонецЕсли; 

	Возврат РезЗначение;
	
КонецФункции // ЗначениеРеквизита()

// Процедура выполняет пользовательскую функцию.
// 
// Параметры:
//  ФункцияСсылка - СправочникСсылка.бит_ПользовательскиеФункции.
// 
Функция ВыполнитьПользовательскуюФункцию(ФункцияСсылка, П1 = Неопределено, П2 = Неопределено,
														П3 = Неопределено, П4 = Неопределено, 
														П5 = Неопределено, П6 = Неопределено, 
														П7 = Неопределено, П8 = Неопределено,
														П9 = Неопределено, П10 = Неопределено) Экспорт

	//ТРТИЛЕК 04.05.2012
	//Результат = бит_ОбщегоНазначения.ВыполнитьПользовательскуюФункцию(ФункцияСсылка, П1, П2, П3, П4, П5, П6, П7, П8, П9, П10);
	Результат 			= Неопределено;
	
	Если ЗначениеЗаполнено(ФункцияСсылка) Тогда
		
		КодФункции 			= "";
		ПараметрыФункции 	= ФункцияСсылка.ПараметрыФункции;
		
		Для Каждого Параметр Из ПараметрыФункции Цикл
			// Сначала инициализируем переменную
			ДобавитьСтрокуКТексту(КодФункции, Параметр.Наименование + " = " + "П" + Строка(ПараметрыФункции.Индекс(Параметр) + 1) + ";");
		КонецЦикла;
		
		ДобавитьСтрокуКТексту(КодФункции, ФункцияСсылка.КодПодпрограммы);
		//izhtc-Kir 01.09.2015 ( исправление функций БП2.0 на функции БП3.0
		КодФункции = СтрЗаменить(КодФункции, "МодульВалютногоУчета.ПолучитьКурсВалюты(", "бит_КурсыВалют.ПолучитьКурсВалюты(");
		КодФункции = СтрЗаменить(КодФункции, "МодульВалютногоУчета.ПересчитатьИзВалютыВВалюту(", "бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(");
		//izhtc-Kir 01.09.2015 )
		Выполнить(КодФункции);
		
	КонецЕсли; 
	//ТРТИЛЕК 04.05.2012	
	
	Возврат Результат;
	
КонецФункции // ВыполнитьПользовательскуюФункцию()

// Процедура устанавливает субконто на счете. Если такое субконто на счете отсутствует, 
// то ничего не делается. 
// Возможен вызов в сгенерированом коде условия трансляции.
// 
// Параметры:
// 	Счет - Счет, к которому относится субконто.
//  Субконто - набор субконто.
// 	Номер или имя установливаемого субконто.
//  Значение субконто - значение устанавливаемого субконто.
// 
Процедура УстановитьСубконто(Счет, Субконто, ИмяСубконто, ЗначениеСубконто, Сообщать = Ложь, Заголовок = "", ВидыСубконтоСчета = Неопределено) Экспорт

	Если Счет = Неопределено ИЛИ Счет.Пустая() Тогда
		Возврат;
	КонецЕсли;

    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
    Если ВидыСубконтоСчета = Неопределено Тогда
         ВидыСубконтоСчета = Счет.ВидыСубконто;
    КонецЕсли; 
	
	Если ТипЗнч(ИмяСубконто) = Тип("Число") Тогда

		//Если ИмяСубконто > ВидыСубконтоСчета.Количество() Тогда
        Если ИмяСубконто > СвСч.КоличествоСубконто Тогда
			Возврат;
		КонецЕсли;

		//ВидСубк = ВидыСубконтоСчета[ИмяСубконто - 1].ВидСубконто;
        ВидСубк = СвСч["ВидСубконто" + ИмяСубконто];

	ИначеЕсли ТипЗнч(ИмяСубконто) = Тип("Строка") Тогда

		ИмяПВХ  = Счет.Метаданные().ВидыСубконто.Имя;
		ВидСубк = НайтиВидСубконто(ИмяПВХ,ИмяСубконто);

	Иначе
		
		ИмяПВХ  = Счет.Метаданные().ВидыСубконто.Имя;
		
		Если ТипЗнч(ИмяСубконто) = ТипЗнч(ПланыВидовХарактеристик[ИмяПВХ].ПустаяСсылка()) Тогда
		
			// В качестве имени указано непосредственно ссылка на ПВХ.
			ВидСубк = ИмяСубконто;
		
		КонецЕсли; 
		
	КонецЕсли;

	Если ТипЗнч(ИмяСубконто) <> Тип("Число") Тогда
		
		Если ВидыСубконтоСчета.Найти(ВидСубк) = Неопределено Тогда
			Если Сообщать тогда
				бит_ОбщегоНазначения.СообщитьОбОшибке("Вид субконто <" + ВидСубк + "> для счета """+СвСч.Код +" ("+СвСч.Наименование+")"" не определен.",, Заголовок );
			КонецЕсли;
			Возврат;
		КонецЕсли;		
		
	КонецЕсли; 
	
	Если ВидСубк.ТипЗначения.СодержитТип(ТипЗнч(ЗначениеСубконто)) Тогда
		Субконто.Вставить(ВидСубк, ЗначениеСубконто);
	ИначеЕсли Сообщать тогда
		бит_ОбщегоНазначения.СообщитьОбОшибке("Неверное значение """ + ЗначениеСубконто + """ для вида субконто <" + ВидСубк + ">",, Заголовок);
	КонецЕсли;

КонецПроцедуры // УстановитьСубконто()

// Функция извлекает значение дополнительной аналитики из соответствия дополнительных аналитик.
// Также возможно получение реквизитов значения аналитики. 
// Формат имени <ИмяАналитики>.<ИмяРеквизита_1>.<ИмяРеквизита_2>...<ИмяРеквизита_n>.
// Возможен вызов в сгенерированом коде условия заполнения.
// 
// Параметры:
//  ИмяАналитики  - Строка.
//  ДополнительныеАналитики  - Соответствие.
// 
// Возвращаемое значение:
//   ЗначениеАналитики   - Произвольный.
// 
Функция ИзвлечьЗначениеАналитики(ИмяАналитикиВх,ДополнительныеАналитики) Экспорт
	
	ЗначениеАналитики = Неопределено;
	
	МассивИмен     = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИмяАналитикиВх,".");
	КоличествоИмен = МассивИмен.Количество();
	
	Если ДополнительныеАналитики.Количество() > 0 И КоличествоИмен > 0 Тогда
		
		ИмяАналитики = МассивИмен[0];
		
		Для каждого КиЗ Из ДополнительныеАналитики Цикл
			
			ЭтоСтроковойКлюч = ?(ТипЗнч(КиЗ.Ключ) = Тип("Строка"),Истина,Ложь);
			Прервать;
			
		КонецЦикла; 
		
		// Получение значения аналитики
		Если ЭтоСтроковойКлюч Тогда
			
			ЗначениеАналитики = ДополнительныеАналитики[ВРег(ИмяАналитики)];
			
		Иначе	
			
			Аналитика = ПланыВидовХарактеристик.бит_ВидыДополнительныхАналитик.ПустаяСсылка();
			
			Если ТипЗнч(ИмяАналитики) = ТипЗнч("Строка") Тогда
				
				Попытка
					
					Аналитика = ПланыВидовХарактеристик.бит_ВидыДополнительныхАналитик[ИмяАналитики];
					
				Исключение
					
					Аналитика = ПланыВидовХарактеристик.бит_ВидыДополнительныхАналитик.НайтиПоКоду(ИмяАналитики);
					
				КонецПопытки;
				
			Иначе	
				
				Аналитика = ИмяАналитики;
				
			КонецЕсли; 
			
			ЗначениеАналитики = ДополнительныеАналитики[Аналитика];
			
		КонецЕсли; // Тип ключа
		
		// Получение реквизитов значения аналитики
		Если КоличествоИмен > 1 И ЗначениеЗаполнено(ЗначениеАналитики) Тогда
		
			 Для й = 1 По КоличествоИмен-1 Цикл
			 
				 Если ЗначениеАналитики <> Неопределено Тогда
					 
					 ИмяРеквизита = МассивИмен[й];
					 
					 Если ЭтоДопРеквизит(ИмяРеквизита) Тогда
						 
						 // Извлечение дополнительных реквизитов/свойств.
						 ИменаДоп = бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИмяРеквизита,"_");
						 ЗначениеАналитики = ЗначениеДопРеквизита(ЗначениеАналитики, ИменаДоп[0], ИменаДоп[1]);
						 
					 Иначе	
						 
						 // Извлечение обычного реквизита
						 Попытка
							 
							 ЗначениеАналитики = ЗначениеАналитики[ИмяРеквизита];
							 
						 Исключение
							 
							 ЗначениеАналитики = Неопределено;
							 
						 КонецПопытки;
						 
					 КонецЕсли; 
					 
				КонецЕсли; 
			 
			 КонецЦикла;// По именам реквизитов 
		
		КонецЕсли; 
		
	КонецЕсли; // Есть аналитики
	
	Возврат ЗначениеАналитики;
	
КонецФункции // ИзвлечьЗначениеАналитики()

// Функция является оберткой для метода платформы ПринадлежитЭлементу(). 
// Для безопасности вызова проверяется существование родительского объекта.
// 
// Параметры:
//  ТекущийОбъект      - СправочникСсылка,ПланСчетовСсылка,ПланВидовХарактеристикСсылка.
//  РодительскийОбъект - СправочникСсылка,ПланСчетовСсылка,ПланВидовХарактеристикСсылка.
// 
// Возвращаемое значение:
//   флОбъектПодчинен   - Булево.
// 
Функция ОбъектПодчинен(ТекущийОбъект,РодительскийОбъект) Экспорт

	Возврат бит_ОбщегоНазначения.ОбъектПодчинен(ТекущийОбъект, РодительскийОбъект);
	
КонецФункции // ОбъектПодчинен()

// Функция является оберткой для метода платформы СтрЧислоВхождений().
// Выполняется без учета регистра.
//
// Параметры:
//  ИсходнаяСтрока	 - Строка - Исходная строка. 
//  ПодстрокаПоиска	 - Строка - Искомая подстрока.
// 
// Возвращаемое значение:
//  Содержит - булево. 
//
Функция Содержит(ИсходнаяСтрока, ПодстрокаПоиска) Экспорт

	Возврат бит_ОбщегоНазначения.Содержит(ИсходнаяСтрока, ПодстрокаПоиска);
	
КонецФункции

// Функция является оберткой для метода платформы СтрНачинаетсяС().
// Выполняется без учета регистра.
//
// Параметры:
//  ИсходнаяСтрока	 - Строка - Исходная строка. 
//  ПодстрокаПоиска	 - Строка - Искомая подстрока.
// 
// Возвращаемое значение:
//  НачинаетсяС - булево. 
//
Функция НачинаетсяС(ИсходнаяСтрока, ПодстрокаПоиска) Экспорт

	Возврат бит_ОбщегоНазначения.НачинаетсяС(ИсходнаяСтрока, ПодстрокаПоиска);

КонецФункции

// Функция выполняет пересчет из валюты регл в валюту упр.
// Предпогалается, что курс валюты Упр получен при формировании СтруктурыШапкиДокумента.
// Если период, на который необходимо выполнить пересчет не совападает с датой документа, 
// курс будет получен в процедуре.
// 
// Параметры:
//  Сумма - Число.
//  Период - Дата.
//  СтруктураШапкиДокумента - Структура.
// 
// Возвращаемое значение:
//  РезСумма - Число.
// 
Функция ПересчитатьРеглУпр(Сумма, Период, СтруктураШапкиДокумента)  Экспорт
	
	РезСумма = Сумма;
	
	Если СтруктураШапкиДокумента.Свойство("бит_ВалютаУправленческогоУчета") Тогда
		
		Если СтруктураШапкиДокумента.Дата = Период Тогда
			
			СтрКурса = Новый Структура("Курс, Кратность", СтруктураШапкиДокумента.бит_КурсУпр, СтруктураШапкиДокумента.бит_КратностьУпр);	
			
		Иначе	
			
			СтрКурса = бит_КурсыВалют.ПолучитьКурсВалюты(СтруктураШапкиДокумента.бит_ВалютаУправленческогоУчета, Период);
			
		КонецЕсли; 
		
		РезСумма = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(Сумма
												, СтруктураШапкиДокумента.ВалютаРегламентированногоУчета
												, СтруктураШапкиДокумента.бит_ВалютаУправленческогоУчета
												, 1
												, СтрКурса.Курс
												, 1
												, СтрКурса.Кратность);
		
		
	КонецЕсли; 
	
	Возврат РезСумма;
	
КонецФункции // ПересчитатьРеглУпр()

// Функция выполняет пересчет из валюты регл в валюту международного учета.
// Предпогалается, что курс валюты МУ получен при формировании СтруктурыШапкиДокумента.
// 
// Параметры:
//  Сумма - Число.
//  Период - Дата.
//  СтруктураШапкиДокумента - Структура.
// 
// Возвращаемое значение:
//  РезСумма - Число.
// 
Функция ПересчитатьРеглМУ(Сумма, Период, СтруктураШапкиДокумента)  Экспорт

	РезСумма = Сумма;
	
	Если СтруктураШапкиДокумента.Свойство("бит_ВалютаМУ") Тогда
		
		Если СтруктураШапкиДокумента.Дата = Период Тогда
			
			СтрКурса = Новый Структура("Курс, Кратность", СтруктураШапкиДокумента.бит_КурсМУ, СтруктураШапкиДокумента.бит_КратностьМУ);	
			
		Иначе	
			
			СтрКурса = бит_КурсыВалют.ПолучитьКурсВалюты(СтруктураШапкиДокумента.бит_ВалютаМУ, Период);
			
		КонецЕсли; 
		
		
		РезСумма = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(Сумма
		               , СтруктураШапкиДокумента.ВалютаРегламентированногоУчета
					   , СтруктураШапкиДокумента.бит_ВалютаМУ
					   , 1
					   , СтрКурса.Курс
					   , 1
					   , СтрКурса.Кратность);
	
	КонецЕсли; 

	Возврат РезСумма;
	
КонецФункции // ПересчитатьРеглМУ()

// Функция выполняет пересчет из валюты регл в валюту сценария.
// 
// Параметры:
//  Сумма  - Число.
//  Период - Дата.
//  Сценарий - СправочникСсылка.СценарииПланирования.
//  СтруктураШапкиДокумента - Структура.
// 
// Возвращаемое значение:
//  РезСумма - Число.
// 
Функция ПересчитатьРеглСценарий(Сумма, Период, Сценарий, СтруктураШапкиДокумента)  Экспорт

	РезСумма = Сумма;
	
	Если ЗначениеЗаполнено(Сценарий) Тогда
		
		ВалютаСценария = Сценарий.Валюта;
		СтрКурса = бит_КурсыВалют.ПолучитьКурсВалюты(ВалютаСценария, Период);
	
		РезСумма = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(Сумма
		               , СтруктураШапкиДокумента.ВалютаРегламентированногоУчета
					   , ВалютаСценария
					   , 1
					   , СтрКурса.Курс
					   , 1
					   , СтрКурса.Кратность);
	
	КонецЕсли; 

	Возврат РезСумма;
	
КонецФункции // ПересчитатьРеглМУ()

// Функция выполняет валютные пересчеты.
// 
// Параметры:
//  Сумма - Число.
//  Период - Дата.
//  ВалютаНач - СправочникСсылка.Валюты.
//  ВалютаКон - СправочникСсылка.Валюты.
// 
// Возвращаемое значение:
//  РезСумма - Число.
// 
Функция ПересчитатьПоВалюте(Сумма, Период, ВалютаНач, ВалютаКон)  Экспорт

	РезСумма = Сумма;
	
	Если ТипЗнч(ВалютаНач) = Тип("Строка") Тогда
	
		 ВалютаНач = Справочники.Валюты.НайтиПоКоду(ВалютаНач);
	
	КонецЕсли; 
	 
	Если ТипЗнч(ВалютаКон) = Тип("Строка") Тогда
	
		 ВалютаКон = Справочники.Валюты.НайтиПоКоду(ВалютаКон);
	
	КонецЕсли;  
	
	Если ВалютаНач <> ВалютаКон Тогда
		
		СтрКурсаНач = бит_КурсыВалют.ПолучитьКурсВалюты(ВалютаНач, Период);
		СтрКурсаКон = бит_КурсыВалют.ПолучитьКурсВалюты(ВалютаКон, Период);
		
		РезСумма = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(Сумма
			               , ВалютаНач
						   , ВалютаКон
						   , СтрКурсаНач.Курс
						   , СтрКурсаКон.Курс
						   , СтрКурсаНач.Кратность
						   , СтрКурсаКон.Кратность);
		
	КонецЕсли; 
	
	Возврат РезСумма;
	
КонецФункции // ПересчитатьРеглМУ()

// Функция определяет, является ли контрагент собственным.
// 
// Параметры:
//   Контрагент - СправочникСсылка.Контрагенты.
// 
// Возвращаемое значение:
//  флСобственный - Булево.
// 
Функция ЭтоСобственныйКонтрагент(Контрагент)  Экспорт

	флСобственный = бит_МеханизмТрансляцииПовтИсп.ЭтоСобственныйКонтрагент(Контрагент);

	Возврат флСобственный;
	
КонецФункции // ЭтоСобственныйКонтрагент()

#КонецОбласти

#Область ПроцедурыИФункцииПолученияСтруктурыРегистров

// Возвращает описание реквизитов движений для регистра бухгалтерии.
// 
// Параметры:
//  ИмяРегистра  - Строка. Имя регистра бухгалтерии.
//  УчитыватьКорреспонденцию - Булево.
//  ДобавлятьИменаВидовСубконто - Булево.
// 
// Возвращаемое значение:
//   ТаблицаРеквизитов   - ТаблицаЗначений.
// 
Функция ПолучитьРеквизитыРегистраБухгалтерии(ИмяРегистра,УчитыватьКорреспонденцию,ДобавлятьИменаВидовСубконто) Экспорт
	
	МетаданныеРегистр = Метаданные.РегистрыБухгалтерии[ИмяРегистра];
	
	ТаблицаРеквизитов = ИнициализироватьТаблицуРеквизитов();	
	
	// Дополним сначала обязательными реквизитами для регистра бухгалтерии.
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "Период", "Период", мхо_ОписаниеТипов("Дата"));
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "Активность", "Активность", мхо_ОписаниеТипов("Булево"));	
	
	// Получим план счетов регистра бухгалтерии
	ПланСчетов = МетаданныеРегистр.ПланСчетов;
	
	// Определим, поддерживается ли корреспонденция счетов регистра бухгалтерии.
	Если МетаданныеРегистр.Корреспонденция И УчитыватьКорреспонденцию Тогда 	// Присутствуют реквизиты движения "СчетДт" и "СчетКт"
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "СчетДт", "Счет Дт", мхо_ОписаниеТипов("ПланСчетовСсылка." + ПланСчетов.Имя),,,Ложь);
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "СчетКт", "Счет Кт", мхо_ОписаниеТипов("ПланСчетовСсылка." + ПланСчетов.Имя),,,Ложь);
	Иначе											
		// Присутствует только реквизит движения	"Счет".
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "Счет", "Счет", мхо_ОписаниеТипов("ПланСчетовСсылка." + ПланСчетов.Имя),,,Ложь);
	КонецЕсли;
	
	// Заполним сведения о субконто регистра бухгалтерии.
	МаксСубконто 	= ПланСчетов.МаксКоличествоСубконто;
	ОписаниеТипаПВХ = ПланСчетов.ВидыСубконто.Тип;
	
	Для жи = 1 По МаксСубконто Цикл
		// Определим, поддерживается ли корреспонденция счетов регистра бухгалтерии
		Если МетаданныеРегистр.Корреспонденция И УчитыватьКорреспонденцию Тогда 	// Присутствуют реквизиты движения "СчетДт" и "СчетКт"
			Если ДобавлятьИменаВидовСубконто Тогда
				ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ИмяВидаСубконтоДт" + Строка(жи), "Имя вида субконто Дт " + Строка(жи), мхо_ОписаниеТипов("Строка"), Ложь,Ложь);
				ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ИмяВидаСубконтоКт" + Строка(жи), "Имя вида субконто Кт " + Строка(жи), мхо_ОписаниеТипов("Строка"), Ложь,Ложь);
			КонецЕсли; 
			
			ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "СубконтоДт" + Строка(жи), "Субконто Дт " + Строка(жи), мхо_ОписаниеТипов(ОписаниеТипаПВХ),,Истина,Ложь);
			ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "СубконтоКт" + Строка(жи), "Субконто Кт " + Строка(жи), мхо_ОписаниеТипов(ОписаниеТипаПВХ),,Истина,Ложь);
		Иначе
			// Присутствует только реквизит движения "Счет".
			Если ДобавлятьИменаВидовСубконто Тогда
				ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ИмяВидаСубконто" + Строка(жи), "Имя вида субконто " + Строка(жи), мхо_ОписаниеТипов("Строка"), Ложь,Ложь);
			КонецЕсли; 
			ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "Субконто" + Строка(жи), "Субконто " + Строка(жи), мхо_ОписаниеТипов(ОписаниеТипаПВХ),,Истина,Ложь);
		КонецЕсли;
	КонецЦикла;
	
	// Заполним сведения об измерениях регистра бухгалтерии.
	Для Каждого Измерение Из МетаданныеРегистр.Измерения Цикл
		
		Если Измерение.Балансовый или не МетаданныеРегистр.Корреспонденция ИЛИ НЕ УчитыватьКорреспонденцию Тогда 	// У измерения не будет экземпляров "Дт" и "Кт".
			НоваяСтрока = ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Измерение.Имя, Измерение.Синоним, мхо_ОписаниеТипов(Измерение.Тип),,,Измерение.Балансовый);
			НоваяСтрока.ЭтоИзмерение = Истина;
		Иначе																		// Имеются экземпляры "Дт" и "Кт"
			НоваяСтрока = ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Измерение.Имя + "Дт", Измерение.Синоним + " Дт", мхо_ОписаниеТипов(Измерение.Тип),,,Измерение.Балансовый);
			НоваяСтрока.ЭтоИзмерение = Истина;			
			НоваяСтрока = ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Измерение.Имя + "Кт", Измерение.Синоним + " Кт", мхо_ОписаниеТипов(Измерение.Тип),,,Измерение.Балансовый);
			НоваяСтрока.ЭтоИзмерение = Истина;						
		КонецЕсли;
		
	КонецЦикла;
	
	// Заполним сведения о ресурсах регистра бухгалтерии.
	Для Каждого Ресурс Из МетаданныеРегистр.Ресурсы Цикл
		Если Ресурс.Балансовый или не МетаданныеРегистр.Корреспонденция ИЛИ НЕ УчитыватьКорреспонденцию Тогда 	// У ресурса не будет экземпляров "Дт" и "Кт".
			ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Ресурс.Имя, Ресурс.Синоним, мхо_ОписаниеТипов(Ресурс.Тип),,,Ресурс.Балансовый);
		Иначе																	// Имеются экземпляры "Дт" и "Кт"
			ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Ресурс.Имя + "Дт", Ресурс.Синоним + " Дт", мхо_ОписаниеТипов(Ресурс.Тип),,,Ресурс.Балансовый);
			ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Ресурс.Имя + "Кт", Ресурс.Синоним + " Кт", мхо_ОписаниеТипов(Ресурс.Тип),,,Ресурс.Балансовый);
		КонецЕсли;
	КонецЦикла;
	
	// Заполним сведения о реквизитах регистра бухгалтерии.
	Для Каждого Реквизит Из МетаданныеРегистр.Реквизиты Цикл
		Если СтрСравнить(Реквизит.Имя, "СторнируемаяПроводка") = 0 И НЕ ИспользоватьСторнируемыеПроводки() Тогда
			Продолжить;
		КонецЕсли; 
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Реквизит.Имя, Реквизит.Синоним, мхо_ОписаниеТипов(Реквизит.Тип));
	КонецЦикла;
	
	Возврат ТаблицаРеквизитов;
	
КонецФункции
 
// Возвращает описание реквизитов движений для регистра накопления.
// 
// Параметры:
//  ИмяРегистра  - Строка. Имя регистра бухгалтерии.
// 
// Возвращаемое значение:
//   ТаблицаРеквизитов   - ТаблицаЗначений.
// 
Функция ПолучитьРеквизитыРегистраНакопления(ИмяРегистра) Экспорт

	МетаданныеРегистр = Метаданные.РегистрыНакопления[ИмяРегистра];
	
	ТаблицаРеквизитов = ИнициализироватьТаблицуРеквизитов();
	
	ТипЗнчПер = ТипЗнч(ВидДвиженияНакопления);
	
	// Дополним сначала обязательными реквизитами для регистра накопления.
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "Период"	, "Период", мхо_ОписаниеТипов("Дата"));
	
	// ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ВидДвижения"	, 
	// "Вид движения", Новый ОписаниеТипов("ПеречислениеВидДвиженияНакопления"));.
	// Если регистр оборотный - вида движений не будет.
	Если МетаданныеРегистр.ВидРегистра <> Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты Тогда
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ВидДвижения"	, "Вид движения", мхо_ОписаниеТипов("ПеречислениеСсылка.бит_ВидДвиженияНакопления"), Ложь);
	Иначе
		// Не добляем реквизит
	КонецЕсли;	
	
	
	// Заполним измерения, ресурсы и реквизиты
	
	МассивОбхода = Новый Массив;
	МассивОбхода.Добавить("Измерения");
	МассивОбхода.Добавить("Ресурсы");
	МассивОбхода.Добавить("Реквизиты");
	
	Для Каждого ЭлементОбхода Из МассивОбхода Цикл
		Для Каждого Реквизит Из МетаданныеРегистр[ЭлементОбхода] Цикл
			НоваяСтрока = ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, Реквизит.Имя, Реквизит.Синоним, мхо_ОписаниеТипов(Реквизит.Тип));
			НоваяСтрока.ЭтоИзмерение = ?(ЭлементОбхода = "Измерения",Истина,Ложь);
		КонецЦикла;
	КонецЦикла;
	
	Возврат ТаблицаРеквизитов;
	
КонецФункции // ПолучитьРеквизитыРегистраНакопления()

// Добавляет строку таблицы значений и заполняет ее поля переданными значениями.
// 
Функция ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов
	                                      , ИмяРеквизита
										  , Синоним
										  , ТипРеквизита
										  , Использование = Истина
										  , ЭтоСубконто   = Ложь
										  , Балансовый = Истина) Экспорт
	
	НовыйРеквизит = ТаблицаРеквизитов.Добавить();
	НовыйРеквизит.ИмяРеквизита 	= ИмяРеквизита;
	НовыйРеквизит.Синоним		= Синоним;
	НовыйРеквизит.Тип			= ТипРеквизита;
	НовыйРеквизит.Использование = Использование;
	НовыйРеквизит.ЭтоСубконто   = ЭтоСубконто;
	НовыйРеквизит.Балансовый    = Балансовый;
	
	Возврат НовыйРеквизит;
	
КонецФункции // ЗаполнитьСвойстваНовогоРеквизита()

// Возвращает описание переданных в качестве параметров типов + описание типа "Строка(900)".
// 
// Параметры:
//  ТипДанныхСтрокаМассив  - "Строка" Или "Массив" типов или "ОписаниеТипов".
// 
// Возвращаемое значение:
//   Описание типов.
// 
Функция мхо_ОписаниеТипов(ТипДанныхСтрокаМассив) Экспорт

	МассивТипов = Новый Массив;
	КС 			= Новый КвалификаторыСтроки(900);
	КЧ			= Неопределено;
	КД          = Неопределено;
	
	Если ТипЗнч(ТипДанныхСтрокаМассив) = Тип("Строка") Тогда
		МассивТипов.Добавить(Тип(ТипДанныхСтрокаМассив));
	ИначеЕсли ТипЗнч(ТипДанныхСтрокаМассив) = Тип("Массив") Тогда
		МассивТипов = ТипДанныхСтрокаМассив;
	Иначе
		МассивТипов = ТипДанныхСтрокаМассив.Типы();
		КЧ 			= ТипДанныхСтрокаМассив.КвалификаторыЧисла;
		КД 			= ТипДанныхСтрокаМассив.КвалификаторыДаты;
	КонецЕсли;
	
	// В любом случае, добавим тип "Строка"
	// МассивТипов.Добавить(Тип("Строка"));.
	
	Если КЧ = Неопределено Тогда
		НовоеОписаниеТипов = Новый ОписаниеТипов(МассивТипов,, КС);
	Иначе // В качестве параметра было передано описание типов. Необходимо учесть его квалификаторы.
		НовоеОписаниеТипов = Новый ОписаниеТипов(МассивТипов, КД, КС, КЧ);
	КонецЕсли;

	Возврат НовоеОписаниеТипов;
	
КонецФункции // Мхо_ОписаниеТипов()

// Дополняет таблицу реквизитов движений предопределенными.
// 
// Параметры:
//  ТаблицаРеквизитов - Таблица значений.
// 
Процедура ДополнитьТаблицуПредопределеннымиРеквизитамиДвижений(ТаблицаРеквизитов,ДобавитьДтКТ,Приемник) Экспорт

	Если ДобавитьДтКТ Тогда	
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ДтКт", "Дт/Кт", Новый ОписаниеТипов("ПеречислениеСсылка.бит_ВидыСоответствия"), Ложь);	
	КонецЕсли; 
	
	// Реквизиты для условий
	Для жи = 1 По 3 Цикл
		Строка250 = ОбщегоНазначения.ОписаниеТипаСтрока(250);
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "Условие" + Строка(жи), "Условие №" + Строка(жи), Строка250, Ложь);
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ВидСравнения" + Строка(жи), "Вид сравнения", Новый ОписаниеТипов("ПеречислениеСсылка.бит_ВидыСравненияТрансляции"), Ложь);
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "Значение" + Строка(жи), "Значение №" + Строка(жи), ОписаниеПроизвольногоТипа(), Ложь);
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ОбъединениеСПоследующим" + Строка(жи), "и/или", Новый ОписаниеТипов("ПеречислениеСсылка.бит_ТипыОбъединенияУсловий"), Ложь);
	КонецЦикла;
	
	// Произвольное условие
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ПроизвольноеУсловие", "Произвольное условие", мхо_ОписаниеТипов("Строка"), Ложь);
	
	// Произвольный код
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ПроизвольныйКод", "Произвольный код", мхо_ОписаниеТипов("Строка"), Истина);
	
	// Дополнительное поле
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ДополнительноеПоле", "Дополнительное поле", ОписаниеПроизвольногоТипа(), Истина);
	
	// Дополнительные счета
	Если Приемник.ВидОбъекта = Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии Тогда
		
		ИмяПланаСчетов = Метаданные.РегистрыБухгалтерии[Приемник.ИмяОбъекта].ПланСчетов.Имя;
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ДополнительноеПоле_Счет", "Дополнительный счет", Новый ОписаниеТипов("ПланСчетовСсылка."+ИмяПланаСчетов), Истина);
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ДополнительноеПоле_СчетДт", "Дополнительный счет Дт", Новый ОписаниеТипов("ПланСчетовСсылка."+ИмяПланаСчетов), Истина);	
		ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ДополнительноеПоле_СчетКт", "Дополнительный счет Кт", Новый ОписаниеТипов("ПланСчетовСсылка."+ИмяПланаСчетов), Истина);	
		
	КонецЕсли; 
	
	// Коэффициенты для суммы и количества
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "КоэффициентСумма"     , "Коэф. сумма"            , Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(12, 9)), Истина);
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "КоэффициентКоличество", "Коэф. количество"       , Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(12, 9)), Истина);

	// Признак заполнения аналитики корр. части
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ИспользоватьАналитикуКорр","Использовать аналитику корр. счета", мхо_ОписаниеТипов("Булево"), Истина);
	// Использовать исторические курсы
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ИспользоватьИсторическиеКурсы","Использовать исторические курсы", мхо_ОписаниеТипов("Булево"),Истина);
	// Шаблон МХО
	ЗаполнитьСвойстваНовогоРеквизита(ТаблицаРеквизитов, "ШаблонДвижений", "Шаблон движений", мхо_ОписаниеТипов("СправочникСсылка.бит_ШаблоныДвижений"), Истина);
	
КонецПроцедуры // ДополнитьТаблицуПредопределеннымиРеквизитамиДвижений()

// Возвращает Описание типов (Строка, Число, Булево, Дата, ЛюбаяСсылка).
// 
// Возвращаемое значение:
//   ОписаниеТипов.
// 
Функция ОписаниеПроизвольногоТипа() Экспорт

	МассивТипов        = Новый Массив;
    МассивТипов.Добавить(Тип(Новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(15, 2))));
    МассивТипов.Добавить(Тип(Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(999)))); 
    МассивТипов.Добавить(Тип(Новый ОписаниеТипов("Дата",,,Новый КвалификаторыДаты()))); 
    МассивТипов.Добавить(Тип(Новый ОписаниеТипов("Булево")));
	
    Для Каждого ЭлементТипа Из Документы.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
    КонецЦикла;  
    Для Каждого ЭлементТипа Из Справочники.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
    КонецЦикла;  
    Для Каждого ЭлементТипа Из Перечисления.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
    КонецЦикла;  
    Для Каждого ЭлементТипа Из ПланыСчетов.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла;
	Для каждого ЭлементТипа Из ПланыОбмена.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 	
	Для каждого ЭлементТипа Из ПланыВидовХарактеристик.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 
	Для каждого ЭлементТипа Из ПланыВидовРасчета.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла;
	Для каждого ЭлементТипа Из БизнесПроцессы.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 	
	Для каждого ЭлементТипа Из Задачи.ТипВсеСсылки().Типы() Цикл
        МассивТипов.Добавить(ЭлементТипа);      
	КонецЦикла; 

	Возврат Новый ОписаниеТипов(МассивТипов);
	
КонецФункции // ОписаниеПроизвольногоТипа()

// Функция инициализирует таблицу реквизитов.
// 
// Возвращаемое значение:
//   ТаблицаРеквизитов   - ТаблицаЗначений.
// 
Функция ИнициализироватьТаблицуРеквизитов()  Экспорт
	
	ОписаниеБулево = Новый ОписаниеТипов("Булево");
	
	ТаблицаРеквизитов = Новый ТаблицаЗначений;
	ТаблицаРеквизитов.Колонки.Добавить("ИмяРеквизита");
	ТаблицаРеквизитов.Колонки.Добавить("Синоним");
	ТаблицаРеквизитов.Колонки.Добавить("Тип");
	ТаблицаРеквизитов.Колонки.Добавить("Использование",ОписаниеБулево);
	ТаблицаРеквизитов.Колонки.Добавить("ЭтоСубконто"  ,ОписаниеБулево);
	ТаблицаРеквизитов.Колонки.Добавить("ЭтоИзмерение" ,ОписаниеБулево);	
	ТаблицаРеквизитов.Колонки.Добавить("Балансовый"   ,ОписаниеБулево);
	
	Возврат ТаблицаРеквизитов;
	
КонецФункции

#КонецОбласти

#Область ПрочиеПроцедурыИФункцииМеханизмаАвтозаполненияПоСоответствиям
 
// Функция получает сответствие статей регламентированного учета и статей затрат.
// 
// Возвращаемое значение:
//   РезСоответствие   - Соответствие.
// 
Функция ПолучитьСоответствиеСтатьиРеглСтатьи() Экспорт

	РезСоответствие = Новый Соответствие;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	бит_СтатьиОборотов_СтатьиРегл.СтатьяРегл КАК СтатьяРегл,
	               |	бит_СтатьиОборотов_СтатьиРегл.СчетУчетаБУ КАК СчетУчетаБУ,
	               |	бит_СтатьиОборотов_СтатьиРегл.СтатьяОборотов КАК СтатьяОборотов
	               |ИЗ
	               |	РегистрСведений.бит_СтатьиОборотов_СтатьиРегл КАК бит_СтатьиОборотов_СтатьиРегл
	               |ИТОГИ
	               |	МАКСИМУМ(СтатьяОборотов)
	               |ПО
	               |	СтатьяРегл,
	               |	СчетУчетаБУ";
				   
	Результат = Запрос.Выполнить();
	
	ВыборкаР = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ВыборкаР.Следующий() Цикл
	
		 ВыборкаС = ВыборкаР.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		 
		 ВнутрСоотв = Новый Соответствие;
		 Пока ВыборкаС.Следующий() Цикл
		 
		 	  ВнутрСоотв.Вставить(ВыборкаС.СчетУчетаБУ, ВыборкаС.СтатьяОборотов);
		 
		 КонецЦикла; 
		 
		 РезСоответствие.Вставить(ВыборкаР.СтатьяРегл, ВнутрСоотв); 
	
	КонецЦикла; 

	Возврат РезСоответствие;
	
КонецФункции // ПолучитьСоответствиеСтатьиРеглСтатьи()

// Функция получает соответствие подразделений и ЦФО.
// 
// 
// Возвращаемое значение:
//   РезСоответствие   - Соответствие.
// 
Функция ПолучитьСоответствиеПодразделенияЦФО() Экспорт

	РезСоответствие = Новый Соответствие;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	бит_ЦФО_Подразделения.ЦФО,
	               |	бит_ЦФО_Подразделения.Подразделение
	               |ИЗ
	               |	РегистрСведений.бит_ЦФО_Подразделения КАК бит_ЦФО_Подразделения";
				   
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
	
		РезСоответствие.Вставить(Выборка.Подразделение,Выборка.ЦФО);
	
	КонецЦикла; 

	Возврат РезСоответствие;
	
КонецФункции // ПолучитьСоответствиеПодразделенияЦФО()

// Функция получает соответствие подразделений и ЦФО в режиме синхронизации подразделений регл и ЦФО.
// 
// Возвращаемое значение:
//   РезСоответствие   - Соответствие.
// 
Функция ПолучитьСинхронизированныеПодразделенияЦФО() Экспорт

	РезСоответствие = Новый Соответствие;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	Подразделения.СтруктурнаяЕдиницаРегл КАК Подразделение,
	               |	Подразделения.Ссылка КАК ЦФО
	               |ИЗ
	               |	Справочник.Подразделения КАК Подразделения
	               |ГДЕ
	               |	Подразделения.СтруктурнаяЕдиницаРегл <> Неопределено";
				   
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если ЗначениеЗаполнено(Выборка.Подразделение) Тогда
			
			РезСоответствие.Вставить(Выборка.Подразделение,Выборка.ЦФО);
			
		КонецЕсли; 
	
	КонецЦикла; 

	Возврат РезСоответствие;
	
КонецФункции // ПолучитьСинхронизированныеПодразделенияЦФО()

// Функция получает сответствие номенклатурных групп и статей оборотов.
// 
// Возвращаемое значение:
//   РезСоответствие   - Соответствие.
// 
Функция ПолучитьСоответствиеНомГруппыСтатьи() Экспорт

	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	бит_СтатьиОборотов_НоменклатурныеГруппы.СчетУчетаБУ КАК СчетУчетаБУ,
	               |	бит_СтатьиОборотов_НоменклатурныеГруппы.НоменклатурнаяГруппа КАК НоменклатурнаяГруппа,
	               |	бит_СтатьиОборотов_НоменклатурныеГруппы.СтатьяОборотов КАК СтатьяОборотов
	               |ИЗ
	               |	РегистрСведений.бит_СтатьиОборотов_НоменклатурныеГруппы КАК бит_СтатьиОборотов_НоменклатурныеГруппы
	               |ИТОГИ
	               |	МАКСИМУМ(СтатьяОборотов)
	               |ПО
	               |	НоменклатурнаяГруппа,
	               |	СчетУчетаБУ";
				   
	Результат = Запрос.Выполнить();
	
	РезСоответствие = Новый Соответствие;
	
	ВыборкаН = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ВыборкаН.Следующий() Цикл
	
		 ВыборкаС = ВыборкаН.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		 
		 ВнутрСоотв = Новый Соответствие;
		 Пока ВыборкаС.Следующий() Цикл
		 
		 	  ВнутрСоотв.Вставить(ВыборкаС.СчетУчетаБУ, ВыборкаС.СтатьяОборотов);
		 
		 КонецЦикла; 
		 
		 РезСоответствие.Вставить(ВыборкаН.НоменклатурнаяГруппа, ВнутрСоотв); 
	
	КонецЦикла; 
	
	Возврат РезСоответствие;
	
КонецФункции // ПолучитьСоответствиеСтатьиРеглСтатьи()

// Функция выполняет поиск в соответствии аналитик. Поиск выполняется по значению поиска 
// и если соответствие двухуровневое, то по СчетуУчетаБУ.
// 
// Параметры:
//  ЗначениеПоиска - Произвольный.
//  СчетПоиска - ПланыСчетовСсылка.Хозрасчетный.
// 
// Возвращаемое значение:
//  РезЗнч - Произвольный.
// 
Функция ИзвлечьИзСоответствия(ЗначениеПоиска, СчетПоиска, СоотвАвтозаполнения) Экспорт
	
	ЗнВрем = СоотвАвтозаполнения[ЗначениеПоиска];
	Если ТипЗнч(ЗнВрем) = Тип("Соответствие") Тогда
		
		РезЗнч = ЗнВрем[СчетПоиска];
		Если НЕ ЗначениеЗаполнено(РезЗнч) Тогда
			
			РезЗнч = ЗнВрем[ПланыСчетов.Хозрасчетный.ПустаяСсылка()];
			
		КонецЕсли; 
		
	Иначе	
		
		РезЗнч = ЗнВрем;
		
	КонецЕсли;	
	
	Возврат РезЗнч;
	
КонецФункции // ИзвлечьИзСоответствия()

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Процедура разбирает строку с разделителями и упаковывает значения в массив.
// 
// Параметры:
//  ИсходнаяСтрока  - Строка.
//  Разделитель     - Строка.
// 
Функция РазобратьСтрокуСРазделителями(ИсходнаяСтрока,Разделитель) Экспорт
	
	Возврат бит_ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСРазделителями(ИсходнаяСтрока,Разделитель);
	
КонецФункции // РазобратьУсловие()

// Добавляет новую строку "СтрокаТекста" к тексту "Текст".
// 
// Параметры:
//  Текст - текст
// 	СтрокаТекста - добавляемая строка.
// 
Процедура ДобавитьСтрокуКТексту(Текст, СтрокаТекста) Экспорт

	Текст = Текст + ?(СокрЛП(Текст) = "", "", Символы.ПС) + СтрокаТекста;

КонецПроцедуры // ДобавитьСтрокуКТексту()

// Функция получает колонки трансляции по настройке конструктора правил трансляции.
// 
// Параметры:
//  НастройкаПравилТрансляции  - СправочникСсылка.бит_СтруктураКонструктораПравилТрансляции.
// 
// Возвращаемое значение:
//   ТаблицаКолонки   - ТаблицаЗначений.
//   ДобавитьСлужебныеКолонки - Булево.
// 
Функция ПолучитьКолонкиТрансляции(НастройкаПравилТрансляции, ДобавитьСлужебныеКолонки = Ложь) Экспорт
 
    Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Таблица.Ссылка КАК Ссылка,
	|	Таблица.НомерСтроки КАК НомерСтроки,
	|	Таблица.ИмяКолонки КАК ИмяКолонки,
	|	Таблица.ИмяРеквизита КАК ИмяРеквизита,
	|	Таблица.ВидКолонки КАК ВидКолонки,
	|	Таблица.ТипыЗначений КАК ТипыЗначений,
	|	Таблица.ТипыЗначенийСтр КАК ТипыЗначенийСтр,
	|	Таблица.НомерКолонки КАК НомерКолонки,
	|	Таблица.ПоложениеКолонки КАК ПоложениеКолонки,
	|	Таблица.ШиринаКолонки КАК ШиринаКолонки,
	|	Таблица.НеБалансовый КАК НеБалансовый,
	|	Таблица.ЭтоСубконто КАК ЭтоСубконто,
	|	Таблица.НаименованиеКолонки КАК НаименованиеКолонки,
	|	Таблица.КнопкаСпискаВыбора КАК КнопкаСпискаВыбора,
	|	Таблица.КнопкаВыбора КАК КнопкаВыбора,
	|	Таблица.КнопкаОткрытия КАК КнопкаОткрытия,
	|	Таблица.КнопкаОчистки КАК КнопкаОчистки,
	|	ИСТИНА КАК Видимость,
	|	ЛОЖЬ КАК ТолькоПросмотр
	|ИЗ
	|	Справочник.бит_СтруктураКонструктораПравилТрансляции.КолонкиПравилТрансляции КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	НомерКолонки";
	
    Запрос.УстановитьПараметр("Ссылка",НастройкаПравилТрансляции);				   
				   
	ТаблицаКолонки = Запрос.Выполнить().Выгрузить();
	
	// Необходимы для отрисовки
	ТаблицаКолонки.Колонки.Добавить("НачатьГруппу"      , Новый ОписаниеТипов("Булево"));
	ТаблицаКолонки.Колонки.Добавить("ЗакончитьГруппу"   , Новый ОписаниеТипов("Булево"));
	ТаблицаКолонки.Колонки.Добавить("ГруппировкаКолонок", Новый ОписаниеТипов("ГруппировкаКолонок"));
	ТаблицаКолонки.Колонки.Добавить("ТипыЗначенийВФорме", Новый ОписаниеТипов("ОписаниеТипов"));
	
	Для каждого СтрокаТаблицы Из ТаблицаКолонки Цикл
		ТипыЗначений = СтрокаТаблицы.ТипыЗначений.Получить();
		Если ТипЗнч(ТипыЗначений) = Тип("ОписаниеТипов") Тогда
			// Один (единственый) из типов удален.
			Если ТипыЗначений.Типы().Количество() = 0 Тогда
				ТипыЗначений = ОбщегоНазначения.ОписаниеТипаСтрока(100);
			КонецЕсли;
		Иначе	
			// Незаполнялось.
			ТипыЗначений = ОбщегоНазначения.ОписаниеТипаСтрока(100); 
		КонецЕсли; 		
		СтрокаТаблицы.ТипыЗначенийВФорме = ТипыЗначений;	
	КонецЦикла; 
	
	Если ДобавитьСлужебныеКолонки Тогда
		
		// Служебные колонки табличного поля настроек трансляции.
		НоваяСтрока = ТаблицаКолонки.Вставить(0);
		НоваяСтрока.НомерСтроки = -1;
		НоваяСтрока.ИмяКолонки = "НомерСтроки";
		НоваяСтрока.ИмяРеквизита = "НомерСтроки";
		НоваяСтрока.ТипыЗначенийСтр = "Число";
		НоваяСтрока.ТипыЗначенийВФорме = Новый ОписаниеТипов("Число");
		НоваяСтрока.ПоложениеКолонки = Перечисления.бит_ПоложенияКолонокТаблицы.НоваяКолонка;
		НоваяСтрока.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.Прочее;
		НоваяСтрока.НаименованиеКолонки = "№";
		НоваяСтрока.Видимость = Истина;
		НоваяСтрока.ТолькоПросмотр = Истина;
		
		НоваяСтрока = ТаблицаКолонки.Добавить();
		НоваяСтрока.НомерСтроки = 9999;
		НоваяСтрока.ИмяКолонки = "ИД";
		НоваяСтрока.ИмяРеквизита = "ИД";
		НоваяСтрока.ТипыЗначенийСтр = "Строка";
		НоваяСтрока.ТипыЗначенийВФорме = Новый ОписаниеТипов("Строка");
		НоваяСтрока.ПоложениеКолонки = Перечисления.бит_ПоложенияКолонокТаблицы.НоваяКолонка;
		НоваяСтрока.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.Прочее;		
		НоваяСтрока.НаименованиеКолонки = "ИД";
		НоваяСтрока.Видимость = Ложь;
		НоваяСтрока.ТолькоПросмотр = Истина;
	
	КонецЕсли; 
	
	Возврат ТаблицаКолонки;
	
КонецФункции // ПолучитьКолонкиТрансляции()

// Функция инициализирует структуру видов регистров источник и приемник.
// 
// Параметры:
//  ИсточникРегистрБухгалтерии - Булево.
//  ИсточникРегистрНакопления  - Булево.           
//  ПриемникРегистрБухгалтерии - Булево.
//  ПриемникРегистрНакопления  - Булево.
// 
// Возвращаемое значение:
//   ВидыРегистров   - Структура.
// 
Функция КонструкторСтруктурыВидыРегистров(ИсточникРегистрБухгалтерии  = Неопределено
	                                      ,ИсточникРегистрНакопления  = Неопределено
										  ,ПриемникРегистрБухгалтерии = Неопределено
										  ,ПриемникРегистрНакопления  = Неопределено)   Экспорт

	ВидыРегистров = Новый Структура("ИсточникРегистрБухгалтерии
								|,ИсточникРегистрНакопления
								|,ПриемникРегистрБухгалтерии
								|,ПриемникРегистрНакопления"
								,ИсточникРегистрБухгалтерии
								,ИсточникРегистрНакопления
								,ПриемникРегистрБухгалтерии
								,ПриемникРегистрНакопления);
								
								
	ВидыРегистров.Вставить("МетаданныеИсточника", Неопределено);
	ВидыРегистров.Вставить("МетаданныеПриемника", Неопределено);
	ВидыРегистров.Вставить("РежимИспользованияСоответствий", Неопределено);
								
								
	
 	Возврат ВидыРегистров;
				
КонецФункции // КонструкторСтруктурыВидыРегистров()

// Функция инициализирует структуру параметров правил трансляции.
// 
// Возвращаемое значение:
//   СтруктураПараметров   - Структура.
// 
Функция КонструкторСтруктурыПараметровТрансляции()  Экспорт

СтруктураПараметров = Новый Структура("ОбязательныеПоля
										|,ПравилоЗаполнения
										|,ПравилаТрансляции
										|,КодУсловияТрансляции
										|,СтруктураШапкиДокумента
										|,ПользовательскиеФункции
										|,ДополнительныеАналитики
										|,ПризнакиУчета
										|,ВидыРегистров
										|,МетаданныеИсточника
										|,МетаданныеПриемника
										|,МетаданныеРегистратора
										|,ЗаписыватьДвижения
										|,ВестиПротокол
										|,ОбъектСистемыИсточник
										|,ОбъектСистемыПриемник
										|,НаборСоответствие
										|,НаборСоответствиеОборотов
										|,ПараметрыАвтозаполнения
										|,ОчиститьПриемник
										|,РежимИспользованияСоответствий");
																								
СтруктураПараметров.ОчиститьПриемник = Истина;
																				
Возврат СтруктураПараметров;														

КонецФункции // КонструкторСтруктурыПараметровТрансляции()

// Функция получает ражим трансляции.
// 
// Параметры:
//  ОбъектСистемы      - СправочникСсылка.ОбъектыСистемы.
//  ТекущаяДата        - Дата.
//  Организация 	   - СправочникСсылка.Организации.
//  НастройкиТрансляции - ТаблицаЗначений.
// 
// Возвращаемое значение:
//   РежимТрансляции   - Перечисления.бит_РежимыТрансляции.OnLine.
// 
Функция ПолучитьРежимТрансляции( ТекущаяДата, ОбъектСистемы, Организация = Неопределено, НастройкиТрансляции = Неопределено) Экспорт

	РежимТрансляции = Перечисления.бит_РежимыТрансляции.НеВыполнять;
	
	Если НастройкиТрансляции = Неопределено Тогда
	
		НастройкиТрансляции = бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_НастройкиТрансляции");
	
	КонецЕсли; 

	ТаблицаДанных = Новый ТаблицаЗначений;
	ТаблицаДанных.Колонки.Добавить("Период"       ,Новый ОписаниеТипов("Дата"));
	ТаблицаДанных.Колонки.Добавить("ОбъектСистемы",Новый ОписаниеТипов("СправочникСсылка.бит_ОбъектыСистемы"));
	ТаблицаДанных.Колонки.Добавить("Организация"  ,Новый ОписаниеТипов("СправочникСсылка.Организации"));
	ТаблицаДанных.Колонки.Добавить("Режим"        ,Новый ОписаниеТипов("ПеречислениеСсылка.бит_РежимыТрансляции"));
	
	Для каждого СтрокаТаблицы Из НастройкиТрансляции Цикл
	
		НоваяСтрока = ТаблицаДанных.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаТаблицы);
	
	КонецЦикла; 
	
	Запрос = Новый Запрос();
	
	Запрос.УстановитьПараметр("ОбъектСистемы",ОбъектСистемы);
	Запрос.УстановитьПараметр("Организация"  ,Организация);
	Запрос.УстановитьПараметр("ТекущаяДата"  ,ТекущаяДата);
	Запрос.УстановитьПараметр("ТаблицаДанных",ТаблицаДанных);
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТаблицаДанных.Период,
	               |	ТаблицаДанных.ОбъектСистемы,
	               |	ТаблицаДанных.Организация,
	               |	ТаблицаДанных.Режим
	               |ПОМЕСТИТЬ ТаблицаДанных
	               |ИЗ
	               |	&ТаблицаДанных КАК ТаблицаДанных
	               |ГДЕ
	               |	(ТаблицаДанных.Организация = &Организация
	               |			ИЛИ ТаблицаДанных.Организация = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	               |			ИЛИ ТаблицаДанных.Организация = НЕОПРЕДЕЛЕНО)
	               |	И (ТаблицаДанных.ОбъектСистемы = &ОбъектСистемы
	               |			ИЛИ ТаблицаДанных.ОбъектСистемы = НЕОПРЕДЕЛЕНО
	               |			ИЛИ ТаблицаДанных.ОбъектСистемы = ЗНАЧЕНИЕ(Справочник.бит_ОбъектыСистемы.ПустаяСсылка))
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ТаблицаДанных.ОбъектСистемы,
	               |	ТаблицаДанных.Организация,
	               |	МАКСИМУМ(ТаблицаДанных.Период) КАК Период
	               |ПОМЕСТИТЬ ТаблицаДат
	               |ИЗ
	               |	ТаблицаДанных КАК ТаблицаДанных
	               |ГДЕ
	               |	ТаблицаДанных.Период <= &ТекущаяДата
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	ТаблицаДанных.ОбъектСистемы,
	               |	ТаблицаДанных.Организация
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ТаблицаДат.Период,
	               |	ТаблицаДанных.ОбъектСистемы,
	               |	ТаблицаДанных.Организация,
	               |	ТаблицаДанных.Режим,
	               |	ВЫБОР
	               |		КОГДА ТаблицаДанных.Организация = НЕОПРЕДЕЛЕНО
	               |				ИЛИ ТаблицаДанных.Организация = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	               |			ТОГДА ВЫБОР
	               |					КОГДА ТаблицаДанных.ОбъектСистемы = НЕОПРЕДЕЛЕНО
	               |							ИЛИ ТаблицаДанных.ОбъектСистемы = ЗНАЧЕНИЕ(Справочник.бит_ОбъектыСистемы.ПустаяСсылка)
	               |						ТОГДА 4
	               |					ИНАЧЕ 3
	               |				КОНЕЦ
	               |		ИНАЧЕ ВЫБОР
	               |				КОГДА ТаблицаДанных.ОбъектСистемы = НЕОПРЕДЕЛЕНО
	               |						ИЛИ ТаблицаДанных.ОбъектСистемы = ЗНАЧЕНИЕ(Справочник.бит_ОбъектыСистемы.ПустаяСсылка)
	               |					ТОГДА 2
	               |				ИНАЧЕ 1
	               |			КОНЕЦ
	               |	КОНЕЦ КАК Приоритет
	               |ИЗ
	               |	ТаблицаДат КАК ТаблицаДат
	               |		ЛЕВОЕ СОЕДИНЕНИЕ ТаблицаДанных КАК ТаблицаДанных
	               |		ПО ТаблицаДат.Период = ТаблицаДанных.Период
	               |			И ТаблицаДат.ОбъектСистемы = ТаблицаДанных.ОбъектСистемы
	               |			И ТаблицаДат.Организация = ТаблицаДанных.Организация
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Приоритет
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |УНИЧТОЖИТЬ ТаблицаДанных
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |УНИЧТОЖИТЬ ТаблицаДат";
				   
				   
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Если Выборка.Следующий() Тогда
	
		РежимТрансляции = Выборка.Режим;
	
	КонецЕсли; 
	
	Возврат РежимТрансляции;
	
КонецФункции // ПолучитьНастройкиТрансляции()

// Процедура очищает соответствие движений для указанных Источника и Приемника.
// 
// Параметры:
//  НаборСоответствие  - РегистрСведенийНаборЗаписей.бит_СоответствиеЗаписейТрансляции.
//						 РегистрНакопленийНаборЗаписей.бит_СоответствиеОборотовТрансляции.
//  Источник           - СправочникСсылка.бит_ОбъектыСистемы.
//  Приемник           - СправочникСсылка.бит_ОбъектыСистемы.
// 
Процедура ОчиститьСоответствиеДвижений(НаборСоответствие, Источник = Неопределено, Приемник) Экспорт
	
	КоличествоСоответствие = НаборСоответствие.Количество();
	
	Для Сч = 1 По КоличествоСоответствие Цикл
		
		Номер = КоличествоСоответствие - Сч;		
		ТекЗапись = НаборСоответствие[Номер];
		
		// Т.к. набор-приемник очищается перед выполнение трансляции, 
		// то и все соответствия номеров по данному приемнику очищаем. 
	    // Иначе могут остаться соответствия от прошлых итерация, движения которых не будут записаны.
		Если ТекЗапись.Приемник = Приемник Тогда
			
			НаборСоответствие.Удалить(ТекЗапись);
			
		КонецЕсли; 
		
	КонецЦикла;  // По записям регистра  	
	
КонецПроцедуры // ОчиститьСоответствиеДвижений()

// Процедура очищает соответствие движений для указанных Источника и Приемника.
// 
// Параметры:
//  НаборСоответствие - РегистрНакопленийНаборЗаписей.бит_ОборотыПоТипамПроводок.
//  Приемник 		  - СправочникСсылка.бит_ОбъектыСистемы.
// 
Процедура ОчиститьСоответствиеДвиженийПоТипуПроводки(НаборСоответствие, Приемник) Экспорт
	
	КоличествоСоответствие = НаборСоответствие.Количество();
	
	Для Сч = 1 По КоличествоСоответствие Цикл
		
		Номер = КоличествоСоответствие - Сч;		
		ТекЗапись = НаборСоответствие[Номер];
		
		// Т.к. набор-приемник очищается перед выполнение трансляции, 
		// то и все соответствия номеров по данному приемнику очищаем. 
	    // Иначе могут остаться соответствия от прошлых итерация, движения которых не будут записаны.
		Если ТекЗапись.РегистрБухгалтерии = Приемник Тогда
			
			НаборСоответствие.Удалить(ТекЗапись);
			
		КонецЕсли; 
				
	КонецЦикла;  // По записям регистра  	
	
КонецПроцедуры // ОчиститьСоответствиеДвиженийПоТипуПроводки()

// Функция формирует имя аналитики БИТ.
// 
// Параметры:
//  АналитикаСсылка  - ПланВидовХарактеристикСсылка.бит_ВидыДополнительныхАналитик.
// 
// Возвращаемое значение:
//   ИмяАналитики   - Строка.
// 
Функция СформироватьИмяАналитики(АналитикаСсылка,ВерхнийРегистр = Ложь) Экспорт

	ИмяАналитики = "";
	
	Если АналитикаСсылка.Предопределенный Тогда
		
		ИмяАналитики    = ПланыВидовХарактеристик.бит_ВидыДополнительныхАналитик.ПолучитьИмяПредопределенного(АналитикаСсылка);
		
	Иначе
		
		ИмяАналитики = СокрЛП(АналитикаСсылка.Код);
		ИмяАналитики = СтрЗаменить(ИмяАналитики," ","");
		
	КонецЕсли; 	
	
	Если ВерхнийРегистр Тогда
	
		ИмяАналитики = ВРег(ИмяАналитики);
	
	КонецЕсли; 
	
	Возврат ИмяАналитики;
	
КонецФункции // СформироватьИмяАналитики()

// Функция выполняет поиск вида субконто.
// 
// Параметры:
//  ИмяПВХ  - Строка.
//  ИмяСубконто - Строка.
// 
// Возвращаемое значение:
//  ВидСубконто - ПланВидовХарактеристикСсылка.
// 
Функция НайтиВидСубконто(ИмяПВХ,ИмяСубконто) Экспорт
	
	ПВХ = ПланыВидовХарактеристик[ИмяПВХ];
	
	ВидСубконто = ПВХ.ПустаяСсылка();
	
	Попытка
		
		// Предопределенные субконто получаем по имени.
		ВидСубконто = ПВХ[ИмяСубконто];
	
	Исключение
	
	КонецПопытки;
	
	Если НЕ ЗначениеЗаполнено(ВидСубконто) Тогда
		
		// Субконто оказалось не предопределенным
		
		Если Найти(ИмяПВХ,"бит_ВидыСубконтоДополнительные_")>0 
			 ИЛИ Найти(ИмяПВХ,"бит_ВидыСубконтоБюджетирования")>0 Тогда
			 
			 // Для субконто БИТ выполняем имя записано в код.
			 ВидСубконто = ПВХ.НайтиПоКоду(ИмяСубконто);
			 
		Иначе	
			
			 // Другие непредопределенные субконто ищем по наименованию.
			 ВидСубконто = ПВХ.НайтиПоНаименованию(ИмяСубконто);
			
		КонецЕсли; 
	
	КонецЕсли; 

	Возврат ВидСубконто;
	
КонецФункции // НайтиВидСубконто()

// Функция получает имя субконто. Для предопределенных это имя, 
// заданное в конфигураторе, для не предопределенных БИТ - код, для остальных наименование.
// 
// Параметры:
//  ИмяПВХ  - Строка.
//  СубконтоСсылка  - ПланВидовХарактеристикСсылка.
// 
// Возвращаемое значение:
//   ИмяСубконто   - Строка.
// 
Функция ПолучитьИмяСубконто(ИмяПВХ,СубконтоСсылка) Экспорт

	Если СубконтоСсылка.Предопределенный Тогда
		
		// Для предопределенных - имя
		ИмяСубконто    = ПланыВидовХарактеристик[ИмяПВХ].ПолучитьИмяПредопределенного(СубконтоСсылка);
		
	Иначе	
		
		Если Найти(ИмяПВХ,"бит_ВидыСубконтоДополнительные_") > 0 
			ИЛИ Найти(ИмяПВХ,"бит_ВидыСубконтоБюджетирования")>0 Тогда
			
			// Не предопределенные БИТ - код
			ИмяСубконто =  СокрЛП(СубконтоСсылка.Код);
			
		Иначе
			
			// Остальные - наименование
			ИмяСубконто = СокрЛП(СубконтоСсылка.Наименование);
			
		КонецЕсли; 
		
	КонецЕсли; 	

	Возврат ИмяСубконто;
	
КонецФункции // СформироватьИмяСубконто()

// Инициализирует колонки таблицы, используемой для визуального представления настроек правил трансляции.
// 
// Параметры:
//  ТаблицаНастройки - ТаблицаЗначений.
//  ТаблицаКолонки   - ТаблицаЗначений.
//  ВидыКолонок           - Массив.
// 
Процедура ИнициализироватьТаблицуНастройки(ТаблицаНастройки,ТаблицаКолонки,ВидыКолонок = Неопределено)  Экспорт
	
	ТаблицаНастройки.Колонки.Очистить();
	
	Для каждого СтрокаОписание Из ТаблицаКолонки Цикл
		
		// Фильтр по виду колонок
		Если ТипЗнч(ВидыКолонок) = Тип("Массив") Тогда
			
			Если ВидыКолонок.Найти(СтрокаОписание.ВидКолонки) = Неопределено Тогда
				
				Продолжить;
				
			КонецЕсли; 
			
		КонецЕсли;  
		
		ТекОписание = СтрокаОписание.ТипыЗначений.Получить();
		Если ТипЗнч(ТекОписание) <> Тип("ОписаниеТипов") Тогда
			
			ТекОписание = ОписаниеПроизвольногоТипа();
			
		КонецЕсли; 
		
		ТаблицаНастройки.Колонки.Добавить(СтрокаОписание.ИмяКолонки,ТекОписание);
		
	КонецЦикла; // По таблице колонок
	
	
	// Добавим колонку обязательную колонку ИД
	ИмяКолонки = "ИД";
	ТекОписание = Новый ОписаниеТипов("Строка");
	ТаблицаНастройки.Колонки.Добавить(ИмяКолонки,ТекОписание);
	
	
КонецПроцедуры // НарисоватьКолонки()
 
Процедура КонтрольПоРучнойКорректировкеФакта(Объект, ЗаписыватьДвижения) Экспорт

	Если НЕ ЕстьРучноеРедактированиеФакта(Объект) Тогда
		Возврат;	
	КонецЕсли; 
	
	ПараметрыПередачи = Объект.ДополнительныеСвойства.ПараметрыРучногоРедактированияФакта;
	НаборСоответствие = ПараметрыПередачи.бит_СоответствиеЗаписейТрансляции;
	НаборОбороты      = ПараметрыПередачи.бит_ОборотыПоБюджетам;

	Если НЕ Объект.Движения.бит_ОборотыПоБюджетам.Количество() = НаборОбороты.Количество() Тогда
		ПриОтказеОтТрансляцииПриПроведении(Объект, ЗаписыватьДвижения);
	КонецЕсли; 
	
КонецПроцедуры
 
// Очищает поля в наборе записей "Обороты по бюджетам" по настройкам измерения "Статья оборотов".
//
// Параметры:
//  Источник - РегистрНакопленияНаборЗаписей - наборе записей "Обороты по бюджетам".
//
Процедура ОчиститьНеиспользуемыеПоляОборотыПоБюджетам(Источник) Экспорт 
	// 28.02.2017  BF-619
	
	Измерения       = бит_Бюджетирование.ПолучитьИзмеренияБюджетирования("Произвольные", "Синоним");
	НастройкиСтатей = Новый Соответствие(); 
	
	// Настройки для пустой статьи
	НастройкиПустойСтатьи = Новый Структура;
	НастройкиПустойСтатьи.Вставить("Измерения", Новый Структура);
	НастройкиПустойСтатьи.Вставить("Учет_Сумма", Ложь);
	НастройкиПустойСтатьи.Вставить("Учет_Количество", Ложь);

	Для каждого Измерение Из Измерения Цикл
		НастройкиИзмерений = Новый Структура("Имя, Учет, Обязательный, ИмяТипаПоУмолчанию, ТипПоУмолчанию", Измерение.Ключ, Ложь, Ложь, "", Неопределено);
		НастройкиПустойСтатьи.Измерения.Вставить(Измерение.Ключ, НастройкиИзмерений);
	КонецЦикла; 
	
	Для каждого Запись Из Источник Цикл
		НастройкиСтатьи = НастройкиСтатей.Получить(Запись.СтатьяОборотов);
		Если НастройкиСтатьи = Неопределено Тогда
			НастройкиСтатьи = Справочники.бит_СтатьиОборотов.ПолучитьНастройки(Запись.СтатьяОборотов);
			НастройкиСтатей.Вставить(Запись.СтатьяОборотов, НастройкиСтатьи);
		КонецЕсли; 
		
		бит_Бюджетирование.УстановитьИспользованиеРесурсов(Запись, НастройкиСтатьи);
		Если ЗначениеЗаполнено(Запись.СтатьяОборотов) Тогда
			бит_Бюджетирование.УстановитьИспользованиеАналитики(Запись, НастройкиСтатьи, Измерения);
		Иначе	
			бит_Бюджетирование.УстановитьИспользованиеАналитики(Запись, НастройкиПустойСтатьи, Измерения);
		КонецЕсли; 		
	КонецЦикла; 

КонецПроцедуры //ОчиститьНеиспользуемыеПоляОборотыПоБюджетам
 
#КонецОбласти

// Процедура обработчик подписки "бит_ОбработкаПроведенияТрансляция" на событие  "ОбработкаПроведения".
// 
// Параметры:
// Источник        - ДокументОбъект
// Отказ           - Булево
// РежимПроведения - РежимПроведенияДокумента. 
// 
Процедура бит_ОбработкаПроведенияТрансляцияОбработкаПроведения(Источник, Отказ, РежимПроведения) Экспорт
	
	Если Отказ Тогда		
		Возврат;		
	КонецЕсли; 
	
	Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_ЭтоЧужойПодчиненныйУзел") = Истина Тогда
		Возврат;
	КонецЕсли; 			
	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2017-08-09 (#2836)
	Если ОК_ПодпискиНаСобытия.ЭтоИзменениеРеквизитовОбъектаБезПроведения(Источник) Тогда
		Возврат;
	КонецЕсли;
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2017-08-09 (#2836)
	
	// +СБ. Широков Николай. 2014-10-06. Оптимизация
	ТипИсточника = ТипЗнч(Источник);
	Если ТипИсточника = Тип("ДокументОбъект.бит_ЗаявкаНаРасходованиеСредств")
		ИЛИ ТипИсточника = Тип("ДокументОбъект.бит_ПлатежнаяПозиция") Тогда
		Возврат;
	КонецЕсли;
	// -СБ. Широков Николай
	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2020-06-29 (#3794)
	Если ТипИсточника = Тип("ДокументОбъект.бит_ПереоценкаВалютныхДенежныхСтатей") Тогда
		Если Источник.ОбъектСистемы = Справочники.бит_ОбъектыСистемы.НайтиПоКоду("000001024") Тогда 
			Возврат;
		КонецЕсли;
	КонецЕсли;
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2020-06-29 (#3794)
	
	МетаданныеИсточника = Источник.Метаданные();		
	
	флЗаписывать = ?(МетаданныеИсточника.Имя = "ЗакрытиеМесяца" , Истина, Ложь);
	
	ОтображатьПротокол = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОтображатьПротоколТрансляции"
												, бит_ОбщиеПеременныеСервер.ЗначениеПеременной("глТекущийПользователь"));	
												
	// БИТ_YK_н 01/16
	НаборДвДопПоЗависОборотам = Источник.Движения.Найти("битСтатьиОборотовПоЗависимымОборотам");
	Если НаборДвДопПоЗависОборотам <> Неопределено Тогда
		НаборДвДопПоЗависОборотам.Прочитать();
		НаборДвДопПоЗависОборотам.Очистить();
	КонецЕсли;
	// БИТ_YK_к
	
	//БИТ Тртилек 22.06.2012 добавим дополнительное свойство, чтобы понимать, что документ по подписке и запустим трансл по очередям
	Источник.ДополнительныеСвойства.Вставить("ДокументПоПодписке",);
	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2020-06-29 (#3794)
	//НаборЗаписейОчередность = РегистрыСведений.бит_му_Настройки.СоздатьНаборЗаписей();
	//НаборЗаписейОчередность.Отбор.ИмяНастройки.Установить("Последовательность онлайн трансляции");
	//НаборЗаписейОчередность.Прочитать();
	
	//Если ТипЗнч(Источник) = Тип("ДокументОбъект.бит_ПереоценкаВалютныхДенежныхСтатей") Тогда
	//	Если Источник.ОбъектСистемы = Справочники.бит_ОбъектыСистемы.НайтиПоКоду("000001024") Тогда 
	//		Возврат;
	//	КонецЕсли;
	//КонецЕсли;
	
	//Если НаборЗаписейОчередность.Количество() > 0 Тогда 
	//	СтрокаОчередностей = НаборЗаписейОчередность[0].Значение;
	//КонецЕсли;
	//
	//СписокОчередностей = Новый СписокЗначений;
	
	Если ТипЗнч(Источник) = Тип("ДокументОбъект.ок_ОперацияБОСС") Тогда
		СтрокаОчередностей = бит_БК_Общий.ПолучитьЗначениеНастройкиМеханизмаИмпортаДанных("РегламентнаяТрансляцияОперацийАксапты", "ОчередностьПравил");
		СписокОчередностей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаОчередностей, ";");
	Иначе
		НаборЗаписейОчередность = РегистрыСведений.бит_му_Настройки.СоздатьНаборЗаписей();
		НаборЗаписейОчередность.Отбор.ИмяНастройки.Установить("Последовательность онлайн трансляции");
		НаборЗаписейОчередность.Прочитать();
		
		Если НаборЗаписейОчередность.Количество() > 0 Тогда 
			СтрокаОчередностей = НаборЗаписейОчередность[0].Значение;
			СписокОчередностей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаОчередностей, ",");
		КонецЕсли;
	КонецЕсли;	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2020-06-29 (#3794)
	
	Если СтрокаОчередностей <> Неопределено тогда
		
		//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2020-06-29 (#3794)
		//Пока СтрокаОчередностей <> "" Цикл
		//	ЗапятаяПорядок = Найти(СтрокаОчередностей, ",");
		//	Если ЗапятаяПорядок <> 0 Тогда
		//		Номер = Число(СокрЛП(Лев(СтрокаОчередностей,ЗапятаяПорядок-1)));
		//		СтрокаОчередностей = Сред(СтрокаОчередностей, ЗапятаяПорядок+1, 100);
		//	Иначе
		//		Номер = Число(СокрЛП(СтрокаОчередностей));
		//		СтрокаОчередностей = "";
		//	КонецЕсли;		
		//	СписокОчередностей.Добавить(Номер, Строка(Номер));
		//КонецЦикла;
		//
		//СписокОчередностей.СортироватьПоЗначению(НаправлениеСортировки.Возр);
		
		//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2020-06-29 (#3794)
		
		Для Каждого Очередность Из СписокОчередностей Цикл
			
			//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2020-06-29 (#3794)
			Если ОК_ОбщегоНазначения.ПроверитьСтрокаВЧисло(Очередность) Тогда 
				Очередность	= Число(Очередность);
			Иначе 
				Продолжить;
			КонецЕсли;
		    //ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2020-06-29 (#3794)
			
			//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2020-06-29 (#3794)
			//РезДанные = ВыполнитьТрансляцию(Источник,,,флЗаписывать,Перечисления.бит_РежимыТрансляции.OnLine,ОтображатьПротокол, Очередность.Значение);
			РезДанные = ВыполнитьТрансляцию(Источник,,,флЗаписывать,Перечисления.бит_РежимыТрансляции.OnLine,ОтображатьПротокол, Очередность);
			//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2020-06-29 (#3794)
			Протокол  = РезДанные.Протокол;
			#Если Клиент Тогда
				
				
				Если ОтображатьПротокол Тогда
					
					ТекстовыйДокумент = Новый ТекстовыйДокумент;
					ТекстовыйДокумент.УстановитьТекст(Протокол);
					ТекстовыйДокумент.Показать("Протокол трансляции "+Источник);
					
				КонецЕсли; 
				
			#Иначе	
				
				Если ОтображатьПротокол Тогда
					
					бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(Протокол);
					
				КонецЕсли;
				
			#КонецЕсли 
			
		КонецЦикла;
		Возврат;
	КонецЕсли;
	///БИТ Тртилек
	
	РезДанные = ВыполнитьТрансляцию(Источник, , ,флЗаписывать, Перечисления.бит_РежимыТрансляции.OnLine, ОтображатьПротокол);
	Протокол  = РезДанные.Протокол;
	
	КонтрольПоРучнойКорректировкеФакта(Источник, флЗаписывать);
	
	#Если Клиент Тогда 		
		
		Если ОтображатьПротокол Тогда			
			ТекстовыйДокумент = Новый ТекстовыйДокумент;
			ТекстовыйДокумент.УстановитьТекст(Протокол);
			ТекстовыйДокумент.Показать("Протокол трансляции " + Источник);			
		КонецЕсли; 
		
	#Иначе	
		
		Если ОтображатьПротокол Тогда			
		  бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(Протокол);		
		КонецЕсли;
		
	#КонецЕсли	
	
КонецПроцедуры

// Процедура обработчик подписки "бит_ТрансляцияОперацияПриЗаписи" на событие  "ПриЗаписи" документа ОперацияБух.
// 
// Параметры:
// Источник        - ДокументОбъект.
// Отказ           - Булево.
// 
Процедура бит_ТрансляцияОперацияПриЗаписиПриЗаписи(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
    	Возврат;
	КонецЕсли;
	
	Если Отказ  Тогда		
		Возврат;		
	КонецЕсли; 
	
	Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_ЭтоЧужойПодчиненныйУзел") = Истина Тогда
		Возврат;
	КонецЕсли; 		
	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2017-08-09 (#2836)
	Если ОК_ПодпискиНаСобытия.ЭтоИзменениеРеквизитовОбъектаБезПроведения(Источник) Тогда
		Возврат;
	КонецЕсли;
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2017-08-09 (#2836)	
		
	ОтображатьПротокол = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОтображатьПротоколТрансляции"
											, Пользователи.ТекущийПользователь());	
	
	Если Метаданные.Документы.Найти("ОперацияБух") <> Неопределено 
		 И ТипЗнч(Источник) = Тип("ДокументОбъект.ОперацияБух") Тогда
		
		Если бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
			бит_ОбщегоНазначения.ПриЗаписиОперацииРучнаяКорректировкаФакта(Источник, ?(Источник.ПометкаУдаления, Ложь, Истина));
		КонецЕсли; 
		
		// Для бух-операции необходимо очистить движения принудительно.
		//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код (
		//Для каждого НаборЗаписей Из Источник.Движения Цикл
		//	МетаРегистр = НаборЗаписей.Метаданные();
		//	Если Лев(МетаРегистр.Имя,4) = "бит_" И НаборЗаписей.Количество() > 0 Тогда
		//		НаборЗаписей.Очистить();
		//		НаборЗаписей.Записывать = Истина;
		//		НаборЗаписей.Записать();
		//	КонецЕсли; 
		//КонецЦикла; 
		//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код )

	ИначеЕсли ТипЗнч(Источник) = Тип("ДокументОбъект.бит_ОперацияУправленческий") Тогда
		Для каждого НаборЗаписей Из Источник.Движения Цикл			
			МетаРегистр = НаборЗаписей.Метаданные();
			Если СтрСравнить(МетаРегистр.Имя, Источник.ИмяРегистраБухгалтерии)<>0 И НаборЗаписей.Количество() > 0 Тогда
			    НаборЗаписей.Очистить();
				НаборЗаписей.Записывать = Истина;
				НаборЗаписей.Записать();
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли; 
	
//БИТ Тртилек 09.07.2012
	//Если документ проводится, а не загружается из аксапты тогда прервать
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2020-10-26 (#ПроектИнтеграцияАксапта12)
	//Если ТипЗнч(Источник) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") И НЕ Источник.ДополнительныеСвойства.Свойство("бит_ДокументЗагружаетсяИзАксапты") Тогда
	Если (ТипЗнч(Источник) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") 
			ИЛИ ТипЗнч(Источник) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты12"))
		И НЕ Источник.ДополнительныеСвойства.Свойство("бит_ДокументЗагружаетсяИзАксапты") Тогда
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2020-10-26 (#ПроектИнтеграцияАксапта12)
		
		Возврат;
		
	КонецЕсли;
	Источник.ДополнительныеСвойства.Вставить("ДокументПоПодписке",);
	
	НаборЗаписейОчередность = РегистрыСведений.бит_му_Настройки.СоздатьНаборЗаписей();
	НаборЗаписейОчередность.Отбор.ИмяНастройки.Установить("Последовательность онлайн трансляции");
	НаборЗаписейОчередность.Прочитать();
	
	Если НаборЗаписейОчередность.Количество() > 0 Тогда 
		СтрокаОчередностей = НаборЗаписейОчередность[0].Значение;
	КонецЕсли;
	
	СписокОчередностей = Новый СписокЗначений;
	
	Если СтрокаОчередностей <> Неопределено тогда
		
		Пока СтрокаОчередностей <> "" Цикл
			ЗапятаяПорядок = Найти(СтрокаОчередностей, ",");
			Если ЗапятаяПорядок <> 0 Тогда
				Номер = Число(СокрЛП(Лев(СтрокаОчередностей,ЗапятаяПорядок-1)));
				СтрокаОчередностей = Сред(СтрокаОчередностей, ЗапятаяПорядок+1, 100);
			Иначе
				Номер = Число(СокрЛП(СтрокаОчередностей));
				СтрокаОчередностей = "";
			КонецЕсли;		
			СписокОчередностей.Добавить(Номер, Строка(Номер));
		КонецЦикла;
		
		СписокОчередностей.СортироватьПоЗначению(НаправлениеСортировки.Возр);
		
		Для Каждого Очередность Из СписокОчередностей Цикл
			
			Протокол = ВыполнитьТрансляцию(Источник,,,,Перечисления.бит_РежимыТрансляции.OnLine,ОтображатьПротокол, Очередность.Значение);
			
			#Если Клиент Тогда
				
				Если ОтображатьПротокол Тогда
					
					ТекстовыйДокумент = Новый ТекстовыйДокумент;
					ТекстовыйДокумент.УстановитьТекст(Протокол);
					ТекстовыйДокумент.Показать("Протокол трансляции "+Источник);
					
				КонецЕсли; 
				
			#Иначе	
				
				Если ОтображатьПротокол Тогда
					
					бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(Протокол);
					
				КонецЕсли;
				
			#КонецЕсли 
			
		КонецЦикла;
		Возврат;
	КонецЕсли;
	///БИТ Тртилек	
	
	ЗаписыватьДвижения = Метаданные.Документы.Найти("РегламентнаяОперация") <> Неопределено 
						 И ТипЗнч(Источник) = Тип("ДокументОбъект.РегламентнаяОперация");
	РезДанные = ВыполнитьТрансляцию(Источник, , ,ЗаписыватьДвижения, Перечисления.бит_РежимыТрансляции.OnLine, ОтображатьПротокол);
	Протокол  = РезДанные.Протокол;	
	
	КонтрольПоРучнойКорректировкеФакта(Источник, ЗаписыватьДвижения);
	
	#Если Клиент Тогда
		
		Если ОтображатьПротокол Тогда			
			ТекстовыйДокумент = Новый ТекстовыйДокумент;
			ТекстовыйДокумент.УстановитьТекст(Протокол);
			ТекстовыйДокумент.Показать("Протокол трансляции " + Источник);			
		КонецЕсли; 
		
	#Иначе
		
		Если ОтображатьПротокол Тогда			
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(Протокол);		
		КонецЕсли;
		
	#КонецЕсли	
	
КонецПроцедуры

// Функция определяет необходимость выполнения трансляции 
// в зависимости от НастройкиРежима трансляции и текущего РежимаВыполнения процедуры трансляции.
// 
// Параметры:
//  НастройкаРежима  - ПеречислениеСсылка.бит_РежимыТрансляции - настройка, 
// 						указывающая в каком режиме должна выполняться трансляция
//  РежимВыполнения  - ПеречислениеСсылка.бит_РежимыТрансляции - текущий режим,
// 						в котором вызвана процедура трансляции
//  Объект           - ДокументСсылка
//  Организация      - СправочникСсылка.Организации
//  РегистрыИсточники - Массив
//  РегистрыПриемники - Массив
//  ВестиПротокол     - Истина.
// 
// Возвращаемое значение:
//   флТрансляцияНеобходима   - Булево.
// 
Функция ОпределитьНеобходимостьТрансляции(НастройкаРежима
	                                        ,РежимВыполнения
											,Объект
											,Организация
											,РегистрыИсточники
											,РегистрыПриемники
											,Протокол      = ""
											,ВестиПротокол = Истина) Экспорт

	флТрансляцияНеобходима = Истина;
	
	//БИТ Тртилек К.И. 20.11.2012 изменения из нового релиза, документ из закрытого периода транслируется сразу онлайн
	//Если НастройкаРежима = Перечисления.бит_РежимыТрансляции.Отложенный Тогда
	Если НастройкаРежима = Перечисления.бит_РежимыТрансляции.Отложенный
		ИЛИ НастройкаРежима = Перечисления.бит_РежимыТрансляции.Ручной Тогда
	///БИТ Тртилек
	
		флЗакрытыйПериод = бит_КонтрольЗакрытогоПериода.ЭтоДокументЗакрытогоПериода(Объект, Организация);
		// Если документ попадает в закрытый период - принудительно выполняется on-line трансляция.
		Если флЗакрытыйПериод Тогда			
			НастройкаРежима = Перечисления.бит_РежимыТрансляции.OnLine;			
		КонецЕсли; 
		
	КонецЕсли; 	
	
	Если НастройкаРежима = Перечисления.бит_РежимыТрансляции.НеВыполнять Тогда
		
		// Трансляция вообще не выполняется
		ТекстСообщения = НСтр("ru = 'Для данного объекта установлен режим трансляции ""не выполнять"".'");
		ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,ВестиПротокол);		
		флТрансляцияНеобходима = Ложь;
		
	ИначеЕсли НастройкаРежима = Перечисления.бит_РежимыТрансляции.OnLine Тогда
		
		// Самый высокий приоритет - трансляция выполняется всегда.
		флТрансляцияНеобходима = Истина;			 
		
	ИначеЕсли НастройкаРежима = Перечисления.бит_РежимыТрансляции.Ручной  Тогда
		
		Если РежимВыполнения = Перечисления.бит_РежимыТрансляции.Ручной Тогда
			флТрансляцияНеобходима = Истина;
		Иначе	
			ТекстСообщения = НСтр("ru = 'Для данного объекта установлен режим трансляции ""Ручной"". Трансляция выполняется обработками 
			                       |""Групповая трансляция"" и ""Групповое редактирование дополнительных аналитик"".'");
			ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,ВестиПротокол);				
			флТрансляцияНеобходима = Ложь;
		КонецЕсли; 
		
	ИначеЕсли НастройкаРежима = Перечисления.бит_РежимыТрансляции.Отложенный  Тогда
		
		Если РежимВыполнения = Перечисления.бит_РежимыТрансляции.Отложенный Тогда
			
			флТрансляцияНеобходима = Истина;
			
		Иначе	
			
			МассивИсточники = Новый Массив;
			МассивПриемники = Новый Массив;
			
			Если ТипЗнч(РегистрыИсточники) = Тип("Массив") Тогда
			    Для каждого Элемент Из РегистрыИсточники Цикл 				
					МассивИсточники.Добавить(Элемент);				
				КонецЦикла; 
			Иначе
			    МассивИсточники.Добавить(Справочники.бит_ОбъектыСистемы.ПустаяСсылка());				
			КонецЕсли; 
			
			Если ТипЗнч(РегистрыПриемники) = Тип("Массив")  Тогда
				Для каждого Элемент Из РегистрыПриемники Цикл					
					МассивПриемники.Добавить(Элемент);					
				КонецЦикла; 
			Иначе
				МассивПриемники.Добавить(Справочники.бит_ОбъектыСистемы.ПустаяСсылка());
			КонецЕсли; 
			
			флЕстьОшибкиЗаписи = Ложь;
			Для каждого ЭлементИсточник Из МассивИсточники Цикл
			
				Для каждого ЭлементПриемник Из МассивПриемники Цикл
				
					МенеджерЗаписи = РегистрыСведений.бит_ОчередьТрансляции.СоздатьМенеджерЗаписи();
					МенеджерЗаписи.Статус             = Перечисления.бит_СтатусыВыполненияОтложеннойТрансляции.Ожидание;
					МенеджерЗаписи.Объект             = Объект;
					МенеджерЗаписи.Организация        = Организация;
					МенеджерЗаписи.ПоставленоВОчередь = ТекущаяДата();
					МенеджерЗаписи.Источник           = ЭлементИсточник;
					МенеджерЗаписи.Приемник           = ЭлементПриемник;

					Попытка					
						МенеджерЗаписи.Записать();					
					Исключение 						
						флЕстьОшибкиЗаписи = Истина;						
					КонецПопытки;
				
				КонецЦикла; 
			
			КонецЦикла; 
			
			
			Если НЕ флЕстьОшибкиЗаписи Тогда
				
				ТекстСообщения = НСтр("ru = 'Документ поставлен в очередь на выполнение трансляции.'");
				ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,ВестиПротокол);
				
			Иначе
				
				ТекстСообщения = НСтр("ru = 'Не удалось поставить документ в очередь на выполнение трансляции.'");
				ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,ВестиПротокол);
				
			КонецЕсли; 
			
			флТрансляцияНеобходима = Ложь; 			
			
		КонецЕсли; 
		
	КонецЕсли;

	Возврат флТрансляцияНеобходима;
	
КонецФункции // ОпределитьВозможностьТрансляции()

// Процедура заполняет запись соответствия оборотов.
// 
// Параметры:
// НаборСоответствиеОборотов - РегистрНакопленияНаборЗаписей.бит_СоответствиеОборотовТрансляции.
// ЗаписьИсточник - РегистрБухгалтерииЗапись.бит_Дополнительный_<i>, РегистрБухгалтерииЗапись.Хозрасчетный.
// ЗаписьПриемник - РегистрБухгалтерииЗапись.бит_Дополнительный_<i>, РегистрБухгалтерииЗапись.Хозрасчетный.
// СтруктураШапкиДокумента - Структура.
// СтруктураПараметров - Структура.
// 
Процедура ЗаполнитьЗаписьСоответствияОборотов(НаборСоответствиеОборотов
	                                            , ЗаписьИсточник
												, ЗаписьПриемник
												, СтруктураШапкиДокумента
												, СтруктураПараметров
												, НомерСтрокиПриемника = 0
												, НомерСтрокиИсточника = 0) Экспорт
	
	// Запишем соответствие оборотов
	ЗаписьСоответствиеОб = НаборСоответствиеОборотов.Добавить();
	
	// Информационные поля
	ЗаписьСоответствиеОб.Регистратор = СтруктураШапкиДокумента.Ссылка;
	ЗаписьСоответствиеОб.Период = ЗаписьИсточник.Период;
	ЗаписьСоответствиеОб.ПериодПриемника = ЗаписьПриемник.Период;
	Если СтруктураШапкиДокумента.Свойство("Организация") Тогда
		
		ЗаписьСоответствиеОб.Организация = СтруктураШапкиДокумента.Организация;
		
	КонецЕсли; 
	ЗаписьСоответствиеОб.Источник    = СтруктураПараметров.ОбъектСистемыИсточник;
	ЗаписьСоответствиеОб.Приемник    = СтруктураПараметров.ОбъектСистемыПриемник;
	
	Если НЕ СтруктураПараметров.МетаданныеПриемника.Реквизиты.Найти("ТипПроводки") = Неопределено Тогда
		
		ЗаписьСоответствиеОб.ТипПроводки = ЗаписьПриемник.ТипПроводки;
		
	КонецЕсли; 
	
	// Активность
	ЗаписьСоответствиеОб.Активность = ЗаписьПриемник.Активность;
	
	// Счета
	ЗаписьСоответствиеОб.СчетИсточникаДт = ЗаписьИсточник.СчетДт;
	ЗаписьСоответствиеОб.СчетИсточникаКт = ЗаписьИсточник.СчетКт;				
	
	ЗаписьСоответствиеОб.СчетПриемникаДт = ЗаписьПриемник.СчетДт;
	ЗаписьСоответствиеОб.СчетПриемникаКт = ЗаписьПриемник.СчетКт;				
	
	// Субконто
	МаксКоличествоСубконтоСоотв = 4;
	
	ЗаполнитьСубконтоДляСоответствия(ЗаписьСоответствиеОб, ЗаписьИсточник, "Дт", "СубконтоИсточника", МаксКоличествоСубконтоСоотв);	
	ЗаполнитьСубконтоДляСоответствия(ЗаписьСоответствиеОб, ЗаписьИсточник, "Кт", "СубконтоИсточника", МаксКоличествоСубконтоСоотв);	
	
	ЗаполнитьСубконтоДляСоответствия(ЗаписьСоответствиеОб, ЗаписьПриемник, "Дт", "СубконтоПриемника", МаксКоличествоСубконтоСоотв);	
	ЗаполнитьСубконтоДляСоответствия(ЗаписьСоответствиеОб, ЗаписьПриемник, "Кт", "СубконтоПриемника", МаксКоличествоСубконтоСоотв);										
	
	// Ресурсы
	Если НЕ СтруктураПараметров.МетаданныеПриемника.Ресурсы.Найти("СуммаУпр") = Неопределено Тогда
		
		ЗаписьСоответствиеОб.СуммаУпр = ЗаписьПриемник.СуммаУпр;
		
	КонецЕсли; 
	Если НЕ СтруктураПараметров.МетаданныеПриемника.Ресурсы.Найти("СуммаРегл") = Неопределено Тогда
		
		ЗаписьСоответствиеОб.СуммаРегл = ЗаписьПриемник.СуммаРегл;
		
	КонецЕсли; 
	Если НЕ СтруктураПараметров.МетаданныеПриемника.Ресурсы.Найти("СуммаМУ") = Неопределено Тогда
		
		ЗаписьСоответствиеОб.СуммаМУ = ЗаписьПриемник.СуммаМУ;
		
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(ЗаписьИсточник.НомерСтроки) Тогда
		
		ЗаписьСоответствиеОб.НомерСтрокиИсточника = ЗаписьИсточник.НомерСтроки;
		
	Иначе
		
		ЗаписьСоответствиеОб.НомерСтрокиИсточника = НомерСтрокиИсточника;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ЗаписьПриемник.НомерСтроки) Тогда
		
		ЗаписьСоответствиеОб.НомерСтрокиПриемника = ЗаписьПриемник.НомерСтроки;	
		
	Иначе
		
		ЗаписьСоответствиеОб.НомерСтрокиПриемника = НомерСтрокиПриемника;
		
	КонецЕсли; 
	
	
КонецПроцедуры // ЗаполнитьЗаписьСоответствияОборотов()

// Процедура выполняет преобразование записей источника в записи приемника по правилам трансляции.
// 
// Параметры:
//  Источник  - ДокументОбъект.
//  НаборИсточник - РегистрНакопления.НаборЗаписей, РегистрБухгалтерии.НаборЗаписей.
//  НаборПриемник - РегистрНакопления.НаборЗаписей, РегистрБухгалтерии.НаборЗаписей.
//  СтруктураПараметров - Структура.
//  Протокол      - Строка.
// 
Функция ВыполнитьТрансляциюДвижений(Источник, НаборИсточник, НаборПриемник, СтруктураПараметров, Протокол, ОбработанныеПриемники = Неопределено) Экспорт

	флЕстьОшибки = Ложь;	
	
	Если Источник = Неопределено И НЕ СтруктураПараметров.ОбработкаБезДокумента Тогда
		Возврат флЕстьОшибки;	
	КонецЕсли; 
	
	// 1С-ИжТиСи Полина 11.11.2015 (
	// При свертке это самая длительная операция
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат флЕстьОшибки;
	КонецЕсли;
	// 1С-ИжТиСи Полина 11.11.2015 )	
	
	// Соберем итоговый код трансляции и кэш реквизитов.
	КодУсловияТрансляции 		= СтруктураПараметров.КодУсловияТрансляции;
	флГенерироватьКодТрансляции = НЕ ЗначениеЗаполнено(КодУсловияТрансляции);
	
	Если флГенерироватьКодТрансляции Тогда
		КодУсловияТрансляции = "";
	КонецЕсли; 
	
	КэшРеквизитов = Новый ТаблицаЗначений;
	КэшРеквизитов.Колонки.Добавить("ИД");
	КэшРеквизитов.Колонки.Добавить("ИмяКолонки");
	КэшРеквизитов.Колонки.Добавить("Значение");
	КэшРеквизитов.Индексы.Добавить("ИД, ИмяКолонки");
	
	//rarus +
	
	//Для каждого Правило Из СтруктураПараметров.ПравилаТрансляции Цикл
	//	
	//	ТабВрем = бит_МеханизмТрансляцииВызовПовтИсп.ПодготовитьКэшРеквизитов(Правило);
	//	
		
	//	Для каждого СтрокаТаблицы Из ТабВрем Цикл
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	бит_ПравилаТрансляции.Ссылка как Правило,
	|	бит_ПравилаТрансляции.КодУсловияТрансляцииСжатый как КодУсловияТрансляцииСжатый
	|ИЗ
	|	Справочник.бит_ПравилаТрансляции КАК бит_ПравилаТрансляции
	|ГДЕ
	|	бит_ПравилаТрансляции.Ссылка В(&Ссылка)";
	
	Запрос.УстановитьПараметр("Ссылка", СтруктураПараметров.ПравилаТрансляции);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Для каждого СтрокаТаблицы Из Выборка.Правило.ЗначенияРеквизитов Цикл
	//rarus -
			НоваяСтрока = КэшРеквизитов.Добавить();
			НоваяСтрока.ИД = СтрокаТаблицы.ИД;
			НоваяСтрока.ИмяКолонки = СтрокаТаблицы.ИмяКолонки;
			НоваяСтрока.Значение = СтрокаТаблицы.Значение;
		КонецЦикла; 
		
		Если флГенерироватьКодТрансляции Тогда
			 //rarus +
			 //КодУсловияТрансляции = КодУсловияТрансляции + Правило.КодУсловияТрансляции;
			 ТекстПравил = ЗначениеИзСтрокиВнутр(Выборка.КодУсловияТрансляцииСжатый).Получить();
			 КодУсловияТрансляции = КодУсловияТрансляции + ТекстПравил;
			 //rarus -
		КонецЕсли; 
	КонецЦикла; 
	
	ПравилоЗаполнения       = СтруктураПараметров.ПравилоЗаполнения;
	СтруктураШапкиДокумента = СтруктураПараметров.СтруктураШапкиДокумента;
	ДополнительныеАналитики = СтруктураПараметров.ДополнительныеАналитики;
	ПользовательскиеФункции = СтруктураПараметров.ПользовательскиеФункции;
    ВидыРегистров           = СтруктураПараметров.ВидыРегистров;
	МетаданныеРегистратора  = СтруктураПараметров.МетаданныеРегистратора;
	
	Если СтруктураПараметров.Свойство("СтруктураШапкиМСФО") Тогда
		СтруктураШапкиМСФО = СтруктураПараметров.СтруктураШапкиМСФО;
	Иначе	
		СтруктураШапкиМСФО =  СтруктураПараметров.СтруктураШапкиДокумента;
	КонецЕсли; 
	
	Если СтруктураПараметров.Свойство("ВестиПротокол") Тогда
		флВестиПротокол     = СтруктураПараметров.ВестиПротокол;
		Если НЕ ТипЗнч(флВестиПротокол) = Тип("Булево") Тогда
			флВестиПротокол = Ложь;
		КонецЕсли; 
	Иначе	
		флВестиПротокол    = Ложь;
	КонецЕсли; 
	
	// Набор записей для хранения соответствия номеров записей источника и приемника.
	НаборСоответствие       = СтруктураПараметров.НаборСоответствие;
	// 1С-ИжТиСи Полина 05.02.2016 (
	//флЗаписыватьСоответствиеНомеров = НЕ НаборСоответствие = Неопределено;
	флЗаписыватьСоответствиеНомеров = (СтруктураПараметров.ПравилоЗаполнения.Наименование <> "МУ >> МУ" И НЕ НаборСоответствие = Неопределено);
	// 1С-ИжТиСи Полина 05.02.2016 )
	
	НаборСоответствиеОборотов = СтруктураПараметров.НаборСоответствиеОборотов;
	флЗаписыватьСоответствиеОборотов = ?(ВидыРегистров.ИсточникРегистрБухгалтерии 
	                                      И ВидыРегистров.ПриемникРегистрБухгалтерии 
										  И НЕ НаборСоответствиеОборотов = Неопределено , Истина, Ложь);
									  
	
	// Возможность отказа от ввода записей
	Отказ = Ложь;			
	// Массив для хранения описания возникших ошибок.
	Ошибки = Новый Массив;
	// Структура для отметки о типах возникших ошибок.
	ТипыОшибок = Новый Структура("ПередФормированиемЗаписи,КодУсловияТрансляции,КодЗаполнения,ПослеФормированияЗаписи"
	                             ,Ложь,Ложь,Ложь,Ложь);
	
	// ОБРАБОТЧИК ПЕРЕД ФОРМИРОВАНИЕМ НАБОРА ЗАПИСЕЙ.
	Попытка
		Выполнить(ПравилоЗаполнения.КодПередФормированиемНабораЗаписей);
	Исключение
		Ошибки.Добавить(КонструкторПараметрыОшибки("ПередФормированиемНабораЗаписей",ОписаниеОшибки()));
	КонецПопытки;
	
	ОбработкаНабораПриРучномРедактированииФакта(СтруктураПараметров.МетаданныеПриемника, ДополнительныеАналитики, Отказ);										
	
	Если Отказ Тогда
		Возврат флЕстьОшибки;
	КонецЕсли; 
	
	// Анализ "НеОтражатьВФактеТрансляция", "НеОтражатьВМСФО", "НеВыполнятьТрансляцию" и
	// "РучнаяКорректировкаФактаБюджета".
	АнализироватьНеобходимостьОбработкиНабора(ПравилоЗаполнения
											,СтруктураПараметров.МетаданныеПриемника
											,ДополнительныеАналитики
											,Отказ);
											
	
	// Если выполняется трансляция документа у которого взведен флаг "Ручное редактирование" и Отказ = Истина,
	// тогда очищать движения не надо.
	Если НЕ Источник = Неопределено Тогда
		ЕстьРучнаяКорректировка = ОбщегоНазначения.ЕстьРеквизитОбъекта("РучнаяКорректировка", Источник.Метаданные());
		Если ЕстьРучнаяКорректировка И Источник.РучнаяКорректировка И Отказ Тогда
			Возврат флЕстьОшибки;
		КонецЕсли;
	КонецЕсли;
	
	флОчиститьСоответствия = Истина;
	Если СтруктураПараметров.ОчиститьПриемник Тогда
		
		Если ТипЗнч(ОбработанныеПриемники) = Тип("Соответствие") Тогда
			
			Если ОбработанныеПриемники[СтруктураПараметров.МетаданныеПриемника.Имя] = Неопределено Тогда
				
				// Приемник очищаем только при первом обращении в рамках трансляции по одному документу.
				// При последующих обращениях дозаписываем движения. Это позволяет выполнять трансляцию "Многие в один".
				//БИТ Тртилек 09.02.2012 Не очищаем набор, если источник = приемнику
				//НаборПриемник.Очистить();
				Если НаборИсточник <> НаборПриемник Тогда
				///БИТ Тртилек
					НаборПриемник.Очистить();
				//БИТ Тртилек 09.02.2012
				Иначе
					//БИТ Тртилек 11.12.12 для случая трансляции МСФО-МСФО удалим все сторно/ддс записи
					Счетч = 0;
					// ОКЕЙ Смирнов М.В. (СофтЛаб) Начало 2021-09-03 (#4320)
					СчетРодитель = ПланыСчетов.бит_Дополнительный_2.СчетаУчетаДДС;
					// ОКЕЙ Смирнов М.В. (СофтЛаб) Конец 2021-09-03 (#4320)
					
					Пока НЕ Счетч = НаборИсточник.Количество() Цикл
						// ОКЕЙ Смирнов М.В. (СофтЛаб) Начало 2021-09-03 (#4320)
						//Если Сред(НаборИсточник[Счетч].СчетДт, 1, 1) = "9" ИЛИ Сред(НаборИсточник[Счетч].СчетКт, 1, 1) = "9" ИЛИ НаборИсточник[Счетч].ВидДвиженияМСФО = Перечисления.БИТ_ВидыДвиженияМСФО.СторноРСБУ Тогда
						Если НаборИсточник[Счетч].СчетДт.ПринадлежитЭлементу(СчетРодитель)
							Или НаборИсточник[Счетч].СчетКт.ПринадлежитЭлементу(СчетРодитель)
							Или НаборИсточник[Счетч].ВидДвиженияМСФО = Перечисления.БИТ_ВидыДвиженияМСФО.СторноРСБУ Тогда
						// ОКЕЙ Смирнов М.В. (СофтЛаб) Конец 2021-09-03 (#4320)
							НаборИсточник.Удалить(Счетч);
						Иначе
							Счетч = Счетч + 1;
						КонецЕсли;
					КонецЦикла;
					///БИТ Тртилек
				КонецЕсли;
				///БИТ Тртилек
				НаборПриемник.Записывать = Истина;			
				ОбработанныеПриемники.Вставить(СтруктураПараметров.МетаданныеПриемника.Имя, Истина);
			Иначе	
				
				// Не очищаем приемник и не очищаем соответствия
				флОчиститьСоответствия = Ложь;
			КонецЕсли; 
		Иначе	
			//БИТ Тртилек 09.02.2012 Не очищаем набор, если источник = приемнику
			//НаборПриемник.Очистить();
			Если НаборИсточник <> НаборПриемник Тогда
			///БИТ Тртилек
				НаборПриемник.Очистить();
			Иначе
				//БИТ Тртилек 11.12.12 для случая трансляции МСФО-МСФО удалим все сторно/ддс записи
				Счетч = 0;
				// ОКЕЙ Смирнов М.В. (СофтЛаб) Начало 2021-09-03 (#4320)
				СчетРодитель = ПланыСчетов.бит_Дополнительный_2.СчетаУчетаДДС;
				// ОКЕЙ Смирнов М.В. (СофтЛаб) Конец 2021-09-03 (#4320)
				Пока НЕ Счетч = НаборИсточник.Количество() Цикл
					// ОКЕЙ Смирнов М.В. (СофтЛаб) Начало 2021-09-03 (#4320)
					//Если Сред(НаборИсточник[Счетч].СчетДт, 1, 1) = "9" ИЛИ Сред(НаборИсточник[Счетч].СчетКт, 1, 1) = "9" ИЛИ НаборИсточник[Счетч].ВидДвиженияМСФО = Перечисления.БИТ_ВидыДвиженияМСФО.СторноРСБУ Тогда
					Если НаборИсточник[Счетч].СчетДт.ПринадлежитЭлементу(СчетРодитель)
						Или НаборИсточник[Счетч].СчетКт.ПринадлежитЭлементу(СчетРодитель)
						Или НаборИсточник[Счетч].ВидДвиженияМСФО = Перечисления.БИТ_ВидыДвиженияМСФО.СторноРСБУ Тогда
					// ОКЕЙ Смирнов М.В. (СофтЛаб) Конец 2021-09-03 (#4320)
						НаборИсточник.Удалить(Счетч);
					Иначе
						Счетч = Счетч + 1;
					КонецЕсли;
				КонецЦикла;
				///БИТ Тртилек
			КонецЕсли;
			///БИТ Тртилек
			НаборПриемник.Записывать = Истина;			
		КонецЕсли; 
	КонецЕсли; 
	
	Если флЗаписыватьСоответствиеНомеров Тогда
		
		НаборСоответствие.Записывать = Истина;
		Если флОчиститьСоответствия Тогда
			ОчиститьСоответствиеДвижений(НаборСоответствие,СтруктураПараметров.ОбъектСистемыИсточник,
											СтруктураПараметров.ОбъектСистемыПриемник);
		КонецЕсли; 
	КонецЕсли; 								  
	
	Если флЗаписыватьСоответствиеОборотов Тогда
		
		НаборСоответствиеОборотов.Записывать = Истина;
		Если флОчиститьСоответствия Тогда
			ОчиститьСоответствиеДвижений(НаборСоответствиеОборотов, СтруктураПараметров.ОбъектСистемыИсточник, 
											СтруктураПараметров.ОбъектСистемыПриемник);
		КонецЕсли; 
	КонецЕсли; 		
	
	//БИТ Тртилек
	Пропускать = Ложь;
	КоличествоИсточников = НаборИсточник.Количество();
	///БИТ Тртилек	
	
	// Очищаем движения при групповой трансляции, когда Отказ = Истина.
	Если Отказ Тогда
		Если СтруктураПараметров.ЗаписыватьДвижения Тогда
			ЗаписатьНаборПриТрансляцииДвижений(НаборПриемник, НаборСоответствие, НаборСоответствиеОборотов, 
			// *Обновление*, Братухин М.В., 2018.09.18 (
			//Протокол, флВестиПротокол, флЕстьОшибки, флЗаписыватьСоответствиеНомеров, флЗаписыватьСоответствиеОборотов);
			Протокол, флВестиПротокол, флЕстьОшибки, флЗаписыватьСоответствиеНомеров, флЗаписыватьСоответствиеОборотов,
			НаборИсточник, КоличествоИсточников, Источник);
			// *Обновление*, Братухин М.В., 2018.09.18 )			
		КонецЕсли;
		Возврат флЕстьОшибки;
	КонецЕсли; 
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-02-11 (#3209)
	ок_ЗаполнитьСвойствоНеУстанавливатьОтказПриПроверкеЗаполнения(СтруктураПараметров);
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-02-11 (#3209)
	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-09-07 (#3053)
	КоличествоЗаписейПриемника = НаборПриемник.Количество();
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-09-07 (#3053)		

	Ном         = 1;
	НомПриемник = 1;
	КоличествоОтказов = 0;
	Для каждого ЗаписьИсточник Из НаборИсточник Цикл
		
		//БИТ Тртилек
		Если НомПриемник > КоличествоИсточников Тогда
			Прервать;
		КонецЕсли;
		///БИТ Тртилек		
		
		// Возможность отказа от ввода записи
		Отказ = Ложь;	
		// При заполнении субконто использовать аналитику корр. счета.
		флИспользоватьАналитикуКорр = Ложь;

		Аналитики = СформироватьСоответствияАналитик(ЗаписьИсточник,СтруктураПараметров.МетаданныеИсточника,ВидыРегистров);
		
		// Соответствие для передачи значений между правилами трасляции и правилами заполнения.
		ДополнительныеДанные = Новый Соответствие;
		
		ЗаписьПриемник = НаборПриемник.Добавить();
		ЗаписьПриемник.Активность = ЗаписьИсточник.Активность;
		Если НЕ СтруктураПараметров.МетаданныеПриемника.Реквизиты.Найти("ТипПроводки") = Неопределено Тогда
			ЗаписьПриемник.ТипПроводки = Справочники.бит_ТипыПроводок.Трансляция;
		КонецЕсли; 
		
	    // ОБРАБОТЧИК ПЕРЕД ФОРМИРОВАНИЕМ ЗАПИСИ
		Попытка
			Выполнить(ПравилоЗаполнения.КодПередФормированиемЗаписи);
		Исключение
			Если НЕ ТипыОшибок.ПередФормированиемЗаписи Тогда
				Ошибки.Добавить(КонструкторПараметрыОшибки("ПередФормированиемЗаписи",ОписаниеОшибки()));
				ТипыОшибок.ПередФормированиемЗаписи = Истина;
			КонецЕсли; 
		КонецПопытки;
		
		// Заполним поля исходя из правил трансляции.
		Попытка
			Выполнить(КодУсловияТрансляции);
		Исключение
			Если НЕ ТипыОшибок.КодУсловияТрансляции Тогда
				Ошибки.Добавить(КонструкторПараметрыОшибки("КодУсловияТрансляции",ОписаниеОшибки()));
				ТипыОшибок.КодУсловияТрансляции = Истина;
			КонецЕсли; 
		КонецПопытки;
		
		//БИТ Тртилек 20.02.2012
		Если Отказ Тогда
			
			НаборПриемник.Удалить(ЗаписьПриемник);
			НомПриемник = НомПриемник-1;
			Пропускать = Истина;
			//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-09-07 (#3053)
			Продолжить; // произошел отказ от трансляции записи, уходим в начало цикла для обработки следующей записи
			//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-09-07 (#3053)
		КонецЕсли;
		///БИТ Тртилек		
		
		// Заполним поля исходя из правил заполнения по - умолчанию.
		Попытка
			Выполнить(ПравилоЗаполнения.КодЗаполнения);
		Исключение
			Если НЕ ТипыОшибок.КодЗаполнения Тогда
				Ошибки.Добавить(КонструкторПараметрыОшибки("КодЗаполнения",ОписаниеОшибки()));
				ТипыОшибок.КодЗаполнения = Истина;
			КонецЕсли; 
		КонецПопытки;
		
		// Алгоритмы заполнения специфичные для МСФО
		Если бит_му_ОбщегоНазначения.ЭтоМеждународныйПланСчетовИлиРегистр(СтруктураПараметров.МетаданныеПриемника.Имя) Тогда
	
			ВыполнитьАлгоритмыМСФО(СтруктураШапкиМСФО
			                          , ЗаписьИсточник
									  , ЗаписьПриемник
									  , ПравилоЗаполнения
									  , ДополнительныеАналитики
									  , ДополнительныеДанные);
			
		КонецЕсли; // Алгоритмы заполнения специфичные для МСФО.
		 
		Если ВидыРегистров.ПриемникРегистрБухгалтерии Тогда
			
			// Подбор субконто по типу
			Если флИспользоватьАналитикуКорр Тогда
				ЗаполнитьСубконтоВПриемнике(ЗаписьПриемник,"Дт",Аналитики.АналитикиИсточникДт,Аналитики.АналитикиИсточникКт);
				ЗаполнитьСубконтоВПриемнике(ЗаписьПриемник,"Кт",Аналитики.АналитикиИсточникКт,Аналитики.АналитикиИсточникДт);			
			Иначе	
				ЗаполнитьСубконтоВПриемнике(ЗаписьПриемник,"Дт",Аналитики.АналитикиИсточникДт,Аналитики.АналитикиИсточник);
				ЗаполнитьСубконтоВПриемнике(ЗаписьПриемник,"Кт",Аналитики.АналитикиИсточникКт,Аналитики.АналитикиИсточник);			
			КонецЕсли; 
			
			// Применение коэффициентов к ресурсам
			Для каждого Ресурс Из СтруктураПараметров.МетаданныеПриемника.Ресурсы Цикл
				Если Ресурс.Балансовый Тогда
					ИмяРесурса = Ресурс.Имя;
					ПрименитьКоэффициенты(ЗаписьПриемник, ДополнительныеДанные, Ресурс.Имя);
				Иначе	
					ИмяРесурса = Ресурс.Имя+"Дт";
					ПрименитьКоэффициенты(ЗаписьПриемник, ДополнительныеДанные, ИмяРесурса);
					
					ИмяРесурса = Ресурс.Имя+"Кт";
					ПрименитьКоэффициенты(ЗаписьПриемник, ДополнительныеДанные, ИмяРесурса);
				КонецЕсли; 
			КонецЦикла; 
			
		ИначеЕсли ВидыРегистров.ПриемникРегистрНакопления Тогда
			
			// Подбор субконто по типу			
			ЗаполнитьИзмеренияВПриемнике(ЗаписьПриемник,Аналитики,СтруктураПараметров.МетаданныеПриемника);
			
			// Применение коэффициентов к ресурсам			
			Для каждого Ресурс Из СтруктураПараметров.МетаданныеПриемника.Ресурсы Цикл
				ПрименитьКоэффициенты(ЗаписьПриемник, ДополнительныеДанные, Ресурс.Имя);
			КонецЦикла; 
		КонецЕсли; 
		
		// Автозаполнение с использованием соответствий.
		// Если СтруктураПараметров.ПравилоЗаполнения.РежимИспользованияСоответствий =
		Если СтруктураПараметров.РежимИспользованияСоответствий = Перечисления.бит_РежимыИспользованияСоответствийПриТрансляции.Стандартный  Тогда
			ЗаполнитьПоСоответствиям(ЗаписьИсточник, ЗаписьПриемник, СтруктураПараметров.ПараметрыАвтозаполнения, ВидыРегистров);
		КонецЕсли; 
					  		
	    // Проверка заполнения обязательных реквизитов.
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-02-11 (#3209)
		//ПроверитьОбязательныеПоля(ЗаписьПриемник,СтруктураПараметров.ОбязательныеПоля,Ном,Отказ,Протокол);
		//Заменено на:
		ПроверитьОбязательныеПоля(ЗаписьПриемник,СтруктураПараметров.ОбязательныеПоля,Ном,Отказ,Протокол,СтруктураПараметров.НеУстанавливатьОтказПриПроверкеЗаполнения);
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-02-11 (#3209)		
		Если ВидыРегистров.ПриемникРегистрБухгалтерии Тогда
		    // Проверка признака валютного и количественного учета.
			ПроверитьПризнакиУчета(ЗаписьПриемник,СтруктураПараметров.ПризнакиУчета);
		КонецЕсли; 
		
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-07-23 (#3053)
		//// BIT AMerkulov ++ 13-11-2015
		//Если СтруктураПараметров.ПравилоЗаполнения.Код <> "00-000003" И СтруктураПараметров.ПравилоЗаполнения.Код <> "00-000005" И СтруктураПараметров.ПравилоЗаполнения.Код <> "00-000003" И СтруктураПараметров.ПравилоЗаполнения.Код <> "00-000004" И СтруктураПараметров.ПравилоЗаполнения.Код <> "00-000002" Тогда
		////БИТ Тртилек 17.02.2012 Записываем все проводки в набор, не смотря на обязательные поля.
		//	Отказ = ЛОЖЬ;
		////КонецЕсли; 
		//КонецЕсли;
		//// BIT AMerkulov -- 13-11-2015
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-07-23 (#3053)		
		
	    // ОБРАБОТЧИК ПОСЛЕ ФОРМИРОВАНИЯ ЗАПИСИ	
		Попытка
			Выполнить(ПравилоЗаполнения.КодПослеФормированияЗаписи);
		Исключение
			Если НЕ ТипыОшибок.ПослеФормированияЗаписи Тогда
				Ошибки.Добавить(КонструкторПараметрыОшибки("ПослеФормированияЗаписи",ОписаниеОшибки()));
				ТипыОшибок.ПослеФормированияЗаписи = Истина;
			КонецЕсли; 
		КонецПопытки;
		
		//БИТ Тртилек 29.12.2011 проверка на обязательные поля не выполняется для соотв документов => пишется весь набор
		//Если ТипЗнч(ЗаписьИсточник.Регистратор) = Тип("ДокументСсылка.бит_ок_ОперацияАксапты") ИЛИ
		//	 ТипЗнч(ЗаписьИсточник.Регистратор) = Тип("ДокументСсылка.ОперацияБух") Тогда
		Если НаборИсточник = НаборПриемник Тогда
			Если ЗаписьПриемник.СчетДт = ПланыСчетов.бит_Дополнительный_2.ПустаяСсылка() И ЗаписьПриемник.СчетКт = ПланыСчетов.бит_Дополнительный_2.ПустаяСсылка() Тогда
				Отказ = Истина
			КонецЕсли;
		КонецЕсли;
		///БИТ Тртилек		
		
		Если Отказ Тогда
			 НаборПриемник.Удалить(ЗаписьПриемник);
			 КоличествоОтказов = КоличествоОтказов + 1;
		Иначе
			Если флЗаписыватьСоответствиеНомеров Тогда
				
				 // Запишем соответствие номеров источника и приемника.
				 //ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-09-07 (#3053)
				 //ЗаполнитьЗаписьСоответствияДвижений(НаборСоответствие
				 //										,СтруктураШапкиДокумента
				 //   									,СтруктураПараметров
				 //   									,Ном
				 //   									,НомПриемник
				 //   									,ЗаписьИсточник.Активность);
				 Если Не Пропускать Тогда
					 ЗаполнитьЗаписьСоответствияДвижений(НаборСоответствие
					 										,СтруктураШапкиДокумента
															,СтруктураПараметров
															//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-09-07 (#3053)
															//,Ном
															//,НомПриемник
															,НаборИсточник.Индекс(ЗаписьИсточник) + 1
															,НаборПриемник.Количество()
															//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-09-07 (#3053)
															,ЗаписьИсточник.Активность);
				 КонецЕсли;
				 Пропускать = Ложь;
				 //ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-09-07 (#3053)
				
			 КонецЕсли; 
			 
			 Если флЗаписыватьСоответствиеОборотов Тогда
				 
				 ЗаполнитьЗаписьСоответствияОборотов(НаборСоответствиеОборотов
				                                        , ЗаписьИсточник
														, ЗаписьПриемник
														, СтруктураШапкиДокумента
														, СтруктураПараметров
														, НомПриемник
														, Ном);
			 
			 КонецЕсли; // Записывать соответствие оборотов
		    НомПриемник = НомПриемник+1;
		КонецЕсли; 
		Ном = Ном+1;
	КонецЦикла; 
	
	// ОБРАБОТЧИК ПОСЛЕ ФОРМИРОВАНИЯ НАБОРА ЗАПИСЕЙ.
	Попытка
		Выполнить(ПравилоЗаполнения.КодПослеФормированияНабораЗаписей);
	Исключение
		Ошибки.Добавить(КонструкторПараметрыОшибки("ПослеФормированияНабораЗаписей",ОписаниеОшибки()));		
	КонецПопытки;
	
    // Если в процессе трансляции были выявлены ошибки очистим приемник.
	Если Ошибки.Количество()>0 Тогда
		
		флЕстьОшибки = Истина;
		
		ПараметрыОбработки = Новый Структура;
		ПараметрыОбработки.Вставить("ТранслируемыйДокумент",Источник.Ссылка);
		ПараметрыОбработки.Вставить("Источник"             ,СтруктураПараметров.ОбъектСистемыИсточник);
		ПараметрыОбработки.Вставить("Приемник"             ,СтруктураПараметров.ОбъектСистемыПриемник);
		ПараметрыОбработки.Вставить("КодУсловияТрансляции" ,КодУсловияТрансляции);
		ПараметрыОбработки.Вставить("ПравилоЗаполнения"    ,ПравилоЗаполнения);
		ПараметрыОбработки.Вставить("ВестиПротокол"        ,флВестиПротокол);
		
		ОбработатьОшибки(Ошибки,ПараметрыОбработки,Протокол);
		
		НаборПриемник.Очистить();
	    НаборПриемник.Записывать = Истина;		
	
	КонецЕсли; 
	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-09-07 (#3053)	
	//ТекстСообщения = СтрШаблон(Нстр("ru = 'Создано %1 записей Приемника.'"),НомПриемник - 1); 
	ТекстСообщения = СтрШаблон(Нстр("ru = 'Создано %1 записей Приемника.'"),(НаборПриемник.Количество() - КоличествоЗаписейПриемника)); 	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2018-09-07 (#3053)	
	ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,флВестиПротокол);
	
	// При необходимости выполним формирование зависимых оборотов.
	Если ПравилоЗаполнения.ФормироватьЗависимыеОбороты 
		 И СтруктураПараметров.МетаданныеПриемника = Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам		 
		 И НаборПриемник.Количество()>0  Тогда
		 
		 КоличествоНач = НаборПриемник.Количество();
		 бит_Бюджетирование.СформироватьЗависимыеОборотыПоНаборуЗаписей(Источник, НаборПриемник);
		 КоличествоКон = НаборПриемник.Количество();
		 Дельта = КоличествоКон - КоличествоНач;
		 
		 ТекстСообщения = НСтр("ru = 'Выполнено формирование зависимых оборотов. 
		                        |Сформировано %1% записей.'");
								
		 ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, Дельта);
	     ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,флВестиПротокол);
	КонецЕсли; 
	
	
	// При необходимости выполним формирование проводок бюджетирования исходя из шаблонов проводок 
	// по движениям регистра бит_ОборотыПоБюджетам.
	Если ПравилоЗаполнения.ФормироватьПроводкиБюджетирования 
		 И НаборПриемник.Количество()>0  
		 И СтруктураПараметров.МетаданныеПриемника = Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам
		 И РегистрУчаствуетВДвижениях(Источник.Движения,"бит_Бюджетирование") Тогда
	
		 СформироватьПроводкиБюджетирования(Источник,НаборПриемник,СтруктураПараметров.ЗаписыватьДвижения);
		 ТекстСообщения = НСтр("ru = 'Выполнено формирование проводок Бюджетирования по шаблонам проводок. 
		                        |Сформировано %1% проводок Бюджетирования.'");
								
		 КоличествоЗаписей = Источник.Движения.бит_Бюджетирование.Количество();						
		 ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, КоличествоЗаписей);
	     ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,флВестиПротокол);
	КонецЕсли; 
	
	// При необходимости запишем движения
	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код (
	//Если СтруктураПараметров.ЗаписыватьДвижения Тогда
	Если СтруктураПараметров.ЗаписыватьДвижения ИЛИ Источник.ДополнительныеСвойства.Свойство("ДокументПоПодписке") Тогда		
	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код )	
		ЗаписатьНаборПриТрансляцииДвижений(НаборПриемник, НаборСоответствие, НаборСоответствиеОборотов, 
			// *Обновление*, Братухин М.В., 2018.09.18 (
			//Протокол, флВестиПротокол, флЕстьОшибки, флЗаписыватьСоответствиеНомеров, флЗаписыватьСоответствиеОборотов);
			Протокол, флВестиПротокол, флЕстьОшибки, флЗаписыватьСоответствиеНомеров, флЗаписыватьСоответствиеОборотов,
			НаборИсточник, КоличествоИсточников, Источник);
			// *Обновление*, Братухин М.В., 2018.09.18 )			
	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код (		
	Иначе
		// ОКЕЙ Конаков Ю.М. (СофтЛаб) Начало 2021-11-09 (#4297) 
		Если Не СтруктураПараметров.Свойство("НеОчищатьНаборПриемникПриТрансляции")
			Или Не СтруктураПараметров.НеОчищатьНаборПриемникПриТрансляции Тогда 
		// ОКЕЙ Конаков Ю.М. (СофтЛаб) Конец 2021-11-09 (#4297) 
		НаборПриемник.Очистить();			
		// ОКЕЙ Конаков Ю.М. (СофтЛаб) Начало 2021-11-09 (#4297) 
		КонецЕсли;
		// ОКЕЙ Конаков Ю.М. (СофтЛаб) Конец 2021-11-09 (#4297) 
	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код )	
	КонецЕсли;
	
	Возврат флЕстьОшибки;
	 
КонецФункции

// Процедура выполняет трансляцию набора записей регистра источника в набор записей регистра приемника.
// 
// Параметры:
// ДокументОбъект     - ДокументОбъект.
// РегистрыИсточники  - Массив, Неопределено.
// РегистрыПриемники  - Массив, Неопределено.
// ЗаписыватьДвижения - Булево.
// РежимВыполнения    - Перечисления.бит_РежимыТрансляции.
// ВестиПротокол      - Булево.
// 
Функция ВыполнитьТрансляцию(ДокументОбъект
	                        , РегистрыИсточники    = Неопределено
	                        , РегистрыПриемники    = Неопределено
	                        , ЗаписыватьДвижения   = ЛОЖЬ
							, РежимВыполнения      = Неопределено
							//БИТ Тртилек
							//, ВестиПротокол        = Истина)  Экспорт
							,ВестиПротокол        = Истина
							,Очередность          = Неопределено)  Экспорт   //БИТ Тртилек 01.12.2011 Дополнительно передается параметр Очередность.
							//БИТ Тртилек	
							
	//{ bit SVKushnirenko Bit 27.01.2017 #2657
	//данный обработчик необходим, т.к. ввод такого типа документа в БД, не предполагает изменение КЗБ при проведении или отмене оного
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2020-10-26 (#ПроектИнтеграцияАксапта12)
	//Если ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты") Тогда
	Если ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты")
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2021-05-31 (#4180)
		ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.ОперацияБух") 
		//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2021-05-31 (#4180)
		ИЛИ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ок_ОперацияАксапты12") Тогда
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2020-10-26 (#ПроектИнтеграцияАксапта12)
		
		//поскольку при трансляции может случиться как очистка движений, так и их новое заполнение, вкючаем команды 
		//для двух событий в модуле набора записей КЗБ которые могут привести к изменению статсуса заявки
		ДокументОбъект.Движения.бит_КонтрольныеЗначенияБюджетов.ДополнительныеСвойства.Вставить("бит_БК_УстановкаСтатусаПослеПроведения", Истина);
		ДокументОбъект.Движения.бит_КонтрольныеЗначенияБюджетов.ДополнительныеСвойства.Вставить("бит_БК_УстановкаСтатусаПередУдалением", Истина);
	КонецЕсли;
	//} bit SVKushnirenko Bit 27.01.2017 #2657
	
	флЕстьОшибки = Ложь;						
							
	УстановитьПривилегированныйРежим(Истина);						
							
	Протокол = "";
	ТекстСообщения = НСтр("ru = 'Выполнение трансляции движений по документу: %1%'");
	ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения,Строка(ДокументОбъект));
	ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,ВестиПротокол);
	
	МетаданныеИсточник = ДокументОбъект.Метаданные();
	
	Если бит_РаботаСМетаданными.ЕстьРеквизит("Организация",МетаданныеИсточник) Тогда
		Организация = ДокументОбъект.Организация;
	Иначе	
		Организация = Справочники.Организации.ПустаяСсылка();
	КонецЕсли; 
	
	ОбъектСистемы   = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(МетаданныеИсточник);
	
	НастройкаРежима = ПолучитьРежимТрансляции(ДокументОбъект.Дата,ОбъектСистемы,Организация);	
	
	флТрансляцияНеобходима = ОпределитьНеобходимостьТрансляции(НастройкаРежима
																,РежимВыполнения
																,ДокументОбъект.Ссылка
																,Организация
																,РегистрыИсточники
																,РегистрыПриемники
																,Протокол
																,ВестиПротокол);
	Если НЕ флТрансляцияНеобходима Тогда
	
		УстановитьПривилегированныйРежим(Ложь);
	    РезДанные = Новый Структура("ЕстьОшибки, Протокол", Ложь, Протокол);
		
		// Добавление кода. Начало: 17.04.2017  {{
		// Восстановление движений.
		Если ЕстьРучноеРедактированиеФакта(ДокументОбъект) Тогда
			ПриОтказеОтТрансляцииПриПроведении(ДокументОбъект, ЗаписыватьДвижения);	
		КонецЕсли;
		// Добавление кода конец }}  
		
		Возврат РезДанные;
	
	КонецЕсли; 
	
	// Хранит имена регистров приемников, в которые уже была выполнена трансляция
	ОбработанныеПриемники = Новый Соответствие;
	// Хранит имена пар источник_приемник, по которым уже была выполнена трансляция.
	ОбработанныеПары = Новый Соответствие;
	
	// Получим данные необходимые для выполнения трансляции - структуру шапки документа 
	// и данные из регистра сведений бит_ДополнительныеАналитики.
	СтруктураШапкиДокумента = бит_ОбщегоНазначения.СформироватьСтруктуруШапкиДокумента(ДокументОбъект);
	ДополнитьСтруктуруШапкиДокумента(ДокументОбъект,СтруктураШапкиДокумента);
	
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-06-13 (#2843)
	//ДополнительныеАналитики = ПолучитьАналитикиОбъекта(ДокументОбъект.Ссылка);
	Если ДокументОбъект.ДополнительныеСвойства.Свойство("ДополнительныеАналитики") Тогда
		ДополнительныеАналитики = ДокументОбъект.ДополнительныеСвойства.ДополнительныеАналитики;
	Иначе
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-06-13 (#2843)
		ДополнительныеАналитики = ПолучитьАналитикиОбъекта(ДокументОбъект.Ссылка);
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2017-06-13 (#2843)
		ДокументОбъект.ДополнительныеСвойства.Вставить("ДополнительныеАналитики",	ДополнительныеАналитики);	
	КонецЕсли;
	//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2017-06-13 (#2843)
	
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2019-02-08 (#3209)
	ОтборНастроек = Новый Структура("Группа", "НеТранслироватьЕслиНеЗаполненыОбязательныеПоля");
	НаборЗаписейОбъектыПриемники = бит_ОбщегоНазначения.ПрочитатьНаборЗаписейРегистраСведений(ОтборНастроек, "бит_му_Настройки");
	СтруктураШапкиДокумента.Вставить("НеТранслироватьЕслиНеЗаполненыОбязательныеПоля", НаборЗаписейОбъектыПриемники);
	//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2019-02-08 (#3209)
	
	// Что бы избежать трансляции в регистр бухгалтерии, который установлен в шапке "Операция (управленческий),
	// зафиксируем ссылку. 
	Если ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.бит_ОперацияУправленческий") Тогда
		РБОперации = ДокументОбъект.РегистрБухгалтерии;
	Иначе
		РБОперации = Неопределено;
	КонецЕсли; 

	// Получим правила заполнения полей и правила трансляции.
	//БИТ Тртилек
	//РезультатПравила = ПолучитьДоступныеПравилаТрансляции(Организация,ДокументОбъект,ДокументОбъект.Дата,РегистрыИсточники,РегистрыПриемники);
	РезультатПравила = ПолучитьДоступныеПравилаТрансляции(Организация,ДокументОбъект,ДокументОбъект.Дата,РегистрыИсточники,РегистрыПриемники, Очередность);
	//БИТ Тртилек
	
	ВыборкаПравилоЗаполнения = РезультатПравила.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ВыборкаПравилоЗаполнения.Следующий() Цикл
		
		СтруктураПравила = ПодготовитьСтруктурыПравил(ВыборкаПравилоЗаполнения.ПравилоЗаполнения);
		
		ВыборкаИсточник = ВыборкаПравилоЗаполнения.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Пока ВыборкаИсточник.Следующий() Цикл
			
			Если НЕ РегистрУчаствуетВДвижениях(ДокументОбъект.Движения,ВыборкаИсточник.Источник.ИмяОбъекта) Тогда
				Продолжить;
			КонецЕсли; 
			
			ВыборкаПриемник = ВыборкаИсточник.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Пока ВыборкаПриемник.Следующий() Цикл
				
				Если НЕ РегистрУчаствуетВДвижениях(ДокументОбъект.Движения,ВыборкаПриемник.Приемник.ИмяОбъекта) Тогда
					Продолжить;
				КонецЕсли;
				
				Выборка = ВыборкаПриемник.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
				
				МассивПравил = Новый Массив;
				КодУсловияТрансляции = "";
				
				флКроме = Ложь;
				Пока Выборка.Следующий() Цикл
					
					Если Выборка.УсловиеВхождения = Перечисления.бит_Кроме.Кроме Тогда
					
						флКроме = Истина;
						Прервать;
					
					КонецЕсли; 
					МассивПравил.Добавить(Выборка.ПравилаТрансляции);
					КодУсловияТрансляции = КодУсловияТрансляции + Выборка.КодУсловияТрансляции;
					
				КонецЦикла; // По настройкам
				
				Если флКроме Тогда
					Продолжить;
				КонецЕсли; 
				
				ИмяИсточника =  ВыборкаИсточник.ИсточникИмяОбъекта;
				ИмяПриемника =  ВыборкаПриемник.ПриемникИмяОбъекта;
				
				// Что бы избежать трансляции в регистр бухгалтерии, который установлен в шапке "Операция (управленческий),
				// пропустим правило. 
				Если ЗначениеЗаполнено(РБОперации) И РБОперации = ВыборкаПриемник.Приемник Тогда
					ОбработанныеПары.Вставить(ИмяИсточника+"_"+ИмяПриемника, Истина);
				КонецЕсли; 
				
				Если НЕ ОбработанныеПары[ИмяИсточника+"_"+ИмяПриемника] = Неопределено Тогда
					Продолжить;
				КонецЕсли; 
				
				// При необходимости получим валюту международного учета
				Если (бит_му_ОбщегоНазначения.ЭтоМеждународныйПланСчетовИлиРегистр(ИмяПриемника) 
					   ИЛИ бит_му_ОбщегоНазначения.ЭтоМеждународныйПланСчетовИлиРегистр(ИмяИсточника))
					 И СтруктураШапкиДокумента.Свойство("Организация") 
					 И НЕ СтруктураШапкиДокумента.Свойство("бит_ВалютаМУ") Тогда
				
					 СтруктураШапкиДокумента.Вставить("бит_ВалютаМУ", бит_му_ОбщегоНазначения.ПолучитьВалютуМеждународногоУчета(СтруктураШапкиДокумента.Организация));
					 СтрКурсаМУ = бит_КурсыВалют.ПолучитьКурсВалюты(СтруктураШапкиДокумента.бит_ВалютаМУ,СтруктураШапкиДокумента.Дата);
					 СтруктураШапкиДокумента.Вставить("бит_КурсМУ"     ,СтрКурсаМУ.Курс);
					 СтруктураШапкиДокумента.Вставить("бит_КратностьМУ",СтрКурсаМУ.Кратность);
					
				КонецЕсли; 
				
				// Проверка необходимости трансляции для проформ
				// если движения по регистру сформированы МХО, то трансляция не должна выполняться.
				Если ДокументОбъект.ДополнительныеСвойства.Свойство("бит_ПриемникиМХО") Тогда
					Если НЕ ДокументОбъект.ДополнительныеСвойства.бит_ПриемникиМХО.Найти(ИмяПриемника) = Неопределено Тогда
						
				         ДобавитьСообщениеВПротокол(Протокол, "");												
						 ТекстСообщения =  НСтр("ru = 'Движения по регистру ""%1%"" сформированы МХО. Трансляция в регистр ""%1%"" выполняться не будет.'");
						 ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, ИмяПриемника);
				         ДобавитьСообщениеВПротокол(Протокол, ТекстСообщения);						
						 Продолжить;
					
					КонецЕсли; 
				КонецЕсли; 
				
				// ++ NB 12.10.18
				//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2019-06-28 (#3386)
				//Если ДокументОбъект.Движения[ИмяИсточника].Модифицированность() 
				//		ИЛИ ДокументОбъект.Движения[ИмяИсточника].Записывать Тогда // ++ NB 25.01.19 BF-2860 Добавил анализ свойства "Записывать".
				//	НаборИсточник = ДокументОбъект.Движения[ИмяИсточника];					
				//Иначе
				//	МДИсточника = Метаданные.НайтиПоПолномуИмени(ВыборкаИсточник.ИсточникИмяОбъектаПолное);
				//	Если ОбщегоНазначения.ЭтоРегистрБухгалтерии(МДИсточника) Тогда
				//		НаборИсточник = РегистрыБухгалтерии[ИмяИсточника].СоздатьНаборЗаписей();
				//	ИначеЕсли ОбщегоНазначения.ЭтоРегистрНакопления(МДИсточника) Тогда 
				//		НаборИсточник = РегистрыНакопления[ИмяИсточника].СоздатьНаборЗаписей();
				//	ИначеЕсли ОбщегоНазначения.ЭтоРегистрСведений(МДИсточника) Тогда 
				//		НаборИсточник = РегистрыСведений[ИмяИсточника].СоздатьНаборЗаписей();
				//	КонецЕсли; 
				//	НаборИсточник.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);
				//	НаборИсточник.Прочитать();
				//КонецЕсли; 
				//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2019-06-28 (#3386)
				// -- NB 12.10.18
				
				//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2019-06-28 (#3386)
				НаборИсточник = ДокументОбъект.Движения[ИмяИсточника];
				//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2019-06-28 (#3386)				
				НаборПриемник = ДокументОбъект.Движения[ИмяПриемника];
				
				// ++ NB 25.01.19 BF-2860 Отключено:
				//Если ЗаписыватьДвижения ИЛИ НаборИсточник.Количество() = 0 Тогда
				//	НаборИсточник.Прочитать();
				//КонецЕсли; 
				// -- NB 
				
				//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2019-06-28 (#3386)
				// Возвращаю назад, чтобы в трансляции МУ-МУ ранее оформленные проводки на МСФО не очищались,
				// очистка происходит, если МУ-МУ запускать отдельно.
				Если ЗаписыватьДвижения ИЛИ НаборИсточник.Количество() = 0 Тогда
					НаборИсточник.Прочитать();
				КонецЕсли;
				//ОКЕЙ Наумов А.Н.(СофтЛаб) Конец 2019-06-28 (#3386)
				
				Если РегистрУчаствуетВДвижениях(ДокументОбъект.Движения,"бит_СоответствиеЗаписейТрансляции") Тогда
					// Набор записей для хранения соответствия номеров записей источника и приемника.
					НаборСоответствие = ДокументОбъект.Движения.бит_СоответствиеЗаписейТрансляции;
					Если ЗаписыватьДвижения ИЛИ НаборСоответствие.Количество() = 0 Тогда
						НаборСоответствие.Прочитать();
					КонецЕсли; 
				Иначе
					НаборСоответствие = Неопределено;
				КонецЕсли; 
				
				Если РегистрУчаствуетВДвижениях(ДокументОбъект.Движения,"бит_СоответствиеОборотовТрансляции") Тогда
					// Набор записей для хранения соответствия номеров записей источника и приемника.
					НаборСоответствиеОборотов = ДокументОбъект.Движения.бит_СоответствиеОборотовТрансляции;
					Если ЗаписыватьДвижения ИЛИ НаборСоответствиеОборотов.Количество() = 0 Тогда
						НаборСоответствиеОборотов.Прочитать();
					КонецЕсли; 
				Иначе
					НаборСоответствиеОборотов = Неопределено;
				КонецЕсли; 
				
				// Определим вид регистров источника и приемника.
				ВидыРегистров = КонструкторСтруктурыВидыРегистров();				
				ВидыРегистров.ИсточникРегистрБухгалтерии = бит_ОбщегоНазначения.ОбъектПринадлежитКоллекцииМетаданных("РегистрыБухгалтерии",ИмяИсточника);													
				ВидыРегистров.ИсточникРегистрНакопления  = бит_ОбщегоНазначения.ОбъектПринадлежитКоллекцииМетаданных("РегистрыНакопления" ,ИмяИсточника);													
				ВидыРегистров.ПриемникРегистрБухгалтерии = бит_ОбщегоНазначения.ОбъектПринадлежитКоллекцииМетаданных("РегистрыБухгалтерии",ИмяПриемника);													
				ВидыРегистров.ПриемникРегистрНакопления  = бит_ОбщегоНазначения.ОбъектПринадлежитКоллекцииМетаданных("РегистрыНакопления" ,ИмяПриемника);													
				
				// Подготовим структуру параметров для передачи в процедуру трансляции.
				СтруктураПараметров = КонструкторСтруктурыПараметровТрансляции();				
				СтруктураПараметров.ОбязательныеПоля  = СтруктураПравила.ОбязательныеПоля;
				СтруктураПараметров.ПравилоЗаполнения = ВыборкаПравилоЗаполнения.ПравилоЗаполнения;
				СтруктураПараметров.ПравилаТрансляции = МассивПравил;
				СтруктураПараметров.КодУсловияТрансляции    = КодУсловияТрансляции;
				СтруктураПараметров.СтруктураШапкиДокумента = СтруктураШапкиДокумента;
				СтруктураПараметров.ПользовательскиеФункции = СтруктураПравила.ПользовательскиеФункции;
				СтруктураПараметров.ДополнительныеАналитики = ДополнительныеАналитики;
				СтруктураПараметров.ПризнакиУчета           = ЗаполнитьПризнакиУчета(ВыборкаПриемник.Приемник);
				СтруктураПараметров.ВидыРегистров           = ВидыРегистров;
				СтруктураПараметров.ЗаписыватьДвижения      = ЗаписыватьДвижения;
				СтруктураПараметров.ОбъектСистемыИсточник   = ВыборкаПриемник.Источник;
				СтруктураПараметров.ОбъектСистемыПриемник   = ВыборкаПриемник.Приемник;
				СтруктураПараметров.НаборСоответствие         = НаборСоответствие;
				СтруктураПараметров.НаборСоответствиеОборотов = НаборСоответствиеОборотов;
				СтруктураПараметров.ВестиПротокол             = ВестиПротокол;
				СтруктураПараметров.РежимИспользованияСоответствий = ВыборкаПравилоЗаполнения.РежимИспользованияСоответствий;
				
				Если ВидыРегистров.ИсточникРегистрБухгалтерии Тогда
					СтруктураПараметров.МетаданныеИсточника = Метаданные.РегистрыБухгалтерии[ИмяИсточника];
				ИначеЕсли ВидыРегистров.ИсточникРегистрНакопления Тогда	
					СтруктураПараметров.МетаданныеИсточника = Метаданные.РегистрыНакопления[ИмяИсточника];
				КонецЕсли; 
				
				Если ВидыРегистров.ПриемникРегистрБухгалтерии Тогда
					СтруктураПараметров.МетаданныеПриемника = Метаданные.РегистрыБухгалтерии[ИмяПриемника];
				ИначеЕсли ВидыРегистров.ПриемникРегистрНакопления Тогда	
					СтруктураПараметров.МетаданныеПриемника = Метаданные.РегистрыНакопления[ИмяПриемника];
				КонецЕсли; 
				
				ВидыРегистров.МетаданныеИсточника 			 = СтруктураПараметров.МетаданныеИсточника;
				ВидыРегистров.МетаданныеПриемника     		 = СтруктураПараметров.МетаданныеПриемника;
				ВидыРегистров.РежимИспользованияСоответствий = СтруктураПараметров.РежимИспользованияСоответствий;
				
				СтруктураПараметров.МетаданныеРегистратора = МетаданныеИсточник;
				
				ПараметрыАвтозаполнения = ПодготовитьПараметрыАвтозаполнения(СтруктураПараметров);
				СтруктураПараметров.ПараметрыАвтозаполнения = ПараметрыАвтозаполнения;
				
				ДобавитьСообщениеВПротокол(Протокол,"");				
				ДобавитьСообщениеВПротокол(Протокол,ИмяИсточника+" --> "+ИмяПриемника);
				
				// Выполним трансляцию для конкретной пары Источник --> Приемник.
				флЕстьОшибки = ВыполнитьТрансляциюДвижений(ДокументОбъект,НаборИсточник,НаборПриемник,СтруктураПараметров,Протокол,ОбработанныеПриемники);
				
				// Добавление кода. Начало: 13.10.2016 # 000000005227 {{
				ТрансляцияПриПроведенииЕстьРучноеРедактированиеФакта(ДокументОбъект, НаборПриемник, СтруктураПараметров, Протокол, флЕстьОшибки);
				// Добавление кода конец }}  

				Если НЕ флЕстьОшибки Тогда
					ОбработанныеПары.Вставить(ИмяИсточника+"_"+ИмяПриемника, Истина);
				КонецЕсли; 
			КонецЦикла; // По приемникам
		КонецЦикла; // По источникам
	КонецЦикла; // Правило заполнения
	
	ДобавитьСообщениеВПротокол(Протокол,"Трансляция завершена.",ВестиПротокол);
	
	УстановитьПривилегированныйРежим(Ложь);	
	РезДанные = Новый Структура("ЕстьОшибки, Протокол", флЕстьОшибки, Протокол);
	Возврат РезДанные;
	
КонецФункции // ВыполнитьТрансляцию()

// Функция выполняет отмену трансляции движений - набора записей регистра приемника.
// 
// Параметры:
//  ДокументСсылка    - ДокументСсылка.
//  РегистрыПриемники - Массив.
// 
// Возвращаемое значение:
//  Строка - текст протокола.
// 
Функция ОтменитьТрансляцию(ДокументСсылка, РегистрыПриемники) Экспорт
	
	МетаданныеДокумента = ДокументСсылка.Метаданные();
	
	Протокол = Нстр("ru = 'Выполняется отмена трансляции движений (%1%) по документу %2%.'");
	Протокол = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(Протокол, ТекущаяДата(), ДокументСсылка);
			
	Для Каждого ТекРегистр Из РегистрыПриемники Цикл
		
		Если ТекРегистр.ВидОбъекта = Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии Тогда
			
			МенеджерРегистра = бит_ОбщегоНазначения.ПолучитьМенеджер("РегистрыБухгалтерии");
			ПредставлеРегистра = Нстр("ru = 'движения регистра бухгалтерии'");
			
		ИначеЕсли ТекРегистр.ВидОбъекта = Перечисления.бит_ВидыОбъектовСистемы.РегистрНакопления Тогда
			
			МенеджерРегистра = бит_ОбщегоНазначения.ПолучитьМенеджер("РегистрыНакопления");
			ПредставлеРегистра = Нстр("ru = 'движения регистра накопления'");
			
		Иначе
			
			МенеджерРегистра = Неопределено;
			
		КонецЕсли;
		
		Если МенеджерРегистра = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		НаборДляОчистки = МенеджерРегистра[ТекРегистр.ИмяОбъекта].СоздатьНаборЗаписей();
		НаборДляОчистки.Отбор.Регистратор.Установить(ДокументСсылка);
		НаборДляОчистки.Прочитать();
		
		Если НаборДляОчистки.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		НаборДляОчистки.Очистить();
				
		// Запишем очищенный набор записей.
		флВыполненаЗапись = бит_ОбщегоНазначения.ЗаписатьНаборЗаписейРегистра(НаборДляОчистки);
		Если флВыполненаЗапись Тогда
			
			// Успешная запись
			Протокол = Протокол + Символы.ПС + Нстр("ru = 'Отменены '");
			
			// бит_СоответствиеЗаписейТрансляции
			Если МетаданныеДокумента.Движения.Содержит(Метаданные.РегистрыСведений.бит_СоответствиеЗаписейТрансляции) Тогда
				
				// Очистка соответсвия номеров движений
				НаборСоответствие = РегистрыСведений.бит_СоответствиеЗаписейТрансляции.СоздатьНаборЗаписей();
				НаборСоответствие.Отбор.Регистратор.Установить(ДокументСсылка);
				НаборСоответствие.Прочитать();
				
				бит_МеханизмТрансляции.ОчиститьСоответствиеДвижений(НаборСоответствие, , ТекРегистр);
				
				бит_ОбщегоНазначения.ЗаписатьНаборЗаписейРегистра(НаборСоответствие);			
				
			КонецЕсли;
			
			// бит_СоответствиеОборотовТрансляции
			Если МетаданныеДокумента.Движения.Содержит(Метаданные.РегистрыНакопления.бит_СоответствиеОборотовТрансляции) Тогда
				
				// Очистка соответсвия номеров движений
				НаборСоответствие = РегистрыНакопления.бит_СоответствиеОборотовТрансляции.СоздатьНаборЗаписей();
				НаборСоответствие.Отбор.Регистратор.Установить(ДокументСсылка);
				НаборСоответствие.Прочитать();
				
				бит_МеханизмТрансляции.ОчиститьСоответствиеДвижений(НаборСоответствие, , ТекРегистр);
				
				бит_ОбщегоНазначения.ЗаписатьНаборЗаписейРегистра(НаборСоответствие);			
				
			КонецЕсли;
			
			// бит_ОборотыПоТипамПроводок
			Если МетаданныеДокумента.Движения.Содержит(Метаданные.РегистрыНакопления.бит_ОборотыПоТипамПроводок) Тогда
				
				// Очистка соответсвия номеров движений
				НаборСоответствие = РегистрыНакопления.бит_ОборотыПоТипамПроводок.СоздатьНаборЗаписей();
				НаборСоответствие.Отбор.Регистратор.Установить(ДокументСсылка);
				НаборСоответствие.Прочитать();
				
				бит_МеханизмТрансляции.ОчиститьСоответствиеДвиженийПоТипуПроводки(НаборСоответствие, ТекРегистр);
				
				бит_ОбщегоНазначения.ЗаписатьНаборЗаписейРегистра(НаборСоответствие);			
				
			КонецЕсли;
			
		Иначе
			
			// Не успешная запись
			Протокол = Протокол + Символы.ПС + Нстр("ru = 'Не отменены '");
								
		КонецЕсли;
		
		Протокол = Протокол + ПредставлеРегистра + ": " + ТекРегистр.Наименование + ".";
		
	КонецЦикла;
	
	Возврат Протокол;
	
КонецФункции // ОтменитьТрансляцию()

// Процедура выполняет подбор счетов для различных приемника и источника.
// 
// Параметры:
//  СтруктураПараметров  - Структура - Ключи: {Счет,Субконто<i>} или {СчетДт,СчетКт,СубконтоДт<i>,СубконтоКт<i>}.
//  Организация          - СправочникСсылка.Организации.
//  ДатаПравил           - Дата.
//  ИмяРегистраИсточник  - Строка.
//  ИмяРегистраПриемник  - Строка.
// 
// Возвращаемое значение:
// РезСтруктура - Структура - Ключи: {Счет,Субконто<i>} или {СчетДт,СчетКт,СубконтоДт<i>,СубконтоКт<i>}.
// 
Функция ВыполнитьПодборСчетов(СтруктураПараметров
	                           ,Организация
							   ,ДатаПравил
	                           ,ИмяРегистраИсточник = "Хозрасчетный"
							   ,ИмяРегистраПриемник = "бит_Дополнительный_2") Экспорт

	Если СтруктураПараметров.Счет = Неопределено Тогда
		ЭтоПодборБезКорреспонденции = Ложь;
	Иначе 	
		ЭтоПодборБезКорреспонденции = Истина;
	КонецЕсли; 
	
	// Создаем наборы источник и приемник
	НаборИсточник = РегистрыБухгалтерии[ИмяРегистраИсточник].СоздатьНаборЗаписей();
	НаборПриемник = РегистрыБухгалтерии[ИмяРегистраПриемник].СоздатьНаборЗаписей();
	
	// Определяем максимальное количество субконто источника и приемника.
	ИмяПланаСчетовИсточник     = Метаданные.РегистрыБухгалтерии[ИмяРегистраИсточник].ПланСчетов.Имя;
	КоличествоСубконтоИсточник = Метаданные.ПланыСчетов[ИмяПланаСчетовИсточник].МаксКоличествоСубконто;
	
	ИмяПланаСчетовПриемник     = Метаданные.РегистрыБухгалтерии[ИмяРегистраПриемник].ПланСчетов.Имя;
	КоличествоСубконтоПриемник = Метаданные.ПланыСчетов[ИмяПланаСчетовПриемник].МаксКоличествоСубконто;
	
	// Инициализируем результирующую структуру
	Если ЭтоПодборБезКорреспонденции Тогда
		
		РезСтруктура = Новый Структура;
		РезСтруктура.Вставить("Счет");
		Для й = 1 По КоличествоСубконтоПриемник Цикл
		
			РезСтруктура.Вставить("Субконто"+й);
		
		КонецЦикла; 
		
	Иначе	
		
		РезСтруктура = Новый Структура;
		РезСтруктура.Вставить("СчетДт");
		РезСтруктура.Вставить("СчетКт");		
		Для й = 1 По КоличествоСубконтоПриемник Цикл
		
			РезСтруктура.Вставить("СубконтоДт"+й);
			РезСтруктура.Вставить("СубконтоКт"+й);
		
		КонецЦикла; 
		
	КонецЕсли; 
	
	// Заполним набор записей источник по переданной стуктуре.
	ЗаписьИсточник = НаборИсточник.Добавить();
	
	// Заполним счета
	Если ЭтоПодборБезКорреспонденции Тогда
		ЗаписьИсточник.СчетДт = СтруктураПараметров.Счет;
		ЗаписьИсточник.СчетКт = СтруктураПараметров.Счет;
		Если Не СтруктураПараметров.Подразделение = Неопределено Тогда
			ЗаписьИсточник.ПодразделениеДт = СтруктураПараметров.Подразделение; 
			ЗаписьИсточник.ПодразделениеКт = СтруктураПараметров.Подразделение; 
		КонецЕсли;
	Иначе	
		ЗаписьИсточник.СчетДт = СтруктураПараметров.СчетДт;
		ЗаписьИсточник.СчетКт = СтруктураПараметров.СчетКт;
	КонецЕсли; 
	
	// Заполним аналитику
	Для й = 1 По КоличествоСубконтоИсточник Цикл
		
		Если ЭтоПодборБезКорреспонденции Тогда
		   ИмяСубконтоДт = "Субконто"+й;
		   ИмяСубконтоКт = "Субконто"+й;
		Иначе	
		   ИмяСубконтоДт = "СубконтоДт"+й;
		   ИмяСубконтоКт = "СубконтоКт"+й;
		КонецЕсли; 
		
		Если Не СтруктураПараметров[ИмяСубконтоДт] = Неопределено Тогда
			бит_му_ОбщегоНазначения.УстановитьСубконто(ЗаписьИсточник.СчетДт,ЗаписьИсточник.СубконтоДт,й,СтруктураПараметров[ИмяСубконтоДт]);
	    КонецЕсли; 
	    Если Не СтруктураПараметров[ИмяСубконтоКт] = Неопределено Тогда
			бит_му_ОбщегоНазначения.УстановитьСубконто(ЗаписьИсточник.СчетКт,ЗаписьИсточник.СубконтоКт,й,СтруктураПараметров[ИмяСубконтоКт]);
		КонецЕсли; 
		
	КонецЦикла; 
	
	Протокол = "";
	
	МетаИсточник = Метаданные.РегистрыБухгалтерии[ИмяРегистраИсточник];
	МетаПриемник = Метаданные.РегистрыБухгалтерии[ИмяРегистраПриемник];
	ПараметрыТрансляции = ПодготовитьСтруктуруПараметровДляПодбораСчетов(Организация,ДатаПравил,МетаИсточник,МетаПриемник, СтруктураПараметров.ТекущийОбъект);
	
	// Выполним подбор счетов по правилам трансляции.
	ТекущийОбъект = СтруктураПараметров.ТекущийОбъект;		
	ПараметрыТрансляции.Вставить("ОбработкаБезДокумента", СтруктураПараметров.ОбработкаБезДокумента);
	
	бит_МеханизмТрансляции.ВыполнитьТрансляциюДвижений(ТекущийОбъект, НаборИсточник, НаборПриемник, ПараметрыТрансляции, Протокол);
	
	// Изменение кода. Начало. 07.06.2016{{
	РезСтруктура.Вставить("ЦФО");
	// Изменение кода. Конец. 07.06.2016}}
	// Заполним результирующую структуру исходя из сформированного набора приемника.
	Если НаборПриемник.Количество()>0 Тогда
	
		 ЗаписьПриемник = НаборПриемник[0];
		 
		 Если ЭтоПодборБезКорреспонденции Тогда
			 
			 РезСтруктура.Счет = ЗаписьПриемник.СчетДт;
			 Для й=1 По КоличествоСубконтоПриемник Цикл
			 
			 	РезСтруктура["Субконто"+й] = бит_МеханизмТрансляции.ЗначениеСубконто(ЗаписьПриемник,"Дт",й);
			 
			 КонецЦикла; 
			 
		 Иначе	
			 
			 РезСтруктура.СчетДт = ЗаписьПриемник.СчетДт;
			 РезСтруктура.СчетКт = ЗаписьПриемник.СчетКт;
			 
			 Для й=1 По КоличествоСубконтоПриемник Цикл
			 
			 	РезСтруктура["СубконтоДт"+й] = бит_МеханизмТрансляции.ЗначениеСубконто(ЗаписьПриемник,"Дт",й);
			 	РезСтруктура["СубконтоКт"+й] = бит_МеханизмТрансляции.ЗначениеСубконто(ЗаписьПриемник,"Кт",й);				
			 
			 КонецЦикла; 
			 
		 КонецЕсли; 
		 
		// Изменение кода. Начало. 07.06.2016{{
		Если ТипЗнч(ЗаписьПриемник) = Тип("РегистрБухгалтерииЗапись.бит_Бюджетирование") Тогда
		
			РезСтруктура.ЦФО = ЗаписьПриемник.ЦФО;
		
		КонецЕсли; 
		// Изменение кода. Конец. 07.06.2016}}
		 
	КонецЕсли; // Набор приемник содержит записи
	
	Возврат РезСтруктура;

КонецФункции // ВыполнитьПодборСчетов()

// Функция готовит структуру параметров трансляции для выполнения подбора счетов по правилам трансляции.
// 
// Параметры:
//  Организация  - СправочникСсылка.Организация.
//  ДатаПравил   - Дата.
//  МетаРегистрИсточник - .
//  МетаРегистрПриемник - .
//  ТекОбъект - ДокументОбъект (По умолчанию = Неопределено).
// 
// Возвращаемое значение:
//   СтруктураПараметров   - Структура.
// 
Функция ПодготовитьСтруктуруПараметровДляПодбораСчетов(Организация,ДатаПравил,МетаРегистрИсточник,МетаРегистрПриемник, ТекОбъект = Неопределено)  Экспорт

	РегистрИсточник = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(МетаРегистрИсточник);	
	РегистрПриемник = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(МетаРегистрПриемник);
	
	МассивНазначений = Новый Массив;
	МассивНазначений.Добавить(Перечисления.бит_НазначенияПравилТрансляции.ПодборСчетов);
	МассивНазначений.Добавить(Перечисления.бит_НазначенияПравилТрансляции.ТрансляцияИПодборСчетов);
	
	
	МассивПравил    = бит_МеханизмТрансляции.ПолучитьПравилаТрансляцииДляПодбораСчетов(Организация
	                                                                                   ,ДатаПравил
	                                                                                   ,МассивНазначений
																					   ,РегистрИсточник
																					   ,РегистрПриемник);
	
																					   
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Источник", РегистрИсточник);
	Запрос.УстановитьПараметр("Приемник", РегистрПриемник);
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ТабНазначения.ПравилоЗаполнения
	               |ИЗ
	               |	РегистрСведений.бит_НазначениеПравилЗаполненияПриТрансляции КАК ТабНазначения
	               |ГДЕ
	               |	ТабНазначения.Источник = &Источник
	               |	И ТабНазначения.Приемник = &Приемник
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ТабНазначения.Приоритет";
				   
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		ПравилоЗаполнения = Выборка.ПравилоЗаполнения;
		
	Иначе	
		
		ПравилоЗаполнения = Справочники.бит_ПравилаЗаполненияПолейПриТрансляции.ПустаяСсылка();
		
	КонецЕсли; 
																					   
	СтруктураПараметров = бит_МеханизмТрансляции.КонструкторСтруктурыПараметровТрансляции();														
														
	СтруктураПараметров.ОбязательныеПоля  = Новый Структура;
	СтруктураПараметров.ПравилоЗаполнения = ПравилоЗаполнения;
	СтруктураПараметров.ПравилаТрансляции = МассивПравил;
	
	СтруктураШапкиДокумента = Новый Структура("ВалютаРегламентированногоУчета", Константы.ВалютаРегламентированногоУчета.Получить());
	СтруктураПараметров.СтруктураШапкиДокумента = СтруктураШапкиДокумента;	
	
	Если ТекОбъект <> Неопределено И РегистрПриемник.ИмяОбъекта = "бит_Дополнительный_2" Тогда
		СтруктураШапкиМСФО = бит_ОбщегоНазначения.СформироватьСтруктуруШапкиДокумента(ТекОбъект);
		СтруктураШапкиМСФО.Организация = Организация;
		СтруктураШапкиМСФО.Вставить("бит_ВалютаУправленческогоУчета", Константы.бит_ВалютаУправленческогоУчета.Получить());
		СтруктураШапкиМСФО.Вставить("бит_ВалютаМУ"					, бит_му_ОбщегоНазначения.ПолучитьВалютуМеждународногоУчета(Организация));
		СтруктураПараметров.Вставить("СтруктураШапкиМСФО"			, СтруктураШапкиМСФО);		
	КонецЕсли;
	
	СтруктураПараметров.ПользовательскиеФункции = Новый Соответствие;
	СтруктураПараметров.ДополнительныеАналитики = Новый Соответствие;
	СтруктураПараметров.ПризнакиУчета           = бит_МеханизмТрансляции.ЗаполнитьПризнакиУчета(РегистрПриемник);
	СтруктураПараметров.ВидыРегистров           = бит_МеханизмТрансляции.КонструкторСтруктурыВидыРегистров(Истина,Ложь,Истина,Ложь);
	СтруктураПараметров.МетаданныеИсточника     = Метаданные.РегистрыБухгалтерии[МетаРегистрИсточник.Имя];
	СтруктураПараметров.МетаданныеПриемника     = Метаданные.РегистрыБухгалтерии[МетаРегистрПриемник.Имя];
	СтруктураПараметров.ЗаписыватьДвижения      = Ложь;
	СтруктураПараметров.ВестиПротокол           = Истина;
	
	Возврат СтруктураПараметров;

КонецФункции // ПодготовитьСтруктуруПараметровДляПодбораСчетов()

// Функция получает массив правил трансляции для подбора счетов.
// 
// Параметры:
//  Организация  - СправочникСсылка.Организации.
//  ДатаЗапроса  - Дата.
//  МассивНазначений - Массив.
//  РегистрИсточник  - СправочникСсылка.бит_ОбъектыСистемы.
//  РегистрПриемник  - СправочникСсылка.бит_ОбъектыСистемы.
// 
// Возвращаемое значение:
//   МассивПравил - Массив.
// 
Функция ПолучитьПравилаТрансляцииДляПодбораСчетов(Организация,ДатаЗапроса,МассивНазначений,РегистрИсточник,РегистрПриемник)  Экспорт

	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.УстановитьПараметр("ДатаЗапроса",ДатаЗапроса);
	Запрос.УстановитьПараметр("ПустаяДата",Дата('00010101'));
	Запрос.УстановитьПараметр("МассивНазначений",МассивНазначений);
	Запрос.УстановитьПараметр("Источник",РегистрИсточник);
	Запрос.УстановитьПараметр("Приемник",РегистрПриемник);
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	0 КАК Приоритет,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции КАК ПравилаТрансляции,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Источник КАК Источник,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Приемник КАК Приемник,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.Приоритет КАК ПриоритетПравилаТрансляции
	               |ПОМЕСТИТЬ ТаблицаПравилТрансляции
	               |ИЗ
	               |	РегистрСведений.бит_НазначениеПравилТрансляции.СрезПоследних(
	               |			&ДатаЗапроса,
	               |			(СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	               |				ИЛИ СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.бит_ГруппыСтруктурныхПодразделений.ПустаяСсылка))
	               |				И (ДатаОкончания > &ДатаЗапроса
	               |					ИЛИ ДатаОкончания = &ПустаяДата)
	               |				И Назначение В (&МассивНазначений)) КАК бит_НазначениеПравилТрансляцииСрезПоследних
	               |ГДЕ
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Источник = &Источник
	               |	И бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Приемник = &Приемник
	               |
	               |ОБЪЕДИНИТЬ ВСЕ
	               |
	               |ВЫБРАТЬ
	               |	1,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Источник,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Приемник,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.Приоритет
	               |ИЗ
	               |	РегистрСведений.бит_НазначениеПравилТрансляции.СрезПоследних(
	               |			&ДатаЗапроса,
	               |			СтруктурноеПодразделение В
	               |					(ВЫБРАТЬ
	               |						бит_ГруппыСтруктурныхПодразделенийСостав.Ссылка
	               |					ИЗ
	               |						Справочник.бит_ГруппыСтруктурныхПодразделений.Состав КАК бит_ГруппыСтруктурныхПодразделенийСостав
	               |					ГДЕ
	               |						бит_ГруппыСтруктурныхПодразделенийСостав.СтруктурноеПодразделение = &Организация)
	               |				И (ДатаОкончания > &ДатаЗапроса
	               |					ИЛИ ДатаОкончания = &ПустаяДата)
	               |				И Назначение В (&МассивНазначений)) КАК бит_НазначениеПравилТрансляцииСрезПоследних
	               |ГДЕ
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Источник = &Источник
	               |	И бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Приемник = &Приемник
	               |
	               |ОБЪЕДИНИТЬ ВСЕ
	               |
	               |ВЫБРАТЬ
	               |	2,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Источник,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Приемник,
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.Приоритет
	               |ИЗ
	               |	РегистрСведений.бит_НазначениеПравилТрансляции.СрезПоследних(
	               |			&ДатаЗапроса,
	               |			СтруктурноеПодразделение = &Организация
	               |				И (ДатаОкончания > &ДатаЗапроса
	               |					ИЛИ ДатаОкончания = &ПустаяДата)
	               |				И Назначение В (&МассивНазначений)) КАК бит_НазначениеПравилТрансляцииСрезПоследних
	               |ГДЕ
	               |	бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Источник = &Источник
	               |	И бит_НазначениеПравилТрансляцииСрезПоследних.ПравилоТрансляции.Приемник = &Приемник
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ТаблицаПравилТрансляции.ПравилаТрансляции
	               |ИЗ
	               |	ТаблицаПравилТрансляции КАК ТаблицаПравилТрансляции
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ТаблицаПравилТрансляции.Приоритет,
	               |	ТаблицаПравилТрансляции.ПриоритетПравилаТрансляции
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |УНИЧТОЖИТЬ ТаблицаПравилТрансляции";


	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	МассивПравил = Новый Массив;
	Пока Выборка.Следующий() Цикл
	
	  МассивПравил.Добавить(Выборка.ПравилаТрансляции);	
	
	КонецЦикла; 
	
	Возврат МассивПравил;
	
КонецФункции // ПолучитьПравилаТрансляцииДляПодбораСчетов()

// Процедура дополняет структуру шапки документа необходимыми полями.
// 
// Параметры:
//  ТекущийОбъект  - ДокументОбъект.
//  СтруктураШапкиДокумента - Структура.
// 
Процедура ДополнитьСтруктуруШапкиДокумента(ТекущийОбъект,СтруктураШапкиДокумента) Экспорт
	
	Если НЕ СтруктураШапкиДокумента.Свойство("ВалютаРегламентированногоУчета") Тогда
		
		СтруктураШапкиДокумента.Вставить("ВалютаРегламентированногоУчета",Константы.ВалютаРегламентированногоУчета.Получить());
		
	КонецЕсли; 	
	СтруктураШапкиДокумента.Вставить("бит_ВалютаУправленческогоУчета",Константы.бит_ВалютаУправленческогоУчета.Получить());
	СтрКурса = бит_КурсыВалют.ПолучитьКурсВалюты(СтруктураШапкиДокумента.бит_ВалютаУправленческогоУчета,СтруктураШапкиДокумента.Дата);
	СтруктураШапкиДокумента.Вставить("бит_КурсУпр",СтрКурса.Курс);
	СтруктураШапкиДокумента.Вставить("бит_КратностьУпр",СтрКурса.Кратность);
	
КонецПроцедуры // ДополнитьСтруктуруШапкиДокумента()

// Функция заполняет структуру признаков учета для регистра бухгалтерии. 
// Структура признаков учета в дальнейшем используется дла проверки заполнения свойств регистров 
// (измерений и ресурсов) с признаками учета.
// 
// Параметры:
//  ОбъектСистемы  - СправочникСсылка.бит_ОбъектыСистемы.
// 
// Возвращаемое значение:
//   ПризнакиУчета   - Структура- ключ: ИмяСвойства, значение: ИмяПризнакаУчета.
// 
Функция ЗаполнитьПризнакиУчета(ОбъектСистемы)  Экспорт
	
	ПризнакиУчета = Новый Структура;	
	
	МетаРегистр = Неопределено;
	Если ОбъектСистемы.ВидОбъекта = Перечисления.бит_ВидыОбъектовСистемы.РегистрБухгалтерии Тогда
		МетаРегистр = Метаданные.РегистрыБухгалтерии[ОбъектСистемы.ИмяОбъекта];
	КонецЕсли; 	
	
	Если МетаРегистр <> Неопределено Тогда
		
		ДобавитьПризнакиУчета(МетаРегистр,"Измерения",ПризнакиУчета);
		ДобавитьПризнакиУчета(МетаРегистр,"Ресурсы",ПризнакиУчета);
		
		
	КонецЕсли; 
	
	Возврат ПризнакиУчета;
	
КонецФункции // ЗаполнитьПризнакиУчета()

// Функция получает дополнительные аналитики для объекта из регистра сведений бит_ДополнительныеАналитики.
// 
// Параметры:
//  ТекущийОбъект  - СправочникСсылка, ДокументСсылка.
//  ТипКлюча       - Строка - "Строка","ПВХ".
// 
// Возвращаемое значение:
//   Аналитики   - Соответствие - Ключ: ПланВидовХарактеристикСсылка.бит_ДополнительныеАналитики.
// 
Функция ПолучитьАналитикиОбъекта(ТекущийОбъект,ТипКлюча = "Строка") Экспорт

	Аналитики = Новый Соответствие;
	
	Запрос = Новый Запрос;
	Запрос.Текст =  "ВЫБРАТЬ
	                |	бит_ДополнительныеАналитики.Аналитика,
	                |	бит_ДополнительныеАналитики.ЗначениеАналитики
	                |ИЗ
	                |	РегистрСведений.бит_ДополнительныеАналитики КАК бит_ДополнительныеАналитики
	                |ГДЕ
	                |	бит_ДополнительныеАналитики.Объект = &Объект";
					
	Запрос.УстановитьПараметр("Объект",ТекущийОбъект);
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если ВРег(ТипКлюча) = ВРег("Строка") Тогда
			
			ИмяАналитики = СформироватьИмяАналитики(Выборка.Аналитика,Истина);
			Аналитики.Вставить(ИмяАналитики,Выборка.ЗначениеАналитики);
			
		Иначе
			
		    Аналитики.Вставить(Выборка.Аналитика,Выборка.ЗначениеАналитики);
		  
		КонецЕсли; 
	
	КонецЦикла; 
	
	Если бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
		Если ВРег(ТипКлюча) = ВРег("Строка") Тогда
			Аналитики.Вставить(ВРЕГ("РучнаяКорректировкаФактаБюджета"),
			бит_МеханизмДопИзмерений.ЕстьРучнаяКорректировкаФакта(ТекущийОбъект));
		КонецЕсли;
	КонецЕсли; 

	Возврат Аналитики;
	
КонецФункции // ПолучитьАналитикиОбъекта()

// Экспортная функция для передачи исполнения функции локального контекста "ПолучитьДоступныеПравилаТрансляции".   
// 
Функция ПолучитьДоступныеПравилаТрансляцииПереопределяемый(Организация,ДокументОбъект,Дата,РегистрыИсточники,РегистрыПриемники) Экспорт 

	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код (	
	//Возврат ПолучитьДоступныеПравилаТрансляции(Организация,ДокументОбъект,Дата,РегистрыИсточники,РегистрыПриемники);	
	Возврат ПолучитьДоступныеПравилаТрансляции(Организация,ДокументОбъект,Дата,РегистрыИсточники,РегистрыПриемники,);	
	//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код )

КонецФункции // ПолучитьДоступныеПравилаТрансляцииПереопределяемый()

// Функция проверяет есть ли заданное субконто на данном счете или нет.
// 
// Параметры
//  ВидСубконто  - ПланВидовХарактеристикСсылка.
//  Счет         - ПланСчетовСсылка.
// 
// Возвращаемое значение:
//   ЕстьСубконто   - Булево
// 
Функция ЕстьСубконтоНаСчете(Счет,ВидСубконто,ПВХ=НЕОПРЕДЕЛЕНО)  Экспорт
	
	ЕстьСубконто = Истина;
	
	Если ЗначениеЗаполнено(Счет) Тогда
		
		ВидыСубконтоСчета = Счет.ВидыСубконто;
		
		Если ТипЗнч(ВидСубконто) = Тип("Строка") Тогда
			ТекВидСубконто = ПВХ[ВидСубконто];
		Иначе
			ТекВидСубконто = ВидСубконто;
		КонецЕсли; 
		
		Если ВидыСубконтоСчета.Найти(ТекВидСубконто) = Неопределено Тогда
			ЕстьСубконто = Ложь;
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат ЕстьСубконто;
	
КонецФункции // ЕстьСубконтоНаСчете()

// Функция определяет является ли данный реквизит дополнительным реквизитом/свойством.
// 
// Параметры:
//  ИмяРеквизита - Строка.
// 
// Возвращаемое значение:
//  флДопРеквизит - Булево.
// 
Функция ЭтоДопРеквизит(ИмяРеквизита) Экспорт

	флДопРеквизит = ?(Найти(ИмяРеквизита, "ДополнительныйРеквизит_")>0 
						 ИЛИ Найти(ИмяРеквизита, "ДополнительноеСвойство_")> 0, Истина, Ложь);
	
	

	Возврат флДопРеквизит;
	
КонецФункции // ЭтоДопРеквизит()

Функция ТипыЗначенийВФорме(ОписаниеТипов) Экспорт

		

КонецФункции

// Процедура создает колонки таблицы, используемой для настройки правил трансляции. 
// 
// Параметры:
//  ТекущаяФорма - УправляемаяФорма.
//  Элементы     - ВсеЭлементыФормы.
//  ТабКолонки   - ТаблицаЗначений.
//  ИмяТаблицы   - Строка.
//  УстанавливатьДействия - Булево.
// 
Процедура СоздатьКолонкиТаблицыТрансляции(ТекущаяФорма, Элементы, ТабКолонки, ИмяТаблицы, УстанавливатьДействия = Ложь, ВидыКолонок = Неопределено) Экспорт
	
	КоличествоКолонок = ТабКолонки.Количество();
	
	// Определим, когда необходимо создавать группы колонок.
	Для Индекс = 0 По КоличествоКолонок - 1 Цикл
	
		ТекСтрока = ТабКолонки[Индекс];
		Если Индекс + 1 <= КоличествоКолонок - 1 Тогда
		   СледСтрока = ТабКолонки[Индекс + 1];
		Иначе	
		   СледСтрока = Неопределено;
		КонецЕсли; 
		
		Если ТекСтрока.ПоложениеКолонки = Перечисления.бит_ПоложенияКолонокТаблицы.НоваяКолонка Тогда
			Если  НЕ СледСтрока = Неопределено 
				И НЕ СледСтрока.ПоложениеКолонки = Перечисления.бит_ПоложенияКолонокТаблицы.НоваяКолонка Тогда
				
				ТекСтрока.НачатьГруппу = Истина;
				Если СледСтрока.ПоложениеКолонки = Перечисления.бит_ПоложенияКолонокТаблицы.ВТойЖеКолонке Тогда
					ТекСтрока.ГруппировкаКолонок = ГруппировкаКолонок.Горизонтальная;
				Иначе	
					ТекСтрока.ГруппировкаКолонок = ГруппировкаКолонок.Вертикальная;
				КонецЕсли; 
			Иначе	
				ТекСтрока.ЗакончитьГруппу = Истина;
			КонецЕсли;
		КонецЕсли; 
	КонецЦикла; // КоличествоКолонок
	
	// Удаляем динамические реквизиты
	ОчиститьДинамическиеКолонкиТаблицыТрансляции(ТекущаяФорма, Элементы, ИмяТаблицы);
	// Добавляем динамические реквизиты
	ДобавитьДинамическиеКолонкиТаблицыТрансляции(ТекущаяФорма, Элементы, ТабКолонки, ИмяТаблицы, УстанавливатьДействия, ВидыКолонок);
	// Условное оформление
	УстановитьУсловноеОформлениеКолонокТаблицыТрансляции(ТекущаяФорма.УсловноеОформление, ТабКолонки, ИмяТаблицы);
	
КонецПроцедуры // ОбновитьОтображение()

// Набор параметров для функионала подбора счетов.
//
// Параметры:
//
// Возвращаемое значение:
//   Конструктор  - структура.
//
Функция КонструкторПараметровПодбораСчетов() Экспорт

	Конструктор = Новый Структура;
	Конструктор.Вставить("ТекущийОбъект", Неопределено);
	Конструктор.Вставить("ОбработкаБезДокумента", Ложь);
	Конструктор.Вставить("Счет",          Неопределено);
	Конструктор.Вставить("Подразделение", Неопределено);
	Конструктор.Вставить("Субконто1",     Неопределено);
	Конструктор.Вставить("Субконто2",     Неопределено);
	Конструктор.Вставить("Субконто3",     Неопределено);
	Конструктор.Вставить("Субконто4",     Неопределено);

	Возврат Конструктор;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроверочныеПроцедурыИФункции
                 
// Процедура осуществляет проверку корректности заполнения свойств с признаками учета в записи Приемника.
// Если признак учета не установлен, значение свойства зачищается.
// 
// Параметры:
//  ЗаписьПриемник - РегистрБухгалтерииЗапись,РегистрНакопленияЗапись.
//  ПризнакиУчета  - Структура.
// 
Процедура ПроверитьПризнакиУчета(ЗаписьПриемник,ПризнакиУчета)
	
	Для каждого КлючИЗначение Из ПризнакиУчета Цикл
		
		ИмяСвойства  = КлючИЗначение.Ключ;
		ИмяПризнака  = КлючИЗначение.Значение;
		
		Если ЗначениеЗаполнено(ЗаписьПриемник[ИмяСвойства]) 
			И НЕ ЗаписьПриемник["Счет"+Прав(ИмяСвойства,2)][ИмяПризнака] Тогда
			
			ЗаписьПриемник[ИмяСвойства] = НЕОПРЕДЕЛЕНО;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // ПроверитьВалютныйКоличественныйУчет()

// Процедура проверяет заполнение обязательных полей в записи Приемника. 
// В случае если обязательное поле не заполнено, устанавливается Отказ = Истина, 
// при дальнейшей обработке запись удаляется из Приемника.
// 
// Параметры:
//  ЗаписьПриемник - РегистрБухгалтерииЗапись,РегистрНакопленияЗапись.
//  СтруктураОбязательныхПолей - Структура.
//  НомерСтрокиИсточника       - Число.
//  Отказ                      - Булево.
//  Протокол                   - Строка.
// 
//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-02-11 (#3209)
//Процедура ПроверитьОбязательныеПоля(ЗаписьПриемник,СтруктураОбязательныхПолей,НомерСтрокиИсточника,Отказ,Протокол)
Процедура ПроверитьОбязательныеПоля(ЗаписьПриемник,СтруктураОбязательныхПолей,НомерСтрокиИсточника,Отказ,Протокол,НеУстанавливатьОтказПриПроверкеЗаполнения)
//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-02-11 (#3209)

	Если СтруктураОбязательныхПолей.Количество()>0 Тогда
		// BF-2908. Для регистра бухгалтерии проверка на заполнение для "СчетДт" и "СчетКТ"
		// является обязательным, исключение только для забалансовых счетов.
		Регистр = Лев(ЗаписьПриемник, СтрНайти(ЗаписьПриемник, "Запись") - 1);
		Регистр = ВРег(Регистр);
		ЭтоРегистрБухгалтерии = (Регистр = "РЕГИСТРБУХГАЛТЕРИИ" Или Регистр = "ACCOUNTINGREGISTER");
		Если ЭтоРегистрБухгалтерии Тогда
			
			СвСчДт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ЗаписьПриемник.СчетДт);
			СвСчКт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ЗаписьПриемник.СчетКт);
			
			ЗабалансСчетДт = СвСчДт.Забалансовый;
			ЗабалансСчетКт = СвСчКт.Забалансовый;
			Если ЗабалансСчетДт ИЛИ ЗабалансСчетКт Тогда
				СтруктураОбязательныхПолей.Удалить("СчетДт");
				СтруктураОбязательныхПолей.Удалить("СчетКт");
			Иначе
				Если Не СтруктураОбязательныхПолей.Свойство("СчетДт") Тогда
					СтруктураОбязательныхПолей.Вставить("СчетДт", "Счет Дт");
				КонецЕсли; 
				Если Не СтруктураОбязательныхПолей.Свойство("СчетКт") Тогда
					СтруктураОбязательныхПолей.Вставить("СчетКт", "Счет Кт");
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;		
		
		Для каждого КлючИЗначение Из СтруктураОбязательныхПолей Цикл
			
			ЗначениеПриемника = ЗаписьПриемник[КлючИЗначение.Ключ];
			Если НЕ ЗначениеЗаполнено(ЗначениеПриемника) Тогда
				
				ПолеОбъекта    = ?(ПустаяСтрока(КлючИЗначение.Значение),КлючИЗначение.Ключ,КлючИЗначение.Значение);
				ТекстСообщения = Нстр("ru = 'По строке № %1 Источника не удалось заполнить обязательное поле ""%2"".'");
				ТекстСообщения = СтрШаблон(ТекстСообщения, НомерСтрокиИсточника, ПолеОбъекта); 
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-02-11 (#3209)
				//Отказ 		   = Истина;
				Если Не НеУстанавливатьОтказПриПроверкеЗаполнения Тогда 
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-02-11 (#3209)
					Отказ 		   = Истина;
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-02-11 (#3209)
				КонецЕсли;
				//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-02-11 (#3209)
			
				ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения);				 
				
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли; 

КонецПроцедуры // ПроверитьОбязательныеПоля()

// Функция определяет принадлежит ли регистр коллекции движений документа.
// 
// Параметры:
//  Движения  - КоллекцияДвиженийДокумента.
//  ИмяРегистра - Строка.
// 
// Возвращаемое значение:
//   УчаствуетВДвижениях   - Булево.
// 
Функция РегистрУчаствуетВДвижениях(Движения,ИмяРегистра)
//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код (	
Экспорт
//1С-ИжТиСи, Кондратьев, 16.03.2020, обновление, некомментированный исправленный код )

	Если Движения.Найти(ИмяРегистра) = Неопределено Тогда
		УчаствуетВДвижениях = Ложь;
	Иначе	
		УчаствуетВДвижениях = Истина;
	КонецЕсли; 
	
	Возврат УчаствуетВДвижениях;
	
КонецФункции // РегистрУчаствуетВДвижениях()

#КонецОбласти

#Область ОтрисовкаКолонокТаблицыТрансляции
 
// Функция возвращает имя поля в таблице, используемой для настройки полей трансляции.
// 
// Параметры:
//  ИмяТаблицы - Строка.
//  ИмяКолонки - Строка.
// 
// Возвращаемое значение:
//  ИмяПоля - Строка.
// 
Функция ИмяПоляТаблицыТрансляции(ИмяТаблицы, ИмяКолонки)

	Возврат ИмяТаблицы + "_"+ИмяКолонки;
	
КонецФункции

// Функция добавляет поле формы на форму.
// 
// Параметры:
//  Элементы - Все элементы формы.
//  Имя - Строка.
//  ПутьКДанным - Строка.
//  НастройкиОтображения - Структура.
//  ЭлементКонтейнер     - ЭлементФормы.
// 
// Возвращаемое значение:
//  ЭУ - ПолеФормы.
// 
Функция ДобавитьПолеФормы(Элементы, Имя, ПутьКДанным, НастройкиОтображения, ЭлементКонтейнер = Неопределено)

	ЭУ = Элементы.Добавить(Имя, Тип("ПолеФормы"), ЭлементКонтейнер);
	ЭУ.ПутьКДанным = ПутьКДанным;	
	
	Если НастройкиОтображения.ВидПоля = Перечисления.бит_ВидыПолейПроформы.ПолеФлажка Тогда
		ЭУ.Вид = ВидПоляФормы.ПолеФлажка;
	Иначе
		ЭУ.Вид                       = ВидПоляФормы.ПолеВвода;
		ЭУ.Видимость                 = НастройкиОтображения.Видимость;
		ЭУ.ТолькоПросмотр            = НастройкиОтображения.ТолькоПросмотр;		
		ЭУ.АвтоОтметкаНезаполненного = НастройкиОтображения.ПроверкаЗаполнения;
		ЭУ.Ширина                    = НастройкиОтображения.Ширина;
		ЭУ.КнопкаВыбора              = НастройкиОтображения.КнопкаВыбора;
		ЭУ.КнопкаОткрытия            = НастройкиОтображения.КнопкаОткрытия;
		ЭУ.КнопкаРегулирования       = НастройкиОтображения.КнопкаРегулирования;
		ЭУ.КнопкаОчистки             = НастройкиОтображения.КнопкаОчистки;
		ЭУ.КнопкаВыпадающегоСписка   = НастройкиОтображения.КнопкаСпискаВыбора;
	КонецЕсли; 
	
	Возврат ЭУ;
	
КонецФункции // ДобавитьПолеФормы()

// Функция конструктор, структуры, используемой для передачи параметров элемента управления.
// 
// Возвращаемое значение:
//  НастройкиОтображения - Строка.
// 
Функция КонструкторСтруктурыОтображения()
	
	Поля = ""
	+ "ВидПоля,"
	+ "ПроверкаЗаполнения,"
	+ "Ширина,"
	+ "Видимость,"
	+ "ТолькоПросмотр,"
	+ "КнопкаВыбора,"
	+ "КнопкаРегулирования,"
	+ "КнопкаСпискаВыбора,"
	+ "КнопкаОткрытия,"
	+ "КнопкаОчистки";

	НастройкиОтображения = Новый Структура(Поля);
	
	НастройкиОтображения.Ширина = 0;
	НастройкиОтображения.Видимость = Истина;
	НастройкиОтображения.ТолькоПросмотр = Ложь;
	
	Возврат НастройкиОтображения;
	
КонецФункции // КонструкторСтруктурыОтображения()

// Процедура устанавливает условное оформление колонок таблицы трансляции.
// 
// Параметры:
//  УсловноеОформление - УсловноеОформление.
//  ТаблицаНастроек - ТаблицаЗначений.
//  ИмяТаблицы - Строка.
// 
Процедура УстановитьУсловноеОформлениеКолонокТаблицыТрансляции(УсловноеОформление, ТаблицаНастроек, ИмяТаблицы)

	// Очистка предыдущих настроек
	КоличествоЭлементов = УсловноеОформление.Элементы.Количество();
	Для Сч = 1 По КоличествоЭлементов Цикл
		Номер = КоличествоЭлементов - Сч;
		ЭлементУО = УсловноеОформление.Элементы[Номер];
		Если ЭлементУО.Представление = ИмяТаблицы Тогда
			УсловноеОформление.Элементы.Удалить(ЭлементУО);
		КонецЕсли;	
	КонецЦикла;	
	
	// Оформление для полей источника
	ЭлементУО_Источник = УсловноеОформление.Элементы.Добавить();
	ЭлементУО_Источник.Представление = ИмяТаблицы;
	ЭлементУО_Источник.Использование = Истина;
	
	УсловиеУО 				 = ЭлементУО_Источник.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	УсловиеУО.Использование  = Истина;
	УсловиеУО.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ОтображениеКолонок.ПустойРеквизит");
	УсловиеУО.ВидСравнения   = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	ЭлементУО_Источник.Оформление.УстановитьЗначениеПараметра("ЦветФона", WebЦвета.СветлоЖелтыйЗолотистый);	
	
	// Оформление для полей приемника
	ЭлементУО_Приемник = УсловноеОформление.Элементы.Добавить();
	ЭлементУО_Приемник.Представление = ИмяТаблицы;
	ЭлементУО_Приемник.Использование = Истина;
	
	УсловиеУО 				 = ЭлементУО_Приемник.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	УсловиеУО.Использование  = Истина;
	УсловиеУО.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ОтображениеКолонок.ПустойРеквизит");
	УсловиеУО.ВидСравнения   = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	ЭлементУО_Приемник.Оформление.УстановитьЗначениеПараметра("ЦветФона", WebЦвета.СветлоНебесноГолубой);	
	
	// Заполнение оформляемых полей для элементов оформления источника и приемника.
	Для каждого СтрокаТаблицы Из ТаблицаНастроек Цикл
		Если СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника 
			 ИЛИ СтрокаТаблицы.ИмяКолонки = "ШаблонДвижений" 
			 ИЛИ Найти(СтрокаТаблицы.ИмяКолонки,"ДополнительноеПоле") > 0 Тогда
			
			ОформляемоеПоле 	 = ЭлементУО_Приемник.Поля.Элементы.Добавить();
			ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(ИмяПоляТаблицыТрансляции(ИмяТаблицы, СтрокаТаблицы.ИмяКолонки));
		Иначе	
			ОформляемоеПоле 	 = ЭлементУО_Источник.Поля.Элементы.Добавить();
			ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(ИмяПоляТаблицыТрансляции(ИмяТаблицы, СтрокаТаблицы.ИмяКолонки));
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры // УстановитьУсловноеОформлениеКолонокТаблицыТрансляции()

Процедура ДобавитьДинамическиеКолонкиТаблицыТрансляции(ТекущаяФорма, Элементы, ТабКолонки, ИмяТаблицы, УстанавливатьДействия, ВидыКолонок)

	// Создать динамические реквизиты
	ДобавляемыеРеквизиты = Новый Массив;
	Для каждого СтрокаТаблицы Из ТабКолонки Цикл
		ОписаниеРеквизита = Новый ОписаниеТипов(СтрокаТаблицы.ТипыЗначенийВФорме.Типы());
		НовыйРеквизит     = Новый РеквизитФормы(СтрокаТаблицы.ИмяКолонки, ОписаниеРеквизита, ИмяТаблицы, СтрокаТаблицы.НаименованиеКолонки, Истина);
		ДобавляемыеРеквизиты.Добавить(НовыйРеквизит);
	КонецЦикла; 
	
	ТекущаяФорма.ИзменитьРеквизиты(ДобавляемыеРеквизиты);
	
	Контейнер = Элементы[ИмяТаблицы];
	ТекНомерГруппы = 1;
	// Создать динамические элементы управления
	Для каждого СтрокаТаблицы Из ТабКолонки Цикл
		
		// Фильтр по виду колонок
		Если ТипЗнч(ВидыКолонок) = Тип("Массив") Тогда
			Если ВидыКолонок.Найти(СтрокаТаблицы.ВидКолонки) = Неопределено Тогда
				Продолжить;
			КонецЕсли; 
		КонецЕсли;  
		
		НастройкиОтображения = КонструкторСтруктурыОтображения();
		ЗаполнитьЗначенияСвойств(НастройкиОтображения, СтрокаТаблицы);
		ОписаниеТипов = СтрокаТаблицы.ТипыЗначенийВФорме;
		Если ОписаниеТипов.Типы().Количество() = 1 И ОписаниеТипов.Типы()[0] = Тип("Булево") Тогда
			НастройкиОтображения.ВидПоля = Перечисления.бит_ВидыПолейПроформы.ПолеФлажка;
		КонецЕсли; 
		
		Если СтрокаТаблицы.НачатьГруппу Тогда
			 ИмяГруппы             = ИмяТаблицы+"_Группа"+ТекНомерГруппы;
			 ТекГруппа             = Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"),Элементы[ИмяТаблицы]);
			 ТекГруппа.Заголовок   = СтрокаТаблицы.НаименованиеКолонки;
			 ТекГруппа.Вид         = ВидГруппыФормы.ГруппаКолонок;
			 ТекГруппа.Группировка = СтрокаТаблицы.ГруппировкаКолонок;
			 ТекНомерГруппы        = ТекНомерГруппы + 1;
			 // ++ NB 
			 ТекГруппа.ОтображатьВШапке = Истина;
			 ТекГруппа.Заголовок = УдалитьЦифры(ТекГруппа.Заголовок);
			 // -- NB 
			 Контейнер = ТекГруппа;
		КонецЕсли; 
		
		Если СтрокаТаблицы.ЗакончитьГруппу Тогда
			 Контейнер = Элементы[ИмяТаблицы];
		КонецЕсли; 
		
		ИмяЭлемента  = ИмяПоляТаблицыТрансляции(ИмяТаблицы, СтрокаТаблицы.ИмяКолонки);
		ПутьКДанным  = ИмяТаблицы + "." + СтрокаТаблицы.ИмяКолонки;
		НовыйЭлемент = ДобавитьПолеФормы(Элементы, ИмяЭлемента, ПутьКДанным, НастройкиОтображения, Контейнер);
		
		// ++ NB 
		Если ТипЗнч(НовыйЭлемент.Родитель) = Тип("ГруппаФормы") Тогда
			НовыйЭлемент.ОтображатьВШапке = Ложь;
			НовыйЭлемент.ПодсказкаВвода = СтрокаТаблицы.НаименованиеКолонки;
		КонецЕсли; 
		// -- NB 
		
		Если УстанавливатьДействия Тогда
			УстановитьДействиеЭлементуФормы(НовыйЭлемент, СтрокаТаблицы);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

Процедура УстановитьДействиеЭлементуФормы(НовыйЭлемент, СтрокаТаблицы)
	
	// При необходимости устанавливаем действия для некоторых колонок.
	Если Найти(СтрокаТаблицы.ИмяКолонки,"Условие")>0 И СтрокаТаблицы <> "ПроизвольноеУсловие"  Тогда
		
		НовыйЭлемент.УстановитьДействие("НачалоВыбора", "Подключаемый_УсловиеНачалоВыбора");
		
	КонецЕсли;
	Если Найти(СтрокаТаблицы.ИмяКолонки,"Значение")>0   Тогда
		
		НовыйЭлемент.УстановитьДействие("НачалоВыбора", "Подключаемый_ЗначениеНачалоВыбора");
		
	КонецЕсли; 
	Если Найти(СтрокаТаблицы.ИмяКолонки,"Счет")>0 
		И СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника Тогда
		
		НовыйЭлемент.УстановитьДействие("ПриИзменении", "Подключаемый_СчетИсточникПриИзменении");
		
	КонецЕсли; 
	Если Найти(СтрокаТаблицы.ИмяКолонки,"Счет")>0 
		И СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
		
		НовыйЭлемент.УстановитьДействие("ПриИзменении", "Подключаемый_СчетПриемникПриИзменении");
		
	КонецЕсли; 
	Если Найти(СтрокаТаблицы.ИмяКолонки,"Субконто")>0 
		И СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитИсточника Тогда
		
		НовыйЭлемент.УстановитьДействие("НачалоВыбора", "Подключаемый_СубконтоИсточникНачалоВыбора");
		
	КонецЕсли; 
	Если Найти(СтрокаТаблицы.ИмяКолонки,"Субконто")>0 
		И СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
		
		НовыйЭлемент.УстановитьДействие("НачалоВыбора", "Подключаемый_СубконтоПриемникНачалоВыбора");
		
	КонецЕсли; 
	Если Найти(СтрокаТаблицы.ИмяКолонки,"ИмяВидаСубконто")>0 
		И СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника Тогда
		
		НовыйЭлемент.УстановитьДействие("АвтоПодбор", "Подключаемый_ИмяВидаСубконтоАвтоПодбор");
		
		
	КонецЕсли; 
	Если Найти(СтрокаТаблицы.ИмяКолонки, "ПроизвольныйКод") > 0 
		И СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника  Тогда
		
		НовыйЭлемент.УстановитьДействие("НачалоВыбора", "Подключаемый_ПроизвольныйКодНачалоВыбора");
		
	КонецЕсли; 
	Если Найти(СтрокаТаблицы.ИмяКолонки, "ПроизвольноеУсловие") > 0 
		И СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.Прочее  Тогда
		
		НовыйЭлемент.УстановитьДействие("НачалоВыбора", "Подключаемый_ПроизвольноеУсловиеНачалоВыбора");
		
	КонецЕсли; 
	Если СтрокаТаблицы.ВидКолонки = Перечисления.бит_ВидыКолонокПравилТрансляции.РеквизитПриемника 
		И НЕ СтрокаТаблицы.ЭтоСубконто = Истина 
		И Найти(СтрокаТаблицы.ИмяКолонки, "ИмяВидаСубконто") = 0
		И Найти(СтрокаТаблицы.ИмяКолонки, "ПроизвольныйКод") = 0
		И Найти(СтрокаТаблицы.ИмяКолонки, "СторнируемаяПроводка") = 0 Тогда
		
		Если НовыйЭлемент.Вид = ВидПоляФормы.ПолеФлажка Тогда
			Возврат;		
		КонецЕсли; 
		
		Если Найти(СтрокаТаблицы.ИмяКолонки, "Счет") = 0 
			ИЛИ Найти(СтрокаТаблицы.ИмяКолонки, "БанковскийСчет") > 0 Тогда
			
			НовыйЭлемент.УстановитьДействие("НачалоВыбора", "Подключаемый_ПолеПриемникаНачалоВыбора");
			
		КонецЕсли;  
	КонецЕсли;

КонецПроцедуры

Процедура ОчиститьДинамическиеКолонкиТаблицыТрансляции(ТекущаяФорма, Элементы, ИмяТаблицы)

	// Удаление "динамически созданных" реквизитов.
	МассивРеквизитов   = ТекущаяФорма.ПолучитьРеквизиты(ИмяТаблицы);
	УдаляемыеРеквизиты = Новый Массив;
	Для каждого РеквФормы Из МассивРеквизитов Цикл
		Если Найти(РеквФормы.Имя,"ПустойРеквизит") = 0 Тогда
			УдаляемыеРеквизиты.Добавить(ИмяТаблицы+"."+РеквФормы.Имя);
		КонецЕсли; 
	КонецЦикла;
	
	ТекущаяФорма.ИзменитьРеквизиты(,УдаляемыеРеквизиты);

	// Удаление "динамически созданных" элементов управления.	
	УдаляемыеЭлементы = Новый Массив;
	Для каждого ЭлФормы Из Элементы[ИмяТаблицы].ПодчиненныеЭлементы Цикл
		Если Найти(ЭлФормы.Имя,ИмяТаблицы+"_")>0 
			 И (ТипЗнч(ЭлФормы) = Тип("ПолеФормы") 
			     ИЛИ ТипЗнч(ЭлФормы) = Тип("ГруппаФормы")) Тогда	
			// Достаточно удалить страницы на которых расположены таблицы.
			УдаляемыеЭлементы.Добавить(ЭлФормы);
		КонецЕсли; 
	КонецЦикла;
	
	Для каждого ЭлФормы Из УдаляемыеЭлементы Цикл
		Элементы.Удалить(ЭлФормы);
	КонецЦикла; 
	
КонецПроцедуры

Функция УдалитьЦифры(Знач Текст)

	БезЦифр = Текст;
	ЛишниеСимволы = СтрРазделить("0,1,2,3,4,5,6,7,8,9,№,-",",");
	Для каждого Символ Из ЛишниеСимволы Цикл
		БезЦифр = СтрЗаменить(БезЦифр, Символ, "");
	КонецЦикла; 

	Возврат БезЦифр;
	
КонецФункции
 
#КонецОбласти

// Процедура добавляет запись в регистр бит_СоответствиеЗаписейТрансляции.
//
// Параметры:
//  НаборСоответствие - РегистрСведенийНаборЗаписей.бит_СоответствиеЗаписейТрансляции.
//  СтруктураШапкиДокумента - Структура.
//  СтруктураПараметров - Структура.
//  НомерСтрокиИсточника - Число.
//  НомерСтрокиПриемника - Число.
//
Процедура ЗаполнитьЗаписьСоответствияДвижений(НаборСоответствие, СтруктураШапкиДокумента, 
							СтруктураПараметров, НомерСтрокиИсточника, НомерСтрокиПриемника, Активность = Истина)

	Если НаборСоответствие = Неопределено Тогда
	
		 Возврат;
	
	КонецЕсли; 
	
	// Запишем соответствие номеров источника и приемника.
	ЗаписьСоответствие = НаборСоответствие.Добавить();
	ЗаписьСоответствие.Регистратор = СтруктураШапкиДокумента.Ссылка;
	ЗаписьСоответствие.Период      = СтруктураШапкиДокумента.Дата;
	ЗаписьСоответствие.Источник    = СтруктураПараметров.ОбъектСистемыИсточник;
	ЗаписьСоответствие.Приемник    = СтруктураПараметров.ОбъектСистемыПриемник;
	Если СтруктураШапкиДокумента.Свойство("Организация") Тогда
		
		ЗаписьСоответствие.Организация = СтруктураШапкиДокумента.Организация;
		
	КонецЕсли; 
	ЗаписьСоответствие.НомерСтрокиИсточника = НомерСтрокиИсточника;
	ЗаписьСоответствие.НомерСтрокиПриемника = НомерСтрокиПриемника;
	ЗаписьСоответствие.Активность           = Активность;
	
КонецПроцедуры // ЗаполнитьЗаписьСоответствияДвижений()

Процедура ЗаписатьНаборПриТрансляцииДвижений(НаборПриемник, НаборСоответствие, НаборСоответствиеОборотов, 
											Протокол, флВестиПротокол, флЕстьОшибки, 
											// *Обновление*, Братухин М.В., 2018.09.18 (
											//флЗаписыватьСоответствиеНомеров, флЗаписыватьСоответствиеОборотов)
											флЗаписыватьСоответствиеНомеров, флЗаписыватьСоответствиеОборотов,
											НаборИсточник, КоличествоИсточников, Источник)
											// *Обновление*, Братухин М.В., 2018.09.18 )	
	Попытка
	//***БИТ***ДА***(
		//НаборПриемник.Записать();
		Записывать = Истина;
		Ограничение = 30; //БИТ Тртилек 29.12.2011
		
		//БИТ Кошелев А.М.
		Для Каждого Запись из НаборПриемник Цикл
			
			//***БИТ***Теплова*** ( проверка для подразделений на НЕОПРЕДЕЛЕНО
			Если НаборПриемник.Метаданные().Измерения.Найти("Подразделение") <> Неопределено Тогда
				
				Если Запись.ПодразделениеДт = Неопределено Тогда
					Запись.ПодразделениеДт = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
				КонецЕсли;
				Если Запись.ПодразделениеКт = Неопределено Тогда
					Запись.ПодразделениеКт = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
				КонецЕсли;
				
			КонецЕсли;
			//***БИТ***Теплова***)		
			
			Попытка
				Для Каждого Субконто из Запись.СчетДт.ВидыСубконто Цикл
					
					//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-18 (#2963)
					Если Субконто.ВидСубконто = ПредопределенноеЗначение("ПланВидовХарактеристик.ВидыСубконтоХозрасчетные.ДокументыРасчетовСКонтрагентами") Тогда
						//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-01-31 (#2963)
						Запись.СубконтоДт.Вставить(Субконто.ВидСубконто, Неопределено);							
						//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-01-31 (#2963)
						Продолжить;
					КонецЕсли;
					//ОКЕЙ Наумов А.Н..(СофтЛаб) Конец 2018-01-18 (#2963)
					
					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Начало 2021-06-23 (#4042)
					//Для Каждого Тип из  Субконто.ВидСубконто.ТипЗначения.Типы() Цикл
					//	ПустаяССылка = Новый(Тип);	
					//	
					//	Если  Запись.СубконтоДт[Субконто.ВидСубконто] = Неопределено Тогда 
					//		Запись.СубконтоДт.Вставить(Субконто.ВидСубконто,ПустаяССылка);
					//	КонецЕсли;
					//	Прервать;	
					//	
					//КонецЦикла;
					Если Запись.СубконтоДт[Субконто.ВидСубконто] = Неопределено
						И Субконто.ВидСубконто.ТипЗначения.Типы().Количество() = 1 Тогда
						Тип = Субконто.ВидСубконто.ТипЗначения.Типы()[0]; 
						ПустаяСсылка = Новый(Тип);
						Запись.СубконтоДт.Вставить(Субконто.ВидСубконто, ПустаяСсылка);
					КонецЕсли;
					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Конец 2021-06-23 (#4042)
				КонецЦикла;
				
			Исключение
			КонецПопытки;
			
			Попытка
				Для Каждого Субконто из Запись.СчетКт.ВидыСубконто Цикл
					
					//ОКЕЙ Наумов А.Н.(СофтЛаб) Начало 2018-01-18 (#2963)
					Если Субконто.ВидСубконто = ПредопределенноеЗначение("ПланВидовХарактеристик.ВидыСубконтоХозрасчетные.ДокументыРасчетовСКонтрагентами") Тогда
						//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2018-01-31 (#2963)
						Запись.СубконтоКт.Вставить(Субконто.ВидСубконто, Неопределено);							
						//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2018-01-31 (#2963)
						Продолжить;
					КонецЕсли;
					//ОКЕЙ Наумов А.Н..(СофтЛаб) Конец 2018-01-18 (#2963)
					
					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Начало 2021-06-23 (#4042)
					//Для Каждого Тип из  Субконто.ВидСубконто.ТипЗначения.Типы() Цикл
					//	ПустаяССылка = Новый(Тип);	
					//	
					//	Если  Запись.СубконтоКт[Субконто.ВидСубконто] = Неопределено Тогда 
					//		Запись.СубконтоКт.Вставить(Субконто.ВидСубконто,ПустаяССылка);
					//	КонецЕсли;
					//	Прервать;	
					//	
					//КонецЦикла;
					Если Запись.СубконтоКт[Субконто.ВидСубконто] = Неопределено
						И Субконто.ВидСубконто.ТипЗначения.Типы().Количество() = 1 Тогда
						Тип = Субконто.ВидСубконто.ТипЗначения.Типы()[0]; 
						ПустаяСсылка = Новый(Тип);
						Запись.СубконтоКт.Вставить(Субконто.ВидСубконто, ПустаяСсылка);
					КонецЕсли;

					//ОКЕЙ Назаренко Д.В. (СофтЛаб) Конец 2021-06-23 (#4042)
				КонецЦикла;
				
			Исключение
			КонецПопытки;
		КонецЦикла;	
		
		НаборПриемник.ОбменДанными.Загрузка = Истина;
		//БИТ Кошелев А.М.
		
		//БИТ Тртилек 16.03.2012 выполним процедуру проверки заполнения из РБ
		
		ОтказПроведения = ЛОЖЬ;
		Если НаборПриемник.Количество() > 0 Тогда
			Заголовок = СокрЛП(НаборПриемник.Отбор.Регистратор.Значение);
			
			Для Каждого Проводка Из НаборПриемник Цикл
				
				Попытка
					Если НЕ ЗначениеЗаполнено(Проводка.СчетДт) И НЕ Проводка.СчетКт.Забалансовый Тогда
						ОтказПроведения = Истина;
					КонецЕсли;
				Исключение
				КонецПопытки;
				
				Попытка
					Если НЕ ЗначениеЗаполнено(Проводка.СчетКт) И НЕ Проводка.СчетДт.Забалансовый Тогда
						ОтказПроведения = Истина;
					КонецЕсли;
				Исключение
				КонецПопытки;
				
			КонецЦикла;
			
		КонецЕсли;
		
		//БИТ Тртилек
		Если Не ОтказПроведения И НаборПриемник.Количество() > 0 Тогда
			//БИТ Тртилек 11.12.12 не записываем набор записей, если не было создано ни одной сторно записи и ни одной ддс записи
			Если НЕ (НаборПриемник = НаборИсточник И НаборПриемник.Количество() = КоличествоИсточников) Тогда
				///БИТ Тртилек
				Пока Записывать Цикл
					
					Попытка
						
						НаборПриемник.Записать();
						
						Записывать = Ложь;
						
					Исключение
						
						Если Ограничение <= 0 Тогда
							Записывать = Ложь;
							ТекстСообщения = НСтр("ru = 'Трансляция. Не удалось 30 раз записать документ при трансляции'");
							ТекстКомментария = НСтр("ru = 'Не удалось записать документ №" + Источник.Номер +"'");
							ЗаписьЖурналаРегистрации(ТекстСообщения 
							,УровеньЖурналаРегистрации.Ошибка 
							, 
							,
							,ТекстКомментария);
							//БИТ Тртилек 29.12.2011 Очистим набор при последней попытке записать		 
						ИначеЕсли Ограничение = 1 Тогда
							НаборПриемник.Очистить();		 
							///БИТ Тртилек 29.12.2011	
							
							
						КонецЕсли;
						Ограничение = Ограничение - 1;
					КонецПопытки;
					
				КонецЦикла;
				//БИТ Тртилек 11.12.12
			КонецЕсли;
			///БИТ Тртилек
		ИначеЕсли ОтказПроведения Тогда
			НаборПриемник.Очистить();
		КонецЕсли;
		//***БИТ***ДА***)
	Исключение
		флЕстьОшибки = Истина;
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ОписаниеОшибки());
		ДобавитьСообщениеВПротокол(Протокол, Строка(ОписаниеОшибки()), флВестиПротокол);						
	КонецПопытки;
	
	Если флЗаписыватьСоответствиеНомеров Тогда
		Попытка
			//БИТ Тртилек 05.04.2012 НаборСоответствие записываем только в случае записи НабораПриемника
			//НаборСоответствие.Записать();
			Если НЕ ОтказПроведения Тогда
			//БИТ Тртилек
				НаборСоответствие.Записать();
			//БИТ Тртилек
			Иначе 
				НаборСоответствие.Очистить();
			КонецЕсли;
			//БИТ Тртилек
		Исключение
			флЕстьОшибки = Истина;
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ОписаниеОшибки());
			ДобавитьСообщениеВПротокол(Протокол, Строка(ОписаниеОшибки()), флВестиПротокол);				 
		КонецПопытки;			
	КонецЕсли; 
	
	Если флЗаписыватьСоответствиеОборотов Тогда
		Попытка
			НаборСоответствиеОборотов.Записать();
		Исключение
			флЕстьОшибки = Истина;
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ОписаниеОшибки());
			ДобавитьСообщениеВПротокол(Протокол, Строка(ОписаниеОшибки()), флВестиПротокол);				 
		КонецПопытки;			
	КонецЕсли; 
	
КонецПроцедуры

// Процедура формирует проводки бюджетирования по сформированным движениям регистра 
// бит_ОборотыПоБюджетам исходя из шаблонов проводок.
// 
// Параметры:
//  Источник           - ДокументОбъект.
//  НаборОбороты       - РегистрНакопленияНаборЗаписей.бит_ОборотыПоБюджетам.
//  ЗаписыватьДвижения - Булево.
// 
Процедура СформироватьПроводкиБюджетирования(Источник,НаборОбороты,ЗаписыватьДвижения)

	ТаблицаОбороты = НаборОбороты.Выгрузить();
	
	// Добавим в таблицу оборотов колонки, необходимые для корректного функционирования 
	// механизма формирования проводок бюджетирования.
	ОписаниеЧисло = Новый ОписаниеТипов("Число");
	
	// Дозаполним необходимые данные
	// т.к. трансляция при сборе факта идет из документов регл. учета будем считать, 
	// что входящие суммы в валюте регл. учета.
	ВалютаРегл = Константы.ВалютаРегламентированногоУчета.Получить();
	Для каждого СтрокаТаблицы Из ТаблицаОбороты Цикл
		
		Если НЕ ЗначениеЗаполнено(СтрокаТаблицы.Валюта) Тогда
			
			СтрокаТаблицы.Валюта      = ВалютаРегл;
			СтрокаТаблицы.Сумма       = СтрокаТаблицы.СуммаРегл;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	// Сформируем проводки бюджетирования
	ПроводкиБюджетирования = Источник.Движения.бит_Бюджетирование;
	
	ПроводкиБюджетирования.Очистить();
	
	бит_БюджетированиеБалансовыйУчет.СформироватьПроводкиБюджетирования(ТаблицаОбороты,ПроводкиБюджетирования);

	Если ЗаписыватьДвижения Тогда
	
		ПроводкиБюджетирования.Записать();
	
	КонецЕсли; 
	
КонецПроцедуры // СформироватьПроводкиБюджетирования()

// Функция получает доступные правила трансляции и правила заполнения полей при трансляции.
// 
// Параметры:
//  Организация  - СправочникСсылка.Организации.
//  Дата         - Дата.
//  РегистрыИсточники - Массив.
//  РегистрыПриемники - Массив.
// 
// Возвращаемое значение:
//   Результат   - РезультатЗапроса.
// 

//БИТ Тртилек +
//БИТ Тртилек 01.12.2011 В функцию дополнительно передается параметр Очередность, используемый в запросе
//Функция ПолучитьДоступныеПравилаТрансляции(Организация,ДокументОбъект,Дата,РегистрыИсточники,РегистрыПриемники)
Функция ПолучитьДоступныеПравилаТрансляции(Организация,ДокументОбъект,Дата,РегистрыИсточники,РегистрыПриемники, Очередность) Экспорт
//БИТ Тртилек -

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	0 КАК Приоритет,
	|	НазначениеПравил.ПравилоТрансляции КАК ПравилаТрансляции,
	|	НазначениеПравил.ПравилоТрансляции.КодУсловияТрансляции КАК КодУсловияТрансляции,
	|	НазначениеПравил.ПравилоТрансляции.Источник КАК Источник,
	|	НазначениеПравил.ПравилоТрансляции.Приемник КАК Приемник,
	|	НазначениеПравил.Приоритет КАК ПриоритетПравилаТрансляции
	|ПОМЕСТИТЬ ТаблицаПравилТрансляции
	|ИЗ
	|	РегистрСведений.бит_НазначениеПравилТрансляции.СрезПоследних(
	|			&ДатаЗапроса,
	|			(СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	|				ИЛИ СтруктурноеПодразделение = ЗНАЧЕНИЕ(Справочник.бит_ГруппыСтруктурныхПодразделений.ПустаяСсылка))
	|				И Назначение В (&НазначенияПравил)) КАК НазначениеПравил
	|ГДЕ
	|	(КОНЕЦПЕРИОДА(НазначениеПравил.ДатаОкончания, ДЕНЬ) >= &ДатаЗапроса
	|			ИЛИ НазначениеПравил.ДатаОкончания = &ПустаяДата)
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	1,
	|	НазначениеПравил.ПравилоТрансляции,
	|	НазначениеПравил.ПравилоТрансляции.КодУсловияТрансляции,
	|	НазначениеПравил.ПравилоТрансляции.Источник,
	|	НазначениеПравил.ПравилоТрансляции.Приемник,
	|	НазначениеПравил.Приоритет
	|ИЗ
	|	РегистрСведений.бит_НазначениеПравилТрансляции.СрезПоследних(
	|			&ДатаЗапроса,
	|			СтруктурноеПодразделение В
	|					(ВЫБРАТЬ
	|						бит_ГруппыСтруктурныхПодразделенийСостав.Ссылка
	|					ИЗ
	|						Справочник.бит_ГруппыСтруктурныхПодразделений.Состав КАК бит_ГруппыСтруктурныхПодразделенийСостав
	|					ГДЕ
	|						бит_ГруппыСтруктурныхПодразделенийСостав.СтруктурноеПодразделение = &Организация)
	|				И Назначение В (&НазначенияПравил)) КАК НазначениеПравил
	|ГДЕ
	|	(КОНЕЦПЕРИОДА(НазначениеПравил.ДатаОкончания, ДЕНЬ) >= &ДатаЗапроса
	|			ИЛИ НазначениеПравил.ДатаОкончания = &ПустаяДата)
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	2,
	|	НазначениеПравил.ПравилоТрансляции,
	|	НазначениеПравил.ПравилоТрансляции.КодУсловияТрансляции,
	|	НазначениеПравил.ПравилоТрансляции.Источник,
	|	НазначениеПравил.ПравилоТрансляции.Приемник,
	|	НазначениеПравил.Приоритет
	|ИЗ
	|	РегистрСведений.бит_НазначениеПравилТрансляции.СрезПоследних(
	|			&ДатаЗапроса,
	|			СтруктурноеПодразделение = &Организация
	|				И Назначение В (&НазначенияПравил)) КАК НазначениеПравил
	|ГДЕ
	|	(КОНЕЦПЕРИОДА(НазначениеПравил.ДатаОкончания, ДЕНЬ) >= &ДатаЗапроса
	|			ИЛИ НазначениеПравил.ДатаОкончания = &ПустаяДата)
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Источник,
	|	Приемник
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА НазначениеПравилЗаполнения.ОбъектСистемы = ЗНАЧЕНИЕ(Справочник.бит_ОбъектыСистемы.ПустаяСсылка)
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК АвтоПриоритетПравилаЗаполнения,
	|	НазначениеПравилЗаполнения.Приоритет КАК ПриоритетПравилаЗаполнения,
	|	ТаблицаПравилТрансляции.Приоритет КАК Приоритет,
	|	ТаблицаПравилТрансляции.ПриоритетПравилаТрансляции КАК ПриоритетПравилаТрансляции,
	|	ТаблицаПравилТрансляции.ПравилаТрансляции КАК ПравилаТрансляции,
	|	ТаблицаПравилТрансляции.КодУсловияТрансляции КАК КодУсловияТрансляции,
	|	ТаблицаПравилТрансляции.Источник КАК Источник,
	|	ТаблицаПравилТрансляции.Приемник КАК Приемник,
	|	ТаблицаПравилТрансляции.Источник.ИмяОбъекта КАК ИсточникИмяОбъекта,
	|	ТаблицаПравилТрансляции.Приемник.ИмяОбъекта КАК ПриемникИмяОбъекта,
	|	НазначениеПравилЗаполнения.ОбъектСистемы КАК ОбъектСистемы,
	|	НазначениеПравилЗаполнения.УсловиеВхождения КАК УсловиеВхождения,
	|	НазначениеПравилЗаполнения.ПравилоЗаполнения КАК ПравилоЗаполнения,
	|	НазначениеПравилЗаполнения.ПравилоЗаполнения.РежимИспользованияСоответствий КАК РежимИспользованияСоответствий,
	|	ТаблицаПравилТрансляции.Источник.ИмяОбъектаПолное КАК ИсточникИмяОбъектаПолное
	//БИТ Тртилек 01.12.2011 Дополнительно выбираем поле Очередность
	|	,ЕСТЬNULL(бит_ПравилаТрансляции.Очередность, 0) КАК Очередность 
	///БИТ Тртилек	
	|ИЗ
	|	ТаблицаПравилТрансляции КАК ТаблицаПравилТрансляции
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.бит_НазначениеПравилЗаполненияПриТрансляции КАК НазначениеПравилЗаполнения
	|		ПО ТаблицаПравилТрансляции.Источник = НазначениеПравилЗаполнения.Источник
	|			И ТаблицаПравилТрансляции.Приемник = НазначениеПравилЗаполнения.Приемник
	//БИТ Тртилек 01.12.2011 
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.бит_ПравилаТрансляции КАК бит_ПравилаТрансляции
	|		ПО ТаблицаПравилТрансляции.ПравилаТрансляции = бит_ПравилаТрансляции.Ссылка
	///БИТ Тртилек	
	|ГДЕ
	|	НазначениеПравилЗаполнения.ОбъектСистемы В (&ОбъектСистемы, ЗНАЧЕНИЕ(Справочник.бит_ОбъектыСистемы.ПустаяСсылка))
	//БИТ Тртилек 01.12.2011
	|	%Очередность%
	///БИТ Тртилек	
	|	И &УсловиеИсточники
	|	И &УсловиеПриемники
	|
	|УПОРЯДОЧИТЬ ПО
	|	АвтоПриоритетПравилаЗаполнения,
	|	ПриоритетПравилаЗаполнения,
	|	Приоритет,
	|	ПриоритетПравилаТрансляции
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2021-02-20 (#ПроектИнтеграцияАксапта12)
	|	, Очередность
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2021-02-20 (#ПроектИнтеграцияАксапта12)
	|ИТОГИ ПО
	|	ПравилоЗаполнения,
	|	Источник,
	|	Приемник";

	ОбъектСистемы = бит_ПраваДоступа.ПолучитьОбъектДоступаПоМетаданным(ДокументОбъект.Метаданные());
	
	// Без "подбора счетов".
	НазначенияПравил = Новый Массив(); 
	Для каждого Элемент Из Перечисления.бит_НазначенияПравилТрансляции Цикл
		Если НЕ Элемент = Перечисления.бит_НазначенияПравилТрансляции.ПодборСчетов Тогда
			НазначенияПравил.Добавить(Элемент);
		КонецЕсли; 
	КонецЦикла; 
	
	Запрос.УстановитьПараметр("Организация",	   Организация);
	Запрос.УстановитьПараметр("ДатаЗапроса",	   Дата);
	Запрос.УстановитьПараметр("ПустаяДата",		   Дата('00010101'));
	Запрос.УстановитьПараметр("ОбъектСистемы",	   ОбъектСистемы);
	Запрос.УстановитьПараметр("НазначенияПравил",  НазначенияПравил);
	Запрос.УстановитьПараметр("УсловиеИсточники",  Истина);
	Запрос.УстановитьПараметр("УсловиеПриемники",  Истина);
	Запрос.УстановитьПараметр("РегистрыИсточники", РегистрыИсточники);
	Запрос.УстановитьПараметр("РегистрыПриемники", РегистрыПриемники);
	
	Если ТипЗнч(РегистрыИсточники) = Тип("Массив") Тогда
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеИсточники", 
							"НазначениеПравилЗаполнения.Источник В(&РегистрыИсточники)");		
	КонецЕсли; 
	
	Если ТипЗнч(РегистрыПриемники) = Тип("Массив") Тогда
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеПриемники", 
							"НазначениеПравилЗаполнения.Приемник В(&РегистрыПриемники)");
	КонецЕсли; 
	
	//+БИТ Тртилек 25.11.11
	Если Очередность <> Неопределено Тогда
		
		Запрос.УстановитьПараметр("Очередность", Очередность);  //БИТ Тртилек
		Запрос.Текст = СтрЗаменить(Запрос.Текст
									,"%Очередность%"
									," И бит_ПравилаТрансляции.Очередность = &Очередность");
		
	Иначе
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст,"%Очередность%","");
		
	КонецЕсли;
	///-БИТ Тртилек	
	
	Результат = Запрос.Выполнить();
	
	Возврат Результат;
	
КонецФункции // ПолучитьДоступныеПравилаТрансляции()

// Функция по справочнику бит_ПравилаЗаполненияПолейПриТрансляции готовит 
// структуры ОбязательныхПолей и ПользовательскихФункции. 
// Структуры используются при выполнении трансляции.
// 
// Параметры:
//  СпрПравила  - СправочникСсылка.бит_ПравилаЗаполненияПолейПриТрансляции.
// 
// Возвращаемое значение:
//   РезСтруктура   - Структура - Содержит структуры ОбязательныеПоля и ПользовательскиеФункции.
// 
Функция ПодготовитьСтруктурыПравил(СпрПравила)

  // Структура для проверки обязательных полей; ключ - ИмяПоля(Строка), значение - Синоним(Строка).
  ОбязательныеПоля  = Новый Структура;
  
  // Структура, содержащая ссылки на пользовательские функции, содержащиеся в правилах заполнения.
  // Ключ - ИмяФункции(Строка), значение - ПользовательскаяФункция(СправочникСсылка.бит_ПользовательскиеФункции). 
  ПользовательскиеФункции = Новый Соответствие;

  Для каждого СтрокаТаблицы Из СпрПравила.ПоляПриемника Цикл
	  
	// Заполняем обязательные поля  
  	Если СтрокаТаблицы.Обязательное Тогда
	
		 ОбязательныеПоля.Вставить(СтрокаТаблицы.ИмяПоля,СтрокаТаблицы.Синоним);
		 
		 
	КонецЕсли; 
	
	// Выделяем имя функции и заполняем структуру пользовательских функций.
	СтрокаКод = СтрокаТаблицы.ПравилоЗаполнения;
	ПозицияФункции = Найти(СтрокаКод,"#П.");
	
	Пока ПозицияФункции >0   Цикл
		
		СтрокаВрем = Сред(СтрокаКод,ПозицияФункции+3);
		ПозицияСкобки = Найти(СтрокаВрем,"(");
		ИмяФункции = Сред(СтрокаВрем,1,ПозицияСкобки-1);
		
		ПользовательскаяФункция = Справочники.бит_ПользовательскиеФункции.НайтиПоНаименованию(ИмяФункции);
		Если ЗначениеЗаполнено(ПользовательскаяФункция) Тогда
		
			 ПользовательскиеФункции.Вставить(ИмяФункции,ПользовательскаяФункция);
		
		КонецЕсли; 
		
		СтрокаВрем = "@@@"+СтрокаВрем;
		СтрокаКод  = Лев(СтрокаКод,ПозицияФункции-1)+СтрокаВрем;
		ПозицияФункции = Найти(СтрокаКод,"#П.");
		
	КонецЦикла;	
	
  КонецЦикла; 
  
  РезСтруктура = Новый Структура("ОбязательныеПоля,ПользовательскиеФункции",ОбязательныеПоля,ПользовательскиеФункции);
  
  Возврат РезСтруктура;
  
КонецФункции // ПодготовитьСтруктурыПравил()

// Процедура заполняет структуру признаков учета по коллекции объекта метаданных.
// 
// Параметры:
//  ОбъектМетаданных  - ОбъектМетаданных.
//  ИмяКоллекции      - Строка.
//  ПризнакиУчета     - Структура.
// 
Процедура ДобавитьПризнакиУчета(ОбъектМетаданных,ИмяКоллекции,ПризнакиУчета)

	Для каждого Мета Из ОбъектМетаданных[ИмяКоллекции] Цикл
		
		Если Мета.ПризнакУчета <> Неопределено Тогда
			
			Если Мета.Балансовый Тогда
				ПризнакиУчета.Вставить(Мета.Имя,Мета.ПризнакУчета.Имя);
			Иначе	
				ПризнакиУчета.Вставить(Мета.Имя+"Дт",Мета.ПризнакУчета.Имя);
				ПризнакиУчета.Вставить(Мета.Имя+"Кт",Мета.ПризнакУчета.Имя);			
			КонецЕсли; 
			
		КонецЕсли; 
		
	КонецЦикла; 

КонецПроцедуры // ДобавитьПризнакУчета()

// Функция формирует структуру с соответствиями аналитик. Соответствия аналитик заполняются по СубконтоДт,
// СубконтоКт и измерениям Источника. В соответствиях ключ 	   - ОписаниеТипов,
// 													  значение - ПроизвольноеЗначение.
// Соответствия используются для автоматической установки значений Субконто и измерений в Приемнике.
// Подбор производится по типам.
// 
// Параметры:
//  ЗаписьИсточник  - РегистрБухгалтерииЗапись,РегистрНакопленияЗапись.
//  МетаданныеИсточника - ОбъектМетаданных.
//  ВидыРегистров       - Структура.
// 
// Возвращаемое значение:
//   Аналитики   - Структура.
// 
Функция СформироватьСоответствияАналитик(ЗаписьИсточник,МетаданныеИсточника,ВидыРегистров)

	// Заполним соответствие аналитик
	Аналитики = Новый Структура;
	Аналитики.Вставить("АналитикиИсточникДт",Новый Соответствие);
	Аналитики.Вставить("АналитикиИсточникКт",Новый Соответствие);
	Аналитики.Вставить("АналитикиИсточник"  ,Новый Соответствие);
	
	Если ВидыРегистров.ИсточникРегистрБухгалтерии Тогда
		
		Для НомДтКт=0 По 1 Цикл
			
			ДтКт = ?(НомДтКт = 0,"Дт","Кт");
			ИмяСоответствия = "АналитикиИсточник"+ДтКт;	
			Счет =ЗаписьИсточник["Счет"+ДтКт];
            
            СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
	
			Для Ном=1 По СвСч.КоличествоСубконто Цикл
				
                ВидСубконто      = СвСч["ВидСубконто" + Ном];
				ЗначениеСубконто = ЗаписьИсточник["Субконто"+ДтКт][ВидСубконто];
                ТипЗнчСубконто   = СвСч["ВидСубконто" + Ном + "ТипЗначения"];
				ЗначениеИзСоответствия = Аналитики[ИмяСоответствия][ТипЗнчСубконто];
				Если Не ЗначениеЗаполнено(ЗначениеИзСоответствия) Тогда
					Аналитики[ИмяСоответствия].Вставить(ТипЗнчСубконто, ЗначениеСубконто);
                КонецЕсли; 
                
            КонецЦикла; // По субконто 
            
		КонецЦикла; // по ДтКт
		
		// Заполнение подразделения из измерения
		ИзмерениеМета = МетаданныеИсточника.Измерения.Найти("Подразделение");
		Если НЕ ИзмерениеМета = Неопределено И ИзмерениеМета.Балансовый = Ложь Тогда
			
			Для НомДтКт=0 По 1 Цикл
				
				ДтКт = ?(НомДтКт = 0,"Дт","Кт");
				ИмяСоответствия  = "АналитикиИсточник"+ДтКт;
				ИмяИзмерения     = ИзмерениеМета.Имя+ДтКт;
			    ЗначениеИзСоответствия = Аналитики[ИмяСоответствия][ИзмерениеМета.Тип];
				Если НЕ ЗначениеЗаполнено(ЗначениеИзСоответствия) Тогда					
					Аналитики[ИмяСоответствия].Вставить(ИзмерениеМета.Тип,ЗаписьИсточник[ИмяИзмерения]);					
				КонецЕсли; 
				
			КонецЦикла; 
		
		КонецЕсли; 
		
	КонецЕсли; // Источник регистр бухгалтерии

	//***БИТ***ДА***(
	//Если ВидыРегистров.ИсточникРегистрНакопления Тогда
	//
	//	 Для каждого Измерение Из МетаданныеИсточника.Измерения Цикл
	//	 
	//	 	 ТекущееЗначение = ЗаписьИсточник[Измерение.Имя];
	//		 МассивДляСоответствия = Новый Массив;
	//		 МассивДляСоответствия.Добавить(ТипЗнч(ТекущееЗначение));
	//		 ОписаниеКлюч = Новый ОписаниеТипов(МассивДляСоответствия);
	//		 Аналитики["АналитикиИсточник"].Вставить(ОписаниеКлюч,ТекущееЗначение);
	//	 
	//	 КонецЦикла; 
	//
	//КонецЕсли; // Источник регистр накопления
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Начало 2020-10-26 (#ПроектИнтеграцияАксапта12)
	//Если МетаданныеИсточника.Имя = "бит_ок_ОборотыАксапты" Тогда
	Если МетаданныеИсточника.Имя = "бит_ок_ОборотыАксапты" 
		ИЛИ МетаданныеИсточника.Имя = "бит_ок_ОборотыАксапты12" Тогда
	//ОКЕЙ Поздняков А.С. (СофтЛаб) Конец 2020-10-26 (#ПроектИнтеграцияАксапта12)
		// наш регистр обрабатываем особым образом, разделяя аналитику дт и кт		
		Для каждого Измерение Из МетаданныеИсточника.Измерения Цикл
			
			Если Измерение.Имя = "Субконто1СДт1"
				ИЛИ Измерение.Имя = "Субконто1СДт2" 
				ИЛИ Измерение.Имя = "Субконто1СДт3" Тогда
				ИмяСоответствия = "АналитикиИсточникДт"; 
			ИначеЕсли Измерение.Имя = "Субконто1СКт1"
				ИЛИ Измерение.Имя = "Субконто1СКт2" 
				ИЛИ Измерение.Имя = "Субконто1СКт3" Тогда
				ИмяСоответствия = "АналитикиИсточникКт";
			Иначе
				ИмяСоответствия = "АналитикиИсточник";
			КонецЕсли;			
			
			ТекущееЗначение = ЗаписьИсточник[Измерение.Имя];
			МассивДляСоответствия = Новый Массив;
			МассивДляСоответствия.Добавить(ТипЗнч(ТекущееЗначение));
			ОписаниеКлюч = Новый ОписаниеТипов(МассивДляСоответствия);
			Аналитики[ИмяСоответствия].Вставить(ОписаниеКлюч,ТекущееЗначение);
			
		КонецЦикла;
		
	Иначе
		//работаем по старому	 
		Если ВидыРегистров.ИсточникРегистрНакопления Тогда
		
			 Для каждого Измерение Из МетаданныеИсточника.Измерения Цикл
			 
			 	 ТекущееЗначение = ЗаписьИсточник[Измерение.Имя];
				 МассивДляСоответствия = Новый Массив;
				 МассивДляСоответствия.Добавить(ТипЗнч(ТекущееЗначение));
				 ОписаниеКлюч = Новый ОписаниеТипов(МассивДляСоответствия);
				 Аналитики["АналитикиИсточник"].Вставить(ОписаниеКлюч,ТекущееЗначение);
			 
			 КонецЦикла; 
		
		КонецЕсли; // Источник регистр накопления
	КонецЕсли;
	//***БИТ***ДА***)
	
    Возврат Аналитики;
	
КонецФункции // СформироватьСоответствияАналитик()

// Функция извлекает значения из соответствия 
// аналитик с учетом использования составных типов.
// 
// Параметры:
//   ТипЗнчИсточник - ОписаниеТипов.
//   СоответствиеАналитик - Соответствие.
// 
// Возвращаемое значение:
//  ЗначениеЗаполнения - Произвольный.
// 
Функция ПолучитьЗначениеДляЗаполнения(ТипЗнчИсточник, СоответствиеАналитик)
	
	ЗначениеЗаполнения = Неопределено;
	МассивТипов = ТипЗнчИсточник.Типы();
	Для каждого ТекТип Из МассивТипов Цикл
		
		МассивВрем = Новый Массив;
		МассивВрем.Добавить(ТекТип);
		
		ОписаниеВрем       = Новый ОписаниеТипов(МассивВрем);
		ЗначениеЗаполнения = СоответствиеАналитик[ОписаниеВрем];
		
		Если ЗначениеЗаполнено(ЗначениеЗаполнения) Тогда
			
			Прервать;
			
		КонецЕсли; 
		
	КонецЦикла; 
	
	// Если не удалось получить значение по ключу, попробуем перебором.
	Если НЕ ЗначениеЗаполнено(ЗначениеЗаполнения) Тогда
		
		Для каждого ТекТип Из МассивТипов Цикл
			
			Для каждого КиЗ Из СоответствиеАналитик Цикл
			
				Если КиЗ.Ключ.СодержитТип(ТекТип) Тогда
				
					 ЗначениеЗаполнения = КиЗ.Значение;
				
				КонецЕсли; 
				
				Если ЗначениеЗаполнено(ЗначениеЗаполнения) Тогда
				
					 Прервать;
				
				КонецЕсли; 
				
			КонецЦикла; // По соответствию
			
		КонецЦикла;	// По типам
		
	КонецЕсли;
	
	Возврат ЗначениеЗаполнения;
	
КонецФункции // ПолучитьЗначениеДляЗаполнения()

//  Производит заполнение субконто в наборе записей Приемника на основании соответствий аналитик.
//              ДопСоответствиеАналитик служит для случае когда аналитики необходимо брать с КоррСчета.
// 
// Параметры:
//  ЗаписьПриемник - РегистрБухгалтерииЗапись,РегистрНакопленияЗапись.
//  ДтКт           - Строка(2) - "Дт","Кт".
//  СоответствиеАналитик    - Соответствие - ключ Тип, значение - ПроизвольноеЗначение.
//  ДопСоответствиеАналитик - Соответствие - ключ Тип, значение - ПроизвольноеЗначение.               
// 
Процедура ЗаполнитьСубконтоВПриемнике(ЗаписьПриемник,ДтКт,СоответствиеАналитик,ДопСоответствиеАналитик = Неопределено)
	
  ДтКтКорр = ?(ДтКт   ="Дт","Кт","Дт");
  
  Счет = ЗаписьПриемник["Счет"+ДтКт];
  ИмяСчета    = "Счет"+ДтКт;
  ИмяСубконто = "Субконто"+ДтКт;
  
  СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
    
  Для Ном = 1 по СвСч.КоличествоСубконто Цикл
      
      ВидСубконтоПриемник = СвСч["ВидСубконто" + Ном];
      ТипЗнчСубконто = СвСч["ВидСубконто" + Ном + "ТипЗначения"];
      
      Если НЕ ЗначениеЗаполнено(ЗаписьПриемник[ИмяСубконто][ВидСубконтоПриемник]) Тогда
		  
		  ЗначениеЗаполнения = ПолучитьЗначениеДляЗаполнения(ТипЗнчСубконто, СоответствиеАналитик);		  
          ЗаписьПриемник[ИмяСубконто][ВидСубконтоПриемник] = ТипЗнчСубконто.ПривестиЗначение(ЗначениеЗаполнения);
		  
	  КонецЕсли; 
      
      Если НЕ ЗначениеЗаполнено(ЗаписьПриемник[ИмяСубконто][ВидСубконтоПриемник]) И ДопСоответствиеАналитик <> Неопределено Тогда
		  
		  ЗначениеЗаполнения = ПолучитьЗначениеДляЗаполнения(ТипЗнчСубконто, ДопСоответствиеАналитик);		  		  
          ЗаписьПриемник[ИмяСубконто][ВидСубконтоПриемник] = ТипЗнчСубконто.ПривестиЗначение(ЗначениеЗаполнения);
		  
      КонецЕсли; 
      
  КонецЦикла;

КонецПроцедуры // ЗаполнитьСубконтоВПриемнике()

// Процедура применяет коэффициенты к ресурсам приемника. 
// 
// Параметры:
//  ЗаписьИсточник - РегистрНакопленияЗапись, РегистрБухгалтерииЗапись.
//  ДополнительныеДанные - Соответствие.
//  ИмяРесурса - Строка.
// 
Процедура ПрименитьКоэффициенты(ЗаписьПриемник, ДополнительныеДанные, ИмяРесурса)
	
	Если ТипЗнч(ЗаписьПриемник[ИмяРесурса]) <> Тип("Число") Тогда
		Возврат;
	КонецЕсли;
	
	Если СтрЧислоВхождений(ИмяРесурса, "Количество") > 0 И ТипЗнч(ДополнительныеДанные["КоэффициентКоличество"]) = Тип("Число") Тогда			
		ЗаписьПриемник[ИмяРесурса] = ДополнительныеДанные["КоэффициентКоличество"] * ЗаписьПриемник[ИмяРесурса];
	КонецЕсли;
	
	Если СтрЧислоВхождений(ИмяРесурса, "Количество") = 0 И ТипЗнч(ДополнительныеДанные["КоэффициентСумма"]) = Тип("Число") Тогда
		ЗаписьПриемник[ИмяРесурса] = ДополнительныеДанные["КоэффициентСумма"] * ЗаписьПриемник[ИмяРесурса];
	КонецЕсли; 
	
КонецПроцедуры // ПрименитьКоэффициент()

// Процедура заполняет значения измерений Приемника по соответствиям аналитик. 
// Подбор соответствия произодится по типам.
// 
// Параметры:
//  ЗаписьПриемник - РегистрБухгалтерииЗапись,РегистрНакопленияЗапись.
//  Аналитики      - Структура - содержит соответствия аналитик.
//  МетаданныеПриемника - ОбъектМетаданных.
// 
Процедура ЗаполнитьИзмеренияВПриемнике(ЗаписьПриемник,Аналитики,МетаданныеПриемника)
	
	Для каждого Измерение Из МетаданныеПриемника.Измерения Цикл
		
		ИмяИзмерения = Измерение.Имя;
		ТипИзмерения = Измерение.Тип;
		Если НЕ ЗначениеЗаполнено(ЗаписьПриемник[ИмяИзмерения]) Тогда
			
			ЗаписьПриемник[ИмяИзмерения] = Аналитики["АналитикиИсточник"][ТипИзмерения];
			
		КонецЕсли; 
		Если НЕ ЗначениеЗаполнено(ЗаписьПриемник[ИмяИзмерения]) Тогда
			
			ЗаписьПриемник[ИмяИзмерения] = Аналитики["АналитикиИсточникДт"][ТипИзмерения];
			
		КонецЕсли; 
		Если НЕ ЗначениеЗаполнено(ЗаписьПриемник[ИмяИзмерения]) Тогда
			
			ЗаписьПриемник[ИмяИзмерения] = Аналитики["АналитикиИсточникКт"][ТипИзмерения];
			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьИзмеренияВПриемнике()

// Процедура анализируем необходима ли дальнейшая обработка текущего набора записей.
// 
// Параметры:
//  ПравилоЗаполнения  		- СправочникСсылка.бит_ПравилаЗаполненияПолейПриТрансляции.
//  МетаданныеПриемника 	- ОбъектМетаданных.
//  ДополнительныеАналитики - Соответствие.
//  Отказ 					- Булево.
// 
Процедура АнализироватьНеобходимостьОбработкиНабора(ПравилоЗаполнения, МетаданныеПриемника, ДополнительныеАналитики, Отказ)

	// Анализ аналитик "НеОтражатьВФакте", "НеОтражатьВМСФО","НеВыполнятьТрансляцию".
	Если бит_му_ОбщегоНазначения.ЭтоМеждународныйПланСчетовИлиРегистр(МетаданныеПриемника.Имя) Тогда
	
		Если ИзвлечьЗначениеАналитики("НеОтражатьВМСФО", ДополнительныеАналитики) = Истина Тогда
			Отказ = Истина;
		КонецЕсли;
		
	ИначеЕсли МетаданныеПриемника = Метаданные.РегистрыБухгалтерии.бит_Бюджетирование 
		  ИЛИ МетаданныеПриемника = Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам Тогда
		  
		  НеОтражатьВФактеТрансляция = (ИзвлечьЗначениеАналитики("НеОтражатьВФактеТрансляция", ДополнительныеАналитики) = Истина);
		  Если НеОтражатьВФактеТрансляция Тогда
			  Отказ = Истина;
		  КонецЕсли;  
	КонецЕсли;
	
	Если ИзвлечьЗначениеАналитики("НеВыполнятьТрансляцию", ДополнительныеАналитики) = Истина Тогда
		Отказ = Истина;
	КонецЕсли;  

КонецПроцедуры // АнализироватьНеобходимостьОбработкиНабора()

Процедура ОбработкаНабораПриРучномРедактированииФакта(МетаданныеПриемника, ДополнительныеАналитики, Отказ)
	
	Если бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
		Если МетаданныеПриемника = Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам Тогда
			
			РучнаяКорректировкаФактаБюджета = (ИзвлечьЗначениеАналитики("РучнаяКорректировкаФактаБюджета", ДополнительныеАналитики) = Истина);
			Если РучнаяКорректировкаФактаБюджета Тогда
				Отказ = Истина;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли; 
	 
КонецПроцедуры

// Процедура выполняет алгоритмы специфичные для МСФО. 
// Установка даты движений по МСФО из аналитик и принудительное заполнение валютных сумм.
// 
// Параметры:
//  ЗаписьИсточник  - РегистрБухгалтерииНаборЗаписей, РегистрСведенийНаборЗаписей.
//  ЗаписьПриемник  - РегистрБухгалтерииНаборЗаписей, РегистрСведенийНаборЗаписей.
//  ПравилоЗаполнения  - СправочникСсылка.бит_ПравилаЗаполненияПолейПриТрансляции.
//  ДополнительныеАналитики - Соответствие.
// 
Процедура ВыполнитьАлгоритмыМСФО(СтруктураШапкиДокумента
	                                , ЗаписьИсточник
									, ЗаписьПриемник
									, ПравилоЗаполнения
									, ДополнительныеАналитики
									, ДополнительныеДанные)
	
	
	// Принудительное заполнение валют
	Если ПравилоЗаполнения.ПринудительноеЗаполнениеВалютныхСумм Тогда
        
        СвСчДт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ЗаписьПриемник.СчетДт);
        СвСчКт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ЗаписьПриемник.СчетКт);
    
		Если СвСчДт.Валютный Тогда
			
			Если НЕ ЗначениеЗаполнено(ЗаписьПриемник.ВалютаДт) Тогда
				
				ЗаписьПриемник.ВалютаДт = Константы.ВалютаРегламентированногоУчета.Получить();
				ЗаписьПриемник.ВалютнаяСуммаДт = ЗаписьПриемник.СуммаРегл; 
				
			КонецЕсли;	
			
		КонецЕсли;
		
		Если СвСчКт.Валютный Тогда
			
			Если НЕ ЗначениеЗаполнено(ЗаписьПриемник.ВалютаКт) Тогда
				
				ЗаписьПриемник.ВалютаКт = Константы.ВалютаРегламентированногоУчета.Получить();
				ЗаписьПриемник.ВалютнаяСуммаКт = ЗаписьПриемник.СуммаРегл; 
				
			КонецЕсли;	
			
		КонецЕсли;	
		
	КонецЕсли;// Принудительное заполнение валют 
	
	// Учет по исторической стоимости
	// Добавление кода. Начало. 07.12.2016{{.
	Если СтруктураШапкиДокумента.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	// Добавление кода. Конец. 07.12.2016}}
	
	Если ПравилоЗаполнения.УчетАвансовПоИсторическойСтоимости ИЛИ ПравилоЗаполнения.УчетМПЗпоИсторическойСтоимости Тогда
			
		флИспользоватьДт = ?(ЗначениеЗаполнено(ЗаписьПриемник.СчетДт),ЗаписьПриемник.СчетДт.ИспользоватьИсторическиеКурсы, Ложь);
		флИспользоватьКт = ?(ЗначениеЗаполнено(ЗаписьПриемник.СчетКт),ЗаписьПриемник.СчетКт.ИспользоватьИсторическиеКурсы, Ложь);
		флИспользовать = флИспользоватьДт ИЛИ флИспользоватьКт;
		
		Если флИспользовать Тогда
			
			// Пересчеты по историческим курсам
			Партия = Неопределено;
			Если ПравилоЗаполнения.УчетМПЗпоИсторическойСтоимости Тогда
				
				Партия = ЗначениеСубконто(ЗаписьИсточник,"Кт","Субконто.Партии");
				Если НЕ ЗначениеЗаполнено(Партия) Тогда
					Партия = ЗначениеСубконто(ЗаписьИсточник,"Кт","Субконто.ПартииМатериаловВЭксплуатации");	  
				КонецЕсли;				
				Если НЕ ЗначениеЗаполнено(Партия) Тогда
					Партия = ЗначениеСубконто(ЗаписьИсточник,"Дт","Субконто.Партии");
				КонецЕсли;
				Если НЕ ЗначениеЗаполнено(Партия) Тогда
					Партия = ЗначениеСубконто(ЗаписьИсточник,"Дт","Субконто.ПартииМатериаловВЭксплуатации");	
				КонецЕсли;  
				
			КонецЕсли; // УчетМПЗпоИсторическойСтоимости
			
			Если ПравилоЗаполнения.УчетАвансовПоИсторическойСтоимости Тогда
				
				Если НЕ ЗначениеЗаполнено(Партия) Тогда
					Партия = ЗначениеСубконто(ЗаписьИсточник,"Кт","Субконто.ДокументыРасчетовСКонтрагентами");
					Если Партия = СтруктураШапкиДокумента.Ссылка Тогда
						Партия = Неопределено;
					КонецЕсли;	  
				КонецЕсли;  				
				
				Если НЕ ЗначениеЗаполнено(Партия) Тогда
					Партия = ЗначениеСубконто(ЗаписьИсточник,"Дт","Субконто.ДокументыРасчетовСКонтрагентами");
					Если Партия = СтруктураШапкиДокумента.Ссылка Тогда
						Партия = Неопределено;
					КонецЕсли;	  	  
				КонецЕсли;	
				
			КонецЕсли; // УчетАвансовПоИсторическойСтоимости
			
			Если ЗначениеЗаполнено(Партия) Тогда
				
				ДатаКурса = Партия.Дата;
				
			Иначе
				
				// Обычные пересчеты по валюте
				ДатаКурса = СтруктураШапкиДокумента.Дата;
				// Добавление кода. Начало. 24.10.2016{{
				Если НЕ ЗначениеЗаполнено(ДатаКурса) Тогда
					ДатаКурса = ТекущаяДата();			
				КонецЕсли;
				// Добавление кода. Конец. 24.10.2016}}
				
			КонецЕсли;	
			
			ВалютаРегл = СтруктураШапкиДокумента.ВалютаРегламентированногоУчета;
			ВалютаУпр  = СтруктураШапкиДокумента.бит_ВалютаУправленческогоУчета;
			Если ЗаписьИсточник.ВалютаДт = ВалютаУпр Тогда
				ЗаписьПриемник.СуммаУпр = ЗаписьИсточник.ВалютнаяСуммаДт;
			ИначеЕсли ЗаписьИсточник.ВалютаКт = ВалютаУпр Тогда
				ЗаписьПриемник.СуммаУпр = ЗаписьИсточник.ВалютнаяСуммаКт;																						  
			Иначе
				КурсУпр = бит_КурсыВалют.ПолучитьКурсВалюты(ВалютаУпр, ДатаКурса);	
				ЗаписьПриемник.СуммаУпр = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(ЗаписьИсточник.Сумма
																								, ВалютаРегл
																								, ВалютаУпр
																								, 1
																								, КурсУпр.Курс
																								, 1
																								, КурсУпр.Кратность);
			КонецЕсли;
			
			ВалютаМСФО = СтруктураШапкиДокумента.бит_ВалютаМУ;																					  
			Если ЗаписьИсточник.ВалютаДт = ВалютаМСФО Тогда
				ЗаписьПриемник.СуммаМУ = ЗаписьИсточник.ВалютнаяСуммаДт;
			ИначеЕсли ЗаписьИсточник.ВалютаКт = ВалютаМСФО Тогда
				ЗаписьПриемник.СуммаМУ = ЗаписьИсточник.ВалютнаяСуммаКт;																						  
			Иначе																						  
				КурсМУ = бит_КурсыВалют.ПолучитьКурсВалюты(СтруктураШапкиДокумента.бит_ВалютаМУ, ДатаКурса);	
				ЗаписьПриемник.СуммаМУ = бит_КурсыВалютКлиентСервер.ПересчитатьИзВалютыВВалюту(ЗаписьИсточник.Сумма
				, ВалютаРегл
				, СтруктураШапкиДокумента.бит_ВалютаМУ
				, 1
				, КурсМУ.Курс
				, 1
				, КурсМУ.Кратность);
			КонецЕсли;
			
		КонецЕсли;	
		
	КонецЕсли; // Учет по исторической стоимости
	
КонецПроцедуры // ВыполнитьАлгоритмыМСФО()
 
// Подключаемая процедура подсистемы "Трансляция". Выполняет шаблон движений МХО.
// 
// Параметры:
//  Источник - ДокументОбъект
//  ШаблонДвижений - СправочникСсылка.бит_ШаблоныДвижений
// 
Процедура ВыполнитьШаблонДвижения(Источник, ЗаписьИсточник, ШаблонДвижения)

	КомплектМодель = Справочники.бит_КомплектыДвижений.СоздатьЭлемент();
	НоваяСтрока = КомплектМодель.ШаблоныДвижений.Добавить();
	НоваяСтрока.ШаблонДвижения = ШаблонДвижения;
	бит_МеханизмХозяйственныхОперацийСервер.ИнтерпретироватьКомплект(КомплектМодель);
	
	// Получим массив переменных
	МассивПеременных 	= КомплектМодель.СтекПеременных.Получить();
	КодОбработчика 		= КомплектМодель.КодОбработчикаПроведения;
	
	Если СокрЛП(КодОбработчика) = "" Тогда
		Возврат;
	КонецЕсли;
	
	ЭтоОтладка = Неопределено;
	
	Источник.ДополнительныеСвойства.Свойство("ЭтоОтладка", ЭтоОтладка);
	
	Попытка
		Выполнить(КодОбработчика);
	Исключение
		бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры 

// Подключаемая процедура подсистемы "Трансляция". Извлекает количество из  проводки.
// 
// Параметры:
//  ЗаписьИсточник - РегистрБухгалтерииХозрасчетный.Запись
// 
// Возвращаемое значение:
//  Количество - Число.
// 
Функция КоличествоПроводки(ЗаписьИсточник)

	Количество = 0;
    
    СвСчДт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ЗаписьИсточник.СчетДт);        
	Если СвСчДт.Количественный Тогда		
		Количество = ЗаписьИсточник.КоличествоДт;		
    Иначе        
        СвСчКт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ЗаписьИсточник.СчетКт);
        Если СвСчКт.Количественный Тогда			
		    Количество = ЗаписьИсточник.КоличествоКт;        
        КонецЕсли;    
	КонецЕсли; 

	Возврат Количество;
	
КонецФункции // КоличествоПроводки()

// Подключаемая процедура подсистемы "Трансляция". Извлекает валюту для использования в движения по бюджету.
// 
// Параметры:
//  ЗаписьИсточник - РегистрБухгалтерииХозрасчетный.Запись
//  СтруктураШапкиДокумента - Структура
// 
// Возвращаемое значение:
//  Валюта - СправочникСсылка.Валюты.
// 
Функция ВалютаОборотовБюджетирования(ЗаписьИсточник, СтруктураШапкиДокумента)
	
	Валюта = СтруктураШапкиДокумента.ВалютаРегламентированногоУчета;
	
	СтатьяДоходовРасходов = ЗначениеСубконто(ЗаписьИсточник, "Дт", "Субконто.ПрочиеДоходыИРасходы");
	
	Если НЕ ЗначениеЗаполнено(СтатьяДоходовРасходов) Тогда
		
		СтатьяДоходовРасходов = ЗначениеСубконто(ЗаписьИсточник, "Кт", "Субконто.ПрочиеДоходыИРасходы");
		
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(СтатьяДоходовРасходов) 
		 И СтатьяДоходовРасходов.Предопределенный 
		 И (СтатьяДоходовРасходов.ИмяПредопределенныхДанных = "КурсовыеРазницы" 
		    ИЛИ СтатьяДоходовРасходов.ИмяПредопределенныхДанных = "КурсовыеРазницыПоРасчетамВУЕ") Тогда
	
		// Для курсовых разниц валюта операции всегда рубль.
		Возврат Валюта;
	
	КонецЕсли; 
	
	Договор = ЗначениеСубконто(ЗаписьИсточник, "Дт", "Субконто.Договоры");
	
	Если НЕ ЗначениеЗаполнено(Договор) Тогда
		
		Договор = ЗначениеСубконто(ЗаписьИсточник, "Кт", "Субконто.Договоры");
		
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(Договор) Тогда
		
		Валюта = бит_КурсыВалют.ПолучитьВалютуДоговораКонтрагента(Договор);
		
	Иначе	
		
		Если ЗначениеЗаполнено(ЗаписьИсточник.ВалютаДт) Тогда
			
			Валюта = ЗаписьИсточник.ВалютаДт;
			
		ИначеЕсли ЗначениеЗаполнено(ЗаписьИсточник.ВалютаКт) Тогда	
			
			Валюта = ЗаписьИсточник.ВалютаКт;
			
		КонецЕсли; 
		
	КонецЕсли; 
	
	Возврат Валюта;
	
КонецФункции // ВалютаОборотовБюджетирования()

// Подключаемая процедура подсистемы "Трансляция".
// Устанавливает период записи согласно данным указанным в дополнительных Аналитиках.
// 
// Параметры:
//  ЗаписьПриемник 			- РегистрНакопленияЗапись, РегистрБухгалтерииЗапись
//  СтруктураПараметров 	- Структура
//  ДополнительныеАналитики - Соответствие
// 
Процедура СкорректироватьПериод(ЗаписьПриемник, СтруктураПараметров, ДополнительныеАналитики)
	
	// При необходимости переопределяем даты движений.
	// Производим это до выполнения всех других алгоритмов, чтобы новые даты могли повлиять на последующие вычисления.
	Если СтруктураПараметров.МетаданныеПриемника = Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам
		ИЛИ СтруктураПараметров.МетаданныеПриемника = Метаданные.РегистрыБухгалтерии.бит_Бюджетирование Тогда
		
		// Установка даты проведения по Бюджету
		ДатаДвиженийБюдж = ИзвлечьЗначениеАналитики("ДатаПроведенияПоБюджету", ДополнительныеАналитики);
		Если ЗначениеЗаполнено(ДатаДвиженийБюдж) Тогда
			ЗаписьПриемник.Период = ДатаДвиженийБюдж;
		КонецЕсли; 	
		
	КонецЕсли;		
	
	Если бит_му_ОбщегоНазначения.ЭтоМеждународныйПланСчетовИлиРегистр(СтруктураПараметров.МетаданныеПриемника.Имя) Тогда
		
		ДатаДвиженийМСФО = ИзвлечьЗначениеАналитики("ДатаПроведенияМСФО", ДополнительныеАналитики);
		Если ЗначениеЗаполнено(ДатаДвиженийМСФО) Тогда
			ЗаписьПриемник.Период = ДатаДвиженийМСФО;
		КонецЕсли; 	
		
	КонецЕсли; // Алгоритмы заполнения специфичные для МСФО.
	
КонецПроцедуры

// Подключаемая процедура подсистемы "Трансляция". Добавляет дополнительную проводку при трансляции.
//
// Параметры:
//  НаборПриемник - РегистрБухгалтерии.НаборЗаписей.
//  ЗаписьИсточник - РегистрБухгалтерии.Запись, РегистрНакопления.Запись.
//  ЗаписьПриемник - РегистрБухгалтерии.Запись.
//  ДополнительныеДанные - Соответствие.
//  СтруктураИмен - Структура
//
// Возвращаемое значение:
//  НоваяЗапись - РегистрБухгалтерии.Запись.
//
Функция ДобавитьДополнительнуюПроводку(НаборПриемник, ЗаписьИсточник, ЗаписьПриемник, ДополнительныеДанные, СтруктураИмен)

	флСоздатьЗапись = Ложь;
	НоваяЗапись = Неопределено;
	
    СчетДопДт = ДополнительныеДанные[СтруктураИмен.ИмяДополнительногоПоля_СчетДт];
    СчетДопКт = ДополнительныеДанные[СтруктураИмен.ИмяДополнительногоПоля_СчетКт];
	
	флЗаполненДт = ЗначениеЗаполнено(СчетДопДт);
	флЗаполненКт = ЗначениеЗаполнено(СчетДопКт);
    
    СвСчДт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетДопДт);
    СвСчКт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетДопКт);
    
	флЗабаланДт  = ?(флЗаполненДт, СвСчДт.Забалансовый, Ложь);
	флЗабаланКт  = ?(флЗаполненКт, СвСчКт.Забалансовый, Ложь);
	
	Если флЗаполненДт И флЗаполненКт Тогда
		
		// Оба счета заполнены. Балансовые корреспондируют с балансовыми, забалансовые с забалансовыми.
		Если флЗабаланДт = флЗабаланКт Тогда
			
			флСоздатьЗапись = Истина;
			
		КонецЕсли; 
		 
	Иначе
		
		// Заполнен только один счет. Можно использовать только забалансовые.
		Если (флЗаполненДт И флЗабаланДт) ИЛИ (флЗаполненКт И флЗабаланКт) Тогда
		
			флСоздатьЗапись = Истина;
		
		КонецЕсли;  
		 
	КонецЕсли; 
		
	Если флСоздатьЗапись Тогда
		
		НоваяЗапись = НаборПриемник.Добавить();
		НоваяЗапись[СтруктураИмен.ИмяПоляПриемника_СчетДт] = СчетДопДт;
		НоваяЗапись[СтруктураИмен.ИмяПоляПриемника_СчетКт] = СчетДопКт;					  
		
		// Копируем свойства из ЗаписиПриемник, записи которая была только что заполнена трансляцией.
		ПоляИсключения = СтруктураИмен.ИмяПоляПриемника_СчетДт+", "+СтруктураИмен.ИмяПоляПриемника_СчетКт;
		ЗаполнитьЗначенияСвойств(НоваяЗапись, ЗаписьПриемник,, ПоляИсключения);
        
        СвСчДт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(НоваяЗапись.СчетДт);
        СвСчКт = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(НоваяЗапись.СчетКт);
    
		Если флЗаполненДт Тогда
						
			Для каждого КиЗ Из ЗаписьПриемник.СубконтоДт Цикл
			
				УстановитьСубконто(НоваяЗапись.СчетДт, НоваяЗапись.СубконтоДт, КиЗ.Ключ, КиЗ.Значение);
			
			КонецЦикла; 
		
		КонецЕсли; 
		
		Если НЕ СвСчДт.Валютный Тогда
			
			НоваяЗапись.ВалютаДт = Неопределено;
			НоваяЗапись.ВалютнаяСуммаДт = 0;
			
		КонецЕсли; 
		
		Если НЕ СвСчДт.Количественный Тогда
			
			НоваяЗапись.КоличествоДт = 0;
			
		КонецЕсли; 
		
		Если флЗаполненКт Тогда
						
			Для каждого КиЗ Из ЗаписьПриемник.СубконтоКт Цикл
				
				УстановитьСубконто(НоваяЗапись.СчетКт, НоваяЗапись.СубконтоКт, КиЗ.Ключ, КиЗ.Значение);
			
			КонецЦикла; 
		
		КонецЕсли; 

		Если НЕ СвСчКт.Валютный Тогда
			
			НоваяЗапись.ВалютаКт = Неопределено;
			НоваяЗапись.ВалютнаяСуммаКт = 0;
			
		КонецЕсли; 
		
		Если НЕ СвСчКт.Количественный Тогда
			
			НоваяЗапись.КоличествоКт = 0;
			
		КонецЕсли; 
		
	КонецЕсли; 

	Возврат НоваяЗапись;
	
КонецФункции // ДобавитьДополнительнуюПроводку()

Функция ИспользоватьСторнируемыеПроводки()
	
	Возврат ПолучитьФункциональнуюОпцию("бит_ИспользоватьСторнируемыеПроводки");
	
КонецФункции

// Функция готовит массив полей для автозаполнения по универсальным соответствиям. 
//
// Параметры:
//  ТекАналитика - ПланВидовХарактеристикСсылка.бит_ВидыДополнительныхАналитик.
//  ИмяПоляАналитики - Строка - Имя аналитики в регистре соответствия.
//  ПоляСоответствия - Структура.
//  МетаданныеРегистра - ОбъектМетаданных.
//
Процедура ПодготовитьМассивПолейУниверсальногоСоответствия(ТекАналитика, ИмяПоляАналитика, ПоляСоответствия, МетаданныеРегистра
															// Изменения кода. Начало: 24.11.2016  {{ 
															,НастройкиДопИзмерений)
															// Изменения кода. Конец 24.11.2016  }} 
	
	Если ЗначениеЗаполнено(ТекАналитика) Тогда
		
		МассивТипов  = ТекАналитика.ТипЗначения.Типы();
		// По типу выполняем поиск потенциальных полей.
		Поля = НайтиПоляАвтозаполнения(МетаданныеРегистра, МассивТипов
															// Изменения кода. Начало: 24.11.2016  {{ 
															,НастройкиДопИзмерений, ТекАналитика);
															// Изменения кода. Конец 24.11.2016  }} 
		Для каждого СтрПоле Из Поля Цикл
		
			СтрПоле.Вставить("ИмяКолонкиТаблицыАналитик", ИмяПоляАналитика);
			ПоляСоответствия.Добавить(СтрПоле);
		
		КонецЦикла; 
		
	КонецЕсли;
	
КонецПроцедуры // ПодготовитьМассивПолейУниверсальногоСоответствия()

// Функция готовит структуру полей для автозаполнения по универсальным соответствиям.
// 
// Параметры:
//  ТекАналитика - ПланВидовХарактеристикСсылка.бит_ВидыДополнительныхАналитик.
//  ИмяПоляАналитики - Строка - Имя аналитики в регистре соответствия.
//  ПоляСоответствия - Структура.
//  МетаданныеРегистра - ОбъектМетаданных.
// 
Процедура ПодготовитьСтруктуруПолейУниверсальногоСоответствия(ТекАналитика, ИмяПоляАналитика, ПоляСоответствия, МетаданныеРегистра, НастройкиДопИзмерений)
	
	Если ЗначениеЗаполнено(ТекАналитика) Тогда
		
		МассивТипов  = ТекАналитика.ТипЗначения.Типы();
		// По типу выполняем поиск потенциальных полей.
		Поля = НайтиПоляАвтозаполнения(МетаданныеРегистра, МассивТипов);
		КоличествоПолей = Поля.Количество();
		
		Если КоличествоПолей > 0 Тогда
			
			// Иногда поставщик меняет имя предопределенных данных.
			СловарьЕдМн = Новый Соответствие;
			СловарьЕдМн.Вставить("Контрагент", "Контрагенты");
			СловарьЕдМн.Вставить("НоменклатурнаяГруппа", "НоменклатурныеГруппы");
			
			Если КоличествоПолей = 1 Тогда
				
				// Если найдено только одно поле - проблем нет.
				ПоляСоответствия.Вставить(ИмяПоляАналитика, Поля[0]);
				
			Иначе	
				
				// Если полей с данным типом несколько - пытаемся найти по имени.
				флОбработано = Ложь;
				ИмяСущности = СокрЛП(ТекАналитика.Код);
				ИмяСущностиМн = СловарьЕдМн[ИмяСущности];
				ИмяСущностиМн = ?( ТипЗнч(ИмяСущностиМн) = Тип("Строка"), ИмяСущностиМн, "");
				
				ТекНастройкаИзмерения = НастройкиДопИзмерений[ТекАналитика];
				
				Для каждого СтрПоле Из Поля Цикл
					
					ИмяПоля = ВРег(СокрЛП(СтрПоле.Поле));
					ИмяПоля = СтрЗаменить(ИмяПоля," ","");
					Если ИмяПоля = ВРег(ИмяСущности) ИЛИ ИмяПоля = ВРег(ИмяСущностиМн) Тогда
						
						ПоляСоответствия.Вставить(ИмяПоляАналитика, СтрПоле);
						флОбработано = Истина;
						Прервать;
						
					ИначеЕсли НЕ ТекНастройкаИзмерения = Неопределено Тогда
						
						Если ИмяПоля = ВРег(ТекНастройкаИзмерения.ИмяИзмерения) Тогда
							
							ПоляСоответствия.Вставить(ИмяПоляАналитика, СтрПоле);
							флОбработано = Истина;
							Прервать;
						КонецЕсли; 
					КонецЕсли; 
				КонецЦикла; 
				
				// Не удалось найти по имени - берем первое.
				Если НЕ флОбработано Тогда
					
					ПоляСоответствия.Вставить(ИмяПоляАналитика, Поля[0]);
					
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры // ПодготовитьСтруктуруПолейУниверсальногоСоответствия()

// Функция готовит параметры для работы механизма автозаполнения по соответствиям.
// 
// Параметры:
//  СтруктураПараметров  - Структура.
// 
// Возвращаемое значение:
//   ПараметрыАвтозаполнения   - Структура.
// 
Функция ПодготовитьПараметрыАвтозаполнения(СтруктураПараметров)
	
	ПараметрыАвтозаполнения = Новый Структура;
	
	
	флИспользоватьСоответствия = ?(СтруктураПараметров.РежимИспользованияСоответствий 
		                             = Перечисления.бит_РежимыИспользованияСоответствийПриТрансляции.НеИспользовать, Ложь, Истина);
	
	
	Если флИспользоватьСоответствия Тогда
		
		НастройкиДопИзмерений = бит_МеханизмДопИзмерений.ПолучитьНастройкиДополнительныхИзмерений();

		
		флНастраиватьВПравилах = ?(СтруктураПараметров.РежимИспользованияСоответствий 
		                             = Перечисления.бит_РежимыИспользованияСоответствийПриТрансляции.ВПравилахТрансляции, Истина, Ложь);
									 
		флСтандартныйРежим = ?(СтруктураПараметров.РежимИспользованияСоответствий 
		                             = Перечисления.бит_РежимыИспользованияСоответствийПриТрансляции.Стандартный, Истина, Ложь);
									 
									 
	     // Автоматическое заполнение ЦФО по подразделениям в режиме синхронизации.
		 Если бит_ОбщиеПеременныеСервер.ЗначениеПеременной("бит_СинхронизироватьПодразделенияРеглЦФО") 
			  И ( флНастраиватьВПравилах 
			      ИЛИ ( флСтандартныйРежим И СтруктураПараметров.ПравилоЗаполнения.Использовать_СинхронизациюПодразделенияЦФО ))  Тогда
		 
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип("СправочникСсылка.ПодразделенияОрганизаций"));
				 МассивТипов.Добавить(Тип("СправочникСсылка.Организации"));				
				 ПоляИсточника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеИсточника,МассивТипов);
				 
				 // Организация должна идти последней, т.к. подразделение имеет приоритет.
				 Если ПоляИсточника.Количество()>1 Тогда
					 
					 ПервыйЭл = ПоляИсточника[0];
					 Если ПервыйЭл.Поле = "Организация" Тогда
						 
						 ПоляИсточника.Удалить(0);
						 ПоляИсточника.Добавить(ПервыйЭл);
						 
					 КонецЕсли; 
					 
				 КонецЕсли; 				 
				 
				 ИмяТипаЦФО = бит_ОбщегоНазначения.ПолучитьИмяТипаЦФО();
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип(ИмяТипаЦФО));
				 ПоляПриемника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеПриемника,МассивТипов, НастройкиДопИзмерений);
				 
				 ТекСоответствие = ПолучитьСинхронизированныеПодразделенияЦФО();
				 
				 ТекСтруктура = Новый Структура;
				 ТекСтруктура.Вставить("ПоляИсточника"  , ПоляИсточника);
				 ТекСтруктура.Вставить("ПоляПриемника"  , ПоляПриемника);
				 ТекСтруктура.Вставить("Соответствие"   , ТекСоответствие);
				 ТекСтруктура.Вставить("ТипСоответствия", "Фиксированное");
				 
				 ПараметрыАвтозаполнения.Вставить("СинхронизацияПодразделенийЦФО",ТекСтруктура);
		 
		 КонецЕсли; 									 
									 
		 // Фиксированные соответствия
		 Если флНастраиватьВПравилах 
			  ИЛИ ( флСтандартныйРежим И СтруктураПараметров.ПравилоЗаполнения.Использовать_Соответствие_ЦФО_Подразделения ) Тогда
			  
			 флЕстьРегистр = ?(НЕ Метаданные.РегистрыСведений.Найти("бит_ЦФО_Подразделения") = Неопределено, Истина, Ложь);
			 
			 Если флЕстьРегистр Тогда
				 
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип("СправочникСсылка.ПодразделенияОрганизаций"));
				 МассивТипов.Добавить(Тип("СправочникСсылка.Организации"));				
				 ПоляИсточника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеИсточника,МассивТипов);
				 
				 // Организация должна идти последней, т.к. подразделение имеет приоритет.
				 Если ПоляИсточника.Количество()>1 Тогда
					 
					 ПервыйЭл = ПоляИсточника[0];
					 Если ПервыйЭл.Поле = "Организация" Тогда
						 
						 ПоляИсточника.Удалить(0);
						 ПоляИсточника.Добавить(ПервыйЭл);
						 
					 КонецЕсли; 
					 
				 КонецЕсли; 
				 
				 ИмяТипаЦФО = бит_ОбщегоНазначения.ПолучитьИмяТипаЦФО();
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип(ИмяТипаЦФО));
				 ПоляПриемника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеПриемника,МассивТипов, НастройкиДопИзмерений);
				 
				 ТекСоответствие = ПолучитьСоответствиеПодразделенияЦФО();				 
				 
				 ТекСтруктура = Новый Структура;
				 ТекСтруктура.Вставить("ПоляИсточника"  , ПоляИсточника);
				 ТекСтруктура.Вставить("ПоляПриемника"  , ПоляПриемника);
				 ТекСтруктура.Вставить("Соответствие"   , ТекСоответствие);
				 ТекСтруктура.Вставить("ТипСоответствия", "Фиксированное");
				 
				 ПараметрыАвтозаполнения.Вставить("ЦФО_Подразделения",ТекСтруктура);
				 
			 КонецЕсли; 
			 
		 КонецЕсли;	
		 
		 Если флНастраиватьВПравилах 
			   ИЛИ ( флСтандартныйРежим И СтруктураПараметров.ПравилоЗаполнения.Использовать_Соответствие_Статьи_СтатьиРегл ) Тогда
			   
			 флЕстьРегистр = ?(НЕ Метаданные.РегистрыСведений.Найти("бит_СтатьиОборотов_СтатьиРегл") = Неопределено, Истина, Ложь);
			 
			 Если флЕстьРегистр Тогда
				 
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип("СправочникСсылка.СтатьиЗатрат"));
				 МассивТипов.Добавить(Тип("СправочникСсылка.СтатьиДвиженияДенежныхСредств"));
				 МассивТипов.Добавить(Тип("СправочникСсылка.ПрочиеДоходыИРасходы"));
				 
				 ПоляИсточника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеИсточника,МассивТипов);
				 
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип("СправочникСсылка.бит_СтатьиОборотов"));
				 ПоляПриемника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеПриемника,МассивТипов, НастройкиДопИзмерений);
				 
				 ТекСоответствие = ПолучитьСоответствиеСтатьиРеглСтатьи();
				 
				 ТекСтруктура = Новый Структура;
				 ТекСтруктура.Вставить("ПоляИсточника"  ,  ПоляИсточника);
				 ТекСтруктура.Вставить("ПоляПриемника"  ,  ПоляПриемника);
				 ТекСтруктура.Вставить("Соответствие"   ,  ТекСоответствие);
				 ТекСтруктура.Вставить("ТипСоответствия", "Фиксированное");
				 
				 
				 ПараметрыАвтозаполнения.Вставить("Статьи_СтатьиРегл",ТекСтруктура);
				 
			 КонецЕсли; 
			 
		 КонецЕсли;
		
		 Если флНастраиватьВПравилах 
			  ИЛИ ( флСтандартныйРежим И СтруктураПараметров.ПравилоЗаполнения.Использовать_Соответствие_Статьи_НомГруппы ) Тогда
			 
			 флЕстьРегистр = ?(НЕ Метаданные.РегистрыСведений.Найти("бит_СтатьиОборотов_НоменклатурныеГруппы") = Неопределено, Истина, Ложь);
			 
			 Если флЕстьРегистр Тогда
				 
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип("СправочникСсылка.НоменклатурныеГруппы"));
				 
				 ПоляИсточника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеИсточника,МассивТипов);
				 
				 МассивТипов = Новый Массив;
				 МассивТипов.Добавить(Тип("СправочникСсылка.бит_СтатьиОборотов"));
				 ПоляПриемника = НайтиПоляАвтозаполнения(СтруктураПараметров.МетаданныеПриемника,МассивТипов, НастройкиДопИзмерений);
				 
				 ТекСоответствие = ПолучитьСоответствиеНомГруппыСтатьи();
				 
				 ТекСтруктура = Новый Структура;
				 ТекСтруктура.Вставить("ПоляИсточника"  ,  ПоляИсточника);
				 ТекСтруктура.Вставить("ПоляПриемника"  ,  ПоляПриемника);
				 ТекСтруктура.Вставить("Соответствие"   ,  ТекСоответствие);
				 ТекСтруктура.Вставить("ТипСоответствия", "Фиксированное");				 
				 
				 ПараметрыАвтозаполнения.Вставить("Статьи_НоменклатурныеГруппы",ТекСтруктура);
				 
			 КонецЕсли; 
			 
		 КонецЕсли;
		 
		 // Универсальные соответствия
		 Если флНастраиватьВПравилах ИЛИ флСтандартныйРежим Тогда
			 ПодготовитьПараметрыАвтозаполненияУниверсальныхСоответствий(ПараметрыАвтозаполнения, 
			 	СтруктураПараметров.МетаданныеИсточника, СтруктураПараметров.МетаданныеПриемника, 
				СтруктураПараметров.ПравилоЗаполнения);
		 КонецЕсли; 
	 КонецЕсли;
	
	Возврат ПараметрыАвтозаполнения;
	
КонецФункции

// Процедура готовит параметры универсальных соответствий.
//
Процедура ПодготовитьПараметрыАвтозаполненияУниверсальныхСоответствий(ПараметрыАвтозаполнения, МетаданныеИсточника, 
				МетаданныеПриемника, ПравилоЗаполнения = Неопределено, ИмяСоответствия = "")

	МаксКоличествоАналитик  = Справочники.бит_ВидыСоответствийАналитик.МаксКоличествоАналитик();
	НастройкиДопИзмеренийАн = бит_МеханизмДопИзмерений.ПолучитьНастройкиДополнительныхИзмерений("Аналитика");
	НастройкиДопИзмерений   = бит_МеханизмДопИзмерений.ПолучитьНастройкиДополнительныхИзмерений();
	
	Если ЗначениеЗаполнено(ПравилоЗаполнения) Тогда
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ВидыСоответствийАналитик.ВидСоответствия.Приоритет КАК ВидСоответствияПриоритет,
		|	ВидыСоответствийАналитик.ВидСоответствия КАК ВидСоответствия,
		|	ВидыСоответствийАналитик.ВидСоответствия.Код КАК КодВидаСоответствия,
		|	ВЫБОР
		|		КОГДА ВидыСоответствийАналитик.ВидСоответствия.ПрименятьПриПолномСовпадениеТипов
		|			ТОГДА 2
		|		ИНАЧЕ 1
		|	КОНЕЦ КАК ВерсияАлгоритма
		|ИЗ
		|	Справочник.бит_ПравилаЗаполненияПолейПриТрансляции.ИспользуемыеСоответствия КАК ВидыСоответствийАналитик
		|ГДЕ
		|	ВидыСоответствийАналитик.Ссылка = &ПравилоЗаполнения
		|
		|УПОРЯДОЧИТЬ ПО
		|	ВидСоответствияПриоритет УБЫВ
		|АВТОУПОРЯДОЧИВАНИЕ";
	Иначе
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ВидыСоответствийАналитик.Ссылка КАК ВидСоответствия,
		|	ВидыСоответствийАналитик.Приоритет КАК Приоритет,
		|	ВидыСоответствийАналитик.Код КАК КодВидаСоответствия,
		|	ВЫБОР
		|		КОГДА ВидыСоответствийАналитик.ПрименятьПриПолномСовпадениеТипов
		|			ТОГДА 2
		|		ИНАЧЕ 1
		|	КОНЕЦ КАК ВерсияАлгоритма
		|ИЗ
		|	Справочник.бит_ВидыСоответствийАналитик КАК ВидыСоответствийАналитик
		|ГДЕ
		|	ВидыСоответствийАналитик.Код = &ИмяСоответствия
		|
		|УПОРЯДОЧИТЬ ПО
		|	Приоритет УБЫВ
		|АВТОУПОРЯДОЧИВАНИЕ";
	КонецЕсли; 
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("ИмяСоответствия", ИмяСоответствия);
	Запрос.УстановитьПараметр("ПравилоЗаполнения", ПравилоЗаполнения);
	
	Результат = Запрос.Выполнить();
	Выборка   = Результат.Выбрать();
	
	// Таблица аналитик
	Аналитики = Новый Запрос;
	Аналитики.Текст = 
	"ВЫБРАТЬ
	|	СоответствияАналитик.ЛеваяАналитика_1 КАК ЛеваяАналитика_1,
	|	СоответствияАналитик.ЛеваяАналитика_2 КАК ЛеваяАналитика_2,
	|	СоответствияАналитик.ЛеваяАналитика_3 КАК ЛеваяАналитика_3,
	|	СоответствияАналитик.ПраваяАналитика_1 КАК ПраваяАналитика_1,
	|	СоответствияАналитик.ПраваяАналитика_2 КАК ПраваяАналитика_2,
	|	СоответствияАналитик.ПраваяАналитика_3 КАК ПраваяАналитика_3,
	|	СоответствияАналитик.ВидСоответствия.Приоритет КАК Приоритет
	|ИЗ
	|	РегистрСведений.бит_СоответствияАналитик КАК СоответствияАналитик
	|ГДЕ
	|	СоответствияАналитик.ВидСоответствия = &ВидСоответствия";
	
	Пока Выборка.Следующий() Цикл
		
		ВидСоответствия = Выборка.ВидСоответствия;
		ПоляИсточника   = Новый Структура;
		ПоляПриемника   = Новый Массив;
		
		Для й = 1 По МаксКоличествоАналитик Цикл
			
			// Определим имена левых аналитик
			ИмяАналитики = "ЛеваяАналитика_"+й;
			ТекАналитика = ВидСоответствия[ИмяАналитики];
			ПодготовитьСтруктуруПолейУниверсальногоСоответствия(ТекАналитика, ИмяАналитики, ПоляИсточника, МетаданныеИсточника, НастройкиДопИзмеренийАн);
			
			// Определим имена правых аналитик
			ИмяАналитики = "ПраваяАналитика_" + й;
			ТекАналитика = ВидСоответствия[ИмяАналитики];
			ПодготовитьМассивПолейУниверсальногоСоответствия(ТекАналитика, ИмяАналитики, ПоляПриемника, МетаданныеПриемника, НастройкиДопИзмерений);
		КонецЦикла;
		
		// Таблица аналитик
		Аналитики.УстановитьПараметр("ВидСоответствия", ВидСоответствия);
		Результат = Аналитики.Выполнить();
		
		ТекСтруктура = Новый Структура;
		ТекСтруктура.Вставить("ПоляИсточника"  , ПоляИсточника);
		ТекСтруктура.Вставить("ПоляПриемника"  , ПоляПриемника);
		ТекСтруктура.Вставить("Соответствие"   , СортированнаяТаблицаРегистраСоответствияАналитик(Результат.Выгрузить()));
		ТекСтруктура.Вставить("ТипСоответствия", "Универсальное");
		ТекСтруктура.Вставить("ВерсияАлгоритма", Выборка.ВерсияАлгоритма);
		
		ПараметрыАвтозаполнения.Вставить(Выборка.КодВидаСоответствия, ТекСтруктура);
		
	КонецЦикла; // По видам соответствий

КонецПроцедуры

// Сортирует выборку из регистра "бит_СоответствияАналитик" так,
// что бы снача шли строки, где аналитики заполненны.
// Потому что, в последствии берется первая строка результата поиска.
//
Функция СортированнаяТаблицаРегистраСоответствияАналитик(ТаблицаРегистра)

	ТаблицаРегистра.Колонки.Добавить("Вес", ОбщегоНазначения.ОписаниеТипаЧисло(4));
	Для каждого СтрокаТаблицы Из ТаблицаРегистра Цикл
		Вес = 0;
		Для Индекс = 1 По 3 Цикл
			Если ЗначениеЗаполнено(СтрокаТаблицы["ЛеваяАналитика_" + Индекс]) Тогда
				Вес = Вес + 1;
			КонецЕсли; 
		КонецЦикла; 
		СтрокаТаблицы.Вес = Вес;
	КонецЦикла; 

	ТаблицаРегистра.Сортировать("Вес убыв");
	Возврат ТаблицаРегистра;
	
КонецФункции

// Функция выполняет поиск полей, для сервиса автозаполнени по соответсвиям .
// 
// Параметры:
//  МетаданныеРегистра  - ОбъектМетаданных.
//  МассивТипов         - Массив.
// 
// Возвращаемое значение:
//   Поля   - Массив.
// 
Функция НайтиПоляАвтозаполнения(МетаданныеРегистра,МассивТипов, НастройкиДопИзмерений = Неопределено
								// Изменения кода. Начало: 24.11.2016  {{ 
								, ТекАналитика = Неопределено)
								// Изменения кода. Конец 24.11.2016  }} 
	
	Поля = Новый Массив;
	
	МассивКоллекций = Новый Массив;
	МассивКоллекций.Добавить("Измерения");
	МассивКоллекций.Добавить("Реквизиты");
	
	ЭтоРегистрБухгалтерии = бит_ОбщегоНазначения.ОбъектПринадлежитКоллекцииМетаданных("РегистрыБухгалтерии",МетаданныеРегистра.Имя);

	ОписаниеКонтроль = Новый ОписаниеТипов(МассивТипов);
	
	Для каждого ИмяКоллекции Из МассивКоллекций Цикл
		
		Для каждого МетаЭлемент Из МетаданныеРегистра[ИмяКоллекции] Цикл
			
			ТекМассивТипов = Новый Массив;
			Если Найти(МетаЭлемент.Имя, "Аналитика_") > 0 
				И НЕ НастройкиДопИзмерений = Неопределено Тогда
				
				ТекНастройка = НастройкиДопИзмерений[МетаЭлемент.Имя];
				
				Если НЕ ТекНастройка = Неопределено Тогда
					
					// Добавление кода. Начало: 24.11.2016  {{
					Если НЕ ТекАналитика = Неопределено Тогда
						Если ТекНастройка.Аналитика = ТекАналитика Тогда
														
							Если ЭтоРегистрБухгалтерии И ИмяКоллекции = "Измерения" Тогда
								флУчитыватьКорр = НЕ МетаЭлемент.Балансовый;
							Иначе
								флУчитыватьКорр = Ложь;
							КонецЕсли; 
							
							ИмяПоля = МетаЭлемент.Имя;					
							
							СтруктураПоля = КонструкторСтруктурыКлючей(ИмяПоля,флУчитыватьКорр,Ложь);
							Поля.Добавить(СтруктураПоля);
							
							// Все нашлось по прямой ссылке
							Прервать;
						Иначе
							Продолжить;
						КонецЕсли;
					КонецЕсли; 
					// Добавление кода конец }} 
					
					ТекМассивТипов = ТекНастройка.ТипЗначения.Типы();
					
				КонецЕсли; 
				
			Иначе	
				
				ТекМассивТипов = МетаЭлемент.Тип.Типы();
				
			КонецЕсли; 
			
			Для каждого Элемент Из ТекМассивТипов Цикл
				
				Если ОписаниеКонтроль.СодержитТип(Элемент) Тогда
					
					Если ЭтоРегистрБухгалтерии И ИмяКоллекции = "Измерения" Тогда
						
						флУчитыватьКорр = НЕ МетаЭлемент.Балансовый;
						
					Иначе
						
						флУчитыватьКорр = Ложь;
						
					КонецЕсли; 
					
					ИмяПоля = МетаЭлемент.Имя;					
					
					СтруктураПоля = КонструкторСтруктурыКлючей(ИмяПоля,флУчитыватьКорр,Ложь);
					Поля.Добавить(СтруктураПоля);
					Прервать;
					
				КонецЕсли; 
				
			КонецЦикла; // По типам 
			
		КонецЦикла; // По метаданным
		
	КонецЦикла; // По массиву коллекций
	
	
	Если ЭтоРегистрБухгалтерии Тогда
	
		 ИмяПВХ = МетаданныеРегистра.ПланСчетов.ВидыСубконто.Имя;
		 
		 ВыборкаПВХ = ПланыВидовХарактеристик[ИмяПВХ].Выбрать();
		 
		 Пока ВыборкаПВХ.Следующий() Цикл
		 
		 	ТекМассивТипов = ВыборкаПВХ.ТипЗначения.Типы();
		    Для каждого Элемент Из ТекМассивТипов Цикл
			
				Если ОписаниеКонтроль.СодержитТип(Элемент) Тогда
					
					 СтруктураПоля = КонструкторСтруктурыКлючей(ВыборкаПВХ.Ссылка,МетаданныеРегистра.Корреспонденция,Истина);								 
					 Поля.Добавить(СтруктураПоля);
					 Прервать;
				
				КонецЕсли; 
			
			КонецЦикла; 
		 
		 КонецЦикла; 
		 
		 ТипПС = Тип("ПланСчетовСсылка."+МетаданныеРегистра.ПланСчетов.Имя);
		 
		 Если ОписаниеКонтроль.СодержитТип(ТипПС) Тогда
			 
			 СтруктураПоля = КонструкторСтруктурыКлючей("Счет",МетаданныеРегистра.Корреспонденция, Ложь);								 
			 Поля.Добавить(СтруктураПоля);
			 
		 КонецЕсли; 
		 
	КонецЕсли; 
	
	Возврат Поля;
	
КонецФункции // НайтиПолеПоТипу()

// Функция возвращает структуру, описывающей поле. Используется при 
// формировани информации для сервиса автозаполнения аналитик по соответствиям.
// 
// Параметры:
//  Поле  - Строка, ПланВидовХарактеристикСсылка.
//  УчитыватьКорр  - Булево.
//  ЭтоСубконто - Булево.
// 
// Возвращаемое значение:
//   СтруктураПоля   - Структура.
// 
Функция КонструкторСтруктурыКлючей(Поле,УчитыватьКорр,ЭтоСубконто)
	
	СтруктураПоля = Новый Структура("Поле,УчитыватьКорр,ЭтоСубконто"
									,Поле
									,УчитыватьКорр
									,ЭтоСубконто);
	
	Возврат СтруктураПоля;
	
КонецФункции // КонструкторСтруктурыКлючей()

// Процедура заполняет по соответствиям Подразделения-ЦФО, 
// СтатьяРегл-Статья, НомГруппа-Статья поля применика.
// 
// Параметры:
//  ЗаписьИсточник  - РегистрНакопления.НаборЗаписей,РегистрБухгалтерии.НаборЗаписей.
//  ЗаписьПриемник  - РегистрНакопления.НаборЗаписей,РегистрБухгалтерии.НаборЗаписей.
//  ПараметрыАвтозаполнения - Структура.
//  ВидыРегистров           - Структура.
//  ИмяСоответствия         - Строка.
// 
Процедура ЗаполнитьПоСоответствию(ЗаписьИсточник, ЗаписьПриемник, ПараметрыАвтозаполнения, ВидыРегистров, ИмяСоответствия)
	
	Если ПараметрыАвтозаполнения = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ТекПараметры = Неопределено;
	ПараметрыАвтозаполнения.Свойство(ИмяСоответствия, ТекПараметры);
	
	// В режиме использования соответствий в правилах трансляции готовим соответствие при первом вызове.
	Если ТекПараметры = Неопределено 
		 И ВидыРегистров.РежимИспользованияСоответствий = Перечисления.бит_РежимыИспользованияСоответствийПриТрансляции.ВПравилахТрансляции Тогда
	
		 ПодготовитьПараметрыАвтозаполненияУниверсальныхСоответствий(ПараметрыАвтозаполнения, 
		 	ВидыРегистров.МетаданныеИсточника, ВидыРегистров.МетаданныеПриемника,, ИмяСоответствия);
																	  
		 ПараметрыАвтозаполнения.Свойство(ИмяСоответствия, ТекПараметры);
	КонецЕсли; 
	
	Если ТекПараметры = Неопределено Тогда
		Возврат;
	КонецЕсли; 

	ПоляИсточникаАвтозаполнение = ТекПараметры.ПоляИсточника;
	ПоляПриемникаАвтозаполнение = ТекПараметры.ПоляПриемника;
	СоотвАвтозаполнения         = ТекПараметры.Соответствие;
	ТипСоответствия             = ТекПараметры.ТипСоответствия;
	
	Если ВРег(ТипСоответствия) = ВРег("Фиксированное") Тогда
		
		// Определим ключевые значение источника, по которым будут извлекаться из соответствий значения для заполнения.
		ЗначенияИсточник = Новый Структура("Дт,Кт");
		
		Для каждого СтрПоляИсточник Из ПоляИсточникаАвтозаполнение Цикл
			Если СтрПоляИсточник.ЭтоСубконто Тогда
				ЗначенияИсточник.Дт = ЗначениеСубконто(ЗаписьИсточник,"Дт",СтрПоляИсточник.Поле);
				ЗначенияИсточник.Кт = ЗначениеСубконто(ЗаписьИсточник,"Кт",СтрПоляИсточник.Поле);
			Иначе
				Если СтрПоляИсточник.УчитыватьКорр Тогда
					ЗначенияИсточник.Дт = ЗаписьИсточник[СтрПоляИсточник.Поле+"Дт"];
					ЗначенияИсточник.Кт = ЗаписьИсточник[СтрПоляИсточник.Поле+"Кт"];						  
				Иначе	
					ЗначенияИсточник.Дт = ЗаписьИсточник[СтрПоляИсточник.Поле];
				КонецЕсли; 
			КонецЕсли; 
			
			Если НЕ ЗначениеЗаполнено(ЗначенияИсточник.Кт) Тогда
				ЗначенияИсточник.Кт = ЗначенияИсточник.Дт;
			КонецЕсли; 
			
			Если НЕ ЗначениеЗаполнено(ЗначенияИсточник.Дт) 
				И ЗначениеЗаполнено(ЗначенияИсточник.Кт) Тогда
				
				ЗначенияИсточник.Дт = ЗначенияИсточник.Кт;
			КонецЕсли; 
			
			// Значения для заполнения из соответствий
			ЗначенияСоотв = Новый Структура("Дт,Кт");
			
			Если ВидыРегистров.ИсточникРегистрБухгалтерии Тогда
				Если СтрПоляИсточник.УчитыватьКорр Тогда
					СчетПоискаДт = ЗаписьИсточник.СчетДт;
					СчетПоискаКт = ЗаписьИсточник.СчетКт;
				Иначе	
					СчетПоискаДт = ПланыСчетов.Хозрасчетный.ПустаяСсылка();
					СчетПоискаКт = ПланыСчетов.Хозрасчетный.ПустаяСсылка();
				КонецЕсли; 
			Иначе	
				СчетПоискаДт = ПланыСчетов.Хозрасчетный.ПустаяСсылка();
				СчетПоискаКт = ПланыСчетов.Хозрасчетный.ПустаяСсылка();
			КонецЕсли; 
			
			ЗначенияСоотв.Дт = ИзвлечьИзСоответствия(ЗначенияИсточник.Дт, СчетПоискаДт, СоотвАвтозаполнения);
			ЗначенияСоотв.Кт = ИзвлечьИзСоответствия(ЗначенияИсточник.Кт, СчетПоискаКт, СоотвАвтозаполнения);
			
			// Заполнение значений
			Для каждого СтрПоляПриемник Из ПоляПриемникаАвтозаполнение Цикл
				
				Если СтрПоляПриемник.УчитыватьКорр ИЛИ СтрПоляПриемник.ЭтоСубконто Тогда
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,СтрПоляПриемник,ЗначенияСоотв,"Дт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,СтрПоляПриемник,ЗначенияСоотв,"Кт",ВидыРегистров.ПриемникРегистрБухгалтерии);
				Иначе	
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,СтрПоляПриемник,ЗначенияСоотв,"Дт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,СтрПоляПриемник,ЗначенияСоотв,"Кт",ВидыРегистров.ПриемникРегистрБухгалтерии);				
				КонецЕсли; 
			КонецЦикла; // Полям приемника к автозаполнению
		КонецЦикла; // По полям источника
	КонецЕсли; // Фиксированное соответствие
	
	Если ВРег(ТипСоответствия) = ВРег("Универсальное") Тогда
		Если ТекПараметры.ВерсияАлгоритма = 2 Тогда
			ЗаполнитьПоУниверсальномуСоответствиюВерсия2(ВидыРегистров, ЗаписьИсточник, ЗаписьПриемник, ПоляИсточникаАвтозаполнение, ПоляПриемникаАвтозаполнение, СоотвАвтозаполнения);
		Иначе	
			ЗаполнитьПоУниверсальномуСоответствиюВерсия1(ВидыРегистров, ЗаписьИсточник, ЗаписьПриемник, ПоляИсточникаАвтозаполнение, ПоляПриемникаАвтозаполнение, СоотвАвтозаполнения);
		КонецЕсли; 
	КонецЕсли;
		
КонецПроцедуры

Процедура ЗаполнитьПоУниверсальномуСоответствиюВерсия1(Знач ВидыРегистров, Знач ЗаписьИсточник, Знач ЗаписьПриемник, Знач ПоляИсточникаАвтозаполнение, Знач ПоляПриемникаАвтозаполнение, Знач СоотвАвтозаполнения)
	
	Перем ЗначенияСоотв, ИмяКолонкиТаблицыАналитик, КиЗ, НайденныеСтроки, ОтборДт, ОтборКт, ПерваяСтрока, ПолеИсточника, ПолеПриемник, ТекЗначение;
	
	ОтборДт = Новый Структура;
	ОтборКт = Новый Структура;
	
	Для каждого КиЗ Из ПоляИсточникаАвтозаполнение Цикл
		
		ИмяКолонкиТаблицыАналитик = КиЗ.Ключ;
		ПолеИсточника = КиЗ.Значение;
		
		Если ПолеИсточника.ЭтоСубконто Тогда
			
			ТекЗначение = ЗначениеСубконто(ЗаписьИсточник,"Дт",ПолеИсточника.Поле);
			Если ЗначениеЗаполнено(ТекЗначение) Тогда
				ОтборДт.Вставить(ИмяКолонкиТаблицыАналитик, ТекЗначение);
			КонецЕсли; 
			
			ТекЗначение = ЗначениеСубконто(ЗаписьИсточник,"Кт",ПолеИсточника.Поле);
			Если ЗначениеЗаполнено(ТекЗначение) Тогда
				ОтборКт.Вставить(ИмяКолонкиТаблицыАналитик, ТекЗначение);
			КонецЕсли; 
		Иначе
			
			Если ПолеИсточника.УчитыватьКорр Тогда
				ТекЗначение = ЗаписьИсточник[ПолеИсточника.Поле+"Дт"];
				Если ЗначениеЗаполнено(ТекЗначение) Тогда
					ОтборДт.Вставить(ИмяКолонкиТаблицыАналитик, ТекЗначение);
				КонецЕсли; 
				
				ТекЗначение = ЗаписьИсточник[ПолеИсточника.Поле+"Кт"];
				Если ЗначениеЗаполнено(ТекЗначение) Тогда
					ОтборКт.Вставить(ИмяКолонкиТаблицыАналитик, ТекЗначение);
				КонецЕсли; 
			Иначе	
				
				ТекЗначение = ЗаписьИсточник[ПолеИсточника.Поле];
				Если ЗначениеЗаполнено(ТекЗначение) Тогда
					ОтборДт.Вставить(ИмяКолонкиТаблицыАналитик, ТекЗначение);
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла; 
	
	Если ОтборДт.Количество() > 0 Тогда
		
		НайденныеСтроки = СоотвАвтозаполнения.НайтиСтроки(ОтборДт);
		
		Если НайденныеСтроки.Количество() > 0 Тогда
			
			ПерваяСтрока = НайденныеСтроки[0];
			
			Для каждого ПолеПриемник Из ПоляПриемникаАвтозаполнение Цикл
				
				ИмяКолонкиТаблицыАналитик = ПолеПриемник.ИмяКолонкиТаблицыАналитик;
				ТекЗначение  = ПерваяСтрока[ИмяКолонкиТаблицыАналитик];
				Если ЗначениеЗаполнено(ТекЗначение) Тогда
					
					ЗначенияСоотв = Новый Структура("Дт", ТекЗначение);
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Дт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					Если ПолеПриемник.УчитыватьКорр ИЛИ ПолеПриемник.ЭтоСубконто Тогда
						
						ЗначенияСоотв = Новый Структура("Кт", ТекЗначение);
						ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Кт",ВидыРегистров.ПриемникРегистрБухгалтерии);
						
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли;  // Есть отбор ДТ
	
	Если ОтборКт.Количество() > 0 Тогда
		
		НайденныеСтроки = СоотвАвтозаполнения.НайтиСтроки(ОтборКт);
		
		Если НайденныеСтроки.Количество() > 0 Тогда
			
			ПерваяСтрока = НайденныеСтроки[0];
			
			Для каждого ПолеПриемник Из ПоляПриемникаАвтозаполнение Цикл
				
				ИмяКолонкиТаблицыАналитик = ПолеПриемник.ИмяКолонкиТаблицыАналитик;
				ТекЗначение  = ПерваяСтрока[ИмяКолонкиТаблицыАналитик];
				Если ЗначениеЗаполнено(ТекЗначение) Тогда
					
					ЗначенияСоотв = Новый Структура("Кт", ТекЗначение);
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Кт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					Если ПолеПриемник.УчитыватьКорр ИЛИ ПолеПриемник.ЭтоСубконто Тогда
						ЗначенияСоотв = Новый Структура("Дт", ТекЗначение);							
						ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Дт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					КонецЕсли;	
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли;  // Есть отбор КТ

КонецПроцедуры

Процедура ЗаполнитьПоУниверсальномуСоответствиюВерсия2(Знач ВидыРегистров, Знач ЗаписьИсточник, Знач ЗаписьПриемник, Знач ПоляИсточникаАвтозаполнение, Знач ПоляПриемникаАвтозаполнение, Знач СоотвАвтозаполнения)
	
	Перем ЗначенияСоотв, ИмяКолонкиТаблицыАналитик, КиЗ, ОбрабатыватьДт, ОбрабатыватьКт, ОтборДт, ОтборКт, ПолеИсточника, ПолеПриемник, СтрокаСоответствия, ТекЗначение;
	
	ОтборДт = Новый Структура;
	ОтборКт = Новый Структура;
	
	ОбрабатыватьДт = Истина;
	ОбрабатыватьКт = Истина;
	
	Для каждого КиЗ Из ПоляИсточникаАвтозаполнение Цикл
		
		ИмяКолонкиТаблицыАналитик = КиЗ.Ключ;
		ПолеИсточника = КиЗ.Значение;
		
		Если ПолеИсточника.ЭтоСубконто Тогда
			ТекЗначение = ЗначениеСубконто(ЗаписьИсточник,"Дт",ПолеИсточника.Поле);
			ДобавитьЭлементОтбораСоответствияАвтозаполнения(ОтборДт, ТекЗначение, ИмяКолонкиТаблицыАналитик, ОбрабатыватьДт);
			
			ТекЗначение = ЗначениеСубконто(ЗаписьИсточник,"Кт",ПолеИсточника.Поле);
			ДобавитьЭлементОтбораСоответствияАвтозаполнения(ОтборКт, ТекЗначение, ИмяКолонкиТаблицыАналитик, ОбрабатыватьКт);
		Иначе				
			Если ПолеИсточника.УчитыватьКорр Тогда
				ТекЗначение = ЗаписьИсточник[ПолеИсточника.Поле+"Дт"];
				ДобавитьЭлементОтбораСоответствияАвтозаполнения(ОтборДт, ТекЗначение, ИмяКолонкиТаблицыАналитик, ОбрабатыватьДт);
				
				ТекЗначение = ЗаписьИсточник[ПолеИсточника.Поле+"Кт"];
				ДобавитьЭлементОтбораСоответствияАвтозаполнения(ОтборКт, ТекЗначение, ИмяКолонкиТаблицыАналитик, ОбрабатыватьКт);
			Иначе	
				ТекЗначение = ЗаписьИсточник[ПолеИсточника.Поле];
				ДобавитьЭлементОтбораСоответствияАвтозаполнения(ОтборДт, ТекЗначение, ИмяКолонкиТаблицыАналитик, ОбрабатыватьДт);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла; 
	
	Если ОбрабатыватьДт Тогда
		
		СтрокаСоответствия = СтрокиСоответствияАвтозаполнения(СоотвАвтозаполнения, ОтборДт);
		Если СтрокаСоответствия <> Неопределено Тогда
			Для каждого ПолеПриемник Из ПоляПриемникаАвтозаполнение Цикл
				ИмяКолонкиТаблицыАналитик = ПолеПриемник.ИмяКолонкиТаблицыАналитик;
				ТекЗначение  = СтрокаСоответствия[ИмяКолонкиТаблицыАналитик];
				Если ЗначениеЗаполнено(ТекЗначение) Тогда
					ЗначенияСоотв = Новый Структура("Дт", ТекЗначение);
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Дт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					Если ПолеПриемник.УчитыватьКорр ИЛИ ПолеПриемник.ЭтоСубконто Тогда
						ЗначенияСоотв = Новый Структура("Кт", ТекЗначение);
						ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Кт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					КонецЕсли; 
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли;
	
	Если ОбрабатыватьКт Тогда
		
		//НайденныеСтроки = СоотвАвтозаполнения.НайтиСтроки(ОтборКт);
		СтрокаСоответствия = СтрокиСоответствияАвтозаполнения(СоотвАвтозаполнения, ОтборКт);
		Если СтрокаСоответствия <> Неопределено Тогда
			Для каждого ПолеПриемник Из ПоляПриемникаАвтозаполнение Цикл
				
				ИмяКолонкиТаблицыАналитик = ПолеПриемник.ИмяКолонкиТаблицыАналитик;
				ТекЗначение  = СтрокаСоответствия[ИмяКолонкиТаблицыАналитик];
				Если ЗначениеЗаполнено(ТекЗначение) Тогда
					
					ЗначенияСоотв = Новый Структура("Кт", ТекЗначение);
					ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Кт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					Если ПолеПриемник.УчитыватьКорр ИЛИ ПолеПриемник.ЭтоСубконто Тогда
						ЗначенияСоотв = Новый Структура("Дт", ТекЗначение);							
						ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,ПолеПриемник,ЗначенияСоотв,"Дт",ВидыРегистров.ПриемникРегистрБухгалтерии);
					КонецЕсли;	
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли;  // Есть отбор КТ

КонецПроцедуры

Функция СтрокиСоответствияАвтозаполнения(Таблица, Отбор)

	СтрокаСоответствия = Неопределено; 
	Для каждого СтрокаТаблицы Из Таблица Цикл
		РезультатСравнения = Истина;
		Для каждого ЭлементОтбора Из Отбор Цикл
			ЗначениеПоля = СтрокаТаблицы[ЭлементОтбора.Ключ];
			// Здесь: ЗначениеПоля - левое значение соотвествия автозаполнения.
			// Поиск прерывается по первому совпадению ЗначениеПоля и значения элемента отбора.
			// Пустое значение ЗначениеПоля игнорируется, т.к. интерпретируется как "любое значение".
			Если ЗначениеЗаполнено(ЗначениеПоля) И ЗначениеПоля <> ЭлементОтбора.Значение Тогда
				РезультатСравнения = Ложь;
				Прервать; // Дальнейшее сравнение по этому отбору бессмыслено. 
			КонецЕсли; 
		КонецЦикла; 
		Если РезультатСравнения Тогда
			СтрокаСоответствия = СтрокаТаблицы;
			Прервать; // Нашли первую строку, удовлетворяющую отбору.
		КонецЕсли; 
	КонецЦикла; 	

	Возврат СтрокаСоответствия;
	
КонецФункции

Процедура ДобавитьЭлементОтбораСоответствияАвтозаполнения(Отбор, Значение, Имя, Использование)
	
	Если Значение = NULL ИЛИ Значение = Неопределено Тогда
		Использование = Ложь;
	Иначе
		Отбор.Вставить(Имя, Значение);
	КонецЕсли; 
	
КонецПроцедуры
 
// Процедура заполняет по соответствиям Подразделения-ЦФО, 
// СтатьяРегл-Статья, НомГруппа-Статья поля применика.
// 
// Параметры:
//  ЗаписьИсточник  - РегистрНакопления.НаборЗаписей,РегистрБухгалтерии.НаборЗаписей.
//  ЗаписьПриемник  - РегистрНакопления.НаборЗаписей,РегистрБухгалтерии.НаборЗаписей.
//  ПараметрыАвтозаполнения - Структура.
//  ВидыРегистров           - Структура.
// 
Процедура ЗаполнитьПоСоответствиям(ЗаписьИсточник, ЗаписьПриемник, ПараметрыАвтозаполнения, ВидыРегистров)
	
	Если ПараметрыАвтозаполнения = Неопределено Тогда
		Возврат;
	КонецЕсли; 
		
	Для каждого КиЗ Из ПараметрыАвтозаполнения Цикл
		ЗаполнитьПоСоответствию(ЗаписьИсточник, ЗаписьПриемник, ПараметрыАвтозаполнения, ВидыРегистров, КиЗ.Ключ);
	КонецЦикла;	
	
КонецПроцедуры

// Процедура заполняет поля и субконто приемника значениями, полученными из соответствий.
// 
// Параметры:
//  ЗаписьПриемник  - РегистрНакопленияНаборЗаписей. 
//  СтрПоля         - Структура.
//  ЗначенияСоотв   - Структура.
//  ДтКт            - Строка.
//  ПриемникРегистрБухгалтерии - Булево.
// 
Процедура ЗаполнитьПолеПоСоответствию(ЗаписьПриемник,СтрПоля,ЗначенияСоотв,ДтКт,ПриемникРегистрБухгалтерии)

	// Значение, которым будем заполнять поля приемника.
	ЗначениеЗаполнения = ЗначенияСоотв[ДтКт];
	
	Если ЗначениеЗаполнено(ЗначениеЗаполнения) Тогда
		Если СтрПоля.ЭтоСубконто Тогда
			// Заполнение субконто - если оно пустое
			ТекЗначение = ЗначениеСубконто(ЗаписьПриемник,ДтКт,СтрПоля.Поле);
			Если НЕ ЗначениеЗаполнено(ТекЗначение) Тогда
				ИмяПоляСчет      = "Счет"+ДтКт;
				ИмяВидовСубконто = "Субконто"+ДтКт;
				УстановитьСубконто(ЗаписьПриемник[ИмяПоляСчет],ЗаписьПриемник[ИмяВидовСубконто],СтрПоля.Поле,ЗначениеЗаполнения);
			КонецЕсли; 
		Иначе	
			
			Если СтрПоля.УчитыватьКорр Тогда
				// Заполнение не балансового поля регистра бухгалтерии, если оно пустое.
				ИмяПоля = СтрПоля.Поле+ДтКт;
				ТекЗначение = ЗаписьПриемник[ИмяПоля];
				Если НЕ ЗначениеЗаполнено(ТекЗначение) Тогда
					ЗаписьПриемник[ИмяПоля] = ЗначениеЗаполнения;
				КонецЕсли; 
			Иначе	
				// Заполнение поля, если оно пустое
				ТекЗначение = ЗаписьПриемник[СтрПоля.Поле];
				Если НЕ ЗначениеЗаполнено(ТекЗначение) Тогда
					ЗаписьПриемник[СтрПоля.Поле] = ЗначениеЗаполнения;
				КонецЕсли; 
			КонецЕсли; // Балансовый
		КонецЕсли; // ЭтоСубконто
	КонецЕсли; // Значение к заполнению не пустое

КонецПроцедуры

// Процедура добавляет сообщение в текстовый протокол.
// 
// Параметры:
//  Протокол  	   - Строка.
//  ТекстСообщения - Строка.
// 
Процедура ДобавитьСообщениеВПротокол(Протокол, ТекстСообщения, ВестиПротокол = Истина)

	Если ВестиПротокол Тогда
		
		Протокол = Протокол + ?(ПустаяСтрока(Протокол), "", Символы.ПС) + ТекстСообщения;
		
	КонецЕсли; 

КонецПроцедуры // ДобавитьСообщениеВПротокол()

// Процедура обрабатывает ошибки трансляции. 
// Возможно открытие формы для отладки ошибок трансляции.
// 
// Параметры:
//  Ошибки  - МассивОшибок.
//  СтруктураПараметров  - Структура.
//  Протокол - Строка.
// 
Процедура ОбработатьОшибки(Ошибки,СтруктураПараметров,Протокол)
	
	Если Метаданные.Обработки.Найти("бит_ОтладкаТрансляции") = Неопределено Тогда
		
		флИспользоватьФормуОшибок = Ложь;
		
		
	Иначе	
		
		флИспользоватьФормуОшибок = бит_УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ИспользоватьФормуОшибокТрансляции")
		                            И  ПравоДоступа("Использование",Метаданные.Обработки["бит_ОтладкаТрансляции"]);
		
	КонецЕсли; 
	
	Заголовок    = "Трансляция движений документа: "+Строка(СтруктураПараметров.ТранслируемыйДокумент);
	
	ДанныеОтладки = Новый СписокЗначений;
	
	ТекстОшибок = "";
	ТекстОшибокХТМЛ = "";
	
	инд = 0;
	Для каждого ПараметрыОшибки Из Ошибки Цикл
		
		ТекстСообщения = НСтр("ru = 'Не удалось выполнить обработчик ""%1%"" по причине:'")+ПараметрыОшибки.ОписаниеОшибки;
		ТекстСообщения = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения,ПараметрыОшибки.ИмяОбработчика);			
		ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,СтруктураПараметров.ВестиПротокол);
		
		Если НЕ флИспользоватьФормуОшибок Тогда
			
			бит_ОбщегоНазначения.СообщитьОбОшибке(ТекстСообщения,,Заголовок,СтатусСообщения.Важное);
			
		Иначе
			
			ТекстОшибокХТМЛ = ТекстОшибокХТМЛ+"<small>"+ТекстСообщения+"<br></small>";
			ТекстОшибокХТМЛ = ТекстОшибокХТМЛ+"<b><A id=""ErrrorNumber"" href="""+инд+""">Исправить</a></b><br><br>";
			
			
			
			РасположениеОшибки = Обработки["бит_ОтладкаТрансляции"].ОпределитьПоложениеОшибки(Строка(ПараметрыОшибки.ОписаниеОшибки)
			                                                                               ,ПараметрыОшибки.ИмяОбработчика
																						   ,СтруктураПараметров.КодУсловияТрансляции);
			
			ДанныеОтладки.Добавить(РасположениеОшибки);																				 
			
		КонецЕсли; 
		
		инд = инд+1;
	КонецЦикла; 
	


	#Если Клиент Тогда
		
		Если флИспользоватьФормуОшибок  Тогда
			
			ОбработкаОтладка = Обработки["бит_ОтладкаТрансляции"].Создать();
			ОбработкаОтладка.ТранслируемыйДокумент = СтруктураПараметров.ТранслируемыйДокумент;
			ОбработкаОтладка.Источник          = СтруктураПараметров.Источник;
			ОбработкаОтладка.Приемник          = СтруктураПараметров.Приемник;
			ОбработкаОтладка.ТекстОшибок       = ТекстОшибокХТМЛ;
			ОбработкаОтладка.ПравилоЗаполнения = СтруктураПараметров.ПравилоЗаполнения;
			ОбработкаОтладка.ДанныеОтладки     = ДанныеОтладки;
			
			КлючФормы = Строка(СтруктураПараметров.ТранслируемыйДокумент.УникальныйИдентификатор())
			            +"/"
						+СтруктураПараметров.Источник.ИмяОбъекта
						+"/"
						+СтруктураПараметров.Приемник.ИмяОбъекта; 
						
			ФормаОбработки = ОбработкаОтладка.ПолучитьФорму("Форма",,КлючФормы);
			ФормаОбработки.Открыть();
			
		КонецЕсли; 
		
		
	#КонецЕсли	
		
КонецПроцедуры // ОбработатьОшибки()

// Функция создает структуру параметров, передающую информацию об ошибке.
// 
// Возвращаемое значение:
//   ПараметрыОшибки   - Структура.
// 
Функция КонструкторПараметрыОшибки(ИмяОбработчика = "",ОписаниеОшибки = "")
	
	ПараметрыОшибки = Новый Структура();
	
	ПараметрыОшибки.Вставить("ИмяОбработчика"       ,ИмяОбработчика);
	ПараметрыОшибки.Вставить("ОписаниеОшибки"       ,ОписаниеОшибки);
	
	Возврат ПараметрыОшибки;
	
КонецФункции // КонструкторПараметрыОшибки()

// Процедура заполняет измерения, соответствующие субконто в регистре соответствий обротов.
// 
// Параметры:
//  ЗаписьСоответствиеОб - РегистрНакопленияЗапись.бит_СоответствиеОборотовТрансляции.
//  Запись - РегистрБухгалтерииЗапись.
//  ДтКт - Строка.
//  НачалоИмениИзмерения - Строка.
//  МаксКоличествоСубконто - Число.
// 
Процедура ЗаполнитьСубконтоДляСоответствия(ЗаписьСоответствиеОб, Запись, ДтКт, НачалоИмениИзмерения, МаксКоличествоСубконто)
	
	// Изменение кода. Начало. 25.04.2016{{
	ИмяСчета = "Счет"+ДтКт;
	ТекСчет = Запись[ИмяСчета];
    
    СвСч = бит_БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(ТекСчет);	
	КоличествоСубконто = СвСч.КоличествоСубконто;
    
	ИмяПланаСчетов = ТекСчет.Метаданные().Имя;
		
	Для НомСубк = 1 По МаксКоличествоСубконто Цикл
		
		Если НомСубк > КоличествоСубконто Тогда 		
			Продолжить; 		
		КонецЕсли; 
		 
		ТекСубконто = ТекСчет.ВидыСубконто[НомСубк - 1];
		
		Если ИмяПланаСчетов <> "бит_Бюджетирование" Тогда
			
			Если НЕ ТекСубконто.Суммовой Тогда				
				Продолжить; 				
			КонецЕсли;
			
		КонецЕсли; 
			
		ИмяИзмерения = НачалоИмениИзмерения + ДтКт + НомСубк;
        
        // Изменение кода. Начало. 10.12.2018{{ BF-2728
        ТипСубконто = СвСч["ВидСубконто" + НомСубк + "ТипЗначения"];
        ЗаписьСоответствиеОб[ИмяИзмерения] = ТипСубконто.ПривестиЗначение(ЗначениеСубконто(Запись, ДтКт, НомСубк));        
		// Изменение кода. Конец. 10.12.2018}}
        
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьСубконтоДляСоответствия()

// Восстанавливает сохраненный набор записей при ручном редактировании фатических данных "Обороты по бюджетам".
//
// Параметры:
//  Источник			 - ДокументОбъект .
//  НаборПриемник		 - Набор записей регистра приемника трансляции .
//  СтруктураПараметров	 - Структура .
//  Протокол			 - Строка .
//  флЕстьОшибки		 - Булево .
//
Процедура ТрансляцияПриПроведенииЕстьРучноеРедактированиеФакта(Источник, НаборПриемник, СтруктураПараметров, Протокол = "", флЕстьОшибки = Ложь)
	
	Если НЕ бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
	     Возврат;
	КонецЕсли; 
		
	Если НЕ Источник.ДополнительныеСвойства.Свойство("ПараметрыРучногоРедактированияФакта") Тогда
	     Возврат;
	КонецЕсли; 
	 
	Если НЕ ТипЗнч(НаборПриемник) = Тип("РегистрНакопленияНаборЗаписей.бит_ОборотыПоБюджетам") Тогда
		Возврат;
	КонецЕсли; 

	РучнаяКорректировкаФакта = бит_МеханизмДопИзмерений.ЕстьРучнаяКорректировкаФакта(Источник.Ссылка);
	Если НЕ РучнаяКорректировкаФакта Тогда
	     Возврат;	
	КонецЕсли; 
		
	ПараметрыПередачи = Источник.ДополнительныеСвойства.ПараметрыРучногоРедактированияФакта;
	НаборСоответствие = ПараметрыПередачи.бит_СоответствиеЗаписейТрансляции;
	НаборОбороты      = ПараметрыПередачи.бит_ОборотыПоБюджетам;
		
	НаборПриемник.Загрузить(НаборОбороты);
	НаборПриемник.Записывать = Истина;

	// Перенести строки соответствия по паре "Источник" - "Приемник"
	СуществующийНабор = СтруктураПараметров.НаборСоответствие;
	флЗаписыватьСоответствиеНомеров = (НЕ СуществующийНабор = Неопределено);
	Если флЗаписыватьСоответствиеНомеров Тогда
		
		ОбъектСистемыИсточник = СтруктураПараметров.ОбъектСистемыИсточник;
		ОбъектСистемыПриемник = СтруктураПараметров.ОбъектСистемыПриемник;
		
		ОчиститьСоответствиеДвижений(СуществующийНабор,СтруктураПараметров.ОбъектСистемыИсточник,СтруктураПараметров.ОбъектСистемыПриемник);
		
        НайденныеСтроки       = НаборСоответствие.НайтиСтроки(Новый Структура("Источник,Приемник",ОбъектСистемыИсточник,ОбъектСистемыПриемник));
		Для каждого СтрокаТаблицы Из НайденныеСтроки Цикл
			НоваяСтрока = СуществующийНабор.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
		КонецЦикла; 
		СуществующийНабор.Записывать = Истина;
	КонецЕсли;

	ПравилоЗаполнения = СтруктураПараметров.ПравилоЗаполнения;
	ВестиПротокол     = СтруктураПараметров.ВестиПротокол;
		
	// При необходимости выполним формирование проводок бюджетирования исходя из шаблонов проводок 
	// по движениям регистра бит_ОборотыПоБюджетам.
	Если ПравилоЗаполнения.ФормироватьПроводкиБюджетирования 
		И НаборПриемник.Количество()>0  
		И СтруктураПараметров.МетаданныеПриемника = Метаданные.РегистрыНакопления.бит_ОборотыПоБюджетам
		И РегистрУчаствуетВДвижениях(Источник.Движения,"бит_Бюджетирование") Тогда
		
		СформироватьПроводкиБюджетирования(Источник,НаборПриемник,СтруктураПараметров.ЗаписыватьДвижения);
		ТекстСообщения = НСтр("ru = 'Выполнено формирование проводок Бюджетирования по шаблонам проводок. 
									|Сформировано %1% проводок Бюджетирования.'");
		
		КоличествоЗаписей = Источник.Движения.бит_Бюджетирование.Количество();						
		ТекстСообщения 	  = бит_ОбщегоНазначенияКлиентСервер.ПодставитьПараметрыСтроки(ТекстСообщения, КоличествоЗаписей);
									ДобавитьСообщениеВПротокол(Протокол,ТекстСообщения,ВестиПротокол);
		
	КонецЕсли; 
	
	// При необходимости запишем движения (Регл. операция)
	Если СтруктураПараметров.ЗаписыватьДвижения Тогда
		
		Попытка
			НаборПриемник.Записать();
		Исключение
			флЕстьОшибки = Истина;
			бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ОписаниеОшибки());
			ДобавитьСообщениеВПротокол(Протокол, Строка(ОписаниеОшибки()), ВестиПротокол);						
		КонецПопытки;
		
		Если флЗаписыватьСоответствиеНомеров Тогда
			
			Попытка
				СуществующийНабор.Записать(); //BF-695
			Исключение
				флЕстьОшибки = Истина;
				бит_ОбщегоНазначенияКлиентСервер.ВывестиСообщение(ОписаниеОшибки());
				ДобавитьСообщениеВПротокол(Протокол, Строка(ОписаниеОшибки()), ВестиПротокол);				 
			КонецПопытки;			
		КонецЕсли; 
	КонецЕсли;	
	 
КонецПроцедуры // бит_ОбработкаПроведенияТрансляцияОбработкаПроведения()

Функция ЕстьРучноеРедактированиеФакта(Объект)

	Результат = Истина;
	
	Если НЕ бит_ОбщегоНазначения.ЭтоСемействоБП() Тогда
		Результат = Ложь;
	КонецЕсли; 
	
	Если Результат И НЕ Объект.ДополнительныеСвойства.Свойство("ПараметрыРучногоРедактированияФакта") Тогда
		Результат = Ложь;
	КонецЕсли; 
	
	Если Результат Тогда
		РучнаяКорректировкаФакта = бит_МеханизмДопИзмерений.ЕстьРучнаяКорректировкаФакта(Объект.Ссылка);
		Результат = РучнаяКорректировкаФакта;
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции
 
Процедура ПриОтказеОтТрансляцииПриПроведении(Объект, ЗаписыватьДвижения)
	
	ПараметрыПередачи = Объект.ДополнительныеСвойства.ПараметрыРучногоРедактированияФакта;
	НаборСоответствие = ПараметрыПередачи.бит_СоответствиеЗаписейТрансляции;
	НаборОбороты      = ПараметрыПередачи.бит_ОборотыПоБюджетам;
	
	ОборотыПоБюджетам = Объект.Движения.бит_ОборотыПоБюджетам;
	ОборотыПоБюджетам.Загрузить(НаборОбороты);
	ОборотыПоБюджетам.Записывать = Истина;

	СоответствиеЗаписей = Объект.Движения.бит_СоответствиеЗаписейТрансляции;
	Для каждого СтрокаТаблицы Из НаборСоответствие Цикл
		НоваяСтрока = СоответствиеЗаписей.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
	КонецЦикла;
	СоответствиеЗаписей.Записывать = Истина;
	
	// При необходимости запишем движения (Регл. операция)
	Если ЗаписыватьДвижения Тогда
		
		Попытка
			ОборотыПоБюджетам.Записать();
		Исключение
			ЗаписьЖурналаРегистрации(
			"Механизм трансляции", 
			УровеньЖурналаРегистрации.Ошибка,, 
			Объект, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Попытка
			СоответствиеЗаписей.Записать(); 
		Исключение
			ЗаписьЖурналаРегистрации(
			"Механизм трансляции", 
			УровеньЖурналаРегистрации.Ошибка,, 
			Объект, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;			
	КонецЕсли;
	
КонецПроцедуры


#КонецОбласти

//izhtc-Kir 01.09.2015 (
Функция СохранитьЗначение(Параметр1 = Неопределено, Параметр2 = Неопределено) Экспорт
	ХранилищеОбщихНастроек.Сохранить("Заглушка", Параметр1, Параметр2);
	Возврат Неопределено;
КонецФункции
//izhtc-Kir 01.09.2015 )

// БИТ Тртилек Процедура выполняет подбор счетов для различных приемника и источника (ВыполнитьПодборСчетов)
//
// Параметры:
//  СтруктураПараметров  – Структура - Ключи: {Счет,Субконто<i>} или {СчетДт,СчетКт,СубконтоДт<i>,СубконтоКт<i>}
//  Организация          - СправочникСсылка.Организации
//  ДатаПравил           - Дата
//  ИмяРегистраИсточник  - Строка
//  ИмяРегистраПриемник  - Строка
//
// Возвращаемое значение:
// РезСтруктура - Структура - Ключи: {Счет,Субконто<i>} или {СчетДт,СчетКт,СубконтоДт<i>,СубконтоКт<i>}
//
Функция ВыполнитьПодборСчетаПоПравилам(СтруктураПараметров
			                           ,Организация
			                           ,ИмяРегистраИсточник = "Хозрасчетный"
									   ,ИмяРегистраПриемник = "бит_Дополнительный_2"
			                           ,Источник
									   ,КодУсловияТрансляций
									   ,Отказ) Экспорт

	Если СтруктураПараметров.Свойство("Счет") Тогда
	  ЭтоПодборБезКорреспонденции = Истина;
	Иначе 	
	  ЭтоПодборБезКорреспонденции = Ложь;
	КонецЕсли; 
	//
	// Создаем наборы источник и приемник
	НаборИсточник = РегистрыБухгалтерии[ИмяРегистраИсточник].СоздатьНаборЗаписей();
	НаборПриемник = РегистрыБухгалтерии[ИмяРегистраПриемник].СоздатьНаборЗаписей();
	
	// Определяем максимальное количество субконто источника и приемника
	ИмяПланаСчетовИсточник     = Метаданные.РегистрыБухгалтерии[ИмяРегистраИсточник].ПланСчетов.Имя;
	ИмяПланаСчетовИсточникПолное ="РегистрБухгалтерии." + ИмяПланаСчетовИсточник;
	КоличествоСубконтоИсточник = Метаданные.ПланыСчетов[ИмяПланаСчетовИсточник].МаксКоличествоСубконто;
	
	ИмяПланаСчетовПриемник     = Метаданные.РегистрыБухгалтерии[ИмяРегистраПриемник].ПланСчетов.Имя;
	ИмяПланаСчетовПриемникПолное ="РегистрБухгалтерии." + ИмяПланаСчетовПриемник;
	КоличествоСубконтоПриемник = Метаданные.ПланыСчетов[ИмяПланаСчетовПриемник].МаксКоличествоСубконто;
	
	// Инициализируем результирующую структуру
	Если ЭтоПодборБезКорреспонденции Тогда
		
		РезСтруктура = Новый Структура;
		РезСтруктура.Вставить("Счет");
		Для й = 1 По КоличествоСубконтоПриемник Цикл
		
			РезСтруктура.Вставить("Субконто"+й);
		
		КонецЦикла; 
		
	Иначе	
		
		РезСтруктура = Новый Структура;
		РезСтруктура.Вставить("СчетДт");
		РезСтруктура.Вставить("СчетКт");		
		Для й = 1 По КоличествоСубконтоПриемник Цикл
		
			РезСтруктура.Вставить("СубконтоДт"+й);
			РезСтруктура.Вставить("СубконтоКт"+й);
		
		КонецЦикла; 
		
	КонецЕсли; 
	
	// Заполним набор записей источник по переданной стуктуре
	ЗаписьИсточник = НаборИсточник.Добавить();
	
	ВидыРегистров = КонструкторСтруктурыВидыРегистров();				
	ВидыРегистров.ИсточникРегистрБухгалтерии = бит_ОбщегоНазначения.ОбъектПринадлежитКоллекцииМетаданных("РегистрыБухгалтерии",ИмяПланаСчетовИсточник);													
	ВидыРегистров.ПриемникРегистрБухгалтерии = бит_ОбщегоНазначения.ОбъектПринадлежитКоллекцииМетаданных("РегистрыБухгалтерии",ИмяПланаСчетовПриемник);																										
	ВидыРегистров.ИсточникРегистрНакопления = ЛОЖЬ;
	ВидыРегистров.ПриемникРегистрНакопления = ЛОЖЬ;
	
	ИсточникДляАналитики = Метаданные.РегистрыБухгалтерии[ИмяПланаСчетовИсточник];
	
	
	
	// Заполним счета
	Если ЭтоПодборБезКорреспонденции Тогда
		
		ЗаписьИсточник.СчетДт          = СтруктураПараметров.СчетДт;
		ЗаписьИсточник.СчетКт          = СтруктураПараметров.СчетКт;
		ЗаписьИсточник.ПодразделениеДт = СтруктураПараметров.ПодразделениеДт;
		ЗаписьИсточник.ПодразделениеКт = СтруктураПараметров.ПодразделениеКт;
		ЗаписьИсточник.Сумма           = СтруктураПараметров.Сумма;
		
	Иначе	
		
		ЗаписьИсточник.СчетДт = СтруктураПараметров.СчетДт;
		ЗаписьИсточник.СчетКт = СтруктураПараметров.СчетКт;
		ЗаписьИсточник.ПодразделениеДт = СтруктураПараметров.ПодразделениеДт;
		ЗаписьИсточник.ПодразделениеКт = СтруктураПараметров.ПодразделениеКт;
		ЗаписьИсточник.Сумма           = СтруктураПараметров.Сумма;
        //bit auavseenkov 
		ЗаписьИсточник.Организация = Организация;
		//}
	КонецЕсли; 
	
	// Заполним аналитику
	Для й = 1 По КоличествоСубконтоИсточник Цикл
		
		Если ЭтоПодборБезКорреспонденции Тогда
		   ИмяСубконтоДт = "Субконто"+й;
		   ИмяСубконтоКт = "Субконто"+й;
		Иначе	
		   ИмяСубконтоДт = "СубконтоДт"+й;
		   ИмяСубконтоКт = "СубконтоКт"+й;
		КонецЕсли; 
		
		Если СтруктураПараметров.Свойство(ИмяСубконтоДт) Тогда
		
		  бит_му_ОбщегоНазначения.УстановитьСубконто(ЗаписьИсточник.СчетДт,ЗаписьИсточник.СубконтоДт,й,СтруктураПараметров[ИмяСубконтоДт]);
		
	    КонецЕсли; 
	    Если СтруктураПараметров.Свойство(ИмяСубконтоКт) Тогда
		
		  бит_му_ОбщегоНазначения.УстановитьСубконто(ЗаписьИсточник.СчетКт,ЗаписьИсточник.СубконтоКт,й,СтруктураПараметров[ИмяСубконтоКт]);
		
		КонецЕсли; 
		
	КонецЦикла; 

	
	Протокол = "";
	
	МетаИсточник = Метаданные.РегистрыБухгалтерии[ИмяРегистраИсточник];
	МетаПриемник = Метаданные.РегистрыБухгалтерии[ИмяРегистраПриемник];
	
	//БИТ Тртилек Выполним код правил трансляции
	
	ЗаписьПриемник = НаборПриемник.Добавить();
	
	КодУсловияТрансляции = КодУсловияТрансляций.Код;
	КэшРеквизитов        = КодУсловияТрансляций.Кэш;
	
	Попытка
		
		Выполнить(КодУсловияТрансляции);		
		
    Исключение
		//Сообщить("Ошибка выполнения кода трансляции.  " + ОписаниеОшибки() + ".Ошибка в документе: " + Строка(Источник)+".");
	КонецПопытки;
	
	Аналитики = СформироватьСоответствияАналитик(ЗаписьИсточник,ИсточникДляАналитики,ВидыРегистров);
	
	//Дозаполним субконто
	
	
	ЗаполнитьСубконтоВПриемнике(ЗаписьПриемник,"Дт",Аналитики.АналитикиИсточникДт,Аналитики.АналитикиИсточник);
	ЗаполнитьСубконтоВПриемнике(ЗаписьПриемник,"Кт",Аналитики.АналитикиИсточникКт,Аналитики.АналитикиИсточник);			
	//
	
	ЗаписьПриемникСтруктура = Новый Структура("ЗаписьПриемник, Отказ");
	ЗаписьПриемникСтруктура.ЗаписьПриемник = ЗаписьПриемник;
	ЗаписьПриемникСтруктура.Отказ = Отказ;
	Возврат(ЗаписьПриемникСтруктура);
	
КонецФункции // ВыполнитьПодборСчетов()

Функция ПолучитьПравилаИКэш(Организация
	                        ,ИмяРегистраИсточник = "Хозрасчетный"
							,ИмяРегистраПриемник = "бит_Дополнительный_2"
	                        ,Документ) Экспорт
							
							
	// Определяем максимальное количество субконто источника и приемника
	ИмяПланаСчетовИсточник     = Метаданные.РегистрыБухгалтерии[ИмяРегистраИсточник].ПланСчетов.Имя;
	ИмяПланаСчетовИсточникПолное ="РегистрБухгалтерии." + ИмяПланаСчетовИсточник;
	
	ИмяПланаСчетовПриемник     = Метаданные.РегистрыБухгалтерии[ИмяРегистраПриемник].ПланСчетов.Имя;
	ИмяПланаСчетовПриемникПолное ="РегистрБухгалтерии." + ИмяПланаСчетовПриемник;
							   
	МассивИсточник = Новый Массив;
	МассивИсточник.Добавить(Справочники.бит_ОбъектыСистемы.НайтиПоРеквизиту("ИмяОбъектаПолное", ИмяПланаСчетовИсточникПолное));
	
	МассивПриемник = Новый Массив;
	МассивПриемник.Добавить(Справочники.бит_ОбъектыСистемы.НайтиПоРеквизиту("ИмяОбъектаПолное", ИмяПланаСчетовПриемникПолное));
	
	Если Документ = ТипЗнч("ДокументСсылка.бит_РеклассификацияНеПринимаемыхРасходов") Тогда
		НашДокумент = Справочники.бит_ОбъектыСистемы.ПустаяСсылка();
		НашаДата = Документ.Дата;
	Иначе
		НашДокумент = Документ;
		НашаДата = НашДокумент.Дата;
	КонецЕсли;
	
	МассивПравил = Новый Массив;
		//БИТ Тртилек Получим код правил трансляции
    // Получим правила заполнения полей и правила трансляции
	РезультатПравила = ПолучитьДоступныеПравилаТрансляции(Организация,НашДокумент,НашаДата,МассивИсточник,МассивПриемник, );
	
	ВыборкаПравилоЗаполнения = РезультатПравила.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	Пока ВыборкаПравилоЗаполнения.Следующий() Цикл
		
		СтруктураПравила = ПодготовитьСтруктурыПравил(ВыборкаПравилоЗаполнения.ПравилоЗаполнения);
		
		ВыборкаИсточник = ВыборкаПравилоЗаполнения.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Пока ВыборкаИсточник.Следующий() Цикл 
			
			ВыборкаПриемник = ВыборкаИсточник.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			Пока ВыборкаПриемник.Следующий() Цикл
				
				Выборка = ВыборкаПриемник.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
				
				
				
				флКроме = Ложь;
				Пока Выборка.Следующий() Цикл
					
					Если Выборка.УсловиеВхождения = Перечисления.бит_Кроме.Кроме Тогда
					
						флКроме = Истина;
						Прервать;
					
					КонецЕсли; 
					МассивПравил.Добавить(Выборка.ПравилаТрансляции);
					
				КонецЦикла; // по настройкам		
				
			КонецЦикла; // по приемникам
			
		КонецЦикла; // по источникам
		
	КонецЦикла;	
	
    КодУсловияТрансляции = "";
	КэшРеквизитов = Новый ТаблицаЗначений;
	КэшРеквизитов.Колонки.Добавить("ИД");
	КэшРеквизитов.Колонки.Добавить("ИмяКолонки");
	КэшРеквизитов.Колонки.Добавить("Значение");
	
	Если МассивПравил.Количество() > 0 Тогда
		Для каждого Правило Из МассивПравил Цикл
			
			КодУсловияТрансляции = КодУсловияТрансляции+Правило.КодУсловияТрансляции;
			
			Для каждого СтрокаТаблицы Из Правило.ЗначенияРеквизитов Цикл
				
				НоваяСтрока = КэшРеквизитов.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаТаблицы);
				
			КонецЦикла; 
			
		КонецЦикла;
	Иначе
		Сообщить("Ни одного правила не было отобрано. Проверьте правила, назначение правил и назначение правил заполнения.")
	КонецЕсли;
	
	СтруктураКодКэш = Новый Структура;
	СтруктураКодКэш.Вставить("Код", КодУсловияТрансляции);
	СтруктураКодКэш.Вставить("Кэш", КэшРеквизитов);
	
	Возврат СтруктураКодКэш;
КонецФункции

//ОКЕЙ Лобанов В.И.(СофтЛаб) Начало 2019-02-11 (#3209)
Процедура ок_ЗаполнитьСвойствоНеУстанавливатьОтказПриПроверкеЗаполнения(СтруктураПараметров)
	
	СтруктураПараметров.Вставить("НеУстанавливатьОтказПриПроверкеЗаполнения",	Ложь);
	
	// определим, требуется ли устанавливать признак Отказ = Истина, чтобы не удалять в приемнике записи
	// ++ БоровинскаяОА (СофтЛаб) 15.05.19 (#3128)
	Если СтруктураПараметров.СтруктураШапкиДокумента.Свойство("НеТранслироватьЕслиНеЗаполненыОбязательныеПоля") Тогда
	// -- БоровинскаяОА (СофтЛаб) 15.05.1
		Для Каждого ЗаписьНастройки Из СтруктураПараметров.СтруктураШапкиДокумента.НеТранслироватьЕслиНеЗаполненыОбязательныеПоля Цикл
			ОбъектПриемник = ЗаписьНастройки.Значение;
			Если ОбъектПриемник = СтруктураПараметров.ОбъектСистемыПриемник Тогда
				СтруктураПараметров.Вставить("НеУстанавливатьОтказПриПроверкеЗаполнения",	Истина);
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры // ок_ЗаполнитьСвойствоНеУстанавливатьОтказПриПроверкеЗаполнения()
//ОКЕЙ Лобанов В.И.(СофтЛаб) Конец 2019-02-11 (#3209)
